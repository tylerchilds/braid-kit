(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name3 in all)
      __defProp(target, name3, { get: all[name3], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports2, module3) {
      "use strict";
      module3.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports2, module3) {
      "use strict";
      var hasSymbols = require_shams();
      module3.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports2, module3) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module3.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports2, module3) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module3.exports = function bind2(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs.push("$" + i2);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports2, module3) {
      "use strict";
      var implementation = require_implementation();
      module3.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports2, module3) {
      "use strict";
      var bind2 = require_function_bind();
      module3.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports2, module3) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name3) {
        var value;
        if (name3 === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name3 === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name3 === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name3 === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name3 === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name3] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind2 = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind2.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
      var $replace = bind2.call(Function.call, String.prototype.replace);
      var $strSlice = bind2.call(Function.call, String.prototype.slice);
      var $exec = bind2.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string2) {
        var first = $strSlice(string2, 0, 1);
        var last = $strSlice(string2, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string2, rePropName, function(match, number2, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
        var intrinsicName = name3;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
      };
      module3.exports = function GetIntrinsic(name3, allowMissing) {
        if (typeof name3 !== "string" || name3.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name3) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name3);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i2 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports2, module3) {
      "use strict";
      var bind2 = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = null;
        }
      }
      module3.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind2, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind2, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module3.exports, "apply", { value: applyBind });
      } else {
        module3.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports2, module3) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module3.exports = function callBoundIntrinsic(name3, allowMissing) {
        var intrinsic = GetIntrinsic(name3, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name3, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports2, module3) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module3.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports2, module3) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e2) {
        }
      };
      var GeneratorFunction;
      module3.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports2, module3) {
      "use strict";
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e2) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e2) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module3.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e2) {
          if (e2 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports2, module3) {
      "use strict";
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i2 = 0, len = array.length; i2 < len; i2++) {
          if (hasOwnProperty.call(array, i2)) {
            if (receiver == null) {
              iterator(array[i2], i2, array);
            } else {
              iterator.call(receiver, array[i2], i2, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string2, iterator, receiver) {
        for (var i2 = 0, len = string2.length; i2 < len; i2++) {
          if (receiver == null) {
            iterator(string2.charAt(i2), i2, string2);
          } else {
            iterator.call(receiver, string2.charAt(i2), i2, string2);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module3.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports2, module3) {
      "use strict";
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g = typeof globalThis === "undefined" ? global : globalThis;
      module3.exports = function availableTypedArrays() {
        var out = [];
        for (var i2 = 0; i2 < possibleNames.length; i2++) {
          if (typeof g[possibleNames[i2]] === "function") {
            out[out.length] = possibleNames[i2];
          }
        }
        return out;
      };
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports2, module3) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      module3.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports2, module3) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i2 = 0; i2 < array.length; i2 += 1) {
          if (array[i2] === value) {
            return i2;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e2) {
            }
          }
        });
        return anyTrue;
      };
      module3.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports2, module3) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g[typedArray] === "function") {
            var arr = new g[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name3 = getter.call(value);
              if (name3 === typedArray) {
                foundName = name3;
              }
            } catch (e2) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module3.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports2) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e2) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction;
      exports2.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports2, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports2, module3) {
      module3.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module3) {
      if (typeof Object.create === "function") {
        module3.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module3.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports2) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys4 = Object.keys(obj);
        var descriptors = {};
        for (var i2 = 0; i2 < keys4.length; i2++) {
          descriptors[keys4[i2]] = Object.getOwnPropertyDescriptor(obj, keys4[i2]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            objects.push(inspect(arguments[i2]));
          }
          return objects.join(" ");
        }
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i2 >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i2]; i2 < len; x = args[++i2]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports2.deprecate = function(fn, msg2) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports2.deprecate(fn, msg2).apply(this, arguments);
          };
        }
        var warned2 = false;
        function deprecated() {
          if (!warned2) {
            if (process.throwDeprecation) {
              throw new Error(msg2);
            } else if (process.traceDeprecation) {
              console.trace(msg2);
            } else {
              console.error(msg2);
            }
            warned2 = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports2.debuglog = function(set2) {
        set2 = set2.toUpperCase();
        if (!debugs[set2]) {
          if (debugEnvRegex.test(set2)) {
            var pid = process.pid;
            debugs[set2] = function() {
              var msg2 = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set2, pid, msg2);
            };
          } else {
            debugs[set2] = function() {
            };
          }
        }
        return debugs[set2];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue2(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style2 = inspect.styles[styleType];
        if (style2) {
          return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue2(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue2(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys4 = Object.keys(value);
        var visibleKeys = arrayToHash(keys4);
        if (ctx.showHidden) {
          keys4 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys4.indexOf("message") >= 0 || keys4.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys4.length === 0) {
          if (isFunction(value)) {
            var name3 = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name3 + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base2 = "", array = false, braces = ["{", "}"];
        if (isArray5(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base2 = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base2 = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base2 = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base2 = " " + formatError(value);
        }
        if (keys4.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base2 + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys4);
        } else {
          output = keys4.map(function(key2) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base2, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys4) {
        var output = [];
        for (var i2 = 0, l = value.length; i2 < l; ++i2) {
          if (hasOwnProperty(value, String(i2))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i2),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys4.forEach(function(key2) {
          if (!key2.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key2,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
        var name3, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key2)) {
          name3 = "[" + key2 + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue2(ctx, desc.value, null);
            } else {
              str = formatValue2(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name3)) {
          if (array && key2.match(/^\d+$/)) {
            return str;
          }
          name3 = JSON.stringify("" + key2);
          if (name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name3 = name3.slice(1, -1);
            name3 = ctx.stylize(name3, "name");
          } else {
            name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name3 = ctx.stylize(name3, "string");
          }
        }
        return name3 + ": " + str;
      }
      function reduceToSingleString(output, base2, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur2) {
          numLinesEst++;
          if (cur2.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur2.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
      }
      exports2.types = require_types();
      function isArray5(ar) {
        return Array.isArray(ar);
      }
      exports2.isArray = isArray5;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      exports2.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports2.isDate = isDate;
      exports2.types.isDate = isDate;
      function isError(e2) {
        return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
      }
      exports2.isError = isError;
      exports2.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = require_inherits_browser();
      exports2._extend = function(origin, add2) {
        if (!add2 || !isObject(add2))
          return origin;
        var keys4 = Object.keys(add2);
        var i2 = keys4.length;
        while (i2--) {
          origin[keys4[i2]] = add2[keys4[i2]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports2.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports2.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports2.callbackify = callbackify;
    }
  });

  // public/statebus/statebus.js
  var require_statebus = __commonJS({
    "public/statebus/statebus.js"(exports, module) {
      (function(name3, definition) {
        window[name3] = definition();
      })("statebus", function() {
        var statelog_indent = 0;
        var busses = {}, bus_count = 0, executing_funk, global_funk, funks = {}, clean_timer, symbols, nodejs = typeof window === "undefined";
        function make_bus(options) {
          function get(key2, callback) {
            if (typeof key2 !== "string" && !(typeof key2 === "object" && typeof key2.key === "string"))
              throw "Error: get(key) called with key = " + JSON.stringify(key2);
            key2 = key2.key || key2;
            bogus_check(key2);
            var called_from_reactive_funk = !callback;
            var funk = callback || executing_funk;
            if (callback) {
              (callback.defined = callback.defined || []).push({ as: "get callback", key: key2 });
              callback.has_seen = callback.has_seen || function(bus3, key3, version) {
                callback.seen_keys = callback.seen_keys || {};
                var bus_key = JSON.stringify([bus3.id, key3]);
                var seen_versions = callback.seen_keys[bus_key] = callback.seen_keys[bus_key] || [];
                seen_versions.push(version);
                if (seen_versions.length > 50)
                  seen_versions.shift();
              };
            }
            gets_in.add(key2, funk_key(funk));
            if (to_be_forgotten[key2]) {
              clearTimeout(to_be_forgotten[key2]);
              delete to_be_forgotten[key2];
            }
            bind(key2, "on_set", funk);
            var getterters = 0;
            if (!gets_out[key2])
              getterters = bus.route(key2, "getter", key2);
            if (called_from_reactive_funk) {
              funk.has_seen(bus, key2, versions[key2]);
              backup_cache[key2] = backup_cache[key2] || { key: key2 };
              return cache[key2] = cache[key2] || { key: key2 };
            } else if (!pending_gets[key2] && getterters === 0) {
              backup_cache[key2] = backup_cache[key2] || { key: key2 };
              run_handler(funk, "on_set", cache[key2] = cache[key2] || { key: key2 });
            }
          }
          function get_once(key2, cb) {
            function cb2(o) {
              cb(o);
              forget(key2, cb2);
            }
            get(key2, cb2);
          }
          get.once = get_once;
          var pending_gets = {};
          var gets_out = {};
          var gets_in = new One_To_Many();
          var currently_saving;
          function set(obj, t2) {
            if (typeof obj === "string" && t2 && t2.patch) {
              if (typeof t2.patch == "string")
                t2.patch = [t2.patch];
              obj = apply_patch(bus.cache[obj] || { key: obj }, t2.patch[0]);
            }
            if (!("key" in obj) || typeof obj.key !== "string") {
              console.error("Error: set(obj) called on object without a key: ", obj);
              console.trace("Bad set(obj)");
            }
            bogus_check(obj.key);
            t2 = t2 || {};
            t2.version = t2.version || new_version();
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes([obj.key]);
              return;
            }
            if (honking_at(obj.key))
              var message = set_msg(obj, t2, "set");
            if (obj.key && !changed(obj)) {
              statelog(obj.key, grey, "x", message);
              return;
            } else
              statelog(obj.key, red, "o", message);
            try {
              statelog_indent++;
              var was_saving = currently_saving;
              currently_saving = obj.key;
              var num_handlers = bus.route(obj.key, "setter", obj, t2);
              if (num_handlers === 0) {
                set.fire(obj, t2);
                bus.route(obj.key, "on_set_sync", obj, t2);
              }
            } finally {
              statelog_indent--;
              currently_saving = was_saving;
            }
          }
          set.sync = function set_sync(obj, t2) {
            t2 = bus.clone(t2 || {});
            t2.version = executing_funk && executing_funk.transaction && executing_funk.transaction.version || executing_funk && executing_funk.latest_reaction_at;
            set(obj, t2);
          };
          set.fire = fire;
          function fire(obj, t2) {
            t2 = t2 || {};
            t2.version = t2.version || executing_funk && executing_funk.latest_reaction_at || new_version();
            if (obj.key && honking_at(obj.key)) {
              var message = set_msg(obj, t2, "set.fire");
              var color, icon;
              if (currently_saving === obj.key && !(obj.key && !changed(obj))) {
                statelog_indent--;
                statelog(obj.key, red, "\u2022", "\u21B5" + (t2.version ? "			[" + t2.version + "]" : ""));
                statelog_indent++;
              } else {
                if (obj.key && !changed(obj)) {
                  color = grey;
                  icon = "x";
                  if (t2.getter)
                    message = t2.m || "Got " + bus + "('" + obj.key + "')";
                  if (t2.version)
                    message += " [" + t2.version + "]";
                  statelog(obj.key, color, icon, message);
                  return;
                }
                color = red, icon = "\u2022";
                if (t2.getter || pending_gets[obj.key]) {
                  color = green;
                  icon = "^";
                  message = add_diff_msg(
                    t2.m || "Got " + bus + "('" + obj.key + "')",
                    obj
                  );
                  if (t2.version)
                    message += " [" + t2.version + "]";
                }
                statelog(obj.key, color, icon, message);
              }
            }
            var modified_keys = update_cache(obj, cache);
            delete pending_gets[obj.key];
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes(modified_keys);
            } else {
              update_cache(obj, backup_cache);
              for (var i2 = 0; i2 < modified_keys.length; i2++) {
                var key2 = modified_keys[i2];
                var parents = [versions[key2]];
                versions[key2] = t2.version;
                mark_changed(key2, t2);
              }
            }
          }
          set.abort = function(obj, t2) {
            if (!obj)
              console.error("No obj", obj);
            abort_changes([obj.key]);
            statelog(obj.key, yellow, "<", "Aborting " + obj.key);
            mark_changed(obj.key, t2);
          };
          var version_count = 0;
          function new_version() {
            return (bus.label || id + " ") + (version_count++).toString(36);
          }
          function bus(arg1, arg2) {
            if (typeof arg1 === "function") {
              var f = reactive(arg1);
              f();
              return f;
            } else
              return subspace(arg1, arg2);
          }
          var id = "bus-" + Math.random().toString(36).substring(7);
          bus.toString = function() {
            return bus.label || "bus" + this_bus_num || id;
          };
          bus.delete_bus = function() {
            delete busses[bus.id];
          };
          var cache = {};
          var backup_cache = {};
          var versions = {};
          function update_cache(object, cache2) {
            var modified_keys = new Set();
            function update_object(obj) {
              if (Array.isArray(obj))
                obj = obj.slice();
              else if (typeof obj === "object" && obj && !(obj.key && cache2[obj.key] === obj)) {
                var tmp = {};
                for (var k in obj)
                  tmp[k] = obj[k];
                obj = tmp;
              }
              if ((nodejs ? global : window).pointerify && obj && obj._key) {
                if (Object.keys(obj).length > 1)
                  console.error("Got a {_key: ...} object with additional fields");
                obj = bus.cache[obj._key] = bus.cache[obj._key] || { key: obj._key };
              } else if (obj && obj.key) {
                bogus_check(obj.key);
                if (cache2 !== backup_cache)
                  if (changed(obj))
                    modified_keys.add(obj.key);
                  else
                    log("Boring modified key", obj.key);
                if (!cache2[obj.key])
                  cache2[obj.key] = obj;
                else if (obj !== cache2[obj.key]) {
                  for (var k in obj)
                    if (cache2[obj.key][k] !== obj[k])
                      cache2[obj.key][k] = obj[k];
                  for (var k in cache2[obj.key])
                    if (!obj.hasOwnProperty(k))
                      delete cache2[obj.key][k];
                }
                obj = cache2[obj.key];
              }
              return obj;
            }
            deep_map(object, update_object);
            return modified_keys.values();
          }
          function changed(object) {
            return pending_gets[object.key] || !cache.hasOwnProperty(object.key) || !backup_cache.hasOwnProperty(object.key) || !deep_equals(object, backup_cache[object.key]);
          }
          function abort_changes(keys4) {
            for (var i2 = 0; i2 < keys4.length; i2++)
              update_cache(backup_cache[keys4[i2]], cache);
          }
          function forget(key2, set_handler, t2) {
            if (arguments.length === 0) {
              console.assert(
                executing_funk !== global_funk,
                "forget() with no arguments forgets the currently executing reactive function.\nHowever, there is no currently executing reactive function."
              );
              executing_funk.forget();
              return;
            }
            bogus_check(key2);
            set_handler = set_handler || executing_funk;
            var fkey = funk_key(set_handler);
            if (!gets_in.has(key2, fkey)) {
              console.error(
                "***\n****\nTrying to forget lost key",
                key2,
                "from",
                funk_name(set_handler),
                fkey,
                "that hasn't got that key."
              );
              console.trace();
              return;
            }
            gets_in.delete(key2, fkey);
            unbind(key2, "on_set", set_handler);
            if (!gets_in.has_any(key2)) {
              clearTimeout(to_be_forgotten[key2]);
              to_be_forgotten[key2] = setTimeout(function() {
                bus.route(key2, "forgetter", key2, t2);
                delete gets_out[key2];
                delete to_be_forgotten[key2];
              }, 200);
            }
          }
          function del(key2, t2) {
            key2 = key2.key || key2;
            bogus_check(key2);
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes([key2]);
              return;
            }
            statelog(key2, yellow, "v", "Deleting " + key2);
            var handlers_called = bus.route(key2, "deleter", key2);
            if (handlers_called === 0) {
              delete cache[key2];
              delete backup_cache[key2];
            }
            bus.route(key2, "on_delete", cache[key2] || { key: key2 }, t2);
          }
          var changed_keys = new Set();
          var dirty_getters = {};
          function dirty(key2, t2) {
            statelog(key2, brown, "*", bus + ".dirty('" + key2 + "')");
            bogus_check(key2);
            var version = t2 && t2.version || "dirty-" + new_version();
            var found = false;
            if (gets_out.hasOwnProperty(key2))
              for (var i2 = 0; i2 < gets_out[key2].length; i2++) {
                dirty_getters[funk_key(gets_out[key2][i2])] = version;
                found = true;
              }
            clean_timer = clean_timer || setTimeout(clean);
            if (!found && cache.hasOwnProperty(key2))
              mark_changed(key2, t2);
          }
          function mark_changed(key2, t2) {
            log("Marking changed", bus.toString(), key2);
            changed_keys.add(key2);
            clean_timer = clean_timer || setTimeout(clean);
          }
          function clean() {
            var dirty_funks = {};
            for (var b in busses) {
              var fs = busses[b].rerunnable_funks();
              for (var i2 = 0; i2 < fs.length; i2++)
                dirty_funks[fs[i2].funk_key] = fs[i2].at_version;
            }
            clean_timer = null;
            log(bus.label, "Cleaning up", Object.keys(dirty_funks).length, "funks");
            for (var k in dirty_funks) {
              var funk = funks[k], version = dirty_funks[k];
              var p = funk.proxies_for;
              if (p && p.priority) {
                log("Clean-early:", funk_name(funk));
                if (!funk.global_funk)
                  funk.latest_reaction_at = version;
                funk.react();
                delete dirty_funks[k];
              }
            }
            for (var k in dirty_funks) {
              var funk = funks[k], version = dirty_funks[k];
              log("Clean:", funk_name(funk));
              if (bus.render_when_loading || !funk.loading()) {
                if (!funk.global_funk)
                  funk.latest_reaction_at = version;
                funk.react();
              }
            }
          }
          function rerunnable_funks() {
            var result = [];
            var keys4 = changed_keys.values();
            for (var i2 = 0; i2 < keys4.length; i2++) {
              var fs = bindings(keys4[i2], "on_set");
              for (var j = 0; j < fs.length; j++) {
                var f = fs[j].func;
                if (f.react) {
                  var v = f.getted_keys[JSON.stringify([this.id, keys4[i2]])];
                  if (v && v.indexOf(versions[keys4[i2]]) !== -1) {
                    log("skipping", funk_name(f), "already at version", versions[keys4[i2]], "proof:", v);
                    continue;
                  }
                } else {
                  f.seen_keys = f.seen_keys || {};
                  var v = f.seen_keys[JSON.stringify([this.id, keys4[i2]])];
                  if (v && v.indexOf(versions[keys4[i2]]) !== -1) {
                    continue;
                  }
                  autodetect_args(f);
                  f = run_handler(f, "on_set", cache[keys4[i2]], {
                    dont_run: true,
                    binding: keys4[i2]
                  });
                }
                result.push({
                  funk_key: funk_key(f),
                  at_version: versions[keys4[i2]]
                });
              }
            }
            for (var k in dirty_getters)
              result.push({
                funk_key: k,
                at_version: dirty_getters[k]
              });
            changed_keys.clear();
            dirty_getters = {};
            return result;
          }
          function subspace(key2, params) {
            var methods = {
              getter: null,
              setter: null,
              on_set: null,
              on_set_sync: null,
              on_delete: null,
              deleter: null,
              forgetter: null
            };
            if (params) {
              for (var method in params) {
                var func = params[method];
                var param_names = {
                  get: "getter",
                  set: "setter",
                  delete: "deleter",
                  forget: "forgetter",
                  on_set: "on_set",
                  on_set_sync: "on_set_sync"
                };
                console.assert(
                  param_names[method],
                  'Method "' + method + '" is invalid'
                );
                method = param_names[method];
                autodetect_args(func);
                func.defined = func.defined || [];
                func.defined.push({ bus, method, key: key2, as: "handler" });
                func.use_linked_json = true;
                bind(key2, method, func, "allow_wildcards");
              }
            } else {
              var result = {};
              for (var method in methods)
                (function(method2) {
                  Object.defineProperty(result, method2, {
                    set: function(func2) {
                      autodetect_args(func2);
                      func2.defined = func2.defined || [];
                      func2.defined.push(
                        { as: "handler", bus, method: method2, key: key2 }
                      );
                      bind(key2, method2, func2, "allow_wildcards");
                    },
                    get: function() {
                      var result2 = bindings(key2, method2);
                      for (var i2 = 0; i2 < result2.length; i2++)
                        result2[i2] = result2[i2].func;
                      result2.delete = function(func2) {
                        unbind(key2, method2, func2, "allow_wildcards");
                      };
                      return result2;
                    }
                  });
                })(method);
              return result;
            }
          }
          function autodetect_args(handler) {
            if (handler.args)
              return;
            var comments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, params = /([^\s,]+)/g, s = handler.toString().replace(comments, "");
            params = s.slice(s.indexOf("(") + 1, s.indexOf(")")).match(params) || [];
            handler.args = {};
            for (var i2 = 0; i2 < params.length; i2++)
              switch (params[i2]) {
                case "key":
                case "k":
                  handler.args["key"] = i2;
                  break;
                case "json":
                case "vars":
                  handler.args["vars"] = i2;
                  break;
                case "star":
                case "rest":
                  handler.args["rest"] = i2;
                  break;
                case "cb":
                case "t":
                case "transaction":
                  handler.args["t"] = i2;
                  break;
                case "o":
                case "obj":
                case "val":
                case "new":
                case "New":
                  handler.args["obj"] = i2;
                  break;
                case "old":
                  handler.args["old"] = i2;
                  break;
              }
          }
          var handlers = new One_To_Many();
          var wildcard_handlers = [];
          var to_be_forgotten = {};
          function bind(key2, method, func, allow_wildcards) {
            bogus_check(key2);
            if (allow_wildcards && key2[key2.length - 1] === "*")
              wildcard_handlers.push({
                prefix: key2,
                method,
                funk: func
              });
            else
              handlers.add(method + " " + key2, funk_key(func));
          }
          function unbind(key2, method, funk, allow_wildcards) {
            bogus_check(key2);
            if (allow_wildcards && key2[key2.length - 1] === "*")
              for (var i2 = 0; i2 < wildcard_handlers.length; i2++) {
                var handler = wildcard_handlers[i2];
                if (handler.prefix === key2 && handler.method === method && handler.funk === funk) {
                  wildcard_handlers.splice(i2, 1);
                  i2--;
                }
              }
            else
              handlers.delete(method + " " + key2, funk_key(funk));
          }
          function bindings(key2, method) {
            bogus_check(key2);
            if (typeof key2 !== "string") {
              console.error("Error:", key2, "is not a string", method);
              console.trace();
            }
            var result = [];
            var seen = {};
            var exacts = handlers.get(method + " " + key2);
            for (var i2 = 0; i2 < exacts.length; i2++) {
              var f = funks[exacts[i2]];
              if (!seen[funk_key(f)]) {
                f.statebus_binding = { key: key2, method };
                result.push({ method, key: key2, func: f });
                seen[funk_key(f)] = true;
              }
            }
            let handler;
            for (var i2 = 0; i2 < wildcard_handlers.length; i2++) {
              handler = wildcard_handlers[i2];
              var prefix2 = handler.prefix.slice(0, -1);
              if (prefix2 === key2.substr(0, prefix2.length) && method === handler.method && !seen[funk_key(handler.funk)]) {
                handler.funk.statebus_binding = { key: handler.prefix, method };
                result.push({ method, key: handler.prefix, func: handler.funk });
                seen[funk_key(handler.funk)] = true;
              }
            }
            return result;
          }
          function run_handler(funck, method, arg, options2) {
            options2 = options2 || {};
            var t2 = options2.t, just_make_it = options2.dont_run, binding = options2.binding;
            var funk = funck.react && funck, func = !funk && funck;
            console.assert(funk || func);
            if (false) {
              var event = {
                "setter": "set",
                "on_set": "set.fire",
                "getter": "get",
                "deleter": "delete",
                "forgetter": "forget"
              }[method], triggering = funk ? "re-running" : "initiating";
              console.log("   > a", bus + "." + event + "('" + (arg.key || arg) + "') is " + triggering + "\n     " + funk_name(funck));
            }
            if (funk) {
              if (method !== "on_set") {
                console.error(method === "on_set", `Funk is being re-triggered, but isn't on_set. It is: "` + method + '", oh and funk: ' + funk_name(funk));
                return;
              }
              return funk.react();
            }
            function key_arg() {
              return typeof arg.key == "string" ? arg.key : arg;
            }
            function rest_arg() {
              return key_arg().substr(binding.length - 1);
            }
            function val_arg() {
              console.assert(
                method === "setter" || method === "on_set" || method === "on_set_sync",
                "Bad method for val_arg()"
              );
              return arg.key ? func.use_linked_json ? arg.val : arg : void 0;
            }
            function vars_arg() {
              var r = rest_arg();
              try {
                return JSON.parse(r);
              } catch (e2) {
                return 'Bad JSON "' + r + '" for key ' + key_arg();
              }
            }
            var f = reactive(function() {
              t2 = clone(t2 || {});
              if (method === "setter" || method === "deleter")
                t2.abort = function() {
                  var key4 = method === "setter" ? arg.key : arg;
                  if (f.loading())
                    return;
                  bus.cache[key4] = bus.cache[key4] || { key: key4 };
                  bus.backup_cache[key4] = bus.backup_cache[key4] || { key: key4 };
                  bus.set.abort(bus.cache[key4]);
                };
              if (method !== "forgetter")
                t2.done = function(o) {
                  var key4 = method === "setter" ? arg.key : arg;
                  if (func.use_linked_json)
                    o = { key: key4, val: o };
                  bus.log("We are DONE()ing", method, key4, o || arg);
                  if (o)
                    t2.version = new_version();
                  if (method === "deleter") {
                    delete bus.cache[key4];
                    delete bus.backup_cache[key4];
                  } else if (method === "setter") {
                    bus.set.fire(o || arg, t2);
                    bus.route(key4, "on_set_sync", o || arg, t2);
                  } else {
                    o.key = key4;
                    bus.set.fire(o, t2);
                    delete t2.version;
                  }
                };
              t2.return = t2.done;
              if (method === "setter")
                t2.reget = function() {
                  bus.dirty(arg.key);
                };
              var args = [];
              args[0] = method in { setter: 1, on_set: 1, on_set_sync: 1 } ? val_arg() : arg;
              args[1] = t2;
              for (var k in func.args || {}) {
                switch (k) {
                  case "key":
                    args[func.args[k]] = key_arg();
                    break;
                  case "rest":
                    args[func.args[k]] = rest_arg();
                    break;
                  case "vars":
                    args[func.args[k]] = vars_arg();
                    break;
                  case "t":
                    args[func.args[k]] = t2;
                    break;
                  case "obj":
                    args[func.args[k]] = val_arg();
                    break;
                  case "old":
                    var key3 = key_arg();
                    args[func.args[k]] = bus.cache[key3] || (bus.cache[key3] = { key: key3 });
                    break;
                }
              }
              var result = func.apply(null, args);
              console.assert(
                !(result === "getter" && (result === "done" || result === "abort")),
                'Returning "done" or "abort" is not allowed from getter handlers'
              );
              if (result === "done")
                t2.done();
              if (result === "abort")
                t2.abort();
              if (func.use_linked_json) {
                if (method === "getter" && result !== void 0 && !f.loading()) {
                  var obj = { key: arg, val: result };
                  var new_t = clone(t2 || {});
                  new_t.getter = true;
                  set.fire(obj, new_t);
                  return result;
                }
              } else {
                if (method === "getter" && result instanceof Object && !f.loading()) {
                  result.key = arg;
                  var new_t = clone(t2 || {});
                  new_t.getter = true;
                  set.fire(result, new_t);
                  return result;
                }
              }
              if (method !== "getter" && !f.loading())
                f.forget();
            });
            f.proxies_for = func;
            f.arg = arg;
            f.transaction = t2 || {};
            if (method === "getter") {
              let handler_done2 = function() {
                f.forget();
                unbind(key2, "forgetter", handler_done2);
              };
              var handler_done = handler_done2;
              var key2 = arg;
              bind(key2, "forgetter", handler_done2);
              gets_out[key2] = gets_out[key2] || [];
              gets_out[key2].push(f);
              pending_gets[key2] = f;
            }
            if (just_make_it)
              return f;
            return f();
          }
          bus.route = function(key2, method, arg, t2) {
            var handlers3 = bus.bindings(key2, method);
            if (handlers3.length)
              log("route:", bus + '("' + key2 + '").' + method + "[" + handlers3.length + '](key:"' + (arg.key || arg) + '")');
            for (var i2 = 0; i2 < handlers3.length; i2++)
              bus.run_handler(handlers3[i2].func, method, arg, { t: t2, binding: handlers3[i2].key });
            return handlers3.length;
          };
          if (!global_funk) {
            global_funk = reactive(function global_funk2() {
            });
            global_funk.global_funk = true;
            executing_funk = global_funk;
            funks[global_funk.statebus_id = "global funk"] = global_funk;
          }
          function reactive(func) {
            function funk() {
              console.assert(executing_funk === global_funk || executing_funk !== funk, "Recursive funk", funk.func);
              if (funk.called_directly)
                funk.this = this, funk.args = arguments;
              funk.forget();
              var last_executing_funk = executing_funk;
              executing_funk = funk;
              try {
                var result = func.apply(funk.this, funk.args);
              } catch (e2) {
                if (e2.message === "Maximum call stack size exceeded") {
                  console.error(e2);
                  process.exit();
                }
                if (funk.loading())
                  return null;
                else {
                  if (nodejs) {
                    console.error(e2.stack);
                    process.exit();
                  } else {
                    var result = func.apply(funk.this, funk.args);
                    console.error("Non-deterministic Error!", e2.stack || e2);
                    console.warn("A non-deterministic error is when your reactive function triggers an error only some of the times it's called.\nThe error originated from calling:", funk_name(func, 400));
                  }
                }
              } finally {
                executing_funk = last_executing_funk;
              }
              return result;
            }
            funk.func = func;
            funk.called_directly = true;
            funk.getted_keys = {};
            funk.abortable_keys = [];
            funk.has_seen = function(bus3, key2, version) {
              var bus_key = JSON.stringify([bus3.id, key2]);
              var seen_versions = this.getted_keys[bus_key] = this.getted_keys[bus_key] || [];
              seen_versions.push(version);
              if (seen_versions.length > 50)
                seen_versions.shift();
            };
            funk.react = function() {
              var result;
              try {
                funk.called_directly = false;
                result = funk();
              } finally {
                funk.called_directly = true;
              }
              return result;
            };
            funk.forget = function() {
              if (funk.statebus_id === "global funk")
                return;
              for (var hash in funk.getted_keys) {
                var tmp = JSON.parse(hash), bus3 = busses[tmp[0]], key2 = tmp[1];
                if (bus3)
                  bus3.forget(key2, funk);
              }
              funk.getted_keys = {};
            };
            funk.loading = function() {
              for (var hash in funk.getted_keys) {
                var tmp = JSON.parse(hash), bus3 = busses[tmp[0]], key2 = tmp[1];
                if (bus3 && bus3.pending_gets[key2])
                  return true;
              }
              return false;
            };
            funk.is_loading = funk.loading;
            return funk;
          }
          function loading_keys(keys4) {
            for (var i2 = 0; i2 < keys4.length; i2++)
              if (pending_gets[keys4[i2]])
                return true;
            return false;
          }
          function loading() {
            return executing_funk.loading();
          }
          bus.default = function() {
            bus.deep_map(arguments, function(o) {
              if (o.key && !bus.cache.hasOwnProperty(o.key))
                bus.cache[o.key] = o;
              return o;
            });
          };
          function once(f) {
            var r = reactive(function() {
              f();
              if (!r.loading())
                r.forget();
            });
            r();
          }
          if (nodejs)
            var red = "\x1B[31m", normal = "\x1B[0m", grey = "\x1B[0;38;5;245m", green = "\x1B[0;38;5;46m", brown = "\x1B[0;38;5;130m", yellow = "\x1B[0;38;5;226m";
          else
            var red = "", normal = "", grey = "", green = "", brown = "";
          function add_diff_msg(message, obj) {
            var diff = sorta_diff(
              backup_cache[obj.key] && backup_cache[obj.key].val,
              obj && obj.val
            );
            if (diff) {
              var end_col = message.length + 2 + statelog_indent * 3;
              for (var i2 = 0; i2 < 40 - end_col; i2++)
                message += " ";
              message += diff.substring(0, 80);
            } else
              message += " <no diff>";
            return message;
          }
          function set_msg(obj, t2, meth) {
            if (!honking_at(obj.key))
              return;
            var message = t2 && t2.m || bus + "." + meth + "('" + obj.key + "')";
            message = add_diff_msg(message, obj);
            if (t2.version)
              message += " [" + t2.version + "]";
            return message;
          }
          var uncallback_counter = 0;
          function uncallback(f, options2) {
            name = options2 && options2.name || f.name || uncallback_counter + "";
            if (!name)
              throw "Uncallback function needs a name";
            var watching = {};
            var prefix2 = "uncallback/" + name;
            bus(prefix2 + "/*").getter = function(key2, json) {
              var args = json;
              function cb(err, result) {
                if (err) {
                  console.trace("have err:", err, "and result is", JSON.stringify(result));
                  throw err;
                } else
                  bus.set.fire({ key: key2, _: result });
              }
              args[options2.callback_at || args.length] = cb;
              f.apply({ key: key2 }, args);
              if (options2.start_watching && !watching[key2]) {
                watching[key2] = true;
                options2.start_watching(
                  args,
                  function() {
                    bus.dirty(key2);
                  },
                  function() {
                    bus.del(key2);
                  }
                );
              }
            };
            if (options2.stop_watching)
              bus(prefix2 + "/*").forgetter = function(key2, json) {
                console.assert(
                  watching[key2],
                  "Forgetting a watcher for " + JSON.stringify(key2) + " that is not enabled"
                );
                delete watching[key2];
                options2.stop_watching(json);
              };
            return function() {
              var args = [].slice.call(arguments);
              return bus.get(prefix2 + "/" + JSON.stringify(args))._;
            };
          }
          function unpromise(f) {
            return uncallback(function() {
              var args = [].slice.call(arguments);
              var cb = args.pop();
              f.apply(null, args).then(cb);
            });
          }
          function aget(key2) {
            return new Promise((resolve, reject) => bus.get_once(key2, (o) => resolve(o)));
          }
          var symbols = {
            is_proxy: Symbol("is_proxy"),
            is_link: Symbol("is_link"),
            get_json: Symbol("get_json"),
            get_base: Symbol("get_base")
          };
          function make_proxy() {
            function item_proxy(base2, o) {
              if (typeof o === "number" || typeof o === "string" || typeof o === "boolean" || o === void 0 || o === null || typeof o === "function")
                return o;
              if (typeof o === "object" && "link" in o) {
                var new_base = bus.get(o.link);
                return item_proxy(new_base, new_base.val);
              }
              return new Proxy(o, {
                get: function get2(o2, k) {
                  if (k === "inspect" || k === "valueOf")
                    return void 0;
                  if (k === symbols.is_proxy)
                    return true;
                  if (typeof k === "symbol")
                    return void 0;
                  return item_proxy(base2, o2[proxied_2_keyed(k)]);
                },
                set: function set2(o2, k, v) {
                  var value = translate_fields(v, proxied_2_keyed);
                  o2[proxied_2_keyed(k)] = value;
                  bus.set(base2);
                  return true;
                },
                has: function has(o2, k) {
                  return o2.hasOwnProperty(proxied_2_keyed(k));
                },
                deleteProperty: function del2(o2, k) {
                  delete o2[proxied_2_keyed(k)];
                }
              });
            }
            return new Proxy(cache, {
              get: function get2(o, k) {
                if (k === "inspect" || k === "valueOf" || typeof k === "symbol")
                  return void 0;
                bogus_check(k);
                var base2 = bus.get(k);
                return item_proxy(base2, base2.val);
              },
              set: function set2(o, key2, val) {
                bus.set({
                  key: key2,
                  val: translate_fields(val, proxied_2_keyed)
                });
                return true;
              },
              deleteProperty: function del2(o, k) {
                bus.delete(proxied_2_keyed(k));
              }
            });
          }
          bus.state = make_proxy();
          function link(url) {
            var result = bus.get(url);
            result[symbols.is_link] = true;
            return result;
          }
          if (!nodejs)
            window.devtoolsFormatters = [{
              header: function(x) {
                if (x[symbols.is_proxy])
                  return [
                    "span",
                    { style: "background-color: #fffbe5; padding: 3px;" },
                    JSON.stringify(x)
                  ];
              },
              hasBody: function(x) {
                return false;
              }
            }];
          function get_domain(key2) {
            var m = key2.match(/^i?statei?\:\/\/(([^:\/?#]*)(?:\:([0-9]+))?)/);
            return m && m[0];
          }
          function message_method(m) {
            return m.get && "get" || m.set && "set" || m["delete"] && "delete" || m.forget && "forget";
          }
          function ws_mount(prefix2, url, client_creds2) {
            var preprefix = prefix2.slice(0, -1);
            var is_absolute = /^i?statei?:\/\//;
            var has_prefix = new RegExp("^" + preprefix);
            var bus3 = this;
            var sock;
            var attempts = 0;
            var outbox = [];
            var client_getted_keys = new bus3.Set();
            var heartbeat;
            if (url[url.length - 1] == "/")
              url = url.substr(0, url.length - 1);
            function nlog(s) {
              if (nodejs) {
                console.log(s);
              } else
                console.log("%c" + s, "color: blue");
            }
            function send(o, pushpop) {
              pushpop = pushpop || "push";
              o = rem_prefixes(o);
              var m = message_method(o);
              if (m == "get" || m == "delete" || m == "forget")
                o[m] = rem_prefix(o[m]);
              bus3.log("ws_mount.send:", JSON.stringify(o));
              outbox[pushpop](JSON.stringify(o));
              flush_outbox();
            }
            function flush_outbox() {
              if (sock.readyState === 1)
                while (outbox.length > 0)
                  if (bus3.simulate_network_delay) {
                    var msg2 = outbox.shift();
                    setTimeout(function() {
                      sock.send(msg2);
                    }, bus3.simulate_network_delay);
                  } else
                    sock.send(outbox.shift());
              else
                setTimeout(flush_outbox, 400);
            }
            function add_prefix(key2) {
              return is_absolute.test(key2) ? key2 : preprefix + key2;
            }
            function rem_prefix(key2) {
              return has_prefix.test(key2) ? key2.substr(preprefix.length) : key2;
            }
            function add_prefixes(obj) {
              var keyed = bus3.translate_keys(bus3.clone(obj), add_prefix);
              return bus3.translate_links(bus3.clone(keyed), add_prefix);
            }
            function rem_prefixes(obj) {
              var keyed = bus3.translate_keys(bus3.clone(obj), rem_prefix);
              return bus3.translate_links(bus3.clone(keyed), rem_prefix);
            }
            bus3(prefix2).setter = function(obj, t2) {
              bus3.set.fire(obj);
              var x = { set: obj };
              if (t2.version)
                x.version = t2.version;
              if (t2.parents)
                x.parents = t2.parents;
              if (t2.patch)
                x.patch = t2.patch;
              if (t2.patch)
                x.set = rem_prefix(x.set.key);
              send(x);
            };
            bus3(prefix2).getter = function(key2) {
              send({ get: key2 }), client_getted_keys.add(key2);
            };
            bus3(prefix2).forgetter = function(key2) {
              send({ forget: key2 }), client_getted_keys.delete(key2);
            };
            bus3(prefix2).deleter = function(key2, t2) {
              t2.done();
              send({ "delete": key2 });
            };
            function connect() {
              nlog("[ ] trying to open " + url);
              sock = bus3.make_websocket(url);
              sock.onopen = function() {
                nlog("[*] opened " + url);
                var peers = bus3.get("peers");
                peers[url] = peers[url] || {};
                peers[url].connected = true;
                set(peers);
                var creds = client_creds2 || bus3.client_creds && bus3.client_creds(url);
                if (creds) {
                  let intro2 = function(o) {
                    i2.push(JSON.stringify({ set: o }));
                  };
                  var intro = intro2;
                  var i2 = [];
                  if (creds.clientid)
                    intro2({ key: "current_user", val: { client: creds.clientid } });
                  if (creds.name && creds.pass)
                    intro2({ key: "current_user", val: { login_as: { name: creds.name, pass: creds.pass } } });
                  if (creds.private_key && creds.public_key) {
                  }
                  outbox = i2.concat(outbox);
                  flush_outbox();
                }
                if (attempts > 0) {
                  var keys4 = client_getted_keys.values();
                  for (var i2 = 0; i2 < keys4.length; i2++)
                    send({ get: keys4[i2] });
                }
                attempts = 0;
              };
              sock.onclose = function() {
                if (done) {
                  nlog("[*] closed " + url + ". Goodbye!");
                  return;
                }
                nlog("[*] closed " + url);
                heartbeat && clearInterval(heartbeat);
                heartbeat = null;
                setTimeout(connect, attempts++ < 3 ? 1500 : 5e3);
                var peers = bus3.get("peers");
                peers[url] = peers[url] || {};
                peers[url].connected = false;
                set(peers);
                var new_outbox = [];
                var bad = { "get": 1, "forget": 1 };
                for (var i2 = 0; i2 < outbox.length; i2++)
                  if (!bad[JSON.parse(outbox[i2]).method])
                    new_outbox.push(outbox[i2]);
                outbox = new_outbox;
              };
              sock.onmessage = function(event) {
                try {
                  var message = JSON.parse(event.data);
                  var method = message_method(message);
                  if (method !== "set" && method !== "pong")
                    throw "barf";
                  bus3.log("net client received", message);
                  var t2 = {
                    version: message.version,
                    parents: message.parents,
                    patch: message.patch
                  };
                  if (t2.patch)
                    msg.set = apply_patch(
                      bus3.cache[msg.set] || { key: msg.set },
                      message.patch[0]
                    );
                  if (!(t2.version || t2.parents || t2.patch))
                    t2 = void 0;
                  bus3.set.fire(add_prefixes(message.set), t2);
                } catch (err) {
                  console.error("Received bad network message from " + url + ": ", event.data, err);
                  return;
                }
              };
            }
            connect();
            var done = false;
            return { send, sock, close: function() {
              done = true;
              sock.close();
            } };
          }
          bus.client_creds = function client_creds2(server_url) {
            return { clientid: Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) };
          };
          function net_automount() {
            var bus3 = this;
            var old_route = bus3.route;
            var connections = {};
            bus3.route = function(key2, method, arg, t2) {
              var d = get_domain(key2);
              if (d && !connections[d]) {
                bus3.ws_mount(d + "/*", d);
                connections[d] = true;
              }
              return old_route(key2, method, arg, t2);
            };
          }
          function translate_keys(obj, f) {
            if (Array.isArray(obj))
              for (var i2 = 0; i2 < obj.length; i2++)
                translate_keys(obj[i2], f);
            else if (typeof obj === "object")
              for (var k in obj) {
                if (k === "key" || /.*_key$/.test(k)) {
                  if (typeof obj[k] == "string")
                    obj[k] = f(obj[k]);
                  else if (Array.isArray(obj[k]))
                    for (var i2 = 0; i2 < obj[k].length; i2++) {
                      if (typeof obj[k][i2] === "string")
                        obj[k][i2] = f(obj[k][i2]);
                    }
                }
                translate_keys(obj[k], f);
              }
            return obj;
          }
          function escape_keys(k) {
            return k.replace(/(_(keys?|time)?$|^key$)/, "$1_");
          }
          function unescape_keys(k) {
            return k.replace(/(_$)/, "");
          }
          function translate_links(obj, f) {
            if (Array.isArray(obj))
              for (var i2 = 0; i2 < obj.length; i2++)
                translate_links(obj[i2], f);
            else if (typeof obj === "object")
              for (var k in obj) {
                if (k === "link") {
                  if (typeof obj[k] == "string")
                    obj[k] = f(obj[k]);
                  else if (Array.isArray(obj[k]))
                    for (var i2 = 0; i2 < obj[k].length; i2++) {
                      if (typeof obj[k][i2] === "string")
                        obj[k][i2] = f(obj[k][i2]);
                    }
                }
                translate_links(obj[k], f);
              }
            return obj;
          }
          function translate_fields(input, f) {
            var result;
            if (Array.isArray(input)) {
              var new_array = input.slice();
              for (var i2 = 0; i2 < input.length; i2++)
                new_array[i2] = translate_fields(input[i2], f);
              result = new_array;
            } else if (typeof input === "object" && input !== null) {
              var new_obj = {};
              for (var k in input)
                new_obj[f(k, input)] = translate_fields(input[k], f);
              result = new_obj;
            } else
              result = input;
            return result;
          }
          function keyed_2_proxied(k, object) {
            if (object[symbols.is_link])
              return k;
            else
              return k.replace(/^(_*)_key$/, "$1key");
          }
          function proxied_2_keyed(k) {
            return k.replace(/^(_*)key$/, "$1_key");
          }
          function json_encode(highlevel_obj) {
          }
          function json_decode(lowlevel_obj) {
          }
          function key_id(string2) {
            return string2.match(/\/?[^\/]+\/(\d+)/)[1];
          }
          function key_name(string2) {
            return string2.match(/\/?([^\/]+).*/)[1];
          }
          function apply_patch(obj, patch) {
            obj = bus.clone(obj);
            var x = patch.match(/(.*) = (.*)/), path2 = x[1], new_stuff = JSON.parse(x[2]);
            var path_segment = /^(\.([^\.\[]+))|(\[((-?\d+):)?(-?\d+)\])/;
            var curr_obj = obj, last_obj = null;
            function de_neg(x2) {
              return x2[0] === "-" ? curr_obj.length - parseInt(x2.substr(1)) : parseInt(x2);
            }
            while (true) {
              var match = path_segment.exec(path2), subpath = match[0], field = match[2], slice_start = match[5], slice_end = match[6];
              slice_start = slice_start && de_neg(slice_start);
              slice_end = slice_end && de_neg(slice_end);
              if (path2.length == subpath.length) {
                if (field)
                  curr_obj[field] = new_stuff;
                else if (typeof curr_obj == "string") {
                  console.assert(typeof new_stuff == "string");
                  if (!slice_start) {
                    slice_start = slice_end;
                    slice_end = slice_end + 1;
                  }
                  if (last_obj) {
                    var s = last_obj[last_field];
                    last_obj[last_field] = s.slice(0, slice_start) + new_stuff + s.slice(slice_end);
                  } else
                    return obj.slice(0, slice_start) + new_stuff + obj.slice(slice_end);
                } else if (slice_start)
                  [].splice.apply(curr_obj, [slice_start, slice_end - slice_start].concat(new_stuff));
                else {
                  console.assert(slice_end >= 0, "Index " + subpath + " is too small");
                  console.assert(
                    slice_end <= curr_obj.length - 1,
                    "Index " + subpath + " is too big"
                  );
                  curr_obj[slice_end] = new_stuff;
                }
                return obj;
              }
              console.assert(!slice_start, "No splices allowed in middle of path");
              last_obj = curr_obj;
              last_field = field;
              curr_obj = curr_obj[field || slice_end];
              path2 = path2.substr(subpath.length);
            }
          }
          function parse(s) {
            try {
              return JSON.parse(s);
            } catch (e2) {
              return {};
            }
          }
          function One_To_Many() {
            var hash = this.hash = {};
            var counts = {};
            this.get = function(k) {
              return Object.keys(hash[k] || {});
            };
            this.add = function(k, v) {
              if (hash[k] === void 0)
                hash[k] = {};
              if (counts[k] === void 0)
                counts[k] = 0;
              if (!hash[k][v])
                counts[k]++;
              hash[k][v] = true;
            };
            this.delete = function(k, v) {
              delete hash[k][v];
              counts[k]--;
            };
            this.delete_all = function(k) {
              delete hash[k];
              delete counts[k];
            };
            this.has = function(k, v) {
              return hash[k] && hash[k][v];
            };
            this.has_any = function(k) {
              return counts[k];
            };
            this.del = this.delete;
          }
          function Set() {
            var hash = {};
            this.add = function(a) {
              hash[a] = true;
            };
            this.has = function(a) {
              return a in hash;
            };
            this.values = function() {
              return Object.keys(hash);
            };
            this.delete = function(a) {
              delete hash[a];
            };
            this.clear = function() {
              hash = {};
            };
            this.del = this.delete;
            this.all = this.values;
          }
          function clone(item) {
            if (!item || item instanceof Number || item instanceof String || item instanceof Boolean)
              return item;
            if (Array.isArray(item)) {
              item = item.slice();
              for (var i2 = 0; i2 < item.length; i2++)
                item[i2] = clone(item[i2]);
              return item;
            }
            if (typeof item == "object") {
              if (item.nodeType && typeof item.cloneNode == "function")
                return item.cloneNode(true);
              if (item instanceof Date)
                return new Date(item);
              else {
                var result = {};
                for (var i2 in item)
                  result[i2] = clone(item[i2]);
                return result;
              }
            }
            return item;
          }
          function extend(obj, with_obj) {
            if (with_obj === void 0)
              return obj;
            for (var attr in with_obj)
              if (obj.hasOwnProperty(attr))
                obj[attr] = with_obj[attr];
            return obj;
          }
          function deep_map(object, func) {
            object = func(object);
            if (Array.isArray(object))
              for (var i2 = 0; i2 < object.length; i2++)
                object[i2] = deep_map(object[i2], func);
            else if (typeof object === "object")
              for (var k in object)
                object[k] = deep_map(object[k], func);
            return object;
          }
          function deep_equals(a, b) {
            if (a === b || isNaN(a) && isNaN(b) && typeof a === "number" && typeof b === "number")
              return true;
            var a_array = Array.isArray(a), b_array = Array.isArray(b);
            if (a_array !== b_array)
              return false;
            if (a_array) {
              if (a.length !== b.length)
                return false;
              for (var i2 = 0; i2 < a.length; i2++)
                if (!deep_equals(a[i2], b[i2]))
                  return false;
              return true;
            }
            var a_obj = a && typeof a === "object", b_obj = b && typeof b === "object";
            if (a_obj !== b_obj)
              return false;
            if (a_obj) {
              var a_length = 0, b_length = 0;
              for (var k in a) {
                a_length++;
                if (!deep_equals(a[k], b[k]))
                  return false;
              }
              for (var k in b)
                b_length++;
              if (a_length !== b_length)
                return false;
              return true;
            }
            return false;
          }
          function sorta_diff(a, b) {
            if (a === b || isNaN(a) && isNaN(b) && typeof a === "number" && typeof b === "number")
              return null;
            var a_array = Array.isArray(a), b_array = Array.isArray(b);
            if (a_array !== b_array)
              return " = " + JSON.stringify(b);
            if (a_array) {
              if (a.length === b.length - 1 && deep_equals(a[a.length - 1], b[b.length - 2])) {
                return ".push(" + JSON.stringify(b[b.length - 1]) + ")";
              }
              for (var i2 = 0; i2 < a.length; i2++) {
                var tmp = sorta_diff(a[i2], b[i2]);
                if (tmp)
                  return "[" + i2 + "]" + tmp;
              }
              return null;
            }
            var a_obj = a && typeof a === "object", b_obj = b && typeof b === "object";
            if (a_obj !== b_obj)
              return " = " + JSON.stringify(b);
            if (a_obj) {
              for (var k in a) {
                var tmp = sorta_diff(a[k], b[k]);
                if (tmp)
                  return "." + k + tmp;
              }
              for (var k in b) {
                if (!a.hasOwnProperty(k))
                  return "." + k + " = " + JSON.stringify(b[k]);
              }
              return null;
            }
            return " = " + JSON.stringify(b);
          }
          function prune(obj) {
            var bus3 = this;
            obj = bus3.clone(obj);
            function recurse(o) {
              if (Array.isArray(o))
                for (var i2 = 0; i2 < o.length; i2++)
                  o[i2] = recurse(o[i2]);
              else if (typeof o === "object")
                if (o !== null && o.key)
                  return bus3.get(o.key);
                else
                  for (var k2 in o)
                    o[k2] = recurse(o[k2]);
              return o;
            }
            for (var k in obj)
              obj[k] = recurse(obj[k]);
            return obj;
          }
          function validate(obj, schema) {
            var optional = false;
            if (schema === "*")
              return true;
            if (obj === schema)
              return true;
            if (typeof obj === "string")
              return schema === "string";
            if (typeof obj === "number")
              return schema === "number";
            if (typeof obj === "boolean")
              return schema === "boolean";
            if (obj === null)
              return schema === "null";
            if (obj === void 0)
              return schema === "undefined";
            if (Array.isArray(obj))
              return schema === "array";
            if (typeof obj === "object") {
              if (schema === "object")
                return true;
              if (typeof schema === "object") {
                for (var k in obj) {
                  var sk;
                  if (schema.hasOwnProperty(k))
                    sk = k;
                  else if (schema.hasOwnProperty("?" + k))
                    sk = "?" + k;
                  else if (schema.hasOwnProperty("*"))
                    sk = "*";
                  else
                    return false;
                  if (!validate(obj[k], schema[sk]))
                    return false;
                }
                for (var k in schema)
                  if (k[0] !== "?" && k !== "*") {
                    if (!obj.hasOwnProperty(k))
                      return false;
                  }
                return true;
              }
              return false;
            }
            if (typeof obj == "function")
              throw "bus.validate() cannot validate functions";
            console.trace();
            throw "You hit a Statebus bug! Tell the developers!";
          }
          function funk_key(funk) {
            if (!funk.statebus_id) {
              funk.statebus_id = Math.random().toString(36).substring(7);
              funks[funk.statebus_id] = funk;
            }
            return funk.statebus_id;
          }
          function funk_keyr(funk) {
            while (funk.proxies_for)
              funk = funk.proxies_for;
            return funk_key(funk);
          }
          function funk_name(f, char_limit) {
            char_limit = char_limit || 30;
            var arg = f.react ? f.args && f.args[0] : "";
            arg = f.react ? (JSON.stringify(f.arg) || "").substring(0, 30) : "";
            f = f.proxies_for || f;
            var f_string = "function " + (f.name || "") + "(" + (arg || "") + ") {..}";
            if (!f.defined)
              return f_string;
            if (f.defined.length > 1)
              return "**" + f_string + "**";
            var def = f.defined[0];
            switch (def.as) {
              case "handler":
                return def.bus + "('" + def.key + "')." + def.method + " = " + f_string;
              case "get callback":
                return "get(" + def.key + ", " + f_string + ")";
              case "reactive":
                return "reactive('" + f_string + "')";
              default:
                return "UNKNOWN Funky Definition!!!... ???";
            }
          }
          function deps(key2) {
            var result = "Deps: (" + key2 + ") fires into:";
            var pubbers = bindings(key2, "on_set");
            if (pubbers.length === 0)
              result += " nothing";
            for (var i2 = 0; i2 < pubbers.length; i2++)
              result += "\n  " + funk_name(pubbers[i2].func);
            return result;
          }
          function log() {
            if (bus.honk === true)
              indented_log.apply(null, arguments);
          }
          function indented_log() {
            if (nodejs) {
              var indent = "";
              for (var i2 = 0; i2 < statelog_indent; i2++)
                indent += "   ";
              console.log(indent + require_util().format.apply(null, arguments).replace(/\n/g, "\n" + indent));
            } else
              console.log.apply(console, arguments);
          }
          function statelog(key2, color, icon, message) {
            if (honking_at(key2))
              if (bus.honking_colors === false)
                indented_log(icon + " " + message);
              else
                indented_log(color + icon + " " + message + normal);
          }
          function honking_at(key2) {
            return bus.honk instanceof RegExp ? bus.honk.test(key2) : bus.honk;
          }
          var bogus_keys = {
            constructor: 1,
            hasOwnProperty: 1,
            isPrototypeOf: 1,
            propertyIsEnumerable: 1,
            toLocaleString: 1,
            toString: 1,
            valueOf: 1,
            __defineGetter__: 1,
            __defineSetter__: 1,
            __lookupGetter__: 1,
            __lookupSetter__: 1,
            __proto__: 1
          };
          function bogus_check(key2) {
            if (!(key2 in bogus_keys))
              return;
            var msg2 = 'Sorry, statebus.js currently prohibits use of the key "' + key2 + '", and in fact all of these keys: ' + Object.keys(bogus_keys).join(", ") + '.  This is because Javascript is kinda lame, and even empty objects like "{}" have the "' + key2 + '" field defined on them.  Try typing this in your Javascript console: "({}).constructor" -- it returns a function instead of undefined!  Mike needs to work around it by replacing every "obj[key]" with "obj.hasOwnProperty(key) && obj[key]" in the statebus code, or switching to a Map() object.  Please contact him and let him know where this is impacting you, so he can bump the priority on it.';
            console.error(msg2);
            throw "Invalid key";
          }
          var api = [
            "cache backup_cache get set forget del fire dirty get_once",
            "subspace bindings run_handler bind unbind reactive uncallback",
            "versions new_version",
            "link aget",
            "funk_key funk_name funks key_id key_name id",
            "pending_gets gets_in gets_out loading_keys loading once",
            "global_funk busses rerunnable_funks",
            "escape_keys unescape_keys translate_keys translate_links apply_patch",
            "keyed_2_proxied proxied_2_keyed translate_fields",
            "ws_mount net_automount message_method",
            "parse Set One_To_Many clone extend deep_map deep_equals prune validate sorta_diff log deps symbols"
          ].join(" ").split(" ");
          for (var i = 0; i < api.length; i++)
            bus[api[i]] = eval(api[i]);
          bus.delete = bus.del;
          bus.executing_funk = function() {
            return executing_funk;
          };
          function clientjs_option(option_name) {
            var script_elem = document.querySelector('script[src*="/client"][src$=".js"]') || document.querySelector('script[src^="client"][src$=".js"]');
            return script_elem && script_elem.getAttribute(option_name);
          }
          busses[bus.id] = bus;
          var this_bus_num = bus_count++;
          bus.libs = {};
          bus.render_when_loading = true;
          return bus;
        }
        return make_bus;
      });
    }
  });

  // public/statebus/client-library.js
  var require_client_library = __commonJS({
    "public/statebus/client-library.js"(exports, module) {
      (function() {
        var websocket_prefix = clientjs_option("websocket_path") || "_connect_to_statebus_";
        window.bus = window.statebus();
        bus.label = "bus";
        bus.libs = {};
        bus.libs.react12 = {};
        bus.libs.react17 = {};
        function set_cookie(key2, val) {
          document.cookie = key2 + "=" + val + "; Expires=21 Oct 2025 00:0:00 GMT;";
        }
        function get_cookie(key2) {
          var c = document.cookie.match("(^|;)\\s*" + key2 + "\\s*=\\s*([^;]+)");
          return c ? c.pop() : "";
        }
        try {
          document.cookie;
        } catch (e2) {
          get_cookie = set_cookie = function() {
          };
        }
        function make_websocket(url) {
          if (!url.match(/^\w{0,7}:\/\//))
            url = location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + url;
          url = url.replace(/^state:\/\//, "wss://");
          url = url.replace(/^istate:\/\//, "ws://");
          url = url.replace(/^statei:\/\//, "ws://");
          url = url.replace(/^https:\/\//, "wss://");
          url = url.replace(/^http:\/\//, "ws://");
          return new WebSocket(url + "/" + websocket_prefix + "/websocket");
        }
        function client_creds(server_url) {
          var me = bus.get("ls/me");
          bus.log("connect: me is", me);
          if (!me.client) {
            var c = get_cookie("peer");
            me.client = c || Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
            bus.set(me);
          }
          set_cookie("peer", me.client);
          return { clientid: me.client };
        }
        bus.libs.http_out = (prefix2, url) => {
          var preprefix = prefix2.slice(0, -1);
          var has_prefix = new RegExp("^" + preprefix);
          var is_absolute = /^https?:\/\//;
          var subscriptions = {};
          var put_counter = 0;
          function add_prefix(url2) {
            return is_absolute.test(url2) ? url2 : preprefix + url2;
          }
          function rem_prefix(url2) {
            return has_prefix.test(url2) ? url2.substr(preprefix.length) : url2;
          }
          function add_prefixes(obj) {
            var keyed = bus.translate_keys(bus.clone(obj), add_prefix);
            return bus.translate_links(bus.clone(keyed), add_prefix);
          }
          function rem_prefixes(obj) {
            var keyed = bus.translate_keys(bus.clone(obj), rem_prefix);
            return bus.translate_links(bus.clone(keyed), rem_prefix);
          }
          var puts = /* @__PURE__ */ new Map();
          function enqueue_put(url2, body) {
            var id2 = put_counter++;
            puts.set(id2, { url: url2, body, id: id2 });
            send_put(id2);
          }
          function send_put(id2) {
            try {
              puts.get(id2).status = "sending";
              braid_fetch(
                puts.get(id2).url,
                {
                  method: "put",
                  headers: {
                    "content-type": "application/json",
                    "put-order": id2
                  },
                  body: puts.get(id2).body
                }
              ).then(function(res) {
                if (res.status !== 200)
                  console.error(
                    "Server gave error on PUT:",
                    e,
                    "for",
                    puts.get(id2).body
                  );
                puts.delete(id2);
              }).catch(function(e2) {
                console.error("Error on PUT, waiting...", puts.get(id2).url);
                puts.get(id2).status = "waiting";
              });
            } catch (e2) {
              console.error("Error on PUT, waiting...", puts.get(id2).url);
              puts.get(id2).status = "waiting";
            }
          }
          function retry_put(id2) {
            setTimeout(function() {
              send_put(id2);
            }, 1e3);
          }
          function send_all_puts() {
            puts.forEach(function(value, id2) {
              if (value.status === "waiting") {
                console.log("Sending waiting put", id2);
                send_put(id2);
              }
            });
          }
          bus(prefix2).setter = function(obj, t2) {
            bus.set.fire(obj);
            var put = {
              url: url + rem_prefix(obj.key),
              body: JSON.stringify(obj.val)
            };
            if (t2.version)
              put.version = t2.version;
            if (t2.parents)
              put.parents = t2.parents;
            if (t2.patch)
              put.patch = t2.patch;
            var put_id = put_counter++;
            puts.set(put_id, put);
            send_put(put_id);
          };
          bus(prefix2).getter = function(key2, t2) {
            if (subscriptions[key2]) {
              console.assert(
                subscriptions[key2].status === "aborted",
                "Regetting a subscription of status " + subscriptions[key2].status
              );
              console.trace("foo");
              subscriptions[key2].status = "reconnect";
            } else
              subscribe(key2, t2);
            function subscribe(key3, t3) {
              var aborter = new AbortController(), reconnect_attempts = 0;
              braid_fetch(
                url + rem_prefix(key3),
                {
                  method: "get",
                  subscribe: true,
                  headers: { accept: "application/json" },
                  signal: aborter.signal
                }
              ).andThen(function(new_version2) {
                if (subscriptions[key3].status === "connecting") {
                  console.log(
                    "%c[*] opened " + key3,
                    "color: blue"
                  );
                  reconnect_attempts = 0;
                  subscriptions[key3].status = "connected";
                  send_all_puts();
                }
                t3.return({
                  key: key3,
                  val: add_prefixes(JSON.parse(new_version2.body))
                });
              }).catch(function(e2) {
                if (subscriptions[key3].status === "aborted") {
                  delete subscriptions[key3];
                  return;
                }
                setTimeout(
                  function() {
                    subscribe(key3, t3);
                  },
                  reconnect_attempts > 0 ? 5e3 : 1500
                );
                subscriptions[key3].status = "reconnecting";
              });
              subscriptions[key3] = {
                aborter,
                status: "connecting"
              };
            }
          };
          bus(prefix2).forgetter = function(key2) {
            subscriptions[key2].status = "aborted";
            subscriptions[key2].aborter.abort();
          };
        };
        function http_automount() {
          function get_domain2(key2) {
            var m = key2.match(/^https?\:\/\/(([^:\/?#]*)(?:\:([0-9]+))?)/);
            return m && m[0];
          }
          var old_route = bus.route;
          var connections = {};
          bus.route = function(key2, method, arg, t2) {
            var d = get_domain2(key2);
            if (d && !connections[d]) {
              bus.libs.http_out(d + "/*", d + "/");
              connections[d] = true;
            }
            return old_route(key2, method, arg, t2);
          };
        }
        bus.libs.localstorage = (prefix2) => {
          try {
            localStorage;
          } catch (e2) {
            return;
          }
          var sets_are_pending = false;
          var pending_sets = {};
          function set_the_pending_sets() {
            bus.log("localstore: saving", pending_sets);
            for (var k in pending_sets)
              localStorage.setItem(k, JSON.stringify(pending_sets[k]));
            sets_are_pending = false;
          }
          bus(prefix2).getter = function(key2) {
            var result = localStorage.getItem(key2);
            return result ? JSON.parse(result) : { key: key2 };
          };
          bus(prefix2).setter = function(obj) {
            bus.log("localStore: on_set:", obj.key);
            pending_sets[obj.key] = obj;
            if (!sets_are_pending) {
              setTimeout(set_the_pending_sets, 50);
              sets_are_pending = true;
            }
            bus.set.fire(obj);
            return obj;
          };
          bus(prefix2).deleter = function(key2) {
            localStorage.removeItem(key2);
          };
          function update2(event) {
            bus.log("Got a localstorage update", event);
            bus.dirty(event.key);
          }
          if (window.addEventListener)
            window.addEventListener("storage", update2, false);
          else
            window.attachEvent("onstorage", update2);
        };
        function url_store(prefix2) {
          var bus3 = this;
          function get_query_string_value(key2) {
            return unescape(window.location.search.replace(
              new RegExp("^(?:.*[&\\?]" + escape(key2).replace(/[\.\+\*]/g, "\\$&") + "(?:\\=([^&]*))?)?.*$", "i"),
              "$1"
            ));
          }
          var data = get_query_string_value(key);
          data = data && JSON.parse(data) || { key };
          bus3(prefix2).setter = function(obj) {
            window.history.replaceState(
              "",
              "",
              document.location.origin + document.location.pathname + escape("?" + key + "=" + JSON.stringify(obj))
            );
            bus3.set.fire(obj);
          };
        }
        function react_version() {
          if (!window.React)
            return void 0;
          return Number(window.React.version.split(".")[0]);
        }
        if (window.React && !React.createClass && window.createReactClass)
          React.createClass = createReactClass;
        var components = {};
        var components_count = 0;
        var dirty_components = {};
        function create_react_class(component) {
          function wrap(name3, new_func) {
            var old_func = component[name3];
            component[name3] = function wrapper() {
              return new_func.bind(this)(old_func);
            };
          }
          wrap(
            (react_version() >= 16 ? "UNSAFE_" : "") + "componentWillMount",
            function new_cwm(orig_func) {
              this.key = "component/" + components_count++;
              components[this.key] = this;
              function add_shortcut(obj, shortcut_name, to_key) {
                delete obj[shortcut_name];
                Object.defineProperty(obj, shortcut_name, {
                  get: function() {
                    return bus.get(to_key);
                  },
                  configurable: true
                });
              }
              add_shortcut(this, "local", this.key);
              orig_func && orig_func.apply(this, arguments);
              var orig_render = this.render;
              this.render = bus.reactive(function() {
                console.assert(this !== window);
                if (this.render.called_directly) {
                  delete dirty_components[this.key];
                  for (var k in this.props)
                    if (this.props.hasOwnProperty(k) && this.props[k] !== null && typeof this.props[k] === "object" && this.props[k].key)
                      bus.get(this.props[k].key);
                  return orig_render.apply(this, arguments);
                } else {
                  dirty_components[this.key] = true;
                  schedule_re_render();
                }
              });
            }
          );
          wrap("componentWillUnmount", function new_cwu(orig_func) {
            orig_func && orig_func.apply(this, arguments);
            bus.delete(this.key);
            delete components[this.key];
            delete dirty_components[this.key];
          });
          function shallow_clone(original) {
            var clone2 = Object.create(Object.getPrototypeOf(original));
            var i2, keys4 = Object.getOwnPropertyNames(original);
            for (i2 = 0; i2 < keys4.length; i2++) {
              Object.defineProperty(
                clone2,
                keys4[i2],
                Object.getOwnPropertyDescriptor(original, keys4[i2])
              );
            }
            return clone2;
          }
          component.shouldComponentUpdate = function new_scu(next_props, next_state) {
            if (dirty_components[this.key] !== void 0)
              return true;
            next_props = shallow_clone(next_props);
            this_props = shallow_clone(this.props);
            delete next_props["children"];
            delete this_props["children"];
            next_props = bus.clone(next_props);
            this_props = bus.clone(this_props);
            return !bus.deep_equals([next_state, next_props], [this.state, this_props]);
          };
          component.loading = function loading2() {
            return this.render.loading();
          };
          var react_class = React.createClass(component);
          var result = function(props, children) {
            props = props || {};
            props["data-key"] = props.key;
            props["data-widget"] = component.displayName;
            return React.createElement(react_class, props, children);
          };
          Object.defineProperty(
            result,
            "name",
            { value: component.displayName, writable: false }
          );
          return result;
        }
        var re_render_scheduled = false;
        var re_rendering = false;
        function schedule_re_render() {
          if (!re_render_scheduled) {
            requestAnimationFrame(function() {
              re_render_scheduled = false;
              for (var comp_key in dirty_components) {
                if (dirty_components[comp_key] && components[comp_key])
                  try {
                    re_rendering = true;
                    components[comp_key].forceUpdate();
                  } finally {
                    re_rendering = false;
                  }
              }
            });
            re_render_scheduled = true;
          }
        }
        function clientjs_option(option_name) {
          var script_elem = document.querySelector('script[src$="statebus/client.js"]');
          return script_elem && script_elem.getAttribute(option_name);
        }
        var loaded_from_file_url = window.location.href.match(/^file:\/\//);
        window.statebus_server = clientjs_option("server");
        function is_css_prop(name3) {
          if (!is_css_prop.memoized) {
            is_css_prop.memoized = {};
            var all_css_props = ["alignContent", "alignItems", "alignSelf", "alignmentBaseline", "all", "animation", "animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction", "backfaceVisibility", "background", "backgroundAttachment", "backgroundBlendMode", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPosition", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundRepeatX", "backgroundRepeatY", "backgroundSize", "baselineShift", "blockSize", "border", "borderBottom", "borderBottomColor", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStyle", "borderBottomWidth", "borderCollapse", "borderColor", "borderImage", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeft", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRadius", "borderRight", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderSpacing", "borderStyle", "borderTop", "borderTopColor", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStyle", "borderTopWidth", "borderWidth", "bottom", "boxShadow", "boxSizing", "breakAfter", "breakBefore", "breakInside", "bufferedRendering", "captionSide", "caretColor", "clear", "clip", "clipPath", "clipRule", "color", "colorInterpolation", "colorInterpolationFilters", "colorRendering", "columnCount", "columnFill", "columnGap", "columnRule", "columnRuleColor", "columnRuleStyle", "columnRuleWidth", "columnSpan", "columnWidth", "columns", "contain", "content", "counterIncrement", "counterReset", "cursor", "cx", "cy", "d", "direction", "display", "dominantBaseline", "emptyCells", "fill", "fillOpacity", "fillRule", "filter", "flex", "flexBasis", "flexDirection", "flexFlow", "flexGrow", "flexShrink", "flexWrap", "float", "floodColor", "floodOpacity", "font", "fontDisplay", "fontFamily", "fontFeatureSettings", "fontKerning", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariationSettings", "fontWeight", "gap", "grid", "gridArea", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridColumn", "gridColumnEnd", "gridColumnGap", "gridColumnStart", "gridGap", "gridRow", "gridRowEnd", "gridRowGap", "gridRowStart", "gridTemplate", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows", "height", "hyphens", "imageRendering", "inlineSize", "isolation", "justifyContent", "justifyItems", "justifySelf", "left", "letterSpacing", "lightingColor", "lineBreak", "lineHeight", "listStyle", "listStyleImage", "listStylePosition", "listStyleType", "margin", "marginBottom", "marginLeft", "marginRight", "marginTop", "marker", "markerEnd", "markerMid", "markerStart", "mask", "maskType", "maxBlockSize", "maxHeight", "maxInlineSize", "maxWidth", "maxZoom", "minBlockSize", "minHeight", "minInlineSize", "minWidth", "minZoom", "mixBlendMode", "objectFit", "objectPosition", "offset", "offsetDistance", "offsetPath", "offsetRotate", "opacity", "order", "orientation", "orphans", "outline", "outlineColor", "outlineOffset", "outlineStyle", "outlineWidth", "overflow", "overflowAnchor", "overflowWrap", "overflowX", "overflowY", "overscrollBehavior", "overscrollBehaviorX", "overscrollBehaviorY", "padding", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "page", "pageBreakAfter", "pageBreakBefore", "pageBreakInside", "paintOrder", "perspective", "perspectiveOrigin", "placeContent", "placeItems", "placeSelf", "pointerEvents", "position", "quotes", "r", "resize", "right", "rowGap", "rx", "ry", "scrollBehavior", "shapeImageThreshold", "shapeMargin", "shapeOutside", "shapeRendering", "size", "speak", "src", "stopColor", "stopOpacity", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "tabSize", "tableLayout", "textAlign", "textAlignLast", "textAnchor", "textCombineUpright", "textDecoration", "textDecorationColor", "textDecorationLine", "textDecorationSkipInk", "textDecorationStyle", "textIndent", "textOrientation", "textOverflow", "textRendering", "textShadow", "textSizeAdjust", "textTransform", "textUnderlinePosition", "top", "touchAction", "transform", "transformBox", "transformOrigin", "transformStyle", "transition", "transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction", "unicodeBidi", "unicodeRange", "userSelect", "userZoom", "vectorEffect", "verticalAlign", "visibility", "webkitAlignContent", "webkitAlignItems", "webkitAlignSelf", "webkitAnimation", "webkitAnimationDelay", "webkitAnimationDirection", "webkitAnimationDuration", "webkitAnimationFillMode", "webkitAnimationIterationCount", "webkitAnimationName", "webkitAnimationPlayState", "webkitAnimationTimingFunction", "webkitAppRegion", "webkitAppearance", "webkitBackfaceVisibility", "webkitBackgroundClip", "webkitBackgroundOrigin", "webkitBackgroundSize", "webkitBorderAfter", "webkitBorderAfterColor", "webkitBorderAfterStyle", "webkitBorderAfterWidth", "webkitBorderBefore", "webkitBorderBeforeColor", "webkitBorderBeforeStyle", "webkitBorderBeforeWidth", "webkitBorderBottomLeftRadius", "webkitBorderBottomRightRadius", "webkitBorderEnd", "webkitBorderEndColor", "webkitBorderEndStyle", "webkitBorderEndWidth", "webkitBorderHorizontalSpacing", "webkitBorderImage", "webkitBorderRadius", "webkitBorderStart", "webkitBorderStartColor", "webkitBorderStartStyle", "webkitBorderStartWidth", "webkitBorderTopLeftRadius", "webkitBorderTopRightRadius", "webkitBorderVerticalSpacing", "webkitBoxAlign", "webkitBoxDecorationBreak", "webkitBoxDirection", "webkitBoxFlex", "webkitBoxOrdinalGroup", "webkitBoxOrient", "webkitBoxPack", "webkitBoxReflect", "webkitBoxShadow", "webkitBoxSizing", "webkitClipPath", "webkitColumnBreakAfter", "webkitColumnBreakBefore", "webkitColumnBreakInside", "webkitColumnCount", "webkitColumnGap", "webkitColumnRule", "webkitColumnRuleColor", "webkitColumnRuleStyle", "webkitColumnRuleWidth", "webkitColumnSpan", "webkitColumnWidth", "webkitColumns", "webkitFilter", "webkitFlex", "webkitFlexBasis", "webkitFlexDirection", "webkitFlexFlow", "webkitFlexGrow", "webkitFlexShrink", "webkitFlexWrap", "webkitFontFeatureSettings", "webkitFontSizeDelta", "webkitFontSmoothing", "webkitHighlight", "webkitHyphenateCharacter", "webkitJustifyContent", "webkitLineBreak", "webkitLineClamp", "webkitLocale", "webkitLogicalHeight", "webkitLogicalWidth", "webkitMarginAfter", "webkitMarginAfterCollapse", "webkitMarginBefore", "webkitMarginBeforeCollapse", "webkitMarginBottomCollapse", "webkitMarginCollapse", "webkitMarginEnd", "webkitMarginStart", "webkitMarginTopCollapse", "webkitMask", "webkitMaskBoxImage", "webkitMaskBoxImageOutset", "webkitMaskBoxImageRepeat", "webkitMaskBoxImageSlice", "webkitMaskBoxImageSource", "webkitMaskBoxImageWidth", "webkitMaskClip", "webkitMaskComposite", "webkitMaskImage", "webkitMaskOrigin", "webkitMaskPosition", "webkitMaskPositionX", "webkitMaskPositionY", "webkitMaskRepeat", "webkitMaskRepeatX", "webkitMaskRepeatY", "webkitMaskSize", "webkitMaxLogicalHeight", "webkitMaxLogicalWidth", "webkitMinLogicalHeight", "webkitMinLogicalWidth", "webkitOpacity", "webkitOrder", "webkitPaddingAfter", "webkitPaddingBefore", "webkitPaddingEnd", "webkitPaddingStart", "webkitPerspective", "webkitPerspectiveOrigin", "webkitPerspectiveOriginX", "webkitPerspectiveOriginY", "webkitPrintColorAdjust", "webkitRtlOrdering", "webkitRubyPosition", "webkitShapeImageThreshold", "webkitShapeMargin", "webkitShapeOutside", "webkitTapHighlightColor", "webkitTextCombine", "webkitTextDecorationsInEffect", "webkitTextEmphasis", "webkitTextEmphasisColor", "webkitTextEmphasisPosition", "webkitTextEmphasisStyle", "webkitTextFillColor", "webkitTextOrientation", "webkitTextSecurity", "webkitTextSizeAdjust", "webkitTextStroke", "webkitTextStrokeColor", "webkitTextStrokeWidth", "webkitTransform", "webkitTransformOrigin", "webkitTransformOriginX", "webkitTransformOriginY", "webkitTransformOriginZ", "webkitTransformStyle", "webkitTransition", "webkitTransitionDelay", "webkitTransitionDuration", "webkitTransitionProperty", "webkitTransitionTimingFunction", "webkitUserDrag", "webkitUserModify", "webkitUserSelect", "webkitWritingMode", "whiteSpace", "widows", "width", "willChange", "wordBreak", "wordSpacing", "wordWrap", "writingMode", "x", "y", "zIndex", "zoom"];
            var ignore = {
              d: 1,
              cx: 1,
              cy: 1,
              rx: 1,
              ry: 1,
              x: 1,
              y: 1,
              content: 1,
              fill: 1,
              stroke: 1,
              src: 1
            };
            for (var i2 = 0; i2 < all_css_props.length; i2++)
              if (!ignore[all_css_props[i2]])
                is_css_prop.memoized[all_css_props[i2]] = true;
          }
          return is_css_prop.memoized[name3];
        }
        bus.libs.react12.improve_react = () => {
          function better_element(el2) {
            return function() {
              var children = [];
              var attrs = { style: {} };
              for (var i2 = 0; i2 < arguments.length; i2++) {
                var arg = arguments[i2];
                if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg === void 0)
                  children.push(arg);
                else if (arg instanceof Array)
                  Array.prototype.push.apply(children, arg);
                else if (arg instanceof Object)
                  for (var k in arg)
                    if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && el2 in { canvas: 1, input: 1, embed: 1, object: 1 }))
                      attrs.style[k] = arg[k];
                    else if (k === "style")
                      for (var k2 in arg[k])
                        attrs.style[k2] = arg[k][k2];
                    else {
                      attrs[k] = arg[k];
                      if (k === "key")
                        attrs["data-key"] = arg[k];
                    }
              }
              if (children.length === 0)
                children = void 0;
              if (attrs["ref"] === "input")
                bus.log(attrs, children);
              return React.DOM[el2](attrs, children);
            };
          }
          for (var el in React.DOM)
            window[el.toUpperCase()] = better_element(el);
          function make_better_input(name3, element3) {
            window[name3] = React.createFactory(React.createClass({
              getInitialState: function() {
                return { value: this.props.value };
              },
              componentWillReceiveProps: function(new_props) {
                this.setState({ value: new_props.value });
              },
              onChange: function(e2) {
                this.props.onChange && this.props.onChange(e2);
                if (this.props.value)
                  this.setState({ value: e2.target.value });
              },
              render: function() {
                var new_props = {};
                for (var k in this.props)
                  if (this.props.hasOwnProperty(k))
                    new_props[k] = this.props[k];
                if (this.state.value)
                  new_props.value = this.state.value;
                new_props.onChange = this.onChange;
                return element3(new_props);
              }
            }));
          }
          make_better_input("INPUT", window.INPUT);
          make_better_input("TEXTAREA", window.TEXTAREA);
          make_syncarea();
          var og_img = window.IMG;
          window.IMG = function() {
            var args = [];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
              if (arguments[i2].state)
                args[i2].src = "data:;base64," + bus.get(args[i2].state)._;
            }
            return og_img.apply(this, args);
          };
          function escape_html(s) {
            return s.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          }
          window.STYLE = function(s) {
            return React.DOM.style({ dangerouslySetInnerHTML: { __html: escape_html(s) } });
          };
          window.TITLE = function(s) {
            return React.DOM.title({ dangerouslySetInnerHTML: { __html: escape_html(s) } });
          };
        };
        bus.libs.react17.reactive_dom = () => {
          window.dom = window.dom || new Proxy({}, {
            get: function(o, k) {
              return o[k];
            },
            set: function(o, k, v) {
              o[k] = v;
              window[k] = make_component(k, v);
              return true;
            }
          });
          var function_for_tag = (tag) => (...args) => {
            var children = [];
            var attrs = { style: {} };
            for (var i2 = 0; i2 < args.length; i2++) {
              var arg = args[i2];
              if (arg === void 0)
                continue;
              else if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg instanceof Array)
                children.push(arg);
              else if (arg instanceof Object)
                for (var k in arg)
                  if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && tag in { canvas: 1, input: 1, embed: 1, object: 1 }))
                    attrs.style[k] = arg[k];
                  else if (k === "style")
                    for (var k2 in arg[k])
                      attrs.style[k2] = arg[k][k2];
                  else
                    attrs[k] = arg[k];
            }
            return React.createElement.apply(
              null,
              [tag, attrs].concat(children)
            );
          };
          var all_tags = "a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,blockquote,br,button,canvas,caption,cite,code,col,colgroup,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,img,ins,kbd,label,legend,li,link,main,map,mark,menu,meta,meter,nav,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,s,samp,script,section,select,slot,small,source,span,strong,style,sub,summary,sup,svg,table,tbody,td,template,tfoot,th,thead,title,tr,u,ul,video,input,circle,ellipse,g,image,line,path,polygon,polyline,rect,switch,symbol,text,textPath,tspan,use".split(",");
          all_tags.forEach((tagname) => {
            window[tagname.toUpperCase()] = function_for_tag(tagname);
          });
          window.INPUT = function_for_tag(bus.libs.react17.input);
          window.TEXTAREA = function_for_tag(bus.libs.react17.textarea);
          function better_element(el) {
            return function() {
              var children = [];
              var attrs = { style: {} };
              for (var i2 = 0; i2 < arguments.length; i2++) {
                var arg = arguments[i2];
                if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg === void 0)
                  children.push(arg);
                else if (arg instanceof Array)
                  Array.prototype.push.apply(children, arg);
                else if (arg instanceof Object)
                  for (var k in arg)
                    if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && el in { canvas: 1, input: 1, embed: 1, object: 1 }))
                      attrs.style[k] = arg[k];
                    else if (k === "style")
                      for (var k2 in arg[k])
                        attrs.style[k2] = arg[k][k2];
                    else {
                      attrs[k] = arg[k];
                      if (k === "key")
                        attrs["data-key"] = arg[k];
                    }
              }
              if (children.length === 0)
                children = void 0;
              return React.DOM[el](attrs, children);
            };
          }
        };
        function make_fixed_textbox(tagname) {
          var component = createReactClass({
            getInitialState: function() {
              return { value: this.props.value };
            },
            UNSAFE_componentWillReceiveProps: function(new_props) {
              this.setState({ value: new_props.value });
            },
            onChange: function(e2) {
              this.props.onChange && this.props.onChange(e2);
              if (this.props.value)
                this.setState({ value: e2.target.value });
            },
            onInput: function(e2) {
              this.props.onInput && this.props.onInput(e2);
              if (this.props.value)
                this.setState({ value: e2.target.value });
            },
            render: function() {
              var new_props = {
                ...this.props,
                ref: this.props.forwarded_ref
              };
              delete new_props.forwarded_ref;
              if (new_props.hasOwnProperty("onChange"))
                new_props.onChange = this.onChange;
              if (new_props.hasOwnProperty("onInput"))
                new_props.onInput = this.onInput;
              return React.createElement(tagname, new_props);
            }
          });
          return React.forwardRef((props, ref) => {
            return React.createElement(component, { ...props, forwarded_ref: ref });
          });
        }
        if (window.React && !React.createClass && window.createReactClass) {
          bus.libs.react17.input = make_fixed_textbox("input");
          bus.libs.react17.textarea = make_fixed_textbox("textarea");
        }
        function autodetect_args(func) {
          if (func.args)
            return;
          var comments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, params = /([^\s,]+)/g, s = func.toString().replace(comments, "");
          func.args = s.slice(s.indexOf("(") + 1, s.indexOf(")")).match(params) || [];
        }
        var users_widgets = {};
        function make_component(name3, func) {
          return users_widgets[name3] = create_react_class({
            displayName: name3,
            render: function() {
              var args = [];
              autodetect_args(func);
              for (var i2 = 0; i2 < func.args.length; i2++)
                args.push(this.props[func.args[i2]]);
              var vdom = func.apply(this, args);
              if (vdom && vdom.props) {
                vdom.props["data-widget"] = name3;
                vdom.props["data-key"] = this.props["data-key"];
              }
              return vdom;
            },
            componentDidMount: function() {
              var refresh = func.refresh;
              refresh && refresh.bind(this)();
            },
            componentWillUnmount: function() {
              var down = func.down;
              return down && down.bind(this)();
            },
            componentDidUpdate: function() {
              if (!this.initial_render_complete && !this.loading()) {
                this.initial_render_complete = true;
                var up = func.up;
                up && up.bind(this)();
              }
              var refresh = func.refresh;
              return refresh && refresh.bind(this)();
            },
            getInitialState: function() {
              return {};
            }
          });
        }
        function compile_coffee(coffee, filename) {
          var compiled;
          try {
            compiled = CoffeeScript.compile(
              coffee,
              {
                bare: true,
                sourceMap: true,
                filename
              }
            );
            var source_map = JSON.parse(compiled.v3SourceMap);
            source_map.sourcesContent = coffee;
            compiled = compiled.js;
            try {
              compiled += "\n";
              compiled += "//# sourceMappingURL=data:application/json;base64,";
              compiled += btoa(JSON.stringify(source_map)) + "\n";
              compiled += "//# sourceURL=" + filename;
            } catch (e2) {
            }
          } catch (error) {
            if (error.location)
              console.error(
                "Syntax error in " + filename + " on line",
                error.location.first_line + ", column " + error.location.first_column + ":",
                error.message
              );
            else
              throw error;
          }
          return compiled;
        }
        function load_client_code(code) {
          var dom = {};
          if (code)
            eval(code);
          else
            dom = window.dom;
          for (var widget_name in dom)
            window.dom[widget_name] = dom[widget_name];
        }
        function load_coffee() {
          load_client_code();
          var scripts = document.getElementsByTagName("script");
          var filename = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
          for (var i2 = 0; i2 < scripts.length; i2++)
            if (scripts[i2].getAttribute("type") in {
              "statebus": 1,
              "coffeedom": 1,
              "statebus-js": 1,
              "coffee": 1,
              "coffeescript": 1
            }) {
              if (!window.CoffeeScript) {
                console.error(`Cannot load <script type="coffee"> because coffeescript library isn't present`);
                return;
              }
              var compiled = scripts[i2].text;
              if (scripts[i2].getAttribute("type") !== "statebus-js")
                compiled = compile_coffee(scripts[i2].text, filename);
              if (compiled)
                load_client_code(compiled);
            }
        }
        function dom_to_widget(node) {
          if (node.nodeName === "#text")
            return node.textContent;
          if (!(node.nodeName in users_widgets))
            return node;
          node.seen = true;
          var children = [], props = {};
          for (var i2 = 0; i2 < node.childNodes.length; i2++)
            children.push(dom_to_widget(node.childNodes[i2]));
          var props = {};
          for (var i2 = 0; node.attributes && i2 < node.attributes.length; i2++)
            props[node.attributes[i2].name] = node.attributes[i2].value;
          var widge = window[node.nodeName.toLowerCase()] || window[node.nodeName.toUpperCase()];
          console.assert(widge, node.nodeName + " has not been defined as a UI widget.");
          return widge(props, children);
        }
        bus.libs.react17.react_class = create_react_class;
        bus.libs.react17.coffreact = () => {
          bus.libs.react17.reactive_dom();
          load_coffee();
          if (dom.BODY)
            document.addEventListener(
              "DOMContentLoaded",
              () => {
                var root = document.createElement("root");
                document.body.appendChild(root);
                ReactDOM.render(BODY(), root);
              },
              false
            );
        };
        http_automount();
        statebus.compile_coffee = compile_coffee;
        statebus.load_client_code = load_client_code;
        document.addEventListener("DOMContentLoaded", function() {
          if (window.statebus_ready)
            for (var i2 = 0; i2 < statebus_ready.length; i2++)
              statebus_ready[i2]();
        }, false);
      })();
    }
  });

  // node_modules/node-fetch/browser.js
  var require_browser = __commonJS({
    "node_modules/node-fetch/browser.js"(exports2, module3) {
      "use strict";
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global3 !== "undefined") {
          return global3;
        }
        throw new Error("unable to locate global object");
      };
      var global3 = getGlobal();
      module3.exports = exports2 = global3.fetch;
      if (global3.fetch) {
        exports2.default = global3.fetch.bind(global3);
      }
      exports2.Headers = global3.Headers;
      exports2.Request = global3.Request;
      exports2.Response = global3.Response;
    }
  });

  // node_modules/abort-controller/browser.js
  var require_browser2 = __commonJS({
    "node_modules/abort-controller/browser.js"(exports2, module3) {
      "use strict";
      var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
      module3.exports = AbortController2;
      module3.exports.AbortSignal = AbortSignal;
      module3.exports.default = AbortController2;
    }
  });

  // node_modules/emitter-component/index.js
  var require_emitter_component = __commonJS({
    "node_modules/emitter-component/index.js"(exports2, module3) {
      module3.exports = Emitter;
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key2 in Emitter.prototype) {
          obj[key2] = Emitter.prototype[key2];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        var self2 = this;
        this._callbacks = this._callbacks || {};
        function on() {
          self2.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
        var cb;
        for (var i2 = 0; i2 < callbacks.length; i2++) {
          cb = callbacks[i2];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i2, 1);
            break;
          }
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
            callbacks[i2].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }
  });

  // node_modules/stream/index.js
  var require_stream = __commonJS({
    "node_modules/stream/index.js"(exports2, module3) {
      var Emitter = require_emitter_component();
      function Stream() {
        Emitter.call(this);
      }
      Stream.prototype = new Emitter();
      module3.exports = Stream;
      Stream.Stream = Stream;
      Stream.prototype.pipe = function(dest, options2) {
        var source2 = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source2.pause) {
              source2.pause();
            }
          }
        }
        source2.on("data", ondata);
        function ondrain() {
          if (source2.readable && source2.resume) {
            source2.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options2 || options2.end !== false)) {
          source2.on("end", onend);
          source2.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (!this.hasListeners("error")) {
            throw er;
          }
        }
        source2.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source2.off("data", ondata);
          dest.off("drain", ondrain);
          source2.off("end", onend);
          source2.off("close", onclose);
          source2.off("error", onerror);
          dest.off("error", onerror);
          source2.off("end", cleanup);
          source2.off("close", cleanup);
          dest.off("end", cleanup);
          dest.off("close", cleanup);
        }
        source2.on("end", cleanup);
        source2.on("close", cleanup);
        dest.on("end", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source2);
        return dest;
      };
    }
  });

  // node_modules/is-stream/index.js
  var require_is_stream = __commonJS({
    "node_modules/is-stream/index.js"(exports2, module3) {
      "use strict";
      var isStream = module3.exports = function(stream) {
        return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
      };
      isStream.writable = function(stream) {
        return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
      };
      isStream.readable = function(stream) {
        return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
      };
      isStream.duplex = function(stream) {
        return isStream.writable(stream) && isStream.readable(stream);
      };
      isStream.transform = function(stream) {
        return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
      };
    }
  });

  // node_modules/node-web-streams/node_modules/web-streams-polyfill/dist/polyfill.min.js
  var require_polyfill_min = __commonJS({
    "node_modules/node-web-streams/node_modules/web-streams-polyfill/dist/polyfill.min.js"(exports2, module3) {
      !function(f) {
        if ("object" == typeof exports2 && "undefined" != typeof module3)
          module3.exports = f();
        else if ("function" == typeof define && define.amd)
          define([], f);
        else {
          var g;
          g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g.default = f();
        }
      }(function() {
        return function e2(t2, n, r) {
          function s(o2, u) {
            if (!n[o2]) {
              if (!t2[o2]) {
                var a = "function" == typeof __require && __require;
                if (!u && a)
                  return a(o2, true);
                if (i2)
                  return i2(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n[o2] = { exports: {} };
              t2[o2][0].call(l.exports, function(e3) {
                var n2 = t2[o2][1][e3];
                return s(n2 ? n2 : e3);
              }, l, l.exports, e2, t2, n, r);
            }
            return n[o2].exports;
          }
          for (var i2 = "function" == typeof __require && __require, o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(require2, module4, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var _require = require2("./spec/reference-implementation/lib/readable-stream"), ReadableStream = _require.ReadableStream, _require2 = require2("./spec/reference-implementation/lib/writable-stream"), WritableStream = _require2.WritableStream, ByteLengthQueuingStrategy = require2("./spec/reference-implementation/lib/byte-length-queuing-strategy"), CountQueuingStrategy = require2("./spec/reference-implementation/lib/count-queuing-strategy"), TransformStream = require2("./spec/reference-implementation/lib/transform-stream");
          exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports3.CountQueuingStrategy = CountQueuingStrategy, exports3.TransformStream = TransformStream, exports3.ReadableStream = ReadableStream, exports3.WritableStream = WritableStream;
          var interfaces = { ReadableStream, WritableStream, ByteLengthQueuingStrategy, CountQueuingStrategy, TransformStream };
          exports3.default = interfaces, "undefined" != typeof window && Object.assign(window, interfaces);
        }, { "./spec/reference-implementation/lib/byte-length-queuing-strategy": 7, "./spec/reference-implementation/lib/count-queuing-strategy": 8, "./spec/reference-implementation/lib/readable-stream": 11, "./spec/reference-implementation/lib/transform-stream": 12, "./spec/reference-implementation/lib/writable-stream": 14 }], 2: [function(require2, module4, exports3) {
          function replacer(key2, value) {
            return util.isUndefined(value) ? "" + value : util.isNumber(value) && !isFinite(value) ? value.toString() : util.isFunction(value) || util.isRegExp(value) ? value.toString() : value;
          }
          function truncate(s, n) {
            return util.isString(s) ? s.length < n ? s : s.slice(0, n) : s;
          }
          function getMessage(self2) {
            return truncate(JSON.stringify(self2.actual, replacer), 128) + " " + self2.operator + " " + truncate(JSON.stringify(self2.expected, replacer), 128);
          }
          function fail(actual, expected, message, operator2, stackStartFunction) {
            throw new assert.AssertionError({ message, actual, expected, operator: operator2, stackStartFunction });
          }
          function ok(value, message) {
            value || fail(value, true, message, "==", assert.ok);
          }
          function _deepEqual(actual, expected) {
            if (actual === expected)
              return true;
            if (util.isBuffer(actual) && util.isBuffer(expected)) {
              if (actual.length != expected.length)
                return false;
              for (var i2 = 0; i2 < actual.length; i2++)
                if (actual[i2] !== expected[i2])
                  return false;
              return true;
            }
            return util.isDate(actual) && util.isDate(expected) ? actual.getTime() === expected.getTime() : util.isRegExp(actual) && util.isRegExp(expected) ? actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase : util.isObject(actual) || util.isObject(expected) ? objEquiv(actual, expected) : actual == expected;
          }
          function isArguments(object) {
            return "[object Arguments]" == Object.prototype.toString.call(object);
          }
          function objEquiv(a, b) {
            if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
              return false;
            if (a.prototype !== b.prototype)
              return false;
            if (util.isPrimitive(a) || util.isPrimitive(b))
              return a === b;
            var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
              return false;
            if (aIsArgs)
              return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b);
            var key2, i2, ka = objectKeys(a), kb = objectKeys(b);
            if (ka.length != kb.length)
              return false;
            for (ka.sort(), kb.sort(), i2 = ka.length - 1; i2 >= 0; i2--)
              if (ka[i2] != kb[i2])
                return false;
            for (i2 = ka.length - 1; i2 >= 0; i2--)
              if (key2 = ka[i2], !_deepEqual(a[key2], b[key2]))
                return false;
            return true;
          }
          function expectedException(actual, expected) {
            return !(!actual || !expected) && ("[object RegExp]" == Object.prototype.toString.call(expected) ? expected.test(actual) : actual instanceof expected || expected.call({}, actual) === true);
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            util.isString(expected) && (message = expected, expected = null);
            try {
              block();
            } catch (e2) {
              actual = e2;
            }
            if (message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message), !shouldThrow && expectedException(actual, expected) && fail(actual, expected, "Got unwanted exception" + message), shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual)
              throw actual;
          }
          var util = require2("util/"), pSlice = Array.prototype.slice, hasOwn = Object.prototype.hasOwnProperty, assert = module4.exports = ok;
          assert.AssertionError = function(options2) {
            this.name = "AssertionError", this.actual = options2.actual, this.expected = options2.expected, this.operator = options2.operator, options2.message ? (this.message = options2.message, this.generatedMessage = false) : (this.message = getMessage(this), this.generatedMessage = true);
            var stackStartFunction = options2.stackStartFunction || fail;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, stackStartFunction);
            else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack, fn_name = stackStartFunction.name, idx = out.indexOf("\n" + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf("\n", idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, assert.equal = function(actual, expected, message) {
            actual != expected && fail(actual, expected, message, "==", assert.equal);
          }, assert.notEqual = function(actual, expected, message) {
            actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
          }, assert.deepEqual = function(actual, expected, message) {
            _deepEqual(actual, expected) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
          }, assert.notDeepEqual = function(actual, expected, message) {
            _deepEqual(actual, expected) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
          }, assert.strictEqual = function(actual, expected, message) {
            actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
          }, assert.notStrictEqual = function(actual, expected, message) {
            actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
          }, assert.throws = function(block, error, message) {
            _throws.apply(this, [true].concat(pSlice.call(arguments)));
          }, assert.doesNotThrow = function(block, message) {
            _throws.apply(this, [false].concat(pSlice.call(arguments)));
          }, assert.ifError = function(err) {
            if (err)
              throw err;
          };
          var objectKeys = Object.keys || function(obj) {
            var keys4 = [];
            for (var key2 in obj)
              hasOwn.call(obj, key2) && keys4.push(key2);
            return keys4;
          };
        }, { "util/": 6 }], 3: [function(require2, module4, exports3) {
          "function" == typeof Object.create ? module4.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
          } : module4.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
          };
        }, {}], 4: [function(require2, module4, exports3) {
          function cleanUpNextTick() {
            draining && currentQueue && (draining = false, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
          }
          function drainQueue() {
            if (!draining) {
              var timeout = cachedSetTimeout(cleanUpNextTick);
              draining = true;
              for (var len = queue.length; len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; )
                  currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, len = queue.length;
              }
              currentQueue = null, draining = false, cachedClearTimeout(timeout);
            }
          }
          function Item(fun, array) {
            this.fun = fun, this.array = array;
          }
          function noop() {
          }
          var cachedSetTimeout, cachedClearTimeout, process2 = module4.exports = {};
          !function() {
            try {
              cachedSetTimeout = setTimeout;
            } catch (e2) {
              cachedSetTimeout = function() {
                throw new Error("setTimeout is not defined");
              };
            }
            try {
              cachedClearTimeout = clearTimeout;
            } catch (e2) {
              cachedClearTimeout = function() {
                throw new Error("clearTimeout is not defined");
              };
            }
          }();
          var currentQueue, queue = [], draining = false, queueIndex = -1;
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var i2 = 1; i2 < arguments.length; i2++)
                args[i2 - 1] = arguments[i2];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || cachedSetTimeout(drainQueue, 0);
          }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, process2.title = "browser", process2.browser = true, process2.env = {}, process2.argv = [], process2.version = "", process2.versions = {}, process2.on = noop, process2.addListener = noop, process2.once = noop, process2.off = noop, process2.removeListener = noop, process2.removeAllListeners = noop, process2.emit = noop, process2.binding = function(name3) {
            throw new Error("process.binding is not supported");
          }, process2.cwd = function() {
            return "/";
          }, process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          }, process2.umask = function() {
            return 0;
          };
        }, {}], 5: [function(require2, module4, exports3) {
          module4.exports = function(arg) {
            return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
          };
        }, {}], 6: [function(require2, module4, exports3) {
          (function(process2, global3) {
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports3._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = false), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = false), isUndefined(ctx.customInspect) && (ctx.customInspect = true), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue2(ctx, obj, ctx.depth);
            }
            function stylizeWithColor(str, styleType) {
              var style2 = inspect.styles[styleType];
              return style2 ? "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m" : str;
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              return array.forEach(function(val, idx) {
                hash[val] = true;
              }), hash;
            }
            function formatValue2(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports3.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                var ret = value.inspect(recurseTimes, ctx);
                return isString(ret) || (ret = formatValue2(ctx, ret, recurseTimes)), ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive)
                return primitive;
              var keys4 = Object.keys(value), visibleKeys = arrayToHash(keys4);
              if (ctx.showHidden && (keys4 = Object.getOwnPropertyNames(value)), isError(value) && (keys4.indexOf("message") >= 0 || keys4.indexOf("description") >= 0))
                return formatError(value);
              if (0 === keys4.length) {
                if (isFunction(value)) {
                  var name3 = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name3 + "]", "special");
                }
                if (isRegExp(value))
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                if (isDate(value))
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                if (isError(value))
                  return formatError(value);
              }
              var base2 = "", array = false, braces = ["{", "}"];
              if (isArray5(value) && (array = true, braces = ["[", "]"]), isFunction(value)) {
                var n = value.name ? ": " + value.name : "";
                base2 = " [Function" + n + "]";
              }
              if (isRegExp(value) && (base2 = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base2 = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base2 = " " + formatError(value)), 0 === keys4.length && (!array || 0 == value.length))
                return braces[0] + base2 + braces[1];
              if (recurseTimes < 0)
                return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
              ctx.seen.push(value);
              var output;
              return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys4) : keys4.map(function(key2) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
              }), ctx.seen.pop(), reduceToSingleString(output, base2, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys4) {
              for (var output = [], i2 = 0, l = value.length; i2 < l; ++i2)
                hasOwnProperty(value, String(i2)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true)) : output.push("");
              return keys4.forEach(function(key2) {
                key2.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key2, true));
              }), output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
              var name3, str, desc;
              if (desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] }, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key2) || (name3 = "[" + key2 + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue2(ctx, desc.value, null) : formatValue2(ctx, desc.value, recurseTimes - 1), str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2) : "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name3)) {
                if (array && key2.match(/^\d+$/))
                  return str;
                name3 = JSON.stringify("" + key2), name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name3 = name3.substr(1, name3.length - 2), name3 = ctx.stylize(name3, "name")) : (name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name3 = ctx.stylize(name3, "string"));
              }
              return name3 + ": " + str;
            }
            function reduceToSingleString(output, base2, braces) {
              var numLinesEst = 0, length = output.reduce(function(prev, cur2) {
                return numLinesEst++, cur2.indexOf("\n") >= 0 && numLinesEst++, prev + cur2.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              return length > 60 ? braces[0] + ("" === base2 ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
            }
            function isArray5(ar) {
              return Array.isArray(ar);
            }
            function isBoolean(arg) {
              return "boolean" == typeof arg;
            }
            function isNull(arg) {
              return null === arg;
            }
            function isNullOrUndefined(arg) {
              return null == arg;
            }
            function isNumber(arg) {
              return "number" == typeof arg;
            }
            function isString(arg) {
              return "string" == typeof arg;
            }
            function isSymbol(arg) {
              return "symbol" == typeof arg;
            }
            function isUndefined(arg) {
              return void 0 === arg;
            }
            function isRegExp(re) {
              return isObject(re) && "[object RegExp]" === objectToString(re);
            }
            function isObject(arg) {
              return "object" == typeof arg && null !== arg;
            }
            function isDate(d) {
              return isObject(d) && "[object Date]" === objectToString(d);
            }
            function isError(e2) {
              return isObject(e2) && ("[object Error]" === objectToString(e2) || e2 instanceof Error);
            }
            function isFunction(arg) {
              return "function" == typeof arg;
            }
            function isPrimitive(arg) {
              return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg;
            }
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            function timestamp() {
              var d = new Date(), time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
              return [d.getDate(), months[d.getMonth()], time].join(" ");
            }
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var formatRegExp = /%[sdj%]/g;
            exports3.format = function(f) {
              if (!isString(f)) {
                for (var objects = [], i2 = 0; i2 < arguments.length; i2++)
                  objects.push(inspect(arguments[i2]));
                return objects.join(" ");
              }
              for (var i2 = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {
                if ("%%" === x2)
                  return "%";
                if (i2 >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i2++]);
                  case "%d":
                    return Number(args[i2++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i2++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              }), x = args[i2]; i2 < len; x = args[++i2])
                str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
              return str;
            }, exports3.deprecate = function(fn, msg2) {
              function deprecated() {
                if (!warned2) {
                  if (process2.throwDeprecation)
                    throw new Error(msg2);
                  process2.traceDeprecation ? console.trace(msg2) : console.error(msg2), warned2 = true;
                }
                return fn.apply(this, arguments);
              }
              if (isUndefined(global3.process))
                return function() {
                  return exports3.deprecate(fn, msg2).apply(this, arguments);
                };
              if (process2.noDeprecation === true)
                return fn;
              var warned2 = false;
              return deprecated;
            };
            var debugEnviron, debugs = {};
            exports3.debuglog = function(set2) {
              if (isUndefined(debugEnviron) && (debugEnviron = process2.env.NODE_DEBUG || ""), set2 = set2.toUpperCase(), !debugs[set2])
                if (new RegExp("\\b" + set2 + "\\b", "i").test(debugEnviron)) {
                  var pid = process2.pid;
                  debugs[set2] = function() {
                    var msg2 = exports3.format.apply(exports3, arguments);
                    console.error("%s %d: %s", set2, pid, msg2);
                  };
                } else
                  debugs[set2] = function() {
                  };
              return debugs[set2];
            }, exports3.inspect = inspect, inspect.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, inspect.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, exports3.isArray = isArray5, exports3.isBoolean = isBoolean, exports3.isNull = isNull, exports3.isNullOrUndefined = isNullOrUndefined, exports3.isNumber = isNumber, exports3.isString = isString, exports3.isSymbol = isSymbol, exports3.isUndefined = isUndefined, exports3.isRegExp = isRegExp, exports3.isObject = isObject, exports3.isDate = isDate, exports3.isError = isError, exports3.isFunction = isFunction, exports3.isPrimitive = isPrimitive, exports3.isBuffer = require2("./support/isBuffer");
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            exports3.log = function() {
              console.log("%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
            }, exports3.inherits = require2("inherits"), exports3._extend = function(origin, add2) {
              if (!add2 || !isObject(add2))
                return origin;
              for (var keys4 = Object.keys(add2), i2 = keys4.length; i2--; )
                origin[keys4[i2]] = add2[keys4[i2]];
              return origin;
            };
          }).call(this, require2("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, { "./support/isBuffer": 5, _process: 4, inherits: 3 }], 7: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), _require = require2("./helpers.js"), createDataProperty = _require.createDataProperty;
          module4.exports = function() {
            function ByteLengthQueuingStrategy(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, ByteLengthQueuingStrategy), createDataProperty(this, "highWaterMark", highWaterMark);
            }
            return _createClass(ByteLengthQueuingStrategy, [{ key: "size", value: function(chunk) {
              return chunk.byteLength;
            } }]), ByteLengthQueuingStrategy;
          }();
        }, { "./helpers.js": 9 }], 8: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), _require = require2("./helpers.js"), createDataProperty = _require.createDataProperty;
          module4.exports = function() {
            function CountQueuingStrategy(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, CountQueuingStrategy), createDataProperty(this, "highWaterMark", highWaterMark);
            }
            return _createClass(CountQueuingStrategy, [{ key: "size", value: function(chunk) {
              return 1;
            } }]), CountQueuingStrategy;
          }();
        }, { "./helpers.js": 9 }], 9: [function(require2, module4, exports3) {
          "use strict";
          var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol ? "symbol" : typeof obj;
          }, assert = require2("assert");
          exports3.promiseCall = function(func) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
              args[_key - 1] = arguments[_key];
            try {
              return Promise.resolve(func.apply(void 0, args));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.typeIsObject = function(x) {
            return "object" === ("undefined" == typeof x ? "undefined" : _typeof(x)) && null !== x || "function" == typeof x;
          }, exports3.toInteger = function(v) {
            return v = Number(v), isNaN(v) ? 0 : v < 0 ? -1 * Math.floor(Math.abs(v)) : Math.floor(Math.abs(v));
          }, exports3.createDataProperty = function(o, p, v) {
            assert(exports3.typeIsObject(o)), o[p] = v;
          }, exports3.createArrayFromList = function(elements) {
            return elements.slice();
          }, exports3.ArrayBufferCopy = function(dest, destOffset, src, srcOffset, n) {
            new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
          }, exports3.CreateIterResultObject = function(value, done) {
            return assert("boolean" == typeof done), { value, done };
          }, exports3.IsFiniteNonNegativeNumber = function(v) {
            return !Number.isNaN(v) && (v !== +(1 / 0) && !(v < 0));
          }, exports3.InvokeOrNoop = function(O, P, args) {
            var method = O[P];
            if (void 0 !== method)
              return method.apply(O, args);
          }, exports3.PromiseInvokeOrNoop = function(O, P, args) {
            var method = void 0;
            try {
              return method = O[P], void 0 === method ? Promise.resolve(void 0) : Promise.resolve(method.apply(O, args));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.PromiseInvokeOrFallbackOrNoop = function(O, P1, args1, P2, args2) {
            var method = void 0;
            try {
              method = O[P1];
            } catch (methodE) {
              return Promise.reject(methodE);
            }
            if (void 0 === method)
              return exports3.PromiseInvokeOrNoop(O, P2, args2);
            try {
              return Promise.resolve(method.apply(O, args1));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.SameRealmTransfer = function(O) {
            return O;
          }, exports3.ValidateAndNormalizeHighWaterMark = function(highWaterMark) {
            if (highWaterMark = Number(highWaterMark), Number.isNaN(highWaterMark) || highWaterMark < 0)
              throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative and non-NaN");
            return highWaterMark;
          }, exports3.ValidateAndNormalizeQueuingStrategy = function(size2, highWaterMark) {
            if (void 0 !== size2 && "function" != typeof size2)
              throw new TypeError("size property of a queuing strategy must be a function");
            return highWaterMark = exports3.ValidateAndNormalizeHighWaterMark(highWaterMark), { size: size2, highWaterMark };
          };
        }, { assert: 2 }], 10: [function(require2, module4, exports3) {
          "use strict";
          var assert = require2("assert"), _require = require2("./helpers.js"), IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;
          exports3.DequeueValue = function(queue) {
            assert(queue.length > 0, "Spec-level failure: should never dequeue from an empty queue.");
            var pair = queue.shift();
            return pair.value;
          }, exports3.EnqueueValueWithSize = function(queue, value, size2) {
            if (size2 = Number(size2), !IsFiniteNonNegativeNumber(size2))
              throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
            queue.push({ value, size: size2 });
          }, exports3.GetTotalQueueSize = function(queue) {
            var totalSize = 0;
            return queue.forEach(function(pair) {
              assert("number" == typeof pair.size && !Number.isNaN(pair.size) && pair.size !== +(1 / 0) && pair.size !== -(1 / 0), "Spec-level failure: should never find an invalid size in the queue."), totalSize += pair.size;
            }), totalSize;
          }, exports3.PeekQueueValue = function(queue) {
            assert(queue.length > 0, "Spec-level failure: should never peek at an empty queue.");
            var pair = queue[0];
            return pair.value;
          };
        }, { "./helpers.js": 9, assert: 2 }], 11: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          function AcquireReadableStreamBYOBReader(stream) {
            return new ReadableStreamBYOBReader(stream);
          }
          function AcquireReadableStreamDefaultReader(stream) {
            return new ReadableStreamDefaultReader(stream);
          }
          function IsReadableStream(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readableStreamController");
          }
          function IsReadableStreamDisturbed(stream) {
            return assert(IsReadableStream(stream) === true, "IsReadableStreamDisturbed should only be used on known readable streams"), stream._disturbed;
          }
          function IsReadableStreamLocked(stream) {
            return assert(IsReadableStream(stream) === true, "IsReadableStreamLocked should only be used on known readable streams"), void 0 !== stream._reader;
          }
          function ReadableStreamTee(stream, shouldClone) {
            assert(IsReadableStream(stream) === true), assert("boolean" == typeof shouldClone);
            var reader = AcquireReadableStreamDefaultReader(stream), teeState = { closedOrErrored: false, canceled1: false, canceled2: false, reason1: void 0, reason2: void 0 };
            teeState.promise = new Promise(function(resolve) {
              return teeState._resolve = resolve;
            });
            var pull = create_ReadableStreamTeePullFunction();
            pull._reader = reader, pull._teeState = teeState, pull._shouldClone = shouldClone;
            var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
            cancel1._stream = stream, cancel1._teeState = teeState;
            var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
            cancel2._stream = stream, cancel2._teeState = teeState;
            var underlyingSource1 = Object.create(Object.prototype);
            createDataProperty(underlyingSource1, "pull", pull), createDataProperty(underlyingSource1, "cancel", cancel1);
            var branch1Stream = new ReadableStream(underlyingSource1), underlyingSource2 = Object.create(Object.prototype);
            createDataProperty(underlyingSource2, "pull", pull), createDataProperty(underlyingSource2, "cancel", cancel2);
            var branch2Stream = new ReadableStream(underlyingSource2);
            return pull._branch1 = branch1Stream._readableStreamController, pull._branch2 = branch2Stream._readableStreamController, reader._closedPromise.catch(function(r) {
              teeState.closedOrErrored !== true && (ReadableStreamDefaultControllerError(pull._branch1, r), ReadableStreamDefaultControllerError(pull._branch2, r), teeState.closedOrErrored = true);
            }), [branch1Stream, branch2Stream];
          }
          function create_ReadableStreamTeePullFunction() {
            var f = function f2() {
              var reader = f2._reader, branch1 = f2._branch1, branch2 = f2._branch2, teeState = f2._teeState;
              f2._shouldClone;
              return ReadableStreamDefaultReaderRead(reader).then(function(result) {
                assert(typeIsObject(result));
                var value = result.value, done = result.done;
                if (assert("boolean" == typeof done), done === true && teeState.closedOrErrored === false && (teeState.canceled1 === false && ReadableStreamDefaultControllerClose(branch1), teeState.canceled2 === false && ReadableStreamDefaultControllerClose(branch2), teeState.closedOrErrored = true), teeState.closedOrErrored !== true) {
                  if (teeState.canceled1 === false) {
                    var value1 = value;
                    ReadableStreamDefaultControllerEnqueue(branch1, value1);
                  }
                  if (teeState.canceled2 === false) {
                    var value2 = value;
                    ReadableStreamDefaultControllerEnqueue(branch2, value2);
                  }
                }
              });
            };
            return f;
          }
          function create_ReadableStreamTeeBranch1CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream, teeState = f2._teeState;
              if (teeState.canceled1 = true, teeState.reason1 = reason, teeState.canceled2 === true) {
                var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          function create_ReadableStreamTeeBranch2CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream, teeState = f2._teeState;
              if (teeState.canceled2 = true, teeState.reason2 = reason, teeState.canceled1 === true) {
                var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          function ReadableStreamAddReadIntoRequest(stream) {
            assert(IsReadableStreamBYOBReader(stream._reader) === true), assert("readable" === stream._state || "closed" === stream._state);
            var promise = new Promise(function(resolve, reject) {
              var readIntoRequest = { _resolve: resolve, _reject: reject };
              stream._reader._readIntoRequests.push(readIntoRequest);
            });
            return promise;
          }
          function ReadableStreamAddReadRequest(stream) {
            assert(IsReadableStreamDefaultReader(stream._reader) === true), assert("readable" === stream._state);
            var promise = new Promise(function(resolve, reject) {
              var readRequest = { _resolve: resolve, _reject: reject };
              stream._reader._readRequests.push(readRequest);
            });
            return promise;
          }
          function ReadableStreamCancel(stream, reason) {
            if (stream._disturbed = true, "closed" === stream._state)
              return Promise.resolve(void 0);
            if ("errored" === stream._state)
              return Promise.reject(stream._storedError);
            ReadableStreamClose(stream);
            var sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);
            return sourceCancelPromise.then(function() {
            });
          }
          function ReadableStreamClose(stream) {
            assert("readable" === stream._state), stream._state = "closed";
            var reader = stream._reader;
            if (void 0 !== reader) {
              if (IsReadableStreamDefaultReader(reader) === true) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
                try {
                  for (var _step, _iterator = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _resolve = _step.value._resolve;
                    _resolve(CreateIterResultObject(void 0, true));
                  }
                } catch (err) {
                  _didIteratorError = true, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator.return && _iterator.return();
                  } finally {
                    if (_didIteratorError)
                      throw _iteratorError;
                  }
                }
                reader._readRequests = [];
              }
              reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;
            }
          }
          function ReadableStreamError(stream, e2) {
            assert(IsReadableStream(stream) === true, "stream must be ReadableStream"), assert("readable" === stream._state, "state must be readable"), stream._state = "errored", stream._storedError = e2;
            var reader = stream._reader;
            if (void 0 !== reader) {
              if (IsReadableStreamDefaultReader(reader) === true) {
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
                try {
                  for (var _step2, _iterator2 = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var readRequest = _step2.value;
                    readRequest._reject(e2);
                  }
                } catch (err) {
                  _didIteratorError2 = true, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
                reader._readRequests = [];
              } else {
                assert(IsReadableStreamBYOBReader(reader), "reader must be ReadableStreamBYOBReader");
                var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
                try {
                  for (var _step3, _iterator3 = reader._readIntoRequests[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var readIntoRequest = _step3.value;
                    readIntoRequest._reject(e2);
                  }
                } catch (err) {
                  _didIteratorError3 = true, _iteratorError3 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();
                  } finally {
                    if (_didIteratorError3)
                      throw _iteratorError3;
                  }
                }
                reader._readIntoRequests = [];
              }
              reader._closedPromise_reject(e2), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;
            }
          }
          function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
            var reader = stream._reader;
            assert(reader._readIntoRequests.length > 0);
            var readIntoRequest = reader._readIntoRequests.shift();
            readIntoRequest._resolve(CreateIterResultObject(chunk, done));
          }
          function ReadableStreamFulfillReadRequest(stream, chunk, done) {
            var reader = stream._reader;
            assert(reader._readRequests.length > 0);
            var readRequest = reader._readRequests.shift();
            readRequest._resolve(CreateIterResultObject(chunk, done));
          }
          function ReadableStreamGetNumReadIntoRequests(stream) {
            return stream._reader._readIntoRequests.length;
          }
          function ReadableStreamGetNumReadRequests(stream) {
            return stream._reader._readRequests.length;
          }
          function ReadableStreamHasBYOBReader(stream) {
            var reader = stream._reader;
            return void 0 !== reader && IsReadableStreamBYOBReader(reader) !== false;
          }
          function ReadableStreamHasDefaultReader(stream) {
            var reader = stream._reader;
            return void 0 !== reader && IsReadableStreamDefaultReader(reader) !== false;
          }
          function IsReadableStreamBYOBReader(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests");
          }
          function IsReadableStreamDefaultReader(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readRequests");
          }
          function ReadableStreamReaderGenericInitialize(reader, stream) {
            reader._ownerReadableStream = stream, stream._reader = reader, "readable" === stream._state ? reader._closedPromise = new Promise(function(resolve, reject) {
              reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
            }) : "closed" === stream._state ? (reader._closedPromise = Promise.resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0) : (assert("errored" === stream._state, "state must be errored"), reader._closedPromise = Promise.reject(stream._storedError), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
          }
          function ReadableStreamReaderGenericCancel(reader, reason) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), ReadableStreamCancel(stream, reason);
          }
          function ReadableStreamReaderGenericRelease(reader) {
            assert(void 0 !== reader._ownerReadableStream), assert(reader._ownerReadableStream._reader === reader), "readable" === reader._ownerReadableStream._state ? reader._closedPromise_reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : reader._closedPromise = Promise.reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
          }
          function ReadableStreamBYOBReaderRead(reader, view) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), stream._disturbed = true, "errored" === stream._state ? Promise.reject(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
          }
          function ReadableStreamDefaultReaderRead(reader) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), stream._disturbed = true, "closed" === stream._state ? Promise.resolve(CreateIterResultObject(void 0, true)) : "errored" === stream._state ? Promise.reject(stream._storedError) : (assert("readable" === stream._state), stream._readableStreamController[InternalPull]());
          }
          function IsReadableStreamDefaultController(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingSource");
          }
          function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
            var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
            if (shouldPull !== false) {
              if (controller._pulling === true)
                return void (controller._pullAgain = true);
              controller._pulling = true;
              var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, "pull", [controller]);
              pullPromise.then(function() {
                if (controller._pulling = false, controller._pullAgain === true)
                  return controller._pullAgain = false, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }, function(e2) {
                if ("readable" === controller._controlledReadableStream._state)
                  return ReadableStreamDefaultControllerError(controller, e2);
              }).catch(rethrowAssertionErrorRejection);
            }
          }
          function ReadableStreamDefaultControllerShouldCallPull(controller) {
            var stream = controller._controlledReadableStream;
            if ("closed" === stream._state || "errored" === stream._state)
              return false;
            if (controller._closeRequested === true)
              return false;
            if (controller._started === false)
              return false;
            if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0)
              return true;
            var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
            return desiredSize > 0;
          }
          function ReadableStreamDefaultControllerClose(controller) {
            var stream = controller._controlledReadableStream;
            assert(controller._closeRequested === false), assert("readable" === stream._state), controller._closeRequested = true, 0 === controller._queue.length && ReadableStreamClose(stream);
          }
          function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
            var stream = controller._controlledReadableStream;
            if (assert(controller._closeRequested === false), assert("readable" === stream._state), IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0)
              ReadableStreamFulfillReadRequest(stream, chunk, false);
            else {
              var chunkSize = 1;
              if (void 0 !== controller._strategySize)
                try {
                  chunkSize = controller._strategySize(chunk);
                } catch (chunkSizeE) {
                  throw "readable" === stream._state && ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
                }
              try {
                EnqueueValueWithSize(controller._queue, chunk, chunkSize);
              } catch (enqueueE) {
                throw "readable" === stream._state && ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
              }
            }
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          function ReadableStreamDefaultControllerError(controller, e2) {
            var stream = controller._controlledReadableStream;
            assert("readable" === stream._state), controller._queue = [], ReadableStreamError(stream, e2);
          }
          function ReadableStreamDefaultControllerGetDesiredSize(controller) {
            var queueSize = GetTotalQueueSize(controller._queue);
            return controller._strategyHWM - queueSize;
          }
          function IsReadableByteStreamController(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingByteSource");
          }
          function IsReadableStreamBYOBRequest(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController");
          }
          function ReadableByteStreamControllerCallPullIfNeeded(controller) {
            var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
            if (shouldPull !== false) {
              if (controller._pulling === true)
                return void (controller._pullAgain = true);
              controller._pullAgain = false, controller._pulling = true;
              var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, "pull", [controller]);
              pullPromise.then(function() {
                controller._pulling = false, controller._pullAgain === true && (controller._pullAgain = false, ReadableByteStreamControllerCallPullIfNeeded(controller));
              }, function(e2) {
                "readable" === controller._controlledReadableStream._state && ReadableByteStreamControllerError(controller, e2);
              }).catch(rethrowAssertionErrorRejection);
            }
          }
          function ReadableByteStreamControllerClearPendingPullIntos(controller) {
            ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = [];
          }
          function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
            assert("errored" !== stream._state, "state must not be errored");
            var done = false;
            "closed" === stream._state && (assert(0 === pullIntoDescriptor.bytesFilled), done = true);
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            "default" === pullIntoDescriptor.readerType ? ReadableStreamFulfillReadRequest(stream, filledView, done) : (assert("byob" === pullIntoDescriptor.readerType), ReadableStreamFulfillReadIntoRequest(stream, filledView, done));
          }
          function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
            var bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
            return assert(bytesFilled <= pullIntoDescriptor.byteLength), assert(bytesFilled % elementSize === 0), new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
          }
          function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
            controller._queue.push({ buffer, byteOffset, byteLength }), controller._totalQueuedBytes += byteLength;
          }
          function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
            var elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._totalQueuedBytes, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = false;
            maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = true);
            for (var queue = controller._queue; totalBytesToCopyRemaining > 0; ) {
              var headOfQueue = queue[0], bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
              ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._totalQueuedBytes -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
            }
            return ready === false && (assert(0 === controller._totalQueuedBytes, "queue must be empty"), assert(pullIntoDescriptor.bytesFilled > 0), assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)), ready;
          }
          function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size2, pullIntoDescriptor) {
            assert(0 === controller._pendingPullIntos.length || controller._pendingPullIntos[0] === pullIntoDescriptor), ReadableByteStreamControllerInvalidateBYOBRequest(controller), pullIntoDescriptor.bytesFilled += size2;
          }
          function ReadableByteStreamControllerHandleQueueDrain(controller) {
            assert("readable" === controller._controlledReadableStream._state), 0 === controller._totalQueuedBytes && controller._closeRequested === true ? ReadableStreamClose(controller._controlledReadableStream) : ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
            void 0 !== controller._byobRequest && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = void 0, controller._byobRequest = void 0);
          }
          function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
            for (assert(controller._closeRequested === false); controller._pendingPullIntos.length > 0; ) {
              if (0 === controller._totalQueuedBytes)
                return;
              var pullIntoDescriptor = controller._pendingPullIntos[0];
              ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor));
            }
          }
          function ReadableByteStreamControllerPullInto(controller, view) {
            var stream = controller._controlledReadableStream, elementSize = 1;
            view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
            var ctor = view.constructor, pullIntoDescriptor = { buffer: view.buffer, byteOffset: view.byteOffset, byteLength: view.byteLength, bytesFilled: 0, elementSize, ctor, readerType: "byob" };
            if (controller._pendingPullIntos.length > 0)
              return pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream);
            if ("closed" === stream._state) {
              var emptyView = new view.constructor(view.buffer, view.byteOffset, 0);
              return Promise.resolve(CreateIterResultObject(emptyView, true));
            }
            if (controller._totalQueuedBytes > 0) {
              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                return ReadableByteStreamControllerHandleQueueDrain(controller), Promise.resolve(CreateIterResultObject(filledView, false));
              }
              if (controller._closeRequested === true) {
                var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                return ReadableByteStreamControllerError(controller, e2), Promise.reject(e2);
              }
            }
            pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor);
            var promise = ReadableStreamAddReadIntoRequest(stream);
            return ReadableByteStreamControllerCallPullIfNeeded(controller), promise;
          }
          function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
            firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer), assert(0 === firstDescriptor.bytesFilled, "bytesFilled must be 0");
            for (var stream = controller._controlledReadableStream; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
              var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
          function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
            if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength)
              throw new RangeError("bytesWritten out of range");
            if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
              if (remainderSize > 0) {
                var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
              }
              pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
            }
          }
          function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
            var firstDescriptor = controller._pendingPullIntos[0], stream = controller._controlledReadableStream;
            if ("closed" === stream._state) {
              if (0 !== bytesWritten)
                throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
              ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
            } else
              assert("readable" === stream._state), ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          function ReadableByteStreamControllerShiftPendingPullInto(controller) {
            var descriptor = controller._pendingPullIntos.shift();
            return ReadableByteStreamControllerInvalidateBYOBRequest(controller), descriptor;
          }
          function ReadableByteStreamControllerShouldCallPull(controller) {
            var stream = controller._controlledReadableStream;
            return "readable" === stream._state && (controller._closeRequested !== true && (controller._started !== false && (!!(ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) || (!!(ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) || ReadableByteStreamControllerGetDesiredSize(controller) > 0))));
          }
          function ReadableByteStreamControllerClose(controller) {
            var stream = controller._controlledReadableStream;
            if (assert(controller._closeRequested === false), assert("readable" === stream._state), controller._totalQueuedBytes > 0)
              return void (controller._closeRequested = true);
            if (controller._pendingPullIntos.length > 0) {
              var firstPendingPullInto = controller._pendingPullIntos[0];
              if (firstPendingPullInto.bytesFilled > 0) {
                var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                throw ReadableByteStreamControllerError(controller, e2), e2;
              }
            }
            ReadableStreamClose(stream);
          }
          function ReadableByteStreamControllerEnqueue(controller, chunk) {
            var stream = controller._controlledReadableStream;
            assert(controller._closeRequested === false), assert("readable" === stream._state);
            var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = SameRealmTransfer(buffer);
            if (ReadableStreamHasDefaultReader(stream) === true)
              if (0 === ReadableStreamGetNumReadRequests(stream))
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
              else {
                assert(0 === controller._queue.length);
                var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
              }
            else
              ReadableStreamHasBYOBReader(stream) === true ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : (assert(IsReadableStreamLocked(stream) === false, "stream must not be locked"), ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength));
          }
          function ReadableByteStreamControllerError(controller, e2) {
            var stream = controller._controlledReadableStream;
            assert("readable" === stream._state), ReadableByteStreamControllerClearPendingPullIntos(controller), controller._queue = [], ReadableStreamError(stream, e2);
          }
          function ReadableByteStreamControllerGetDesiredSize(controller) {
            return controller._strategyHWM - controller._totalQueuedBytes;
          }
          function ReadableByteStreamControllerRespond(controller, bytesWritten) {
            if (bytesWritten = Number(bytesWritten), IsFiniteNonNegativeNumber(bytesWritten) === false)
              throw new RangeError("bytesWritten must be a finite");
            assert(controller._pendingPullIntos.length > 0), ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
          }
          function ReadableByteStreamControllerRespondWithNewView(controller, view) {
            assert(controller._pendingPullIntos.length > 0);
            var firstDescriptor = controller._pendingPullIntos[0];
            if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
              throw new RangeError("The region specified by view does not match byobRequest");
            if (firstDescriptor.byteLength !== view.byteLength)
              throw new RangeError("The buffer of view has different capacity than byobRequest");
            firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
          }
          var _slicedToArray = function() {
            function sliceIterator(arr, i2) {
              var _arr = [], _n = true, _d = false, _e = void 0;
              try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = true)
                  ;
              } catch (err) {
                _d = true, _e = err;
              } finally {
                try {
                  !_n && _i.return && _i.return();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr))
                return arr;
              if (Symbol.iterator in Object(arr))
                return sliceIterator(arr, i2);
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
          }(), _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), assert = require2("assert"), _require = require2("./helpers.js"), ArrayBufferCopy = _require.ArrayBufferCopy, CreateIterResultObject = _require.CreateIterResultObject, IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber, InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, SameRealmTransfer = _require.SameRealmTransfer, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark, _require2 = require2("./helpers.js"), createArrayFromList = _require2.createArrayFromList, createDataProperty = _require2.createDataProperty, typeIsObject = _require2.typeIsObject, _require3 = require2("./utils.js"), rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection, _require4 = require2("./queue-with-sizes.js"), DequeueValue = _require4.DequeueValue, EnqueueValueWithSize = _require4.EnqueueValueWithSize, GetTotalQueueSize = _require4.GetTotalQueueSize, InternalCancel = Symbol("[[Cancel]]"), InternalPull = Symbol("[[Pull]]"), ReadableStream = function() {
            function ReadableStream2() {
              var underlyingSource = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], size2 = _ref.size, highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, ReadableStream2), this._state = "readable", this._reader = void 0, this._storedError = void 0, this._disturbed = false, this._readableStreamController = void 0;
              var type = underlyingSource.type, typeString = String(type);
              if ("bytes" === typeString)
                void 0 === highWaterMark && (highWaterMark = 0), this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
              else {
                if (void 0 !== type)
                  throw new RangeError("Invalid type is specified");
                void 0 === highWaterMark && (highWaterMark = 1), this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size2, highWaterMark);
              }
            }
            return _createClass(ReadableStream2, [{ key: "cancel", value: function(reason) {
              return IsReadableStream(this) === false ? Promise.reject(new TypeError("ReadableStream.prototype.cancel can only be used on a ReadableStream")) : IsReadableStreamLocked(this) === true ? Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason);
            } }, { key: "getReader", value: function() {
              var _ref2 = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], mode = _ref2.mode;
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.getReader can only be used on a ReadableStream");
              if ("byob" === mode) {
                if (IsReadableByteStreamController(this._readableStreamController) === false)
                  throw new TypeError("Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                return AcquireReadableStreamBYOBReader(this);
              }
              if (void 0 === mode)
                return AcquireReadableStreamDefaultReader(this);
              throw new RangeError("Invalid mode is specified");
            } }, { key: "pipeThrough", value: function(_ref3, options2) {
              var writable = _ref3.writable, readable = _ref3.readable;
              return this.pipeTo(writable, options2), readable;
            } }, { key: "pipeTo", value: function(dest) {
              function doPipe() {
                lastRead = reader.read(), Promise.all([lastRead, dest.ready]).then(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), _ref6$ = _ref6[0], value = _ref6$.value, done = _ref6$.done;
                  Boolean(done) === true ? closeDest() : "writable" === dest.state && (lastWrite = dest.write(value), doPipe());
                }).catch(rethrowAssertionErrorRejection);
              }
              function cancelSource(reason) {
                preventCancel === false ? (reader.cancel(reason), reader.releaseLock(), rejectPipeToPromise(reason)) : lastRead.then(function() {
                  reader.releaseLock(), rejectPipeToPromise(reason);
                });
              }
              function closeDest() {
                reader.releaseLock();
                var destState = dest.state;
                preventClose !== false || "waiting" !== destState && "writable" !== destState ? void 0 !== lastWrite ? lastWrite.then(resolvePipeToPromise, rejectPipeToPromise) : resolvePipeToPromise() : (closedPurposefully = true, dest.close().then(resolvePipeToPromise, rejectPipeToPromise));
              }
              function abortDest(reason) {
                reader.releaseLock(), preventAbort === false && dest.abort(reason), rejectPipeToPromise(reason);
              }
              var _ref4 = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], preventClose = _ref4.preventClose, preventAbort = _ref4.preventAbort, preventCancel = _ref4.preventCancel;
              preventClose = Boolean(preventClose), preventAbort = Boolean(preventAbort), preventCancel = Boolean(preventCancel);
              var source2 = this, reader = void 0, lastRead = void 0, lastWrite = void 0, closedPurposefully = false, resolvePipeToPromise = void 0, rejectPipeToPromise = void 0;
              return new Promise(function(resolve, reject) {
                resolvePipeToPromise = resolve, rejectPipeToPromise = reject, reader = source2.getReader(), reader.closed.catch(abortDest), dest.closed.then(function() {
                  closedPurposefully || cancelSource(new TypeError("destination is closing or closed and cannot be piped to anymore"));
                }, cancelSource), doPipe();
              });
            } }, { key: "tee", value: function() {
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.tee can only be used on a ReadableStream");
              var branches = ReadableStreamTee(this, false);
              return createArrayFromList(branches);
            } }, { key: "locked", get: function() {
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.locked can only be used on a ReadableStream");
              return IsReadableStreamLocked(this);
            } }]), ReadableStream2;
          }();
          exports3.ReadableStream = ReadableStream, exports3.IsReadableStreamDisturbed = IsReadableStreamDisturbed;
          var ReadableStreamDefaultReader = function() {
            function ReadableStreamDefaultReader2(stream) {
              if (_classCallCheck(this, ReadableStreamDefaultReader2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
              if (IsReadableStreamLocked(stream) === true)
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = [];
            }
            return _createClass(ReadableStreamDefaultReader2, [{ key: "cancel", value: function(reason) {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : ReadableStreamReaderGenericCancel(this, reason);
            } }, { key: "read", value: function() {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : ReadableStreamDefaultReaderRead(this);
            } }, { key: "releaseLock", value: function() {
              if (IsReadableStreamDefaultReader(this) === false)
                throw new TypeError("ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader");
              if (void 0 !== this._ownerReadableStream) {
                if (this._readRequests.length > 0)
                  throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                ReadableStreamReaderGenericRelease(this);
              }
            } }, { key: "closed", get: function() {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader")) : this._closedPromise;
            } }]), ReadableStreamDefaultReader2;
          }(), ReadableStreamBYOBReader = function() {
            function ReadableStreamBYOBReader2(stream) {
              if (_classCallCheck(this, ReadableStreamBYOBReader2), !IsReadableStream(stream))
                throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
              if (IsReadableStreamLocked(stream))
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = [];
            }
            return _createClass(ReadableStreamBYOBReader2, [{ key: "cancel", value: function(reason) {
              return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : ReadableStreamReaderGenericCancel(this, reason) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader"));
            } }, { key: "read", value: function(view) {
              return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : ArrayBuffer.isView(view) ? 0 === view.byteLength ? Promise.reject(new TypeError("view must have non-zero byteLength")) : ReadableStreamBYOBReaderRead(this, view) : Promise.reject(new TypeError("view must be an array buffer view")) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader"));
            } }, { key: "releaseLock", value: function() {
              if (!IsReadableStreamBYOBReader(this))
                throw new TypeError("ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader");
              if (void 0 !== this._ownerReadableStream) {
                if (this._readIntoRequests.length > 0)
                  throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                ReadableStreamReaderGenericRelease(this);
              }
            } }, { key: "closed", get: function() {
              return IsReadableStreamBYOBReader(this) ? this._closedPromise : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader"));
            } }]), ReadableStreamBYOBReader2;
          }(), ReadableStreamDefaultController = function() {
            function ReadableStreamDefaultController2(stream, underlyingSource, size2, highWaterMark) {
              if (_classCallCheck(this, ReadableStreamDefaultController2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");
              if (void 0 !== stream._readableStreamController)
                throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");
              this._controlledReadableStream = stream, this._underlyingSource = underlyingSource, this._queue = [], this._started = false, this._closeRequested = false, this._pullAgain = false, this._pulling = false;
              var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size2, highWaterMark);
              this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark;
              var controller = this, startResult = InvokeOrNoop(underlyingSource, "start", [this]);
              Promise.resolve(startResult).then(function() {
                controller._started = true, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }, function(r) {
                "readable" === stream._state && ReadableStreamDefaultControllerError(controller, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(ReadableStreamDefaultController2, [{ key: "close", value: function() {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController");
              if (this._closeRequested === true)
                throw new TypeError("The stream has already been closed; do not close it again!");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be closed");
              ReadableStreamDefaultControllerClose(this);
            } }, { key: "enqueue", value: function(chunk) {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController");
              if (this._closeRequested === true)
                throw new TypeError("stream is closed or draining");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be enqueued to");
              return ReadableStreamDefaultControllerEnqueue(this, chunk);
            } }, { key: "error", value: function(e2) {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController");
              var stream = this._controlledReadableStream;
              if ("readable" !== stream._state)
                throw new TypeError("The stream is " + stream._state + " and so cannot be errored");
              ReadableStreamDefaultControllerError(this, e2);
            } }, { key: InternalCancel, value: function(reason) {
              return this._queue = [], PromiseInvokeOrNoop(this._underlyingSource, "cancel", [reason]);
            } }, { key: InternalPull, value: function() {
              var stream = this._controlledReadableStream;
              if (this._queue.length > 0) {
                var chunk = DequeueValue(this._queue);
                return this._closeRequested === true && 0 === this._queue.length ? ReadableStreamClose(stream) : ReadableStreamDefaultControllerCallPullIfNeeded(this), Promise.resolve(CreateIterResultObject(chunk, false));
              }
              var pendingPromise = ReadableStreamAddReadRequest(stream);
              return ReadableStreamDefaultControllerCallPullIfNeeded(this), pendingPromise;
            } }, { key: "desiredSize", get: function() {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController");
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            } }]), ReadableStreamDefaultController2;
          }(), ReadableStreamBYOBRequest = function() {
            function ReadableStreamBYOBRequest2(controller, view) {
              _classCallCheck(this, ReadableStreamBYOBRequest2), this._associatedReadableByteStreamController = controller, this._view = view;
            }
            return _createClass(ReadableStreamBYOBRequest2, [{ key: "respond", value: function(bytesWritten) {
              if (IsReadableStreamBYOBRequest(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController");
              if (void 0 === this._associatedReadableByteStreamController)
                throw new TypeError("This BYOB request has been invalidated");
              ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
            } }, { key: "respondWithNewView", value: function(view) {
              if (IsReadableStreamBYOBRequest(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController");
              if (void 0 === this._associatedReadableByteStreamController)
                throw new TypeError("This BYOB request has been invalidated");
              if (!ArrayBuffer.isView(view))
                throw new TypeError("You can only respond with array buffer views");
              ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
            } }, { key: "view", get: function() {
              return this._view;
            } }]), ReadableStreamBYOBRequest2;
          }(), ReadableByteStreamController = function() {
            function ReadableByteStreamController2(stream, underlyingByteSource, highWaterMark) {
              if (_classCallCheck(this, ReadableByteStreamController2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");
              if (void 0 !== stream._readableStreamController)
                throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");
              this._controlledReadableStream = stream, this._underlyingByteSource = underlyingByteSource, this._pullAgain = false, this._pulling = false, ReadableByteStreamControllerClearPendingPullIntos(this), this._queue = [], this._totalQueuedBytes = 0, this._closeRequested = false, this._started = false, this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
              var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
              if (void 0 !== autoAllocateChunkSize && (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize < 0))
                throw new RangeError("autoAllocateChunkSize must be a non negative integer");
              this._autoAllocateChunkSize = autoAllocateChunkSize, this._pendingPullIntos = [];
              var controller = this, startResult = InvokeOrNoop(underlyingByteSource, "start", [this]);
              Promise.resolve(startResult).then(function() {
                controller._started = true, assert(controller._pulling === false), assert(controller._pullAgain === false), ReadableByteStreamControllerCallPullIfNeeded(controller);
              }, function(r) {
                "readable" === stream._state && ReadableByteStreamControllerError(controller, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(ReadableByteStreamController2, [{ key: "close", value: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController");
              if (this._closeRequested === true)
                throw new TypeError("The stream has already been closed; do not close it again!");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be closed");
              ReadableByteStreamControllerClose(this);
            } }, { key: "enqueue", value: function(chunk) {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController");
              if (this._closeRequested === true)
                throw new TypeError("stream is closed or draining");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be enqueued to");
              if (!ArrayBuffer.isView(chunk))
                throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
              ReadableByteStreamControllerEnqueue(this, chunk);
            } }, { key: "error", value: function(e2) {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController");
              var stream = this._controlledReadableStream;
              if ("readable" !== stream._state)
                throw new TypeError("The stream is " + stream._state + " and so cannot be errored");
              ReadableByteStreamControllerError(this, e2);
            } }, { key: InternalCancel, value: function(reason) {
              if (this._pendingPullIntos.length > 0) {
                var firstDescriptor = this._pendingPullIntos[0];
                firstDescriptor.bytesFilled = 0;
              }
              return this._queue = [], this._totalQueuedBytes = 0, PromiseInvokeOrNoop(this._underlyingByteSource, "cancel", [reason]);
            } }, { key: InternalPull, value: function() {
              var stream = this._controlledReadableStream;
              if (0 === ReadableStreamGetNumReadRequests(stream)) {
                if (this._totalQueuedBytes > 0) {
                  var entry = this._queue.shift();
                  this._totalQueuedBytes -= entry.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
                  var view = void 0;
                  try {
                    view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                  } catch (viewE) {
                    return Promise.reject(viewE);
                  }
                  return Promise.resolve(CreateIterResultObject(view, false));
                }
                var autoAllocateChunkSize = this._autoAllocateChunkSize;
                if (void 0 !== autoAllocateChunkSize) {
                  var buffer = void 0;
                  try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                  } catch (bufferE) {
                    return Promise.reject(bufferE);
                  }
                  var pullIntoDescriptor = { buffer, byteOffset: 0, byteLength: autoAllocateChunkSize, bytesFilled: 0, elementSize: 1, ctor: Uint8Array, readerType: "default" };
                  this._pendingPullIntos.push(pullIntoDescriptor);
                }
              } else
                assert(void 0 === this._autoAllocateChunkSize);
              var promise = ReadableStreamAddReadRequest(stream);
              return ReadableByteStreamControllerCallPullIfNeeded(this), promise;
            } }, { key: "byobRequest", get: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.byobRequest can only be used on a ReadableByteStreamController");
              if (void 0 === this._byobRequest && this._pendingPullIntos.length > 0) {
                var firstDescriptor = this._pendingPullIntos[0], view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                this._byobRequest = new ReadableStreamBYOBRequest(this, view);
              }
              return this._byobRequest;
            } }, { key: "desiredSize", get: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.desiredSize can only be used on a ReadableByteStreamController");
              return ReadableByteStreamControllerGetDesiredSize(this);
            } }]), ReadableByteStreamController2;
          }();
        }, { "./helpers.js": 9, "./queue-with-sizes.js": 10, "./utils.js": 13, assert: 2 }], 12: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _require = require2("./readable-stream.js"), ReadableStream = _require.ReadableStream, _require2 = require2("./writable-stream.js"), WritableStream = _require2.WritableStream;
          module4.exports = function TransformStream(transformer) {
            function maybeDoTransform() {
              if (transforming === false) {
                transforming = true;
                try {
                  transformer.transform(writeChunk, enqueueInReadable, transformDone), writeChunk = void 0, chunkWrittenButNotYetTransformed = false;
                } catch (e2) {
                  transforming = false, errorWritable(e2), errorReadable(e2);
                }
              }
            }
            function transformDone() {
              transforming = false, writeDone();
            }
            if (_classCallCheck(this, TransformStream), void 0 === transformer.flush && (transformer.flush = function(enqueue, close) {
              return close();
            }), "function" != typeof transformer.transform)
              throw new TypeError("transform must be a function");
            var writeChunk = void 0, writeDone = void 0, errorWritable = void 0, transforming = false, chunkWrittenButNotYetTransformed = false;
            this.writable = new WritableStream({ start: function(error) {
              errorWritable = error;
            }, write: function(chunk) {
              writeChunk = chunk, chunkWrittenButNotYetTransformed = true;
              var p = new Promise(function(resolve) {
                return writeDone = resolve;
              });
              return maybeDoTransform(), p;
            }, close: function() {
              try {
                transformer.flush(enqueueInReadable, closeReadable);
              } catch (e2) {
                errorWritable(e2), errorReadable(e2);
              }
            } }, transformer.writableStrategy);
            var enqueueInReadable = void 0, closeReadable = void 0, errorReadable = void 0;
            this.readable = new ReadableStream({ start: function(c) {
              enqueueInReadable = c.enqueue.bind(c), closeReadable = c.close.bind(c), errorReadable = c.error.bind(c);
            }, pull: function() {
              chunkWrittenButNotYetTransformed === true && maybeDoTransform();
            } }, transformer.readableStrategy);
          };
        }, { "./readable-stream.js": 11, "./writable-stream.js": 14 }], 13: [function(require2, module4, exports3) {
          "use strict";
          var assert = require2("assert");
          exports3.rethrowAssertionErrorRejection = function(e2) {
            e2 && e2.constructor === assert.AssertionError && setTimeout(function() {
              throw e2;
            }, 0);
          };
        }, { assert: 2 }], 14: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          function closure_WritableStreamErrorFunction() {
            var f = function f2(e2) {
              return ErrorWritableStream(f2._stream, e2);
            };
            return f;
          }
          function CallOrScheduleWritableStreamAdvanceQueue(stream) {
            return stream._started === false ? void stream._startedPromise.then(function() {
              WritableStreamAdvanceQueue(stream);
            }).catch(rethrowAssertionErrorRejection) : stream._started === true ? WritableStreamAdvanceQueue(stream) : void 0;
          }
          function CloseWritableStream(stream) {
            assert("closing" === stream._state, "stream must be in closing state while calling CloseWritableStream");
            var sinkClosePromise = PromiseInvokeOrNoop(stream._underlyingSink, "close");
            sinkClosePromise.then(function() {
              "errored" !== stream._state && (assert("closing" === stream._state), stream._closedPromise_resolve(void 0), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = "closed");
            }, function(r) {
              return ErrorWritableStream(stream, r);
            }).catch(rethrowAssertionErrorRejection);
          }
          function ErrorWritableStream(stream, e2) {
            if ("closed" !== stream._state && "errored" !== stream._state) {
              for (; stream._queue.length > 0; ) {
                var writeRecord = DequeueValue(stream._queue);
                "close" !== writeRecord && writeRecord._reject(e2);
              }
              stream._storedError = e2, "waiting" === stream._state && stream._readyPromise_resolve(void 0), stream._closedPromise_reject(e2), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = "errored";
            }
          }
          function IsWritableStream(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingSink");
          }
          function SyncWritableStreamStateWithQueue(stream) {
            if ("closing" !== stream._state) {
              assert("writable" === stream._state || "waiting" === stream._state, "stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue");
              var queueSize = GetTotalQueueSize(stream._queue), shouldApplyBackpressure = queueSize > stream._strategyHWM;
              shouldApplyBackpressure === true && "writable" === stream._state && (stream._state = "waiting", stream._readyPromise = new Promise(function(resolve, reject) {
                stream._readyPromise_resolve = resolve;
              })), shouldApplyBackpressure === false && "waiting" === stream._state && (stream._state = "writable", stream._readyPromise_resolve(void 0));
            }
          }
          function WritableStreamAdvanceQueue(stream) {
            if (0 !== stream._queue.length && stream._writing !== true) {
              var writeRecord = PeekQueueValue(stream._queue);
              return "close" === writeRecord ? (assert("closing" === stream._state, "can't process final write record unless already closing"), DequeueValue(stream._queue), assert(0 === stream._queue.length, "queue must be empty once the final write record is dequeued"), CloseWritableStream(stream)) : (stream._writing = true, void PromiseInvokeOrNoop(stream._underlyingSink, "write", [writeRecord.chunk]).then(function() {
                "errored" !== stream._state && (stream._writing = false, writeRecord._resolve(void 0), DequeueValue(stream._queue), SyncWritableStreamStateWithQueue(stream), WritableStreamAdvanceQueue(stream));
              }, function(r) {
                return ErrorWritableStream(stream, r);
              }).catch(rethrowAssertionErrorRejection));
            }
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), assert = require2("assert"), _require = require2("./helpers.js"), InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, PromiseInvokeOrFallbackOrNoop = _require.PromiseInvokeOrFallbackOrNoop, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, typeIsObject = _require.typeIsObject, _require2 = require2("./utils.js"), rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection, _require3 = require2("./queue-with-sizes.js"), DequeueValue = _require3.DequeueValue, EnqueueValueWithSize = _require3.EnqueueValueWithSize, GetTotalQueueSize = _require3.GetTotalQueueSize, PeekQueueValue = _require3.PeekQueueValue, WritableStream = (require2("./count-queuing-strategy.js"), function() {
            function WritableStream2() {
              var _this = this, underlyingSink = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], size2 = _ref.size, _ref$highWaterMark = _ref.highWaterMark, highWaterMark = void 0 === _ref$highWaterMark ? 0 : _ref$highWaterMark;
              _classCallCheck(this, WritableStream2), this._underlyingSink = underlyingSink, this._closedPromise = new Promise(function(resolve, reject) {
                _this._closedPromise_resolve = resolve, _this._closedPromise_reject = reject;
              }), this._readyPromise = Promise.resolve(void 0), this._readyPromise_resolve = null, this._queue = [], this._state = "writable", this._started = false, this._writing = false;
              var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size2, highWaterMark);
              this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark, SyncWritableStreamStateWithQueue(this);
              var error = closure_WritableStreamErrorFunction();
              error._stream = this;
              var startResult = InvokeOrNoop(underlyingSink, "start", [error]);
              this._startedPromise = Promise.resolve(startResult), this._startedPromise.then(function() {
                _this._started = true, _this._startedPromise = void 0;
              }), this._startedPromise.catch(function(r) {
                return ErrorWritableStream(_this, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(WritableStream2, [{ key: "abort", value: function(reason) {
              if (!IsWritableStream(this))
                return Promise.reject(new TypeError("WritableStream.prototype.abort can only be used on a WritableStream"));
              if ("closed" === this._state)
                return Promise.resolve(void 0);
              if ("errored" === this._state)
                return Promise.reject(this._storedError);
              ErrorWritableStream(this, reason);
              var sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(this._underlyingSink, "abort", [reason], "close", []);
              return sinkAbortPromise.then(function() {
              });
            } }, { key: "close", value: function() {
              return IsWritableStream(this) ? "closing" === this._state ? Promise.reject(new TypeError("cannot close an already-closing stream")) : "closed" === this._state ? Promise.reject(new TypeError("cannot close an already-closed stream")) : "errored" === this._state ? Promise.reject(this._storedError) : ("waiting" === this._state && this._readyPromise_resolve(void 0), this._state = "closing", EnqueueValueWithSize(this._queue, "close", 0), CallOrScheduleWritableStreamAdvanceQueue(this), this._closedPromise) : Promise.reject(new TypeError("WritableStream.prototype.close can only be used on a WritableStream"));
            } }, { key: "write", value: function(chunk) {
              if (!IsWritableStream(this))
                return Promise.reject(new TypeError("WritableStream.prototype.write can only be used on a WritableStream"));
              if ("closing" === this._state)
                return Promise.reject(new TypeError("cannot write while stream is closing"));
              if ("closed" === this._state)
                return Promise.reject(new TypeError("cannot write after stream is closed"));
              if ("errored" === this._state)
                return Promise.reject(this._storedError);
              assert("waiting" === this._state || "writable" === this._state);
              var chunkSize = 1;
              if (void 0 !== this._strategySize)
                try {
                  chunkSize = this._strategySize(chunk);
                } catch (chunkSizeE) {
                  return ErrorWritableStream(this, chunkSizeE), Promise.reject(chunkSizeE);
                }
              var resolver = void 0, rejecter = void 0, promise = new Promise(function(resolve, reject) {
                resolver = resolve, rejecter = reject;
              }), writeRecord = { promise, chunk, _resolve: resolver, _reject: rejecter };
              try {
                EnqueueValueWithSize(this._queue, writeRecord, chunkSize);
              } catch (enqueueResultE) {
                return ErrorWritableStream(this, enqueueResultE), Promise.reject(enqueueResultE);
              }
              return SyncWritableStreamStateWithQueue(this), CallOrScheduleWritableStreamAdvanceQueue(this), promise;
            } }, { key: "closed", get: function() {
              return IsWritableStream(this) ? this._closedPromise : Promise.reject(new TypeError("WritableStream.prototype.closed can only be used on a WritableStream"));
            } }, { key: "state", get: function() {
              if (!IsWritableStream(this))
                throw new TypeError("WritableStream.prototype.state can only be used on a WritableStream");
              return this._state;
            } }, { key: "ready", get: function() {
              return IsWritableStream(this) ? this._readyPromise : Promise.reject(new TypeError("WritableStream.prototype.ready can only be used on a WritableStream"));
            } }]), WritableStream2;
          }());
          exports3.WritableStream = WritableStream, exports3.IsWritableStream = IsWritableStream;
        }, { "./count-queuing-strategy.js": 8, "./helpers.js": 9, "./queue-with-sizes.js": 10, "./utils.js": 13, assert: 2 }] }, {}, [1])(1);
      });
    }
  });

  // node_modules/node-web-streams/lib/conversions.js
  var require_conversions = __commonJS({
    "node_modules/node-web-streams/lib/conversions.js"(exports2, module3) {
      "use strict";
      var Readable = require_stream().Readable;
      var ReadableStream = require_polyfill_min().ReadableStream;
      function readableNodeToWeb(nodeStream) {
        return new ReadableStream({
          start(controller) {
            nodeStream.pause();
            nodeStream.on("data", (chunk) => {
              controller.enqueue(chunk);
              nodeStream.pause();
            });
            nodeStream.on("end", () => controller.close());
            nodeStream.on("error", (e2) => controller.error(e2));
          },
          pull(controller) {
            nodeStream.resume();
          },
          cancel(reason) {
            nodeStream.pause();
          }
        });
      }
      function arrayToWeb(arr) {
        return new ReadableStream({
          start(controller) {
            for (var i2 = 0; i2 < arr.length; i2++) {
              controller.enqueue(arr[i2]);
            }
            controller.close();
          }
        });
      }
      var NodeReadable = class extends Readable {
        constructor(webStream, options2) {
          super(options2);
          this._webStream = webStream;
          this._reader = webStream.getReader();
          this._reading = false;
        }
        _read(size2) {
          if (this._reading) {
            return;
          }
          this._reading = true;
          const doRead = () => {
            this._reader.read().then((res) => {
              if (res.done) {
                this.push(null);
                return;
              }
              if (this.push(res.value)) {
                return doRead(size2);
              } else {
                this._reading = false;
              }
            });
          };
          doRead();
        }
      };
      function readableWebToNode(webStream) {
        return new NodeReadable(webStream);
      }
      module3.exports = {
        readable: {
          nodeToWeb: readableNodeToWeb,
          arrayToWeb,
          webToNode: readableWebToNode
        }
      };
    }
  });

  // node_modules/node-web-streams/index.js
  var require_node_web_streams = __commonJS({
    "node_modules/node-web-streams/index.js"(exports2, module3) {
      "use strict";
      var nodeStream = require_stream();
      var isNodeStream = require_is_stream();
      var conversions = require_conversions();
      module3.exports = require_polyfill_min();
      module3.exports.toNodeReadable = function(stream) {
        if (stream instanceof module3.exports.ReadableStream || stream && typeof stream.getReader === "function") {
          return conversions.readable.webToNode(stream);
        } else {
          throw new TypeError("Expected a ReadableStream.");
        }
      };
      module3.exports.toWebReadableStream = function(stream) {
        if (isNodeStream(stream) && stream.readable) {
          return conversions.readable.nodeToWeb(stream);
        } else if (Array.isArray(stream)) {
          return conversions.readable.arrayToWeb(stream);
        } else if (Buffer.isBuffer(stream) || typeof stream === "string") {
          return conversions.readable.arrayToWeb([stream]);
        } else {
          throw new TypeError("Expected a Node streams.Readable, an Array, Buffer or String.");
        }
      };
    }
  });

  // public/statebus/braidify-client.js
  var require_braidify_client = __commonJS({
    "public/statebus/braidify-client.js"(exports2, module3) {
      var peer = Math.random().toString(36).substr(2);
      function braidify_http(http) {
        http.normal_get = http.get;
        http.get = function braid_req(arg1, arg2, arg3) {
          var url, options2, cb;
          if (typeof arg1 === "string" || arg1 instanceof URL) {
            url = arg1;
            if (typeof arg2 === "function")
              cb = arg2;
            else {
              options2 = arg2;
              cb = arg3;
            }
          } else {
            options2 = arg2;
            cb = arg3;
          }
          options2 = options2 || {};
          if (!options2.headers)
            options2.headers = {};
          if (options2.subscribe)
            options2.headers.subscribe = "true";
          options2.headers.peer = options2.headers.peer || peer;
          var on_version, on_error, orig_cb = cb;
          cb = (res) => {
            res.orig_on = res.on;
            res.on = (key2, f) => {
              if (key2 === "version") {
                on_version = f;
                var parser = subscription_parser((version, error) => {
                  if (!error)
                    on_version && on_version(version);
                  else
                    on_error && on_error(error);
                });
                res.orig_on("data", (chunk) => {
                  parser.read(chunk.toString());
                });
              } else if (key2 === "error") {
                on_error = f;
                res.orig_on(key2, f);
              } else
                res.orig_on(key2, f);
            };
            orig_cb && orig_cb(res);
          };
          if (url) {
            arg1 = url;
            if (options2) {
              arg2 = options2;
              arg3 = cb;
            } else {
              arg2 = cb;
            }
          } else {
            arg1 = options2;
            arg2 = cb;
          }
          return http.normal_get(arg1, arg2, arg3);
        };
        return http;
      }
      var normal_fetch;
      var AbortController2;
      var Headers;
      var is_nodejs = typeof window === "undefined";
      if (is_nodejs) {
        normal_fetch = require_browser();
        AbortController2 = require_browser2();
        Headers = normal_fetch.Headers;
        to_whatwg_stream = require_node_web_streams().toWebReadableStream;
      } else {
        normal_fetch = window.fetch;
        AbortController2 = window.AbortController;
        Headers = window.Headers;
        window.fetch = braid_fetch2;
      }
      var to_whatwg_stream;
      function braid_fetch2(url, params = {}) {
        if (!params.headers)
          params.headers = new Headers();
        if (!(params.headers instanceof Headers))
          params.headers = new Headers(params.headers);
        if (params.version)
          params.headers.set("version", JSON.stringify(params.version));
        if (params.parents)
          params.headers.set("parents", params.parents.map(JSON.stringify).join(", "));
        if (params.subscribe)
          params.headers.set("subscribe", "true");
        params.cache = "no-cache";
        if (params.patches) {
          console.assert(Array.isArray(params.patches), "Patches must be array");
          console.assert(!params.body, "Cannot send both patches and body");
          params.patches = params.patches || [];
          params.headers.set("patches", params.patches.length);
          params.body = params.patches.map((patch) => {
            var length = `content-length: ${patch.content.length}`;
            var range = `content-range: ${patch.unit} ${patch.range}`;
            return `${length}\r
${range}\r
\r
${patch.content}\r
`;
          }).join("\r\n");
        }
        var original_signal = params.signal;
        var underlying_aborter = new AbortController2();
        params.signal = underlying_aborter.signal;
        if (original_signal)
          original_signal.addEventListener(
            "abort",
            () => underlying_aborter.abort()
          );
        var andThen, iterator;
        var promise = new Promise((resolve, reject) => {
          var fetched = normal_fetch(url, params);
          function start_subscription(cb, error) {
            fetched.then(function(res) {
              if (!res.ok)
                error(new Error("Subscription request failed", res));
              handle_fetch_stream(
                res.body,
                (result, err) => {
                  if (!err)
                    cb(result);
                  else {
                    underlying_aborter.abort();
                    error(err);
                  }
                }
              );
            }).catch(error);
          }
          if (params.subscribe) {
            andThen = (cb) => {
              start_subscription(cb, reject);
              return promise;
            };
            iterator = () => ({
              initialized: false,
              resolve: null,
              reject: null,
              async next() {
                if (!this.initialized) {
                  this.initialized = true;
                  start_subscription(
                    (x) => this.resolve(x),
                    (x) => this.reject(x)
                  );
                }
                var result = await new Promise((resolve2, reject2) => {
                  this.resolve = resolve2;
                  this.reject = reject2;
                });
                var tellme = "Error! Please tell toomim@gmail.com that this happened.";
                this.resolve = () => {
                  throw tellme;
                };
                this.reject = () => {
                  throw tellme;
                };
                return { done: false, value: result };
              }
            });
          } else
            fetched.then(resolve).catch(reject);
        });
        promise.andThen = andThen;
        promise[Symbol.asyncIterator] = iterator;
        return promise;
      }
      async function handle_fetch_stream(stream, cb) {
        if (is_nodejs)
          stream = to_whatwg_stream(stream);
        var reader = stream.getReader(), decoder = new TextDecoder("utf-8"), parser = subscription_parser(cb);
        while (true) {
          var versions2 = [];
          try {
            var { done, value } = await reader.read();
            if (done) {
              console.debug("Connection closed.");
              cb(null, "Connection closed");
              return;
            }
            parser.read(decoder.decode(value));
          } catch (e2) {
            cb(null, e2);
            return;
          }
        }
      }
      var subscription_parser = (cb) => ({
        state: { input: "" },
        cb,
        read(input) {
          this.state.input += input;
          do {
            this.state = parse_version(this.state);
            if (this.state.result === "success") {
              this.cb({
                version: this.state.version,
                parents: this.state.parents,
                body: this.state.body,
                patches: this.state.patches
              });
              this.state = { input: this.state.input };
            } else if (this.state.result === "error") {
              this.cb(null, this.state.message);
              return;
            }
          } while (this.state.result !== "waiting" && this.state.input.trim() !== "");
        }
      });
      function parse_version(state3) {
        if (!state3.headers) {
          var parsed = parse_headers(state3.input);
          if (parsed.result === "error")
            return parsed;
          if (parsed.result === "waiting") {
            state3.result = "waiting";
            return state3;
          }
          state3.headers = parsed.headers;
          state3.version = state3.headers.version;
          state3.parents = state3.headers.parents;
          state3.input = parsed.input;
        }
        return parse_body(state3);
      }
      function swallow_blank_lines(input) {
        var blank_lines = /(\r\n|\n)*/.exec(input)[0];
        return input.substr(blank_lines.length);
      }
      function parse_headers(input) {
        input = swallow_blank_lines(input);
        var headers_end = input.match(/(\r?\n)\r?\n/);
        if (!headers_end)
          return { result: "waiting" };
        var headers_length = headers_end.index + headers_end[1].length, headers_source = input.substring(0, headers_length);
        var headers = {}, header_regex = /([\w-_]+):\s?(.*)\r?\n/gy, match, found_last_match = false;
        while (match = header_regex.exec(headers_source)) {
          headers[match[1].toLowerCase()] = match[2];
          if (header_regex.lastIndex === headers_length)
            found_last_match = true;
        }
        if (!found_last_match)
          return {
            result: "error",
            message: 'Parse error in headers: "' + JSON.stringify(headers_source.substr(header_regex.lastIndex)) + '"',
            headers_so_far: headers,
            last_index: header_regex.lastIndex,
            headers_length
          };
        if ("version" in headers)
          headers.version = JSON.parse(headers.version);
        if ("parents" in headers)
          headers.parents = JSON.parse("[" + headers.parents + "]");
        if ("patches" in headers)
          headers.patches = JSON.parse(headers.patches);
        input = input.substring(headers_length);
        if (input.substr(0, 2) === "\r\n")
          input = input.substr(2);
        else
          input = input.substr(1);
        return { result: "success", headers, input };
      }
      function parse_body(state3) {
        var content_length = parseInt(state3.headers["content-length"]);
        if (content_length !== NaN) {
          if (content_length > state3.input.length) {
            state3.result = "waiting";
            return state3;
          }
          var consumed_length = content_length + 2;
          state3.result = "success";
          state3.body = state3.input.substring(0, content_length);
          state3.input = state3.input.substring(consumed_length);
          return state3;
        } else if (state3.headers.patches) {
          state3.patches = state3.patches || [];
          var last_patch = state3.patches[state3.patches.length - 1];
          while (!(state3.patches.length === state3.headers.patches && "content" in last_patch)) {
            state3.input = state3.input.trimStart();
            if (!last_patch || "content" in last_patch) {
              last_patch = {};
              state3.patches.push(last_patch);
            }
            if (!("headers" in last_patch)) {
              var parsed = parse_headers(state3.input);
              if (parsed.result === "error")
                return parsed;
              if (parsed.result === "waiting") {
                state3.result = "waiting";
                return state3;
              }
              last_patch.headers = parsed.headers;
              state3.input = parsed.input;
            }
            {
              if (!("content-length" in last_patch.headers))
                return {
                  result: "error",
                  message: "no content-length in patch",
                  patch: last_patch,
                  input: state3.input
                };
              if (!("content-range" in last_patch.headers))
                return {
                  result: "error",
                  message: "no content-range in patch",
                  patch: last_patch,
                  input: state3.input
                };
              var content_length = parseInt(last_patch.headers["content-length"]);
              if (state3.input.length < content_length) {
                state3.result = "waiting";
                return state3;
              }
              var match = last_patch.headers["content-range"].match(/(\S+) (.*)/);
              if (!match)
                return {
                  result: "error",
                  message: "cannot parse content-range in patch",
                  patch: last_patch,
                  input: state3.input
                };
              last_patch.unit = match[1];
              last_patch.range = match[2];
              last_patch.content = state3.input.substr(0, content_length);
              state3.input = state3.input.substring(content_length);
            }
          }
          state3.result = "success";
          return state3;
        }
        return {
          result: "error",
          message: "cannot parse body without content-length or patches header"
        };
      }
      if (typeof module3 !== "undefined" && module3.exports)
        module3.exports = {
          fetch: braid_fetch2,
          http: braidify_http,
          subscription_parser,
          parse_version,
          parse_headers,
          parse_body
        };
    }
  });

  // public/module.js
  var import_statebus = __toESM(require_statebus());
  var import_client_library = __toESM(require_client_library());
  var import_braidify_client = __toESM(require_braidify_client());

  // node_modules/diffhtml/dist/es/util/types.js
  var NODE_TYPE = { ELEMENT: 1, ATTR: 2, TEXT: 3, COMMENT: 8, FRAGMENT: 11 };
  var EMPTY = { STR: "", NUM: 1, OBJ: {}, ARR: [], MAP: /* @__PURE__ */ new Map(), SET: /* @__PURE__ */ new Set(), DOM: {}, FUN: () => {
  } };
  var PATCH_TYPE = { SET_ATTRIBUTE: 0, REMOVE_ATTRIBUTE: 1, NODE_VALUE: 2, INSERT_BEFORE: 3, REPLACE_CHILD: 4, REMOVE_CHILD: 5 };
  var TransitionStateNames = ["attached", "detached", "replaced", "attributeChanged", "textChanged"];
  var TransitionCache = /* @__PURE__ */ new Map([["attached", /* @__PURE__ */ new Set()], ["detached", /* @__PURE__ */ new Set()], ["replaced", /* @__PURE__ */ new Set()], ["attributeChanged", /* @__PURE__ */ new Set()], ["textChanged", /* @__PURE__ */ new Set()]]);
  var StateCache = /* @__PURE__ */ new Map();
  var NodeCache = /* @__PURE__ */ new Map();
  var MiddlewareCache = /* @__PURE__ */ new Set();
  var CreateTreeHookCache = /* @__PURE__ */ new Set();
  var CreateNodeHookCache = /* @__PURE__ */ new Set();
  var SyncTreeHookCache = /* @__PURE__ */ new Set();
  var ReleaseHookCache = /* @__PURE__ */ new Set();
  var ParseHookCache = /* @__PURE__ */ new Set();
  var TransitionStateName = EMPTY.OBJ;
  var VTreeAttributes = EMPTY.OBJ;
  var VTree = EMPTY.OBJ;
  var VTreeLike = EMPTY.OBJ;
  var ValidInput = EMPTY.OBJ;
  var ValidNode = EMPTY.OBJ;
  var Mount = EMPTY.OBJ;
  var Middleware = EMPTY.OBJ;
  var ParserConfig = EMPTY.OBJ;
  var TransactionConfig = EMPTY.OBJ;
  var GlobalConfig = EMPTY.OBJ;
  var Supplemental = EMPTY.OBJ;
  var TransactionState = EMPTY.OBJ;
  var Internals = EMPTY.OBJ;

  // node_modules/diffhtml/dist/es/util/process.js
  var process_default = typeof process !== "undefined" ? process : { env: { NODE_ENV: "development" }, argv: [] };

  // node_modules/diffhtml/dist/es/util/global.js
  var global_default = typeof global === "object" ? global : (typeof window === "object" ? window : self) || {};

  // node_modules/diffhtml/dist/es/util/config.js
  var { parseInt: parseInt2 } = Number;
  var { parse: parse2 } = JSON;
  var globalConfig = { collectMetrics: true, executeScripts: true };
  function formatValue(value, type) {
    const valueAsString = String(value);
    switch (type) {
      case "boolean": {
        return valueAsString !== "false";
      }
      case "string": {
        return valueAsString;
      }
      case "number": {
        return parseInt2(valueAsString, 10);
      }
      case "object": {
        return parse2(valueAsString);
      }
    }
  }
  function getConfig(name3, defaultValue, type = typeof defaultValue, overrides) {
    const { location: location2, URLSearchParams: URLSearchParams2 } = global_default;
    const hasSearchParams = typeof URLSearchParams2 !== "undefined";
    const hasLocation = typeof location2 !== "undefined";
    const useSearchParams = hasSearchParams && hasLocation;
    const useEnv = process_default.env;
    if (overrides && name3 in overrides) {
      return overrides[name3];
    }
    const keyName2 = `DIFF_${name3.replace(/[^a-zA-Z0-9]/, "")}`;
    if (useSearchParams) {
      const searchParams = new URLSearchParams2(location2.search);
      const lowerKey = keyName2.toLowerCase();
      if (searchParams.has(lowerKey)) {
        return formatValue(decodeURIComponent(String(searchParams.get(lowerKey))), type);
      }
    }
    const upperKey = keyName2.toUpperCase();
    if (useEnv && upperKey in process_default.env) {
      return formatValue(process_default.env[upperKey.toUpperCase()], type);
    }
    return defaultValue;
  }

  // node_modules/diffhtml/dist/es/util/pool.js
  var size = getConfig("initialPoolSize", 5e3);
  var free = /* @__PURE__ */ new Set();
  var allocate = /* @__PURE__ */ new Set();
  var protect = /* @__PURE__ */ new Set();
  var shape = () => ({ rawNodeName: EMPTY.STR, nodeName: EMPTY.STR, nodeValue: EMPTY.STR, nodeType: NODE_TYPE.ELEMENT, key: EMPTY.STR, childNodes: [], attributes: {} });
  var memory = { free, allocated: allocate, protected: protect };
  var freeValues = free.values();
  var Pool = {
    size,
    memory,
    fill() {
      for (let i2 = free.size; i2 < this.size; i2++) {
        free.add(shape());
      }
      if (this.size < free.size) {
        free.forEach((value) => {
          if (free.size !== this.size) {
            free.delete(value);
          }
        });
      }
    },
    get() {
      const { value = shape(), done } = freeValues.next();
      if (done) {
        freeValues = free.values();
      }
      free.delete(value);
      allocate.add(value);
      return value;
    },
    protect(vTree) {
      allocate.delete(vTree);
      protect.add(vTree);
    },
    unprotect(vTree) {
      if (protect.has(vTree) || allocate.has(vTree)) {
        protect.delete(vTree);
        allocate.delete(vTree);
        free.add(vTree);
      }
    }
  };
  Pool.fill();
  var pool_default = Pool;

  // node_modules/diffhtml/dist/es/tree/create.js
  function ownKeys(object, enumerableOnly) {
    var keys4 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys4.push.apply(keys4, symbols2);
    }
    return keys4;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source2), true).forEach(function(key2) {
        _defineProperty(target, key2, source2[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var { isArray } = Array;
  var { memory: memory2 } = pool_default;
  var fragmentName = "#document-fragment";
  var textName = "#text";
  function flatten(vTrees, retVal = []) {
    for (let i2 = 0; i2 < vTrees.length; i2++) {
      const vTree = vTrees[i2];
      if (vTree && vTree.rawNodeName === fragmentName) {
        flatten(vTree.childNodes, retVal);
      } else if (vTree) {
        retVal.push(vTree);
      }
    }
    return retVal;
  }
  function createTree(input, attributes, childNodes, ...rest) {
    let entry = null;
    if (memory2.protected.has(input) || memory2.allocated.has(input)) {
      entry = input;
    } else if (!input || isArray(input)) {
      const length = input ? input.length : 0;
      childNodes = [];
      for (let i2 = 0; i2 < length; i2++) {
        const hasInput = input && !input[i2];
        if (hasInput)
          continue;
        input && childNodes.push(input[i2]);
      }
      entry = createTree(fragmentName, null, childNodes);
    }
    if (entry) {
      return entry;
    }
    const isObject = typeof input === "object";
    const inputAsHTMLEl = input;
    if (input && isObject && "ownerDocument" in inputAsHTMLEl) {
      const { nodeType } = inputAsHTMLEl;
      if (nodeType === NODE_TYPE.TEXT) {
        const vTree = createTree(textName, inputAsHTMLEl.nodeValue);
        NodeCache.set(vTree, inputAsHTMLEl);
        return vTree;
      }
      attributes = {};
      childNodes = [];
      const inputAttrs = inputAsHTMLEl.attributes;
      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT && inputAttrs && inputAttrs.length) {
        for (let i2 = 0; i2 < inputAttrs.length; i2++) {
          const { name: name3, value } = inputAttrs[i2];
          if (value === EMPTY.STR && name3 in inputAsHTMLEl) {
            attributes[name3] = input[name3];
            continue;
          }
          attributes[name3] = value;
        }
      }
      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT || inputAsHTMLEl.nodeType === NODE_TYPE.FRAGMENT) {
        childNodes = [];
        for (let i2 = 0; i2 < inputAsHTMLEl.childNodes.length; i2++) {
          const childNodeElement = inputAsHTMLEl.childNodes[i2];
          childNodes.push(createTree(childNodeElement));
        }
      }
      NodeCache.forEach((domNode, vTree) => {
        if (domNode === input) {
          entry = vTree;
        }
      });
      entry = entry || createTree(inputAsHTMLEl.nodeName, attributes, childNodes);
      entry.attributes = _objectSpread(_objectSpread({}, entry.attributes), attributes);
      entry.childNodes = childNodes;
      NodeCache.set(entry, inputAsHTMLEl);
      return entry;
    }
    if (isObject) {
      const { rawNodeName, nodeName, nodeValue, attributes: attributes2, childNodes: childNodes2, children } = input;
      const treeName = rawNodeName || nodeName;
      const vTree = createTree(treeName, attributes2 || null, children || childNodes2);
      if (nodeValue) {
        vTree.nodeValue = nodeValue;
      }
      return vTree;
    }
    if (rest.length) {
      childNodes = [childNodes, ...rest];
    }
    entry = pool_default.get();
    const isTextNode = input === textName;
    const isString = typeof input === "string";
    if (isString) {
      entry.rawNodeName = input;
      entry.nodeName = entry.rawNodeName.toLowerCase();
    } else {
      entry.rawNodeName = input;
      entry.nodeName = fragmentName;
    }
    entry.nodeValue = EMPTY.STR;
    entry.key = EMPTY.STR;
    entry.childNodes.length = 0;
    entry.attributes = {};
    const useAttributes = isArray(attributes) || typeof attributes !== "object";
    const useNodes = useAttributes ? attributes : childNodes;
    const allNodes = flatten(isArray(useNodes) ? useNodes : [useNodes]);
    if (isTextNode) {
      const nodeValue = allNodes.join(EMPTY.STR);
      entry.nodeType = NODE_TYPE.TEXT;
      entry.nodeValue = String(nodeValue);
      return entry;
    } else if (entry.nodeName === fragmentName) {
      entry.nodeType = NODE_TYPE.FRAGMENT;
    } else if (input === "#comment") {
      entry.nodeType = NODE_TYPE.COMMENT;
    } else {
      entry.nodeType = NODE_TYPE.ELEMENT;
    }
    if (useNodes && allNodes.length && (!attributes || !attributes.childNodes)) {
      for (let i2 = 0; i2 < allNodes.length; i2++) {
        const newNode = allNodes[i2];
        if (isArray(newNode)) {
          entry.childNodes.push(...newNode);
        } else if (!newNode) {
          continue;
        } else if (newNode.nodeType === NODE_TYPE.FRAGMENT && typeof newNode.rawNodeName === "string") {
          entry.childNodes.push(...newNode.childNodes);
        } else if (newNode && typeof newNode === "object") {
          entry.childNodes.push(createTree(newNode));
        } else {
          entry.childNodes.push(createTree(textName, null, newNode));
        }
      }
    }
    if (attributes && typeof attributes === "object" && !isArray(attributes)) {
      entry.attributes = _objectSpread({}, attributes);
      if (attributes.childNodes) {
        const isObject2 = typeof attributes.childNodes === "object";
        entry.childNodes.push(isObject2 ? createTree(attributes.childNodes) : createTree("#text", attributes.childNodes));
      }
    }
    if (entry.nodeName === "script" && entry.attributes.src) {
      entry.key = String(entry.attributes.src);
    }
    if (entry.attributes && "key" in entry.attributes) {
      entry.key = String(entry.attributes.key);
    }
    if (CreateTreeHookCache.size) {
      CreateTreeHookCache.forEach((fn, retVal) => {
        if (retVal = fn(entry)) {
          entry = createTree(retVal);
        }
      });
    }
    return entry;
  }

  // node_modules/diffhtml/dist/es/util/parse.js
  var TOKEN = "__DIFFHTML__";
  var doctypeEx = /<!DOCTYPE.*>/i;
  var spaceEx = /[^ ]/;
  var tokenEx = new RegExp(`${TOKEN}([^_]*)__`);
  var defaultSupplemental = { tags: [], attributes: {}, children: {} };
  var { assign } = Object;
  var { isArray: isArray2 } = Array;
  var rawElementsDefaults = ["script", "noscript", "style", "template"];
  var selfClosingElementsDefaults = ["source", "embed", "param", "track", "input", "meta", "link", "area", "base", "col", "wbr", "img", "br", "hr"];
  var kElementsClosedByOpening = { li: { li: true }, p: { p: true, div: true }, td: { td: true, th: true }, th: { td: true, th: true } };
  var kElementsClosedByClosing = { li: { ul: true, ol: true }, a: { div: true }, b: { div: true }, i: { div: true }, p: { div: true }, td: { tr: true, table: true }, th: { tr: true, table: true } };
  var interpolateChildNodes = (currentParent, markup, supplemental) => {
    if ("childNodes" in currentParent.attributes) {
      return;
    }
    if (markup && !doctypeEx.test(markup) && !tokenEx.test(markup)) {
      return currentParent.childNodes.push(createTree("#text", markup));
    }
    const childNodes = [];
    const parts = markup.split(tokenEx);
    for (let i2 = 0; i2 < parts.length; i2++) {
      const value = parts[i2];
      if (!value) {
        continue;
      }
      if (i2 % 2 === 1) {
        const supValue = supplemental.children[value];
        const innerTree = value in supplemental.children ? supValue : createTree("#text", `${TOKEN}${value}__`);
        if (!innerTree)
          continue;
        const isFragment = innerTree.nodeType === NODE_TYPE.FRAGMENT;
        if (typeof innerTree.rawNodeName === "string" && isFragment) {
          childNodes.push(...innerTree.childNodes);
        } else {
          childNodes.push(innerTree);
        }
      } else if (!doctypeEx.test(value)) {
        childNodes.push(createTree("#text", value));
      }
    }
    currentParent.childNodes.push(...childNodes);
  };
  var HTMLElement = (nodeName, rawAttrs, supplemental, options2) => {
    let match = null;
    const attrEx = /([_@$#a-z][^\s\x00-\x1F"'>\/=\uFDD0-\uFDEF\uFFFE\uFFFF]*)\s*(=\s*("([^"]+)"|'([^']+)'|(\S+)))?/ig;
    if (match = tokenEx.exec(nodeName)) {
      return HTMLElement(supplemental.tags[match[1]], rawAttrs, supplemental, options2);
    }
    const attributes = {};
    for (let match2; match2 = attrEx.exec(rawAttrs || EMPTY.STR); ) {
      const isHTML = typeof nodeName === "string";
      const name3 = match2[1];
      let tokenValue;
      if (name3 === "") {
        const match3 = rawAttrs.match(tokenEx);
        tokenValue = match3 ? match3[0] : "";
      }
      const testValue = match2[6] || match2[5] || match2[4];
      const rawValue = tokenValue || testValue || (isHTML ? match2[1] : testValue || true);
      const value = rawValue === `''` || rawValue === `""` ? EMPTY.STR : rawValue;
      let valueMatchesToken = String(value).match(tokenEx);
      if (valueMatchesToken && valueMatchesToken.length) {
        const parts = String(value).split(tokenEx);
        const hasToken = tokenEx.exec(name3);
        const newName = hasToken ? supplemental.attributes[hasToken[1]] : name3;
        for (let i2 = 0; i2 < parts.length; i2++) {
          const value2 = parts[i2];
          if (!value2) {
            continue;
          }
          if (i2 % 2 === 1) {
            const isObject = typeof newName === "object";
            const hasSupValue = value2 in supplemental.attributes;
            const supValue = supplemental.attributes[value2];
            const fallback = `${TOKEN}${value2}__`;
            if (attributes[newName]) {
              attributes[newName] += hasSupValue ? supValue : fallback;
            } else if (isObject) {
              if (newName && !isArray2(newName)) {
                assign(attributes, newName);
              } else {
                if (process_default.env.NODE_ENV !== "production") {
                  throw new Error("Arrays cannot be spread as attributes");
                }
              }
            } else if (newName) {
              const defaultValue = hasSupValue ? supValue : fallback;
              attributes[newName] = testValue ? defaultValue : true;
            }
          } else if (attributes[newName]) {
            attributes[newName] += value2;
          } else {
            attributes[newName] = value2;
          }
        }
      } else if (valueMatchesToken = tokenEx.exec(name3)) {
        const nameAndValue = supplemental.attributes[valueMatchesToken[1]];
        if (typeof nameAndValue === "object" && !isArray2(nameAndValue)) {
          assign(attributes, nameAndValue);
        } else {
          attributes[nameAndValue] = value;
        }
      } else {
        attributes[name3] = testValue !== void 0 ? value : true;
      }
    }
    return createTree(nodeName, attributes, attributes.childNodes || []);
  };
  function parse3(html, supplemental, options2 = {}) {
    if (!options2.parser) {
      options2.parser = {};
    }
    if (!supplemental) {
      supplemental = defaultSupplemental;
    }
    const blockText = new Set(getConfig("rawElements", rawElementsDefaults, "array", options2.parser));
    const selfClosing = new Set(getConfig("selfClosingElements", selfClosingElementsDefaults, "array", options2.parser));
    const tagEx = /<!--[^]*?(?=-->)-->|<(\/?)([a-z\-\_][a-z0-9\-\_]*)\s*([^>]*?)(".*?"|'.*?')?(\/?)>/ig;
    const root = createTree("#document-fragment", null, []);
    const stack = [root];
    let currentParent = root;
    let lastTextPos = -1;
    if (process_default.env.NODE_ENV !== "production") {
      const markup = [html];
      if (!html.includes("<") && options2.parser.strict) {
        markup.splice(1, 0, `
Possibly invalid markup. Opening tag was not properly opened.
      `);
        throw new Error(`

${markup.join("\n")}`);
      }
      if (!html.includes(">") && options2.parser.strict) {
        markup.splice(1, 0, `
Possibly invalid markup. Opening tag was not properly closed.
      `);
        throw new Error(`

${markup.join("\n")}`);
      }
    }
    if (!html.includes("<") && html) {
      interpolateChildNodes(currentParent, html, supplemental);
      return root;
    }
    for (let match, text, i2 = 0; match = tagEx.exec(html); i2++) {
      const [fullMatch, isClosingMatch, tagMatch, attributeMatch, extraMatch, selfClosingMatch] = match;
      if (lastTextPos > -1) {
        if (lastTextPos + fullMatch.length < tagEx.lastIndex) {
          text = html.slice(lastTextPos, tagEx.lastIndex - fullMatch.length);
          if (text) {
            interpolateChildNodes(currentParent, text, supplemental);
          }
        }
      }
      const matchOffset = tagEx.lastIndex - fullMatch.length;
      if (lastTextPos === -1 && matchOffset > 0) {
        const string2 = html.slice(0, matchOffset);
        if (string2 && !doctypeEx.exec(string2)) {
          interpolateChildNodes(currentParent, string2, supplemental);
        }
      }
      lastTextPos = tagEx.lastIndex;
      if (match[0][1] === "!") {
        continue;
      }
      const tokenMatch = tokenEx.exec(tagMatch);
      const supTag = tokenMatch && supplemental.tags[tokenMatch[1]];
      const name3 = supTag ? supTag.name || supTag : tagMatch;
      let bypassMatch;
      if (!isClosingMatch) {
        if (!match[4] && kElementsClosedByOpening[currentParent.rawNodeName]) {
          if (kElementsClosedByOpening[currentParent.rawNodeName][name3]) {
            stack.pop();
            currentParent = stack[stack.length - 1];
          }
        }
        const attrs = attributeMatch + (extraMatch || "");
        currentParent = currentParent.childNodes[currentParent.childNodes.push(HTMLElement(tagMatch, attrs, supplemental, options2)) - 1];
        stack.push(currentParent);
        if (options2.parser.strict || blockText.has(name3)) {
          const closeMarkup = `</${name3}>`;
          const index = html.indexOf(closeMarkup, tagEx.lastIndex);
          if (process_default.env.NODE_ENV !== "production") {
            if (index === -1 && options2.parser.strict && !selfClosing.has(name3)) {
              const markup = html.slice(tagEx.lastIndex - fullMatch.length).split("\n").map((line) => line.replace(tokenEx, (value, index2) => {
                if (!supplemental) {
                  return value;
                }
                const { tags: tags2, children, attributes } = supplemental;
                return tags2[index2] || children[index2] || attributes[index2];
              })).slice(0, 3);
              const lookup = spaceEx.exec(markup[0]);
              const caret = Array((lookup ? lookup.index - 1 : 0) + closeMarkup.length - 1).join(" ") + "^";
              markup.splice(1, 0, `${caret}
    Possibly invalid markup. <${name3}> must be closed in strict mode.
            `);
              throw new Error(`

${markup.join("\n")}`);
            }
          }
          if (blockText.has(name3)) {
            if (index === -1) {
              lastTextPos = tagEx.lastIndex = html.length + 1;
            } else {
              lastTextPos = index + closeMarkup.length;
              tagEx.lastIndex = lastTextPos;
              bypassMatch = true;
            }
            const newText = html.slice(match.index + fullMatch.length, index);
            interpolateChildNodes(currentParent, newText, supplemental);
          }
        }
      }
      if (bypassMatch || isClosingMatch || selfClosingMatch || selfClosing.has(name3)) {
        if (process_default.env.NODE_ENV !== "production") {
          if (currentParent && name3 !== currentParent.rawNodeName && options2.parser.strict) {
            const nodeName = currentParent.rawNodeName;
            const markup = html.slice(tagEx.lastIndex - fullMatch.length).split("\n").map((line) => line.replace(tokenEx, (value, index) => {
              if (!supplemental) {
                return value;
              }
              const { tags: tags2, children, attributes } = supplemental;
              return tags2[index] || children[index] || attributes[index];
            })).slice(0, 3);
            const lookup = spaceEx.exec(markup[0]);
            const caret = Array(lookup ? lookup.index : 0).join(" ") + "^";
            markup.splice(1, 0, `${caret}
  Possibly invalid markup. Saw ${name3}, expected ${nodeName}...
          `);
            throw new Error(`

${markup.join("\n")}`);
          }
        }
        while (currentParent) {
          if (selfClosingMatch === "/" && tokenMatch) {
            stack.pop();
            currentParent = stack[stack.length - 1];
            break;
          } else if (supTag) {
            if (currentParent.rawNodeName === name3) {
              stack.pop();
              currentParent = stack[stack.length - 1];
              break;
            }
          }
          if (currentParent.rawNodeName === name3) {
            stack.pop();
            currentParent = stack[stack.length - 1];
            break;
          } else {
            const tag = kElementsClosedByClosing[currentParent.rawNodeName];
            if (tag) {
              if (tag[name3]) {
                stack.pop();
                currentParent = stack[stack.length - 1];
                continue;
              }
            }
            break;
          }
        }
      }
    }
    const remainingText = html.slice(lastTextPos === -1 ? 0 : lastTextPos);
    if (process_default.env.NODE_ENV !== "production") {
      if ((remainingText.includes(">") || remainingText.includes("<")) && options2.parser.strict) {
        const markup = [remainingText];
        const lookup = spaceEx.exec(markup[0]);
        const caret = Array(lookup ? lookup.index : 0).join(" ") + "^";
        if (remainingText.includes(">")) {
          markup.splice(1, 0, `${caret}
  Possibly invalid markup. Opening tag was not properly opened.
        `);
        } else {
          markup.splice(1, 0, `${caret}
  Possibly invalid markup. Opening tag was not properly closed.
        `);
        }
        throw new Error(`

${markup.join("\n")}`);
      }
    }
    if (remainingText) {
      interpolateChildNodes(currentParent, remainingText, supplemental);
    }
    if (root.childNodes.length && root.childNodes[0].nodeName === "html") {
      const head = { before: [], after: [] };
      const body = { after: [] };
      const HTML = root.childNodes[0];
      let beforeHead = true;
      let beforeBody = true;
      HTML.childNodes = HTML.childNodes.filter((el) => {
        if (el.nodeName === "body" || el.nodeName === "head") {
          if (el.nodeName === "head")
            beforeHead = false;
          if (el.nodeName === "body")
            beforeBody = false;
          return true;
        } else if (el.nodeType === NODE_TYPE.ELEMENT) {
          if (beforeHead && beforeBody)
            head.before.push(el);
          else if (!beforeHead && beforeBody)
            head.after.push(el);
          else if (!beforeBody)
            body.after.push(el);
        }
      });
      if (!HTML.childNodes[0] || HTML.childNodes[0].nodeName !== "head") {
        const headInstance = createTree("head", null, []);
        if (headInstance) {
          const existing = headInstance.childNodes;
          existing.unshift.apply(existing, head.before);
          existing.push.apply(existing, head.after);
          HTML.childNodes.unshift(headInstance);
        }
      } else {
        const existing = HTML.childNodes[0].childNodes;
        existing.unshift.apply(existing, head.before);
        existing.push.apply(existing, head.after);
      }
      if (!HTML.childNodes[1] || HTML.childNodes[1].nodeName !== "body") {
        const bodyInstance = createTree("body", null, []);
        if (bodyInstance) {
          const existing = bodyInstance.childNodes;
          existing.push.apply(existing, body.after);
          HTML.childNodes.push(bodyInstance);
        }
      } else {
        const existing = HTML.childNodes[1].childNodes;
        existing.push.apply(existing, body.after);
      }
    }
    return root;
  }

  // node_modules/diffhtml/dist/es/util/make-measure.js
  var prefix = "diffHTML";
  var marks = /* @__PURE__ */ new Map();
  var count = 0;
  function makeMeasure(transaction) {
    const { mount, input } = transaction;
    const inputAsVTree = input;
    const id2 = count++;
    if (!getConfig("collectMetrics", false)) {
      return EMPTY.FUN;
    }
    return (name3) => {
      name3 = `[${id2}] ${name3}`;
      const { host } = mount;
      if (mount && host) {
        name3 = `${host.constructor.name} ${name3}`;
      } else if (inputAsVTree && typeof inputAsVTree.rawNodeName === "function") {
        name3 = `${inputAsVTree.rawNodeName.name} ${name3}`;
      }
      const endName = `${name3}-end`;
      if (marks.has(name3)) {
        const prevMark = marks.get(name3) || 0;
        const totalMs = (performance.now() - prevMark).toFixed(3);
        marks.delete(name3);
        performance.mark(endName);
        performance.measure(`${prefix} ${name3} (${totalMs}ms)`, name3, endName);
      } else {
        marks.set(name3, performance.now());
        performance.mark(name3);
      }
    };
  }

  // node_modules/diffhtml/dist/es/util/memory.js
  var memory_exports = {};
  __export(memory_exports, {
    gc: () => gc,
    protectVTree: () => protectVTree,
    unprotectVTree: () => unprotectVTree
  });
  var { protect: protect2, unprotect, memory: memory3 } = pool_default;
  function protectVTree(vTree) {
    protect2(vTree);
    if (vTree.childNodes.length) {
      for (let i2 = 0; i2 < vTree.childNodes.length; i2++) {
        protectVTree(vTree.childNodes[i2]);
      }
    }
  }
  function unprotectVTree(vTree) {
    if (vTree.childNodes.length) {
      for (let i2 = 0; i2 < vTree.childNodes.length; i2++) {
        unprotectVTree(vTree.childNodes[i2]);
      }
    }
    NodeCache.delete(vTree);
    unprotect(vTree);
  }
  function gc() {
    memory3.allocated.forEach((vTree) => {
      vTree.attributes = {};
      vTree.childNodes.length = 0;
      memory3.free.add(vTree);
      memory3.allocated.delete(vTree);
      NodeCache.delete(vTree);
    });
  }

  // node_modules/diffhtml/dist/es/tasks/schedule.js
  function schedule(transaction) {
    let { state: state3, state: { isRendering } } = transaction;
    state3.measure("schedule");
    StateCache.forEach((val) => {
      const oldMount = val.activeTransaction && val.activeTransaction.mount;
      const newMount = transaction.mount;
      if (!oldMount || !newMount || !val.isRendering) {
        return;
      } else if (oldMount.contains && oldMount.contains(newMount) || newMount.contains && newMount.contains(oldMount)) {
        state3 = val;
        isRendering = true;
      } else if (oldMount === newMount) {
        state3 = val;
        isRendering = true;
      }
    });
    const { activeTransaction, nextTransaction } = state3;
    if (isRendering) {
      const { tasks: tasks2 } = transaction;
      state3.nextTransaction = transaction;
      transaction.abort();
      const promise = nextTransaction && nextTransaction.promise || activeTransaction.promise || Promise.resolve();
      return transaction.promise = promise.then(() => {
        transaction.aborted = false;
        transaction.state.isRendering = true;
        transaction.state.activeTransaction = transaction;
        state3.measure("schedule");
        return Transaction.flow(transaction, tasks2.slice(1));
      });
    }
    state3.isRendering = true;
    state3.activeTransaction = transaction;
    state3.measure("schedule");
  }

  // node_modules/diffhtml/dist/es/tasks/should-update.js
  function shouldUpdate(transaction) {
    const { mount, input, state: { measure }, config: options2 } = transaction;
    const prop = options2.inner ? "innerHTML" : "outerHTML";
    measure("should update");
    const mountAsHTMLEl = mount;
    if (typeof input === "string" && mountAsHTMLEl[prop] === input) {
      return transaction.abort(true);
    }
    measure("should update");
  }

  // node_modules/diffhtml/dist/es/release.js
  var hasIdle = typeof requestIdleCallback !== "undefined";
  var gcTimerId = -1;
  var scheduleTimeout = (fn) => (hasIdle ? requestIdleCallback : setTimeout)(fn);
  var cancelTimeout = (id2) => (hasIdle ? cancelIdleCallback : clearTimeout)(id2);
  function release(mount) {
    if (StateCache.has(mount)) {
      const { mutationObserver, oldTree } = StateCache.get(mount);
      mutationObserver && mutationObserver.disconnect();
      if (oldTree && !NodeCache.has(oldTree)) {
        ReleaseHookCache.forEach((fn) => fn(oldTree));
        unprotectVTree(oldTree);
      }
      StateCache.delete(mount);
    }
    if (!mount) {
      return;
    }
    const asHTMLElement = mount;
    if (asHTMLElement.childNodes && asHTMLElement.childNodes.length) {
      for (let i2 = 0; i2 < asHTMLElement.childNodes.length; i2++) {
        release(asHTMLElement.childNodes[i2]);
      }
    }
    if (asHTMLElement.shadowRoot) {
      release(asHTMLElement.shadowRoot);
    }
    NodeCache.forEach((domNode, vTree) => {
      if (domNode === asHTMLElement) {
        ReleaseHookCache.forEach((fn) => fn(vTree));
        unprotectVTree(vTree);
      }
    });
    cancelTimeout(gcTimerId);
    gcTimerId = scheduleTimeout(gc);
  }

  // node_modules/diffhtml/dist/es/tasks/reconcile-trees.js
  function reconcileTrees(transaction) {
    const { state: state3, mount, input, config: options2 } = transaction;
    const { inner } = options2;
    const mountAsHTMLEl = mount;
    if (state3.mutationObserver && !state3.isDirty) {
      state3.isDirty = Boolean(state3.mutationObserver.takeRecords().length);
    } else if (!state3.mutationObserver) {
      state3.isDirty = false;
    }
    if (state3.isDirty || !state3.oldTree) {
      release(mountAsHTMLEl);
      if (mountAsHTMLEl.ownerDocument && state3.mutationObserver) {
        state3.mutationObserver.observe(mountAsHTMLEl, { subtree: true, childList: true, attributes: true, characterData: true });
      }
      state3.oldTree = createTree(mountAsHTMLEl);
      protectVTree(state3.oldTree);
      StateCache.set(mount, state3);
    }
    const { nodeName, attributes } = state3.oldTree;
    if (!transaction.newTree) {
      transaction.newTree = createTree(input);
    }
    const inputAsVTree = transaction.newTree;
    if (!inner && inputAsVTree.nodeType === NODE_TYPE.FRAGMENT && state3.oldTree.nodeType !== NODE_TYPE.FRAGMENT) {
      let foundElements = [];
      for (let i2 = 0; i2 < inputAsVTree.childNodes.length; i2++) {
        const value = inputAsVTree.childNodes[i2];
        const isText = value.nodeType === NODE_TYPE.TEXT;
        if (!isText || value.nodeValue.trim()) {
          foundElements.push(value);
        }
      }
      if (foundElements.length === 1) {
        transaction.newTree = foundElements[0];
      } else if (foundElements.length > 1) {
        transaction.newTree = createTree(inputAsVTree.childNodes);
      }
    }
    transaction.oldTree = state3.oldTree;
    const { oldTree, newTree } = transaction;
    if (inner && oldTree && newTree) {
      const isUnknown = typeof newTree.rawNodeName !== "string";
      const isFragment = newTree.nodeType === NODE_TYPE.FRAGMENT;
      const children = isFragment && !isUnknown ? newTree.childNodes : newTree;
      transaction.newTree = createTree(nodeName, attributes, children);
    }
  }

  // node_modules/diffhtml/dist/es/tree/sync.js
  var { max } = Math;
  var keyNames = ["old", "new"];
  var textName2 = "#text";
  function syncTree(oldTree, newTree, patches = [], state3 = {}, transaction = EMPTY.OBJ, attributesOnly) {
    if (!oldTree)
      oldTree = EMPTY.OBJ;
    if (!newTree)
      newTree = EMPTY.OBJ;
    const { svgElements = /* @__PURE__ */ new Set() } = state3;
    const oldNodeName = oldTree.nodeName;
    const newNodeName = newTree.nodeName;
    const isEmpty = oldTree === EMPTY.OBJ || attributesOnly;
    const isSVG = newNodeName === "svg" || svgElements.has(newTree);
    let shortCircuit = null;
    if (SyncTreeHookCache.size) {
      SyncTreeHookCache.forEach((fn) => {
        const entry = fn(oldTree, newTree, transaction);
        if (entry && entry === oldTree) {
          shortCircuit = patches;
        } else if (entry === false) {
          shortCircuit = false;
        } else if (entry) {
          newTree = entry;
        }
      });
    }
    if (shortCircuit !== null || !newTree) {
      return shortCircuit;
    }
    if (newNodeName === textName2) {
      if (oldNodeName === textName2 && oldTree.nodeValue !== newTree.nodeValue) {
        patches.push(PATCH_TYPE.NODE_VALUE, oldTree, newTree.nodeValue, oldTree.nodeValue);
        oldTree.nodeValue = newTree.nodeValue;
        return patches;
      } else if (isEmpty) {
        patches.push(PATCH_TYPE.NODE_VALUE, newTree, newTree.nodeValue, null);
        return patches;
      }
    }
    const newChildNodes = newTree.childNodes || [];
    if (newTree.nodeType === NODE_TYPE.ELEMENT) {
      const oldAttributes = isEmpty ? EMPTY.OBJ : oldTree.attributes;
      const newAttributes = newTree.attributes || {};
      for (let key2 in newAttributes) {
        const value = newAttributes[key2];
        if (key2 in oldAttributes && oldAttributes[key2] === newAttributes[key2]) {
          continue;
        }
        if (!isEmpty) {
          oldAttributes[key2] = value;
        }
        if ((!oldTree || oldTree.nodeName !== "script") && newTree.nodeName === "script" && key2 === "type") {
          continue;
        }
        patches.push(PATCH_TYPE.SET_ATTRIBUTE, isEmpty ? newTree : oldTree, key2, value);
      }
      if (!isEmpty) {
        for (let key2 in oldAttributes) {
          if (key2 in newAttributes) {
            continue;
          }
          patches.push(PATCH_TYPE.REMOVE_ATTRIBUTE, oldTree, key2);
          delete oldAttributes[key2];
        }
      }
    }
    if (attributesOnly) {
      for (let i2 = 0; i2 < newChildNodes.length; i2++) {
        isSVG && svgElements.add(newChildNodes[i2]);
        syncTree(null, newChildNodes[i2], patches, state3, transaction, true);
      }
      return patches;
    }
    const keysLookup = { old: /* @__PURE__ */ new Map(), new: /* @__PURE__ */ new Map() };
    for (let i2 = 0; i2 < keyNames.length; i2++) {
      const keyName2 = keyNames[i2];
      const map = keysLookup[keyName2];
      const vTree = arguments[i2];
      const nodes = vTree && vTree.childNodes;
      if (nodes && nodes.length) {
        for (let i3 = 0; i3 < nodes.length; i3++) {
          const vTree2 = nodes[i3];
          if (vTree2.key) {
            if (process_default.env.NODE_ENV !== "production") {
              if (map.has(vTree2.key)) {
                throw new Error(`Key: ${vTree2.key} cannot be duplicated`);
              }
            }
            map.set(vTree2.key, vTree2);
          }
        }
      }
    }
    const oldChildNodes = oldTree.childNodes || [];
    let maxLength = max(newChildNodes.length, oldChildNodes.length);
    for (let i2 = 0; i2 < maxLength; i2++) {
      const oldChildNode = oldChildNodes && oldChildNodes[i2];
      const newChildNode = newChildNodes[i2];
      if (isSVG || newChildNode && newChildNode.nodeName === "svg") {
        svgElements.add(newChildNode);
      }
      if (!newChildNode) {
        if (syncTree(oldChildNode, null, patches, state3, transaction, true) === false) {
          newChildNodes.splice(i2, 0, oldChildNode);
        }
        continue;
      }
      if (!oldChildNode) {
        oldChildNodes.push(newChildNode);
        syncTree(null, newChildNode, patches, state3, transaction, true);
        patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, newChildNode, null);
        continue;
      }
      const newKey = newChildNode.key;
      const oldKey = oldChildNode.key;
      const oldInNew = keysLookup.new.has(oldKey);
      const newInOld = keysLookup.old.has(newKey);
      if (oldKey || newKey) {
        if (!oldInNew && !newInOld) {
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1, newChildNode);
          syncTree(null, newChildNode, patches, state3, transaction, true);
          patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
          i2 = i2 - 1;
          continue;
        } else if (!oldInNew) {
          patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNode);
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1);
          i2 = i2 - 1;
          continue;
        }
        if (newKey !== oldKey) {
          let optimalNewNode = newChildNode;
          if (newKey && newInOld) {
            optimalNewNode = keysLookup.old.get(newKey);
            oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode), 1);
          } else {
            optimalNewNode = newChildNode;
          }
          syncTree(null, optimalNewNode, patches, state3, transaction, true);
          patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, optimalNewNode, oldChildNode);
          oldChildNodes.splice(i2, 0, optimalNewNode);
          continue;
        }
      }
      const sameType = oldChildNode.nodeName === newChildNode.nodeName;
      const retVal = syncTree(oldChildNode, newChildNode, patches, state3, transaction, !sameType);
      if (retVal === false) {
        newChildNodes.splice(i2, 0, oldChildNode);
        maxLength += 1;
        continue;
      }
      if (!sameType) {
        oldChildNodes[i2] = newChildNode;
        const lookupIndex = oldChildNodes.lastIndexOf(newChildNode);
        if (lookupIndex > i2) {
          oldChildNodes.splice(lookupIndex, 1);
        }
        patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
      }
    }
    if (oldChildNodes.length !== newChildNodes.length) {
      for (let i2 = newChildNodes.length; i2 < oldChildNodes.length; i2++) {
        patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNodes[i2]);
      }
      oldChildNodes.length = newChildNodes.length;
    }
    return patches;
  }

  // node_modules/diffhtml/dist/es/node/create.js
  var namespace = "http://www.w3.org/2000/svg";
  function createNode(vTreeLike, ownerDocument = global_default.document, isSVG) {
    if (process_default.env.NODE_ENV !== "production") {
      if (!vTreeLike) {
        throw new Error("Missing VTree when trying to create DOM Node");
      }
    }
    const vTree = createTree(vTreeLike);
    const existingNode = NodeCache.get(vTree);
    if (existingNode) {
      return existingNode;
    }
    const { nodeName, rawNodeName = nodeName, childNodes = [] } = vTree;
    isSVG = isSVG || nodeName === "svg";
    let domNodeCheck = null;
    let retVal = null;
    CreateNodeHookCache.forEach((fn) => {
      if (retVal = fn(vTree)) {
        domNodeCheck = retVal;
      }
    });
    if (!ownerDocument) {
      return domNodeCheck;
    }
    let domNode = domNodeCheck;
    if (!domNode) {
      if (nodeName === "#text") {
        domNode = ownerDocument.createTextNode(vTree.nodeValue || EMPTY.STR);
      } else if (nodeName === "#document-fragment") {
        domNode = ownerDocument.createDocumentFragment();
      } else if (isSVG) {
        domNode = ownerDocument.createElementNS(namespace, rawNodeName);
      } else {
        domNode = ownerDocument.createElement(rawNodeName);
      }
      if (nodeName === "script") {
        domNode.type = "no-execute";
      }
    }
    NodeCache.set(vTree, domNode);
    for (let i2 = 0; i2 < childNodes.length; i2++) {
      const validChildNode = createNode(childNodes[i2], ownerDocument, isSVG);
      if (domNode && validChildNode) {
        domNode.appendChild(validChildNode);
      }
    }
    return domNode;
  }

  // node_modules/diffhtml/dist/es/tasks/sync-trees.js
  function syncTrees(transaction) {
    const { state: state3, state: { measure }, oldTree, newTree, mount } = transaction;
    measure("sync trees");
    if (process_default.env.NODE_ENV !== "production") {
      if (!oldTree) {
        throw new Error("Missing old tree during synchronization");
      }
      if (!newTree) {
        throw new Error("Missing new tree during synchronization");
      }
    }
    if (oldTree && newTree && oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== NODE_TYPE.FRAGMENT) {
      if (process_default.env.NODE_ENV !== "production") {
        if (!mount.parentNode) {
          throw new Error("Unable to replace top level node without a parent");
        }
      }
      transaction.patches = [PATCH_TYPE.REPLACE_CHILD, newTree, oldTree];
      transaction.oldTree = state3.oldTree = newTree;
      const newNode = createNode(newTree);
      StateCache.delete(mount);
      StateCache.set(newNode, state3);
      transaction.mount = newNode;
      if (newTree.nodeName === "script") {
        state3.scriptsToExecute.set(newTree, newTree.attributes.type || EMPTY.STR);
      }
    } else {
      transaction.patches = syncTree(oldTree || null, newTree || null, [], state3, transaction);
    }
    measure("sync trees");
  }

  // node_modules/diffhtml/dist/es/transition.js
  function addTransitionState(stateName, callback) {
    if (process_default.env.NODE_ENV !== "production") {
      if (!TransitionStateNames.includes(stateName)) {
        throw new Error(`Invalid state name '${stateName}'`);
      }
      if (!callback) {
        throw new Error("Missing transition state callback");
      }
    }
    TransitionCache.get(stateName)?.add(callback);
  }
  function removeTransitionState(stateName, callback) {
    if (process_default.env.NODE_ENV !== "production") {
      if (stateName && !TransitionStateNames.includes(stateName)) {
        throw new Error(`Invalid state name '${stateName}'`);
      }
    }
    if (!callback && stateName) {
      TransitionCache.get(stateName)?.clear();
    } else if (stateName && callback) {
      TransitionCache.get(stateName)?.delete(callback);
    } else {
      for (let i2 = 0; i2 < TransitionStateNames.length; i2++) {
        TransitionCache.get(TransitionStateNames[i2])?.clear();
      }
    }
  }
  function runTransitions(setName, ...args) {
    const set2 = TransitionCache.get(setName);
    const promises = [];
    if (!set2) {
      return promises;
    }
    const vTree = args[0];
    const isElement = vTree.nodeType === NODE_TYPE.ELEMENT;
    if (!set2.size || setName !== "textChanged" && !isElement) {
      return promises;
    }
    set2.forEach((callback) => {
      const nodes = args.map((x) => NodeCache.get(x) || x);
      const retVal = callback(...nodes);
      if (typeof retVal === "object" && retVal.then) {
        promises.push(retVal);
      }
    });
    if (setName === "attached" || setName === "detached") {
      vTree.childNodes.forEach((childTree) => {
        promises.push(...runTransitions(setName, childTree, ...args.slice(1)));
      });
    }
    return promises;
  }

  // node_modules/diffhtml/dist/es/util/decode-entities.js
  var element = global_default.document ? document.createElement("div") : null;
  function decodeEntities(string2) {
    if (!element || !string2 || !string2.indexOf || !string2.includes("&")) {
      return string2;
    }
    element.innerHTML = string2;
    return element.textContent || EMPTY.STR;
  }

  // node_modules/diffhtml/dist/es/util/symbols.js
  var $$strict = Symbol.for("diff.strict");
  var $$insertAfter = Symbol.for("diff.after");
  var $$diffHTML = Symbol.for("diffHTML");

  // node_modules/diffhtml/dist/es/node/patch.js
  var { keys } = Object;
  var blocklist = /* @__PURE__ */ new Set();
  var allowlist = /* @__PURE__ */ new Set();
  var setAttribute = (vTree, domNode, name3, value) => {
    const isObject = typeof value === "object" && value;
    const isFunction = typeof value === "function";
    const isSymbol = typeof value === "symbol";
    const isEvent = name3.indexOf("on") === 0;
    const anyNode = domNode;
    const lowerName = isEvent ? name3.toLowerCase() : name3;
    const blocklistName = "s-" + vTree.nodeName + "-" + lowerName;
    const htmlElement = domNode;
    if (allowlist.has(blocklistName)) {
      anyNode[lowerName] = value;
    } else if (!blocklist.has(blocklistName)) {
      try {
        anyNode[lowerName] = value;
        allowlist.add(blocklistName);
      } catch {
        blocklist.add(blocklistName);
      }
    }
    if (!isObject && !isFunction && !isSymbol) {
      const emptyValue = value === null || value === void 0 || value === true;
      htmlElement.setAttribute(lowerName, emptyValue ? EMPTY.STR : value);
    } else if (isObject && lowerName === "style") {
      const valueKeys = keys(value);
      for (let i2 = 0; i2 < valueKeys.length; i2++) {
        htmlElement.style[valueKeys[i2]] = value[valueKeys[i2]];
      }
    }
  };
  var removeAttribute = (vTree, domNode, name3) => {
    const blocklistName = "r-" + vTree.nodeName + "-" + name3;
    const anyNode = domNode;
    if (allowlist.has(blocklistName)) {
      anyNode[name3] = void 0;
      delete anyNode[name3];
    } else if (!blocklist.has(blocklistName)) {
      try {
        anyNode[name3] = void 0;
        delete anyNode[name3];
        allowlist.add(blocklistName);
      } catch {
        blocklist.add(blocklistName);
      }
    }
    domNode.removeAttribute(name3);
  };
  var changeNodeValue = (domNode, nodeValue) => {
    const htmlElement = domNode;
    if (nodeValue.includes("&")) {
      htmlElement.nodeValue = decodeEntities(nodeValue);
    } else {
      htmlElement.nodeValue = nodeValue;
    }
  };
  function patchNode(patches, state3 = EMPTY.OBJ) {
    const promises = [];
    const { ownerDocument, svgElements = /* @__PURE__ */ new Set() } = state3;
    const { length } = patches;
    let i2 = 0;
    while (true) {
      const patchType = patches[i2];
      if (i2 === length) {
        break;
      }
      switch (patchType) {
        case PATCH_TYPE.REMOVE_ATTRIBUTE:
        case PATCH_TYPE.SET_ATTRIBUTE: {
          const isSet = patchType === PATCH_TYPE.SET_ATTRIBUTE;
          const vTree = patches[i2 + 1];
          const name3 = patches[i2 + 2];
          const value = isSet ? decodeEntities(patches[i2 + 3]) : null;
          i2 += isSet ? 4 : 3;
          const isSVG = svgElements.has(vTree);
          const domNode = createNode(vTree, ownerDocument, isSVG);
          const oldValue = domNode.getAttribute(name3);
          const attributeChangedPromises = runTransitions("attributeChanged", vTree, name3, oldValue, value);
          protectVTree(vTree);
          const setOrRemove = isSet ? setAttribute : removeAttribute;
          if (attributeChangedPromises.length) {
            Promise.all(attributeChangedPromises).then(() => setOrRemove(vTree, domNode, name3, value));
            promises.push(...attributeChangedPromises);
          } else {
            setOrRemove(vTree, domNode, name3, value);
          }
          break;
        }
        case PATCH_TYPE.NODE_VALUE: {
          const vTree = patches[i2 + 1];
          const nodeValue = patches[i2 + 2];
          const oldValue = patches[i2 + 3];
          const isSVG = svgElements.has(vTree);
          i2 += 4;
          const domNode = createNode(vTree, ownerDocument, isSVG);
          protectVTree(vTree);
          const textChangedPromises = runTransitions("textChanged", vTree, oldValue, nodeValue);
          if (textChangedPromises.length) {
            Promise.all(textChangedPromises).then(() => changeNodeValue(domNode, nodeValue));
            promises.push(...textChangedPromises);
          } else {
            changeNodeValue(domNode, nodeValue);
          }
          break;
        }
        case PATCH_TYPE.INSERT_BEFORE: {
          const vTree = patches[i2 + 1];
          const newTree = patches[i2 + 2];
          let refTree = patches[i2 + 3];
          i2 += 4;
          if (!NodeCache.has(vTree) && vTree !== $$insertAfter) {
            continue;
          }
          let domNode = NodeCache.get(vTree);
          if (vTree === $$insertAfter) {
            const refNode2 = NodeCache.get(refTree);
            if (refNode2) {
              domNode = refNode2.parentNode;
              refTree = refNode2.nextSibling ? refNode2.nextSibling : null;
            }
          }
          const isSVG = svgElements.has(newTree);
          protectVTree(newTree);
          const refNode = refTree && createNode(refTree, ownerDocument, isSVG);
          const newNode = createNode(newTree, ownerDocument, isSVG);
          domNode.insertBefore(newNode, refNode || null);
          promises.push(...runTransitions("attached", newTree));
          break;
        }
        case PATCH_TYPE.REPLACE_CHILD: {
          const newTree = patches[i2 + 1];
          const oldTree = patches[i2 + 2];
          i2 += 3;
          const isSVG = svgElements.has(newTree);
          const oldDomNode = NodeCache.get(oldTree);
          const newDomNode = createNode(newTree, ownerDocument, isSVG);
          if (!oldDomNode || !oldDomNode.parentNode) {
            break;
          }
          protectVTree(newTree);
          const hasAttached = TransitionCache.get("attached")?.size;
          const hasDetached = TransitionCache.get("detached")?.size;
          const hasReplaced = TransitionCache.get("replaced")?.size;
          if (!hasAttached && !hasDetached && !hasReplaced) {
            oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
            unprotectVTree(oldTree);
            break;
          }
          oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
          const allPromises = [...hasAttached && runTransitions("attached", newTree) || EMPTY.ARR, ...hasDetached && runTransitions("detached", oldTree) || EMPTY.ARR, ...hasReplaced && runTransitions("replaced", oldTree, newTree) || EMPTY.ARR];
          if (allPromises.length) {
            Promise.all(allPromises).then(() => {
              if (oldDomNode.parentNode) {
                oldDomNode.parentNode.removeChild(oldDomNode);
              }
              unprotectVTree(oldTree);
            });
            promises.push(...allPromises);
          } else {
            oldDomNode.parentNode.removeChild(oldDomNode);
            unprotectVTree(oldTree);
          }
          break;
        }
        case PATCH_TYPE.REMOVE_CHILD: {
          const vTree = patches[i2 + 1];
          i2 += 2;
          const domNode = NodeCache.get(vTree);
          if (!domNode || !domNode.parentNode) {
            break;
          }
          const detachedPromises = runTransitions("detached", vTree);
          if (detachedPromises.length) {
            Promise.all(detachedPromises).then(() => {
              if (domNode.parentNode) {
                domNode.parentNode.removeChild(domNode);
              }
              unprotectVTree(vTree);
            });
            promises.push(...detachedPromises);
          } else {
            domNode.parentNode.removeChild(domNode);
            unprotectVTree(vTree);
          }
          break;
        }
      }
    }
    return promises;
  }

  // node_modules/diffhtml/dist/es/tasks/patch-node.js
  function patchNode2(transaction) {
    const { mount, state: state3, patches } = transaction;
    const { mutationObserver, measure, scriptsToExecute } = state3;
    measure("patch node");
    const { ownerDocument } = mount;
    const promises = transaction.promises || [];
    state3.ownerDocument = ownerDocument || global_default.document;
    if (mutationObserver) {
      mutationObserver.disconnect();
    }
    const collectScripts = (vTree) => {
      if (vTree.nodeName === "script") {
        scriptsToExecute.set(vTree, vTree.attributes.type);
      }
    };
    CreateNodeHookCache.add(collectScripts);
    if (state3.ownerDocument) {
      promises.push(...patchNode(patches, state3));
    }
    CreateNodeHookCache.delete(collectScripts);
    transaction.promises = promises;
    measure("patch node");
  }

  // node_modules/diffhtml/dist/es/tasks/end-as-promise.js
  function endAsPromise(transaction) {
    const { promises } = transaction;
    if (promises && promises.length) {
      return transaction.promise = Promise.all(promises).then(() => transaction.end());
    }
    return transaction.promise = Promise.resolve(transaction.end());
  }

  // node_modules/diffhtml/dist/es/util/has-module.js
  var element2 = global_default.document ? document.createElement("script") : null;
  function hasModule() {
    return Boolean(element2 && "noModule" in element2);
  }

  // node_modules/diffhtml/dist/es/transaction.js
  function _defineProperty2(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var { assign: assign2 } = Object;
  var defaultTasks = [schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode2, endAsPromise];
  var tasks = { schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode: patchNode2, endAsPromise };
  var Transaction = class {
    static create(mount, input, options2) {
      return new Transaction(mount, input, options2);
    }
    static flow(transaction, tasks2) {
      let retVal = transaction;
      for (let i2 = 0; i2 < tasks2.length; i2++) {
        if (transaction.aborted) {
          return retVal;
        }
        retVal = tasks2[i2](transaction);
        if (retVal !== void 0 && retVal !== transaction) {
          return retVal;
        }
      }
      return retVal;
    }
    static assert(transaction) {
      if (process_default.env.NODE_ENV !== "production") {
        if (typeof transaction.mount !== "object" || !transaction.mount) {
          throw new Error("Transaction requires a DOM Node mount point");
        }
        if (transaction.aborted && transaction.completed) {
          throw new Error("Transaction was previously aborted");
        }
        if (transaction.completed) {
          throw new Error("Transaction was previously completed");
        }
      }
    }
    static invokeMiddleware(transaction) {
      const { state: { measure }, tasks: tasks2 } = transaction;
      MiddlewareCache.forEach((fn) => {
        const label = `invoke ${fn.name || "anon"}`;
        measure(label);
        const result = fn(transaction);
        if (result) {
          tasks2.push(result);
        }
        measure(label);
      });
    }
    constructor(mount, input, config2) {
      _defineProperty2(this, "state", EMPTY.OBJ);
      _defineProperty2(this, "mount", EMPTY.OBJ);
      _defineProperty2(this, "input", EMPTY.OBJ);
      _defineProperty2(this, "oldTree", void 0);
      _defineProperty2(this, "newTree", void 0);
      _defineProperty2(this, "promise", void 0);
      _defineProperty2(this, "promises", void 0);
      _defineProperty2(this, "tasks", []);
      _defineProperty2(this, "patches", []);
      this.mount = mount;
      this.input = input;
      this.config = config2;
      const useObserver = !config2.disableMutationObserver && "MutationObserver" in (global_default.window || EMPTY.OBJ);
      this.state = StateCache.get(mount) || { measure: makeMeasure(this), svgElements: /* @__PURE__ */ new Set(), scriptsToExecute: /* @__PURE__ */ new Map(), activeTransaction: this, mutationObserver: useObserver && new global_default.window.MutationObserver(EMPTY.FUN) };
      this.tasks = getConfig("tasks", defaultTasks, void 0, config2).slice();
      this.endedCallbacks = /* @__PURE__ */ new Set();
      StateCache.set(mount, this.state);
    }
    start() {
      if (process_default.env.NODE_ENV !== "production") {
        Transaction.assert(this);
      }
      const { state: { measure }, tasks: tasks2 } = this;
      const takeLastTask = tasks2.pop();
      measure("render");
      this.aborted = false;
      Transaction.invokeMiddleware(this);
      takeLastTask && tasks2.push(takeLastTask);
      return Transaction.flow(this, tasks2);
    }
    abort(isReturn) {
      this.aborted = true;
      if (isReturn) {
        return this.tasks[this.tasks.length - 1](this);
      }
    }
    end() {
      const { state: state3, config: config2, mount } = this;
      const { mutationObserver, measure, svgElements, scriptsToExecute } = state3;
      const mountAsHTMLEl = mount;
      measure("finalize");
      this.completed = true;
      svgElements.clear();
      state3.isRendering = false;
      state3.isDirty = false;
      if (mountAsHTMLEl.ownerDocument && mutationObserver) {
        mutationObserver.observe(mountAsHTMLEl, { subtree: true, childList: true, attributes: true, characterData: true });
      } else {
        state3.isDirty = true;
      }
      scriptsToExecute.forEach((type, vTree) => {
        const oldNode = NodeCache.get(vTree);
        oldNode.type = type;
        if (!config2.executeScripts || hasModule() && type === "nomodule") {
          return;
        }
        const newNode = assign2(oldNode.ownerDocument.createElement("script"), oldNode);
        for (let key2 in vTree.attributes) {
          const value = vTree.attributes[key2];
          newNode.setAttribute(key2, value);
        }
        newNode.textContent = oldNode.textContent;
        if (StateCache.has(oldNode)) {
          release(oldNode);
          StateCache.set(newNode, state3);
        }
        NodeCache.set(vTree, newNode);
        oldNode.parentNode && oldNode.parentNode.replaceChild(newNode, oldNode);
      });
      scriptsToExecute.clear();
      this.endedCallbacks.forEach((callback) => callback(this));
      this.endedCallbacks.clear();
      measure("finalize");
      measure("render");
      if (state3.oldTree)
        protectVTree(state3.oldTree);
      return this;
    }
    onceEnded(callback) {
      this.endedCallbacks.add(callback);
    }
  };

  // node_modules/diffhtml/dist/es/tasks/parse-new-tree.js
  function parseNewTree(transaction) {
    const { state: state3, input, config: options2 } = transaction;
    const { measure } = state3;
    if (typeof input === "string") {
      measure("parsing input for new tree");
      const { childNodes } = parse3(input, void 0, options2);
      const vTree = createTree(childNodes);
      if (vTree) {
        transaction.newTree = vTree;
      }
      measure("parsing input for new tree");
    }
  }

  // node_modules/diffhtml/dist/es/util/escape.js
  function escape2(unescaped) {
    return unescaped.replace(/[&<>]/g, (match) => `&#${match.charCodeAt(0)};`);
  }

  // node_modules/diffhtml/dist/es/util/internals.js
  function ownKeys2(object, enumerableOnly) {
    var keys4 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys4.push.apply(keys4, symbols2);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source2 = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source2), true).forEach(function(key2) {
        _defineProperty3(target, key2, source2[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2)) : ownKeys2(Object(source2)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source2, key2));
      });
    }
    return target;
  }
  function _defineProperty3(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var caches = { StateCache, NodeCache, TransitionCache, MiddlewareCache, CreateTreeHookCache, CreateNodeHookCache, SyncTreeHookCache, ReleaseHookCache, ParseHookCache };
  var internals_default = _objectSpread2({
    decodeEntities,
    escape: escape2,
    makeMeasure,
    memory: memory_exports,
    Pool: pool_default,
    process: process_default,
    PATCH_TYPE,
    globalConfig,
    createNode,
    syncTree,
    Transaction,
    defaultTasks,
    tasks
  }, caches);

  // node_modules/diffhtml/dist/es/inner-html.js
  function innerHTML(mount, input = EMPTY.STR, config2 = {}) {
    config2.inner = true;
    config2.executeScripts = "executeScripts" in config2 ? config2.executeScripts : true;
    config2.tasks = config2.tasks || defaultTasks;
    return Transaction.create(mount, input, config2).start();
  }

  // node_modules/diffhtml/dist/es/outer-html.js
  function outerHTML(mount, input = EMPTY.STR, config2 = {}) {
    config2.inner = false;
    config2.executeScripts = "executeScripts" in config2 ? config2.executeScripts : true;
    config2.tasks = config2.tasks || defaultTasks;
    return Transaction.create(mount, input, config2).start();
  }

  // node_modules/diffhtml/dist/es/to-string.js
  var { keys: keys2 } = Object;
  function toString(input, config2 = {}) {
    const oldTree = createTree();
    const activeTasks = new Set(config2.tasks || defaultTasks);
    activeTasks.delete(tasks.patchNode);
    activeTasks.delete(tasks.endAsPromise);
    activeTasks.add(function endAsString(transaction) {
      return serializeVTree(transaction.oldTree);
    });
    config2.tasks = [...activeTasks];
    config2.inner = true;
    let markup = "";
    try {
      markup = Transaction.create(oldTree, input, config2).start();
    } catch (e2) {
      release(oldTree);
      throw e2;
    }
    release(oldTree);
    return markup;
  }
  function serializeAttributes(attributes) {
    const attrs = keys2(attributes);
    return attrs.length ? " " + attrs.map((keyName2) => {
      const value = attributes[keyName2];
      const isFalsy = !value;
      const isDynamic = typeof value === "object" || typeof value === "function";
      if (value === true) {
        return keyName2;
      }
      return `${keyName2}${!isFalsy && !isDynamic ? `="${String(value)}"` : ""}`;
    }).join(" ") : "";
  }
  function serializeVTree(vTree) {
    let output = "";
    if (!vTree) {
      return output;
    }
    const { childNodes, nodeType, nodeName: tag, nodeValue, attributes } = vTree;
    if (nodeType === 11) {
      for (let i2 = 0; i2 < childNodes.length; i2++) {
        output += serializeVTree(childNodes[i2]);
      }
    } else if (!childNodes.length && nodeType === 1) {
      output += `<${tag}${serializeAttributes(attributes)}></${tag}>`;
    } else if (nodeType === 3) {
      output += nodeValue;
    } else if (childNodes.length) {
      const children = childNodes.map((childNode) => `${serializeVTree(childNode)}`).join("");
      output += `<${tag}${serializeAttributes(attributes)}>${children}</${tag}>`;
    }
    return output;
  }

  // node_modules/diffhtml/dist/es/html.js
  var { isArray: isArray3 } = Array;
  var isTagEx = /(<|\/)/;
  var nextValue = (values) => {
    const value = values.shift();
    return typeof value === "string" ? escape2(decodeEntities(value)) : value;
  };
  function handleTaggedTemplate(strings, ...values) {
    const empty2 = createTree("#text", EMPTY.STR);
    if (!strings) {
      return empty2;
    } else if (typeof strings === "string") {
      strings = [strings];
    }
    if (strings.length === 1 && !values.length) {
      if (!strings[0]) {
        return empty2;
      }
      const strict2 = getConfig("strict", false, "boolean", { strict: handleTaggedTemplate[$$strict] });
      delete handleTaggedTemplate[$$strict];
      const { childNodes: childNodes2 } = parse3(strings[0], void 0, { parser: { strict: strict2 } });
      return createTree(childNodes2.length === 1 ? childNodes2[0] : childNodes2);
    }
    let HTML = EMPTY.STR;
    const supplemental = { attributes: {}, children: {}, tags: {} };
    strings.forEach((string2, i2) => {
      HTML += string2;
      if (values.length) {
        const value = nextValue(values);
        const lastCharacter = HTML.trim().slice(-1);
        const isAttribute = HTML.lastIndexOf(">") < HTML.lastIndexOf("<");
        const isTag = Boolean(lastCharacter.match(isTagEx));
        const isObject = typeof value === "object";
        const token = `${TOKEN}${i2}__`;
        if (isTag) {
          supplemental.tags[i2] = value;
          HTML += token;
        } else if (isAttribute) {
          supplemental.attributes[i2] = value;
          HTML += token;
        } else if (isArray3(value) || isObject) {
          supplemental.children[i2] = createTree(value);
          HTML += token;
        } else if (value) {
          HTML += value;
        }
      }
    });
    const strict = getConfig("strict", false, "boolean", { strict: handleTaggedTemplate[$$strict] });
    const { childNodes } = parse3(HTML, supplemental, { parser: { strict } });
    return createTree(childNodes.length === 1 ? childNodes[0] : childNodes);
  }
  delete handleTaggedTemplate[$$strict];
  function setStrictMode(markup, ...args) {
    handleTaggedTemplate[$$strict] = true;
    try {
      return handleTaggedTemplate(markup, ...args);
    } catch (e2) {
      handleTaggedTemplate[$$strict] = false;
      throw e2;
    }
  }
  handleTaggedTemplate.strict = setStrictMode;

  // node_modules/diffhtml/dist/es/use.js
  var { isArray: isArray4 } = Array;
  function use(middleware) {
    const isFunction = typeof middleware === "function";
    const isObject = typeof middleware === "object";
    if (process_default.env.NODE_ENV !== "production") {
      if (!middleware || !isFunction && !isObject || isArray4(middleware)) {
        throw new Error("Middleware must be a function or plain object");
      }
    }
    const { subscribe, unsubscribe, createTreeHook, createNodeHook, syncTreeHook, releaseHook, parseHook } = middleware;
    isFunction && MiddlewareCache.add(middleware);
    subscribe && subscribe(internals_default);
    createTreeHook && CreateTreeHookCache.add(createTreeHook);
    createNodeHook && CreateNodeHookCache.add(createNodeHook);
    syncTreeHook && SyncTreeHookCache.add(syncTreeHook);
    releaseHook && ReleaseHookCache.add(releaseHook);
    parseHook && ParseHookCache.add(parseHook);
    return () => {
      isFunction && MiddlewareCache.delete(middleware);
      unsubscribe && unsubscribe(internals_default);
      createTreeHook && CreateTreeHookCache.delete(createTreeHook);
      createNodeHook && CreateNodeHookCache.delete(createNodeHook);
      syncTreeHook && SyncTreeHookCache.delete(syncTreeHook);
      releaseHook && ReleaseHookCache.delete(releaseHook);
      parseHook && ParseHookCache.delete(parseHook);
    };
  }

  // node_modules/diffhtml/dist/es/version.js
  var __VERSION__ = "1.0.0-beta.29";

  // node_modules/diffhtml/dist/es/index.js
  defaultTasks.splice(defaultTasks.indexOf(reconcileTrees), 0, parseNewTree);
  internals_default.parse = parse3;
  internals_default.VERSION = __VERSION__;
  var api2 = {};
  api2.VERSION = __VERSION__;
  api2.addTransitionState = addTransitionState;
  api2.removeTransitionState = removeTransitionState;
  api2.release = release;
  api2.createTree = createTree;
  api2.use = use;
  api2.outerHTML = outerHTML;
  api2.innerHTML = innerHTML;
  api2.toString = toString;
  api2.html = handleTaggedTemplate;
  api2.Internals = internals_default;
  var global2 = global_default;
  if ($$diffHTML in global_default) {
    const existingApi = global2[$$diffHTML];
    if (__VERSION__ !== existingApi.VERSION) {
      console.log(`Loaded ${__VERSION__} after ${existingApi.VERSION}`);
    }
  }
  global2[$$diffHTML] = api2;
  if (global2.devTools) {
    global2.unsubscribeDevTools = use(global2.devTools(internals_default));
  }

  // public/module.js
  var bus2 = window.bus;
  var state2 = bus2.state;
  bus2.libs.localstorage("ls/*");
  bus2.libs.http_out("/*", "/");
  window.braid_fetch = window.fetch;
  window.module = module2;
  window.state = state2;
  var CREATE_EVENT = "create";
  var observableEvents = [CREATE_EVENT];
  function update(target, compositor) {
    const html = compositor(target);
    if (html)
      innerHTML(target, html);
  }
  function draw(link2, compositor) {
    listen(CREATE_EVENT, link2, (event) => {
      bus2.reactive(
        update.bind(null, event.target, compositor)
      )();
    });
  }
  function style(link2, stylesheet) {
    const styles = `
    <style type="text/css" data-tag=${link2}>
      ${stylesheet.replaceAll("&", link2)}
    </style>
  `;
    document.body.insertAdjacentHTML("beforeend", styles);
  }
  function learn(link2) {
    return state2[link2] || {};
  }
  function teach(link2, knowledge, nuance = (s, p) => ({ ...s, ...p })) {
    const current = bus2.cache[link2] || {};
    state2[link2] = nuance(current.val || {}, knowledge);
  }
  function when(link1, eventName, link2, callback) {
    listen(eventName, `${link1} ${link2}`, callback);
  }
  function module2(link2, initialState = {}) {
    teach(link2, initialState);
    return {
      link: link2,
      learn: learn.bind(null, link2),
      draw: draw.bind(null, link2),
      style: style.bind(null, link2),
      when: when.bind(null, link2),
      teach: teach.bind(null, link2)
    };
  }
  function listen(type, link2, handler = () => null) {
    const callback = (event) => {
      if (event.target && event.target.matches && event.target.matches(link2)) {
        handler.call(null, event);
      }
    };
    document.addEventListener(type, callback, true);
    if (observableEvents.includes(type)) {
      observe(link2);
    }
    return function unlisten() {
      if (type === CREATE_EVENT) {
        disregard(link2);
      }
      document.removeEventListener(type, callback, true);
    };
  }
  var links = [];
  function observe(link2) {
    links = [.../* @__PURE__ */ new Set([...links, link2])];
    maybeCreateReactive([...document.querySelectorAll(link2)]);
  }
  function disregard(link2) {
    const index = links.indexOf(link2);
    if (index >= 0) {
      links = [
        ...links.slice(0, index),
        ...links.slice(index + 1)
      ];
    }
  }
  function maybeCreateReactive(targets) {
    targets.filter((x) => !x.reactive).forEach(dispatchCreate);
  }
  function getSubscribers({ target }) {
    if (links.length > 0)
      return [...target.querySelectorAll(links.join(", "))];
    else
      return [];
  }
  function dispatchCreate(target) {
    if (!target.id)
      target.id = sufficientlyUniqueId();
    target.dispatchEvent(new Event(CREATE_EVENT));
    target.reactive = true;
  }
  new MutationObserver((mutationsList) => {
    const targets = [...mutationsList].map(getSubscribers).flatMap((x) => x);
    maybeCreateReactive(targets);
  }).observe(document.body, { childList: true, subtree: true });
  function sufficientlyUniqueId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n) {
      if (n < 1 || n > this.lines)
        throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
      return this.lineInner(n, true, 1, 0);
    }
    replace(from, to, text) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to = this.length) {
      let parts = [];
      this.decompose(from, to, parts, 0);
      return TextNode.from(parts, to - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a = new RawTextCursor(this), b = new RawTextCursor(other);
      for (let skip = start, pos = start; ; ) {
        a.next(skip);
        b.next(skip);
        skip = 0;
        if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
          return false;
        pos += a.value.length;
        if (a.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to = this.length) {
      return new PartialTextCursor(this, from, to);
    }
    iterLines(from, to) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to == null)
          to = this.lines + 1;
        let start = this.line(from).from;
        inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let string2 = this.text[i2], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to, target, open) {
      let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from, to, text);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
      let newLen = this.length + text.length - (to - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i2 = 0; pos <= to && i2 < this.text.length; i2++) {
        let line = this.text[i2], end = pos + line.length;
        if (pos > from && i2)
          result += lineSep;
        if (from < end && to > pos)
          result += line.slice(Math.max(0, from - pos), to - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to, target, open) {
      for (let i2 = 0, pos = 0; pos <= to && i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from <= end && to >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
          if (pos >= from && end <= to && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to, text) {
      if (text.lines < this.lines)
        for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (from >= pos && to <= end) {
            let updated = child.replace(from - pos, to - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i2] = updated;
              return new TextNode(copy, this.length - (to - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
      let result = "";
      for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos > from && i2)
          result += lineSep;
        if (from < end && to > pos)
          result += child.sliceString(from - pos, to - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to; i2++) {
      let line = text[i2], end = pos + line.length;
      if (end >= from) {
        if (end > to)
          line = line.slice(0, to - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last = this.nodes.length - 1;
        let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
        let size2 = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size2 : 0)) {
          if (last == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last] += dir;
          } else {
            if (dir < 0)
              this.offsets[last]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
      this.pos = start > end ? text.length : 0;
      this.from = Math.min(start, end);
      this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to, number2, text) {
      this.from = from;
      this.to = to;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i2 = 1; i2 < extend2.length; i2++)
    extend2[i2] += extend2[i2 - 1];
  function isExtendingChar(code2) {
    for (let i2 = 1; i2 < extend2.length; i2 += 2)
      if (extend2[i2] > code2)
        return extend2[i2 - 1] <= code2;
    return false;
  }
  function isRegionalIndicator(code2) {
    return code2 >= 127462 && code2 <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i2 = pos - 2;
        while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
          countBefore++;
          i2 -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code2) {
    if (code2 <= 65535)
      return String.fromCharCode(code2);
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  function codePointSize(code2) {
    return code2 < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2)
        result += this.sections[i2];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let ins = this.sections[i2 + 1];
        result += ins < 0 ? this.sections[i2] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to = from) {
      for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
        if (ins >= 0 && pos <= to && end >= from)
          return pos < from && end > to ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a) => typeof a != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
        let len = sections[i2], ins = sections[i2 + 1];
        if (ins >= 0) {
          sections[i2] = ins;
          sections[i2 + 1] = len;
          let index = i2 >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i2 = 0, pos = 0; ; ) {
          let next = i2 == ranges.length ? 1e9 : ranges[i2++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i2++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let len = this.sections[i2], ins = this.sections[i2 + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set2 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set2.map(total)) : set2;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to = from, insert: insert2 } = spec;
          if (from > to || from < 0 || to > length)
            throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i2 = 0; i2 < json.length; i2++) {
        let part = json[i2];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i2)
            inserted.push(Text.empty);
          inserted[i2] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i2].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
      sections[last] += len;
    else if (len == 0 && sections[last] == 0)
      sections[last + 1] += ins;
    else if (forceJoin) {
      sections[last] += len;
      sections[last + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
      let len = desc.sections[i2++], ins = desc.sections[i2++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i2 - 2 >> 1]);
          if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
            break;
          len = desc.sections[i2++];
          ins = desc.sections[i2++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let posA = 0, posB = 0; ; ) {
      if (a.ins == -1) {
        posA += a.len;
        a.next();
      } else if (b.ins == -1 && posB < posA) {
        let skip = Math.min(b.len, posA - posB);
        b.forward(skip);
        addSection(sections, skip, -1);
        posB += skip;
      } else if (b.ins >= 0 && (a.done || posB < posA || posB == posA && (b.len < a.len || b.len == a.len && !before))) {
        addSection(sections, b.ins, -1);
        while (posA > posB && !a.done && posA + a.len < posB + b.len) {
          posA += a.len;
          a.next();
        }
        posB += b.len;
        b.next();
      } else if (a.ins >= 0) {
        let len = 0, end = posA + a.len;
        for (; ; ) {
          if (b.ins >= 0 && posB > posA && posB + b.len < end) {
            len += b.ins;
            posB += b.len;
            b.next();
          } else if (b.ins == -1 && posB < end) {
            let skip = Math.min(b.len, end - posB);
            len += skip;
            b.forward(skip);
            posB += skip;
          } else {
            break;
          }
        }
        addSection(sections, len, a.ins);
        if (insert2)
          addInsert(insert2, sections, a.text);
        posA = end;
        a.next();
      } else if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a.done && b.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a.ins == 0) {
        addSection(sections, a.len, 0, open);
        a.next();
      } else if (b.len == 0 && !b.done) {
        addSection(sections, 0, b.ins, open);
        if (insert2)
          addInsert(insert2, sections, b.text);
        b.next();
      } else if (a.done || b.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a.len2, b.len), sectionLen = sections.length;
        if (a.ins == -1) {
          let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b.text);
        } else if (b.ins == -1) {
          addSection(sections, a.off ? 0 : a.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a.textBit(len));
        } else {
          addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
          if (insert2 && !b.off)
            addInsert(insert2, sections, b.text);
        }
        open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
        a.forward2(len);
        b.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set2) {
      this.set = set2;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to, flags) {
      this.from = from;
      this.to = to;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to;
      if (this.empty) {
        from = to = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to = change.mapPos(this.to, -1);
      }
      return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    extend(from, to = from) {
      if (from <= this.anchor && to >= this.anchor)
        return EditorSelection.range(from, to);
      let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to, flags) {
      return new SelectionRange(from, to, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i2 = 0; i2 < this.ranges.length; i2++)
        if (!this.ranges[i2].eq(other.ranges[i2]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range, main = true) {
      return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
        let range = ranges[i2];
        if (range.empty ? range.from <= pos : range.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a, b) => a.from - b.from);
      mainIndex = ranges.indexOf(main);
      for (let i2 = 1; i2 < ranges.length; i2++) {
        let range = ranges[i2], prev = ranges[i2 - 1];
        if (range.empty ? range.from <= prev.to : range.from < prev.to) {
          let from = prev.from, to = Math.max(range.to, prev.to);
          if (i2 <= mainIndex)
            mainIndex--;
          ranges.splice(--i2, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
      if (range.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, extensions) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.extensions = extensions;
      this.id = nextID++;
      this.default = combine([]);
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a) => a), config2.compareInput || ((a, b) => a === b), config2.compare || (!config2.combine ? sameArray : (a, b) => a === b), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps2, get2) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps2, this, 1, get2);
    }
    computeN(deps2, get2) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps2, this, 2, get2);
    }
    from(field, get2) {
      if (!get2)
        get2 = (x) => x;
      return this.compute([field], (state3) => get2(state3.field(field)));
    }
  };
  function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e2, i2) => e2 === b[i2]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state3) {
          state3.values[idx] = getter(state3);
          return 1;
        },
        update(state3, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state3, depAddrs)) {
            let newVal = getter(state3);
            if (multi ? !compareArray(newVal, state3.values[idx], compare2) : !compare2(newVal, state3.values[idx])) {
              state3.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state3, oldState) => {
          let newVal = getter(state3);
          let oldAddr = oldState.config.address[id2];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state3.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state3.field(dep, false) : true;
            }) || (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))) {
              state3.values[idx] = oldVal;
              return 0;
            }
          }
          state3.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a, b, compare2) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!compare2(a[i2], b[i2]))
        return false;
    return true;
  }
  function ensureAll(state3, addrs) {
    let changed2 = false;
    for (let addr of addrs)
      if (ensureAddr(state3, addr) & 1)
        changed2 = true;
    return changed2;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p) => addresses[p.id]);
    let providerTypes = providers.map((p) => p.type);
    let dynamic = providerAddrs.filter((p) => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get2(state3) {
      let values = [];
      for (let i2 = 0; i2 < providerAddrs.length; i2++) {
        let value = getAddr(state3, providerAddrs[i2]);
        if (providerTypes[i2] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state3) {
        for (let addr of providerAddrs)
          ensureAddr(state3, addr);
        state3.values[idx] = get2(state3);
        return 1;
      },
      update(state3, tr) {
        if (!ensureAll(state3, dynamic))
          return 0;
        let value = get2(state3);
        if (facet.compare(value, state3.values[idx]))
          return 0;
        state3.values[idx] = value;
        return 1;
      },
      reconfigure(state3, oldState) {
        let depChanged = ensureAll(state3, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state3.values[idx] = oldValue;
          return 0;
        }
        let value = get2(state3);
        if (facet.compare(value, oldValue)) {
          state3.values[idx] = oldValue;
          return 0;
        }
        state3.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id2, createF, updateF, compareF, spec) {
      this.id = id2;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a, b) => a === b), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state3) {
      let init = state3.facet(initField).find((i2) => i2.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state3);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state3) => {
          state3.values[idx] = this.create(state3);
          return 1;
        },
        update: (state3, tr) => {
          let oldVal = state3.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state3.values[idx] = value;
          return 1;
        },
        reconfigure: (state3, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state3.values[idx] = oldState.field(this);
            return 0;
          }
          state3.values[idx] = this.create(state3);
          return 1;
        }
      };
    }
    init(create) {
      return [this, initField.of({ field: this, create })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state3) {
      return state3.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten2(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a) => field.slot(a));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id2 in facets) {
        let providers = facets[id2], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id2] || [];
        if (providers.every((p) => p.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p) => p.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p of providers) {
            if (p.type == 0) {
              address[p.id] = staticValues.length << 1 | 1;
              staticValues.push(p.value);
            } else {
              address[p.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a) => p.dynamicSlot(a));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a) => dynamicFacetSlot(a, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten2(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e2 of ext)
          inner(e2, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, prec2);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
  }
  function ensureAddr(state3, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state3.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state3.status[idx] = 4;
    let changed2 = state3.computeSlot(state3, state3.config.dynamicSlots[idx]);
    return state3.status[idx] = 2 | changed2;
  }
  function getAddr(state3, addr) {
    return addr & 1 ? state3.config.staticValues[addr >> 1] : state3.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map) {
      this.map = map;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type) {
      return this.type == type;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction2 = class {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a) => a.type == Transaction2.time))
        this.annotations = annotations.concat(Transaction2.time.of(Date.now()));
    }
    static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
      return new Transaction2(startState, changes, selection, effects, annotations, scrollIntoView3);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type) {
      for (let ann of this.annotations)
        if (ann.type == type)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e2 = this.annotation(Transaction2.userEvent);
      return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
    }
  };
  Transaction2.time = /* @__PURE__ */ Annotation.define();
  Transaction2.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction2.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction2.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to;
      if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
        from = a[iA++];
        to = a[iA++];
      } else if (iB < b.length) {
        from = b[iB++];
        to = b[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to);
      else if (result[result.length - 1] < to)
        result[result.length - 1] = to;
    }
  }
  function mergeTransaction(a, b, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b.changes;
      mapForB = ChangeSet.empty(b.changes.length);
      changes = a.changes.compose(b.changes);
    } else {
      mapForA = b.changes.map(a.changes);
      mapForB = a.changes.mapDesc(b.changes, true);
      changes = a.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b.selection ? b.selection.map(mapForB) : (_a2 = a.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
      annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
      scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
  }
  function resolveTransactionInner(state3, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction2.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state3.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state3, specs, filter) {
    let s = resolveTransactionInner(state3, specs.length ? specs[0] : {}, state3.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i2 = 1; i2 < specs.length; i2++) {
      if (specs[i2].filter === false)
        filter = false;
      let seq = !!specs[i2].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state3, specs[i2], seq ? s.changes.newLength : state3.doc.length), seq);
    }
    let tr = Transaction2.create(state3, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state3 = tr.startState;
    let result = true;
    for (let filter of state3.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state3.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.invertedDesc;
      }
      tr = Transaction2.create(state3, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state3.facet(transactionFilter);
    for (let i2 = filters.length - 1; i2 >= 0; i2--) {
      let filtered = filters[i2](tr);
      if (filtered instanceof Transaction2)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction2)
        tr = filtered[0];
      else
        tr = resolveTransaction(state3, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state3 = tr.startState, extenders = state3.facet(transactionExtender), spec = tr;
    for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
      let extension = extenders[i2](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(tr, resolveTransactionInner(state3, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction2.create(state3, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i2 = 0; i2 < str.length; i2++) {
      let ch = str[i2];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i2 = 0; i2 < wordChars.length; i2++)
        if (char.indexOf(wordChars[i2]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config2, doc2, selection, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
        ensureAddr(this, i2 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key2) => compartments.set(key2, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state3, slot) => slot.reconfigure(state3, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state3, slot) => slot.update(state3, tr), tr);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range) => ({
        changes: { from: range.from, to: range.to, insert: text },
        range: EditorSelection.cursor(range.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i2 = 1; i2 < sel.ranges.length; i2++) {
        let result = f(sel.ranges[i2]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i2; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to = this.doc.length) {
      return this.doc.sliceString(from, to, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state3) => field.spec.fromJSON(value, state3)));
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state3, slot) => slot.create(state3), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
          phrase2 = map[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m, i2) => {
          if (i2 == "$")
            return "$";
          let n = +(i2 || 1);
          return n > insert2.length ? m : insert2[n - 1];
        });
      return phrase2;
    }
    languageDataAt(name3, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name3))
            values.push(result[name3]);
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start = pos - from, end = pos - from;
      while (start > 0) {
        let prev = findClusterBreak(text, start, false);
        if (cat(text.slice(prev, start)) != CharCategory.Word)
          break;
        start = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start == end ? null : EditorSelection.range(start + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a, b) {
      let kA = Object.keys(a), kB = Object.keys(b);
      return kA.length == kB.length && kA.every((k) => a[k] == b[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults3, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key2 of Object.keys(config2)) {
        let value = config2[key2], current = result[key2];
        if (current === void 0)
          result[key2] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key2))
          result[key2] = combine[key2](current, value);
        else
          throw new Error("Config merge conflict for field " + key2);
      }
    for (let key2 in defaults3)
      if (result[key2] === void 0)
        result[key2] = defaults3[key2];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to = from) {
      return Range.create(from, to, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to, value) {
      this.from = from;
      this.to = to;
      this.value = value;
    }
    static create(from, to, value) {
      return new Range(from, to, value);
    }
  };
  function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
  }
  var Chunk = class {
    constructor(from, to, value, maxPoint) {
      this.from = from;
      this.to = to;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to, f) {
      for (let i2 = this.findIndex(from, -1e9, true), e2 = this.findIndex(to, 1e9, false, i2); i2 < e2; i2++)
        if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last = this.chunk.length - 1;
      return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size2 = this.nextLayer.size;
      for (let chunk of this.chunk)
        size2 += chunk.value.length;
      return size2;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i2 < add2.length) {
        if (i2 < add2.length && (cur2.from - add2[i2].from || cur2.startSide - add2[i2].value.startSide) >= 0) {
          let range = add2[i2++];
          if (!builder.addInner(range.from, range.to, range.value))
            spill.push(range);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start = this.chunkPos[i2], chunk = this.chunk[i2];
        let touch = changes.touchesRange(start, start + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to, f) {
      if (this.isEmpty)
        return;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start = this.chunkPos[i2], chunk = this.chunk[i2];
        if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false)
          return;
      }
      this.nextLayer.between(from, to, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a, b, textDiff);
      let sideA = new SpanCursor(a, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to) {
      if (to == null)
        to = 1e9;
      let a = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
      let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
      if (a.length != b.length)
        return false;
      if (!a.length)
        return true;
      let sharedChunks = findSharedChunks(a, b);
      let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let open = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to);
        if (cursor.point) {
          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open, cursor.pointRank);
          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, open);
          open = cursor.openEnd(curTo);
        }
        if (cursor.to > to)
          break;
        pos = cursor.to;
        cursor.next();
      }
      return open;
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range.from, range.to, range.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
        let cur2 = ranges[i2];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to, value) {
      if (!this.addInner(from, to, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
    }
    addInner(from, to, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last = chunk.value.length - 1;
      this.last = chunk.value[last];
      this.lastFrom = chunk.from[last] + from;
      this.lastTo = chunk.to[last] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a, b, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set2 of a)
      for (let i2 = 0; i2 < set2.chunk.length; i2++)
        if (set2.chunk[i2].maxPoint <= 0)
          inA.set(set2.chunk[i2], set2.chunkPos[i2]);
    let shared = /* @__PURE__ */ new Set();
    for (let set2 of b)
      for (let i2 = 0; i2 < set2.chunk.length; i2++) {
        let known = inA.get(set2.chunk[i2]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i2].length)))
          shared.add(set2.chunk[i2]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i2 = 0; i2 < sets.length; i2++) {
        for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i2));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur2 = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i2 = 0, { value, to, rank } = this.cursor;
      while (i2 < this.activeRank.length && this.activeRank[i2] <= rank)
        i2++;
      insert(this.active, i2, value);
      insert(this.activeTo, i2, to);
      insert(this.activeRank, i2, rank);
      if (trackOpen)
        insert(trackOpen, i2, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
      for (; ; ) {
        let a = this.minActive;
        if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a] > from) {
            this.to = this.activeTo[a];
            this.endSide = this.active[a].endSide;
            break;
          }
          this.removeActive(a);
          if (trackOpen)
            remove(trackOpen, a);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            if (this.cursor.from < from)
              trackExtra = 1;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        let openStart = 0;
        while (openStart < trackOpen.length && trackOpen[openStart] < from)
          openStart++;
        this.openStart = openStart + trackExtra;
      }
    }
    activeForPoint(to) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
        if (this.activeRank[i2] < this.pointRank)
          break;
        if (this.activeTo[i2] > to || this.activeTo[i2] == to && this.active[i2].endSide >= this.point.endSide)
          active.push(this.active[i2]);
      }
      return active.reverse();
    }
    openEnd(to) {
      let open = 0;
      for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to; i2--)
        open++;
      return open;
    }
  };
  function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a.to + dPos - b.to || a.endSide - b.endSide;
      let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
      if (a.point || b.point) {
        if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))
          comparator.comparePoint(pos, clipEnd, a.point, b.point);
      } else {
        if (clipEnd > pos && !sameValues(a.active, b.active))
          comparator.compareRange(pos, clipEnd, a.active, b.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a.next();
      if (diff >= 0)
        b.next();
    }
  }
  function sameValues(a, b) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (a[i2] != b[i2] && !a[i2].eq(b[i2]))
        return false;
    return true;
  }
  function remove(array, index) {
    for (let i2 = index, e2 = array.length - 1; i2 < e2; i2++)
      array[i2] = array[i2 + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i2 = array.length - 1; i2 >= index; i2--)
      array[i2 + 1] = array[i2];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i2 = 0; i2 < array.length; i2++)
      if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
        found = i2;
        foundPos = array[i2];
      }
    return found;
  }
  function countColumn(string2, tabSize, to = string2.length) {
    let n = 0;
    for (let i2 = 0; i2 < to; ) {
      if (string2.charCodeAt(i2) == 9) {
        n += tabSize - n % tabSize;
        i2++;
      } else {
        n++;
        i2 = findClusterBreak(string2, i2);
      }
    }
    return n;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i2 = 0, n = 0; ; ) {
      if (n >= col)
        return i2;
      if (i2 == string2.length)
        break;
      n += string2.charCodeAt(i2) == 9 ? tabSize - n % tabSize : 1;
      i2 = findClusterBreak(string2, i2);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options2) {
      this.rules = [];
      let { finish } = options2 || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id2 = top[COUNT] || 1;
      top[COUNT] = id2 + 1;
      return C + id2.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i2 = 0; i2 < modules.length; i2++) {
        let mod = modules[i2], index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet)
            for (let k = 0; k < mod.rules.length; k++)
              sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index)
            pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i2 = 0; i2 < this.modules.length; i2++)
          text += this.modules[i2].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (i2 = 0; i2 < 10; i2++)
    base[48 + i2] = base[96 + i2] = String(i2);
  var i2;
  for (i2 = 1; i2 <= 24; i2++)
    base[i2 + 111] = "F" + i2;
  var i2;
  for (i2 = 65; i2 <= 90; i2++) {
    base[i2] = String.fromCharCode(i2 + 32);
    shift[i2] = String.fromCharCode(i2);
  }
  var i2;
  for (code2 in base)
    if (!shift.hasOwnProperty(code2))
      shift[code2] = base[code2];
  var code2;
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name3 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name3 == "Esc")
      name3 = "Escape";
    if (name3 == "Del")
      name3 = "Delete";
    if (name3 == "Left")
      name3 = "ArrowLeft";
    if (name3 == "Up")
      name3 = "ArrowUp";
    if (name3 == "Right")
      name3 = "ArrowRight";
    if (name3 == "Down")
      name3 = "ArrowDown";
    return name3;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom2, node) {
    return node ? dom2 == node || dom2.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement() {
    let elt = document.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom2, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom2, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom2) {
    if (dom2.nodeType == 3)
      return textRange(dom2, 0, dom2.nodeValue.length).getClientRects();
    else if (dom2.nodeType == 1)
      return dom2.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom2, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc2 = dom2.ownerDocument, win = doc2.defaultView;
    for (let cur2 = dom2; cur2; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            if (moveY) {
              let start = cur2.scrollTop;
              cur2.scrollTop += moveY;
              moveY = cur2.scrollTop - start;
            }
            if (moveX) {
              let start = cur2.scrollLeft;
              cur2.scrollLeft += moveX;
              moveX = cur2.scrollLeft - start;
            }
            rect = {
              left: rect.left - moveX,
              top: rect.top - moveY,
              right: rect.right - moveX,
              bottom: rect.bottom - moveY
            };
          }
        }
        if (top2)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
        x = y = "nearest";
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
      this.set(range.anchorNode, range.anchorOffset, range.focusNode, range.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom2) {
    if (dom2.setActive)
      return dom2.setActive();
    if (preventScrollSupported)
      return dom2.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom2; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom2.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i2 = 0; i2 < stack.length; ) {
        let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
  }
  function dispatchKey(elt, name3, code2) {
    let options2 = { key: name3, code: name3, keyCode: code2, which: code2, cancelable: true };
    let down = new KeyboardEvent("keydown", options2);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options2);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom2, precise) {
      return new DOMPos(dom2.parentNode, domIndex(dom2), precise);
    }
    static after(dom2, precise) {
      return new DOMPos(dom2.parentNode, domIndex(dom2) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.constructor == child.constructor)
                child.reuseDOM(next);
            }
            child.sync(track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i2 = 0, pos = 0; ; i2++) {
        let child = this.children[i2];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos < from && end > to)
          return child.domBoundsAround(from, to, pos);
        if (end >= from && fromI == -1) {
          fromI = i2;
          fromStart = pos;
        }
        if (pos > to && child.dom.parentNode == this.dom) {
          toI = i2;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom2) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom2;
      dom2.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to, children = noChildren) {
      this.markDirty();
      for (let i2 = from; i2 < to; i2++) {
        let child = this.children[i2];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from, to - from, ...children);
      for (let i2 = 0; i2 < children.length; i2++)
        children[i2].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name3 = this.constructor.name.replace("View", "");
      return name3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom2) {
    let next = dom2.nextSibling;
    dom2.parentNode.removeChild(dom2);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i2) {
      this.children = children;
      this.pos = pos;
      this.i = i2;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last)
          last.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom2) {
      if (dom2.nodeType == 3)
        this.createDOM(dom2);
    }
    merge(from, to, source2) {
      if (source2 && (!(source2 instanceof TextView) || this.length - (to - from) + source2.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source2 ? source2.text : "") + this.text.slice(to);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom2) {
      clearAttributes(dom2);
      if (this.mark.class)
        dom2.className = this.mark.class;
      if (this.mark.attrs)
        for (let name3 in this.mark.attrs)
          dom2.setAttribute(name3, this.mark.attrs[name3]);
      return dom2;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from, to, source2, _hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof MarkView && source2.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to, source2 ? source2.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i2 = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i2;
        off = end;
        i2++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to = pos, flatten3 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten3 = 1;
        } else if (to < length) {
          to++;
          flatten3 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to < length)
        to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten3 ? flatten3 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten3 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten3 ? flattenRect(rect, flatten3 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2 && (!(source2 instanceof WidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view = top2.editorView, text = view && view.state.doc, start = this.posAtStart;
      return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i2 = pos > 0 ? rects.length - 1 : 0; ; i2 += pos > 0 ? -1 : 1) {
        rect = rects[i2];
        if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let { topView, text } = this.widget;
      if (!topView)
        return new DOMPos(text, Math.min(pos, text.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text, (v, p) => v.domAtPos(p), (p) => new DOMPos(text, Math.min(p, text.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let { topView, text } = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let { topView, text } = this.widget;
      if (!topView)
        return textCoords(text, pos, side);
      return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view, text, enterView, fromText) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let hasComp = contains(child.dom, text);
        let len = hasComp ? text.nodeValue.length : child.length;
        if (pos < len || pos == len && child.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, child, text, enterView, fromText) : enterView(child, pos, side);
        pos -= len;
      }
      return enterView(view, view.length, -1);
    } else if (view.dom == text) {
      return fromText(pos, side);
    } else {
      return enterView(view, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view, text) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let pos = 0, hasComp = contains(child.dom, text);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text.nodeValue.length : child.length;
      }
    } else if (view.dom == text) {
      return Math.min(offset, text.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom2 = document.createElement("img");
        dom2.className = "cm-widgetBuffer";
        dom2.setAttribute("aria-hidden", "true");
        this.setDOM(dom2);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view, side) {
    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
      if (side < 0 ? index > 0 : index < parent.children.length) {
        let next = parent.children[index + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last = parent.dom.lastChild;
        if (last && last.nodeName == "BR")
          return last.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(dom2, children, pos) {
    let i2 = 0;
    for (let off = 0; i2 < children.length; i2++) {
      let child = children[i2], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom2)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (; i2 > 0; i2--) {
      let before = children[i2 - 1].dom;
      if (before.parentNode == dom2)
        return DOMPos.after(before);
    }
    return new DOMPos(dom2, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
      joinInlineInto(last, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    for (let off = 0, i2 = 0; i2 < view.children.length; i2++) {
      let child = view.children[i2], end = off + child.length, next;
      if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i2 + 1 == view.children.length || (next = view.children[i2 + 1]).length || next.getSide() > 0)) {
        let flatten3 = 0;
        if (end == off) {
          if (child.getSide() <= 0)
            continue;
          flatten3 = side = -child.getSide();
        }
        let rect = child.coordsAt(Math.max(0, pos - off), side);
        return flatten3 && rect ? flattenRect(rect, side < 0) : rect;
      }
      off = end;
    }
    let last = view.dom.lastChild;
    if (!last)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source2, target) {
    for (let name3 in source2) {
      if (name3 == "class" && target.class)
        target.class += " " + source2.class;
      else if (name3 == "style" && target.style)
        target.style += ";" + source2.style;
      else
        target[name3] = source2[name3];
    }
    return target;
  }
  function attrsEq(a, b) {
    if (a == b)
      return true;
    if (!a || !b)
      return false;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length != keysB.length)
      return false;
    for (let key2 of keysA) {
      if (keysB.indexOf(key2) == -1 || a[key2] !== b[key2])
        return false;
    }
    return true;
  }
  function updateAttrs(dom2, prev, attrs) {
    let changed2 = null;
    if (prev) {
      for (let name3 in prev)
        if (!(attrs && name3 in attrs))
          dom2.removeAttribute(changed2 = name3);
    }
    if (attrs) {
      for (let name3 in attrs)
        if (!(prev && prev[name3] == attrs[name3]))
          dom2.setAttribute(changed2 = name3, attrs[name3]);
    }
    return !!changed2;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom2) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom2) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start, end } = getInclusive(spec, block);
        startSide = (start ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start, end } = getInclusive(spec);
      super(start ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to = from) {
      if (from >= to)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
      if (to != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
      if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
      start = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
  }
  function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
      ranges[last] = Math.max(ranges[last], to);
    else
      ranges.push(from, to);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to, source2, hasStart, openStart, openEnd) {
      if (source2) {
        if (!(source2 instanceof LineView))
          return false;
        if (!this.dom)
          source2.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source2 ? source2.attrs : null);
      mergeChildrenInto(this, from, to, source2 ? source2.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i: i2, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i2].split(off), 0);
        this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
        i2++;
      }
      for (let j = i2; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i2 > 0 && this.children[i2 - 1].length == 0)
        this.children[--i2].destroy();
      this.children.length = i2;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last = this.dom.lastChild;
      while (last && ContentView.get(last) instanceof MarkView)
        last = last.lastChild;
      if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
        let block = docView.children[i2], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, type) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to, source2, _takeDeco, openStart, openEnd) {
      if (source2 && (!(source2 instanceof BlockWidgetView) || !this.widget.compare(source2.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
        return false;
      this.length = from + (source2 ? source2.length : 0) + (this.length - to);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last = this.content[this.content.length - 1];
      return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer([]);
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (!openEnd)
        this.flushBuffer([]);
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer([]);
            this.curLine = null;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(0, openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to, active, openStart) {
      this.buildText(to - from, active, openStart);
      this.pos = to;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let { type } = deco;
          if (type == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type));
        } else {
          let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to ? 1 : 2;
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var ScrollTarget = class {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
  function logException(state3, exception, context2) {
    let handler = state3.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context2, void 0, void 0, exception);
    else if (context2)
      console.error(context2 + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id2, create, domEventHandlers, buildExtensions) {
      this.id = id2;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const { eventHandlers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e2) {
            logException(view.state, e2, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update2 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update2);
          } catch (e2) {
            logException(update2.state, e2, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e2) {
          logException(view.state, e2, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set2) {
      let i2 = set2.length, me = this;
      for (; i2 > 0; i2--) {
        let range = set2[i2 - 1];
        if (range.fromA > me.toA)
          continue;
        if (range.toA < me.fromA)
          break;
        me = me.join(range);
        set2.splice(i2 - 1, 1);
      }
      set2.splice(i2, 0, me);
      return set2;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state3, transactions) {
      this.view = view;
      this.state = state3;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
    static create(view, state3, transactions) {
      return new ViewUpdate(view, state3, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i2 = 0; i2 < str.length; i2++)
      result.push(1 << +str[i2]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var BidiSpan = class {
    constructor(from, to, level) {
      this.from = from;
      this.to = to;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i2 = 0; i2 < order.length; i2++) {
        let span = order[i2];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i2;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i2;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i2 = 0, prev = outerType, prevStrong = outerType; i2 < len; i2++) {
      let type = charType(line.charCodeAt(i2));
      if (type == 512)
        type = prev;
      else if (type == 8 && prevStrong == 4)
        type = 16;
      types[i2] = type == 4 ? 2 : type;
      if (type & 7)
        prevStrong = type;
      prev = type;
    }
    for (let i2 = 0, prev = outerType, prevStrong = outerType; i2 < len; i2++) {
      let type = types[i2];
      if (type == 128) {
        if (i2 < len - 1 && prev == types[i2 + 1] && prev & 24)
          type = types[i2] = prev;
        else
          types[i2] = 256;
      } else if (type == 64) {
        let end = i2 + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace = i2 && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++)
          types[j] = replace;
        i2 = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type;
      if (type & 7)
        prevStrong = type;
    }
    for (let i2 = 0, sI = 0, context2 = 0, ch, br, type; i2 < len; i2++) {
      if (br = Brackets[ch = line.charCodeAt(i2)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type2 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type2)
                types[i2] = types[BracketStack[sJ]] = type2;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context2;
        }
      } else if ((type = types[i2]) == 2 || type == 1) {
        let embed = type == outerType;
        context2 = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i2 = 0; i2 < len; i2++) {
      if (types[i2] == 256) {
        let end = i2 + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i2 ? types[i2 - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i2; j < end; j++)
          types[j] = replace;
        i2 = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i2 = 0; i2 < len; ) {
        let start = i2, rtl = types[i2++] != 1;
        while (i2 < len && rtl == (types[i2] != 1))
          i2++;
        if (rtl) {
          for (let j = i2; j > start; ) {
            let end = j, l = types[--j] != 2;
            while (j > start && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start, i2, 0));
        }
      }
    } else {
      for (let i2 = 0; i2 < len; ) {
        let start = i2, rtl = types[i2++] == 2;
        while (i2 < len && rtl == (types[i2] == 2))
          i2++;
        order.push(new BidiSpan(start, i2, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start, forward) {
    var _a2;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last = order[order.length - 1];
      if (last.level != dir) {
        startIndex = last.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state3) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state3.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
      if (!start)
        return this;
      let parent = start.parentNode;
      for (let cur2 = start; ; ) {
        this.findPointBefore(parent, cur2);
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m = re.exec(text)) {
          nextBreak = m.index;
          breakSize = m[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i2 = fromView.iter(); !i2.next().done; ) {
          if (i2.lineBreak)
            this.lineBreak();
          else
            this.append(i2.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
    get root() {
      return this.view.root;
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update2) {
      let changedRanges = update2.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update2.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update2.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update2.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update2.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update2 && update2.state.doc.lines != update2.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update2.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update2.startState.doc.length);
        if (update2.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i2 = changes.length - 1; ; i2--) {
        let next = i2 >= 0 ? changes[i2] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next;
        let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.root);
          if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            rawSel.extend(head.node, head.offset);
          } else {
            let range = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range.setEnd(head.node, head.offset);
            range.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let cursor = this.view.state.selection.main;
      let sel = getSelection(this.root);
      if (!cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom2 = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom2.node, dom2.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
      return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
    }
    nearest(dom2) {
      for (let cur2 = dom2; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i: i2, off } = this.childCursor().findPos(pos, -1);
      for (; i2 < this.children.length - 1; ) {
        let child = this.children[i2];
        if (off < child.length || child instanceof LineView)
          break;
        i2++;
        off = 0;
      }
      return this.children[i2].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i2 = this.children.length - 1; ; i2--) {
        let child = this.children[i2], start = off - child.breakAfter - child.length;
        if (pos > start || pos == start && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i2 || side == 2 || this.children[i2 - 1].breakAfter || this.children[i2 - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start, side);
        off = start;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (end > to)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last = child.dom.lastChild;
            let rects = last ? clientRectsFor(last) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i2 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
      let i2 = this.children.length;
      if (i2)
        pos -= this.children[--i2].length;
      return new ChildCursor(this.children, pos, i2);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i2 = 0; ; i2++) {
        let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d, i2) => {
        let dynamic = this.dynamicDecorationMap[i2] = typeof d == "function";
        return dynamic ? d(this.view) : d;
      });
      for (let i2 = allDeco.length; i2 < allDeco.length + 3; i2++)
        this.dynamicDecorationMap[i2] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let { range } = target;
      let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let { left, right, top: top2, bottom } = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return { from: pos, to: pos, node: topNode, text: textNode };
    } else {
      for (; ; ) {
        let { parent } = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from = cView.posAtStart;
      return { from, to: from + cView.length, node: cView.dom, text: textNode };
    }
  }
  function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding)
      return Decoration.none;
    let { from, to, node, text: textNode } = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to, -1));
    let { state: state3 } = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state3).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
      if (state3.doc.sliceString(newFrom, Math.min(state3.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
        newTo = newFrom + text.length;
      else if (state3.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
        newFrom = newTo - text.length;
      else
        return Decoration.none;
    } else if (state3.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text, topView) {
      super();
      this.top = top2;
      this.text = text;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to) {
      addRange(from, to, this.changes);
    }
    comparePoint(from, to) {
      addRange(from, to, this.changes);
    }
  };
  function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a, b, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state3, pos, bias = 1) {
    let categorize = state3.charCategorizer(pos);
    let line = state3.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to < line.length) {
      let next = findClusterBreak(line.text, to);
      if (categorize(line.text.slice(to, next)) != cat)
        break;
      to = next;
    }
    return EditorSelection.range(from + line.from, to + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y);
    if (!closestX && closest.contentEditable == "true")
      return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i2 = 0; i2 < len; i2++) {
      let rects = textRange(node, i2, i2 + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i2).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i2 + (after ? 1 : 0) };
          closestOffset = i2 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, { x, y }, precise, bias = -1) {
    var _a2;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element3 = root.elementFromPoint(x, y);
    if (element3 && !view.contentDOM.contains(element3))
      element3 = null;
    if (!element3) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element3 = root.elementFromPoint(x, y);
      if (element3 && !view.contentDOM.contains(element3))
        element3 = null;
    }
    let node, offset = -1;
    if (element3 && ((_a2 = view.docView.nearest(element3)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range = doc2.caretRangeFromPoint(x, y);
        if (range) {
          ({ startContainer: node, startOffset: offset } = range);
          if (browser.safari && isSuspiciousCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = view.state.doc.lineAt(start.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : view.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start.assoc, void 0, goal);
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let atoms = view.state.facet(atomicRanges).map((f) => f(view));
    for (; ; ) {
      let moved = false;
      for (let set2 of atoms) {
        set2.between(pos.from - 1, pos.from + 1, (from, to, value) => {
          if (pos.from > from && pos.from < to) {
            pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.rapidCompositionStart = false;
      this.mouseSelection = null;
      for (let type in handlers2) {
        let handler = handlers2[type];
        view.contentDOM.addEventListener(type, (event) => {
          if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
            return;
          if (type == "keydown" && this.keydown(view, event))
            return;
          if (this.mustFlushObserver(event))
            view.observer.forceFlush();
          if (this.runCustomHandlers(type, view, event))
            event.preventDefault();
          else
            handler(view, event);
        });
        this.registeredEvents.push(type);
      }
      if (browser.chrome && browser.chrome_version >= 102) {
        view.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view.contentDOM.style.pointerEvents = "";
          }, 100);
        }, { passive: true });
      }
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
      var _a2;
      let handlers3;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers3 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({ plugin: plugin.value, handlers: handlers3 });
          for (let type in handlers3)
            if (this.registeredEvents.indexOf(type) < 0 && type != "scroll") {
              this.registeredEvents.push(type);
              view.contentDOM.addEventListener(type, (event) => {
                if (!eventBelongsToEditor(view, event))
                  return;
                if (this.runCustomHandlers(type, view, event))
                  event.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type, view, event) {
      for (let set2 of this.customHandlers) {
        let handler = set2.handlers[type];
        if (handler) {
          try {
            if (handler.call(set2.plugin, event, view) || event.defaultPrevented)
              return true;
          } catch (e2) {
            logException(view.state, e2);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      for (let set2 of this.customHandlers) {
        let handler = set2.handlers.scroll;
        if (handler) {
          try {
            handler.call(set2.plugin, event, view);
          } catch (e2) {
            logException(view.state, e2);
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && (pending = PendingKeys.find((key2) => key2.keyCode == event.keyCode)) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
        this.pendingIOSKey = pending;
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      let key2 = this.pendingIOSKey;
      if (!key2)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view.contentDOM, key2.key, key2.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update2) {
      if (this.mouseSelection)
        this.mouseSelection.update(update2);
      if (update2.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(view, startEvent, style2, mustSelect) {
      this.view = view;
      this.style = style2;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      let selection = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
      this.mustSelect = false;
    }
    update(update2) {
      if (update2.docChanged && this.dragging)
        this.dragging = this.dragging.map(update2.changes);
      if (this.style.update(update2))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers2 = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let { state: state3 } = view, changes, i2 = 1, text = state3.toText(input);
    let byLine = text.lines == state3.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state3.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state3.changeByRange((range) => {
        let line = state3.doc.lineAt(range.from);
        if (line.from == lastLine)
          return { range };
        lastLine = line.from;
        let insert2 = state3.toText((byLine ? text.line(i2++).text : input) + state3.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state3.changeByRange((range) => {
        let line = text.line(i2++);
        return {
          changes: { from: range.from, to: range.to, insert: line.text },
          range: EditorSelection.cursor(range.from + line.length)
        };
      });
    } else {
      changes = state3.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers2.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
      view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      view.inputState.lastEscPress = 0;
  };
  var lastTouch = 0;
  handlers2.touchstart = (view, e2) => {
    lastTouch = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers2.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers2.mousedown = (view, event) => {
    view.observer.flush();
    if (lastTouch > Date.now() - 2e3 && getClickType(event) == 1)
      return;
    let style2 = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style2 = makeStyle(view, event);
      if (style2)
        break;
    }
    if (!style2 && event.button == 0)
      style2 = basicMouseSelection(view, event);
    if (style2) {
      let mustFocus = view.root.activeElement != view.contentDOM;
      if (mustFocus)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(new MouseSelection(view, event, style2, mustFocus));
    }
  };
  function rangeForClick(view, pos, bias, type) {
    if (type == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
      if (to < view.state.doc.length && to == line.to)
        to++;
      return EditorSelection.range(from, to);
    }
  }
  var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
  var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
      return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    let last = start, lastEvent = event;
    return {
      update(update2) {
        if (update2.docChanged) {
          if (start)
            start.pos = update2.changes.mapPos(start.pos);
          startSel = startSel.map(update2.changes);
          lastEvent = null;
        }
      },
      get(event2, extend3, multiple) {
        let cur2;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur2 = last;
        else {
          cur2 = last = queryPos(view, event2);
          lastEvent = event2;
        }
        if (!cur2 || !start)
          return startSel;
        let range = rangeForClick(view, cur2.pos, cur2.bias, type);
        if (start.pos != cur2.pos && !extend3) {
          let startRange = rangeForClick(view, start.pos, start.bias, type);
          let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
          range = from < range.from ? EditorSelection.range(from, to) : EditorSelection.range(to, from);
        }
        if (extend3)
          return startSel.replaceRange(startSel.main.extend(range.from, range.to));
        else if (multiple)
          return startSel.addRange(range);
        else
          return EditorSelection.create([range]);
      }
    };
  }
  handlers2.dragstart = (view, event) => {
    let { selection: { main } } = view.state;
    let { mouseSelection } = view.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    event.preventDefault();
    let { mouseSelection } = view.inputState;
    let del2 = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del2 ? [del2, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del2 ? "move.drop" : "input.drop"
    });
  }
  handlers2.drop = (view, event) => {
    if (!event.dataTransfer)
      return;
    if (view.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i2 = 0; i2 < files.length; i2++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i2] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i2]);
      }
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers2.paste = (view, event) => {
    if (view.state.readOnly)
      return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state3) {
    let content2 = [], ranges = [], linewise = false;
    for (let range of state3.selection.ranges)
      if (!range.empty) {
        content2.push(state3.sliceDoc(range.from, range.to));
        ranges.push(range);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state3.selection.ranges) {
        let line = state3.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state3.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state3.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers2.copy = handlers2.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
      return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text);
    } else {
      captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  function updateForFocusChange(view) {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused)
        view.update([]);
    }, 10);
  }
  handlers2.focus = updateForFocusChange;
  handlers2.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  function forceClearComposition(view, rapid) {
    if (view.docView.compositionDeco.size) {
      view.inputState.rapidCompositionStart = rapid;
      try {
        view.update([]);
      } finally {
        view.inputState.rapidCompositionStart = false;
      }
    }
  }
  handlers2.compositionstart = handlers2.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
      if (view.docView.compositionDeco.size) {
        view.observer.flush();
        forceClearComposition(view, true);
      }
    }
  };
  handlers2.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    setTimeout(() => {
      if (view.inputState.composing < 0)
        forceClearComposition(view, false);
    }, 50);
  };
  handlers2.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers2.beforeinput = (view, event) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key2) => key2.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor() {
      this.doc = Text.empty;
      this.lineWrapping = false;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to) {
      let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i2 = 0; i2 < lineHeights.length; i2++) {
        let h = lineHeights[i2];
        if (h < 0) {
          i2++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed2 = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed2) {
        this.heightSamples = {};
        for (let i2 = 0; i2 < knownHeights.length; i2++) {
          let h = knownHeights[i2];
          if (h < 0)
            i2++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed2;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length, top2, height, type) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i2 = changes.length - 1; i2 >= 0; i2--) {
        let { fromA, toA, fromB, toB } = changes[i2];
        let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i2 > 0 && start.from <= changes[i2 - 1].toA) {
          fromA = changes[i2 - 1].fromA;
          fromB = changes[i2 - 1].fromB;
          i2--;
          if (fromA < start.from)
            start = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start.from - fromA;
        fromA = start.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i2 = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i2 == j) {
          if (before > after * 2) {
            let split = nodes[i2 - 1];
            if (split.break)
              nodes.splice(--i2, 1, split.left, null, split.right);
            else
              nodes.splice(--i2, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i2++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i2 - 1] == null) {
        brk = 1;
        i2--;
      } else if (nodes[i2] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, type) {
      super(length, height);
      this.type = type;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      if (from <= offset + this.length && to >= offset)
        f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    lines(doc2, offset) {
      let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
      return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc2, top2, offset) {
      let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let { from, length } = doc2.line(firstLine + line);
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type, doc2, top2, offset) {
      if (type == QueryType.ByHeight)
        return this.blockAt(value, doc2, top2, offset);
      if (type == QueryType.ByPosNoHeight) {
        let { from: from2, to } = doc2.lineAt(value);
        return new BlockInfo(from2, to - from2, 0, 0, BlockType.Text);
      }
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      let { from, length, number: number2 } = doc2.lineAt(value);
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to); pos <= end; ) {
        let line = doc2.lineAt(pos);
        if (pos == from)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to, nodes) {
      let after = this.length - to;
      if (after > 0) {
        let last = nodes[nodes.length - 1];
        if (last instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
      result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        let wasChanged = oracle.heightChanged;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, doc2, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type, doc2, top2, offset) : this.right.lineAt(value, type, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to, doc2, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to, doc2, top2, offset, f);
        if (to >= rightOffset)
          this.right.forEachLine(from, to, doc2, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to)
          f(mid);
        if (to > mid.to)
          this.right.forEachLine(mid.to + 1, to, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to, nodes) {
      let rightStart = this.left.length + this.break;
      if (to < rightStart)
        return this.balanced(this.left.replace(from, to, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to < this.length) {
        let right = result.length;
        this.decomposeRight(to, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
      let left = this.left.length;
      if (to <= left)
        return this.left.decomposeLeft(to, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to >= left)
          result.push(null);
      }
      if (to > left)
        this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
      if (this.lineStart > -1) {
        let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
        if (last instanceof HeightMapText)
          last.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to;
    }
    point(from, to, deco) {
      if (from < to || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to > from) {
        this.span(from, to);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to) {
      let gap = new HeightMapGap(to - from);
      if (this.oracle.doc.lineAt(from).to == to)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last instanceof HeightMapText)
        return last;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to, a, b) {
      if (from < to || a && a.heightRelevant || b && b.heightRelevant)
        addRange(from, to, this.changes, 5);
    }
  };
  function visiblePixelRange(dom2, paddingTop) {
    let rect = dom2.getBoundingClientRect();
    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
    let body = dom2.ownerDocument.body;
    for (let parent = dom2.parentNode; parent && parent != body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style2 = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style2.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = Math.min(bottom, parentRect.bottom);
        }
        parent = style2.position == "absolute" || style2.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom2, paddingTop) {
    let rect = dom2.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to, size2) {
      this.from = from;
      this.to = to;
      this.size = size2;
    }
    static same(a, b) {
      if (a.length != b.length)
        return false;
      for (let i2 = 0; i2 < a.length; i2++) {
        let gA = a[i2], gB = b[i2];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size2, vertical) {
      super();
      this.size = size2;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state3) {
      this.state = state3;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.heightOracle = new HeightOracle();
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.RTL;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      this.stateDeco = state3.facet(decorations).filter((d) => typeof d != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state3.doc), [new ChangedRange(0, 0, 0, state3.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i2 = 0; i2 <= 1; i2++) {
        let pos = i2 ? main.head : main.anchor;
        if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
          let { from, to } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to));
        }
      }
      this.viewports = viewports.sort((a, b) => a.from - b.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update2, scrollTarget = null) {
      this.state = update2.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
      let contentChanges = update2.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update2 ? update2.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update2.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update2.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update2.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update2.changes.empty || update2.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update2.changes)));
      update2.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update2.selectionSet && update2.view.lineWrapping && update2.state.selection.main.empty && update2.state.selection.main.assoc)
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom2 = view.contentDOM, style2 = window.getComputedStyle(dom2);
      let oracle = this.heightOracle;
      let whiteSpace = style2.whiteSpace;
      this.defaultTextDirection = style2.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom2.clientHeight;
      this.contentDOMHeight = dom2.clientHeight;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style2.paddingTop) || 0, paddingBottom = parseInt(style2.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom2, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView)
        return 0;
      let contentWidth = dom2.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth } = view.docView.measureTextSize();
          refresh = oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({ from, to }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
      let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.state.doc, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current) {
      let gaps = [];
      if (this.defaultTextDirection != Direction.LTR)
        return gaps;
      for (let line of this.viewportLines) {
        if (line.length < 4e3)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < 4e3)
          continue;
        let viewFrom, viewTo;
        if (this.heightOracle.lineWrapping) {
          let marginHeight = 2e3 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          viewFrom = findPosition(structure, (this.visibleTop - line.top - marginHeight) / line.height);
          viewTo = findPosition(structure, (this.visibleBottom - line.top + marginHeight) / line.height);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = 2e3 * this.heightOracle.charWidth;
          viewFrom = findPosition(structure, (this.pixelViewport.left - marginWidth) / totalWidth);
          viewTo = findPosition(structure, (this.pixelViewport.right + marginWidth) / totalWidth);
        }
        let outside = [];
        if (viewFrom > line.from)
          outside.push({ from: line.from, to: viewFrom });
        if (viewTo < line.to)
          outside.push({ from: viewTo, to: line.to });
        let sel = this.state.selection.main;
        if (sel.from >= line.from && sel.from <= line.to)
          cutRange(outside, sel.from - 10, sel.from + 10);
        if (!sel.empty && sel.to >= line.from && sel.to <= line.to)
          cutRange(outside, sel.to - 10, sel.to + 10);
        for (let { from, to } of outside)
          if (to - from > 1e3) {
            gaps.push(find(current, (gap) => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < 1e3 && Math.abs(gap.to - to) < 1e3) || new LineGap(from, to, this.gapSize(line, from, to, structure)));
          }
      }
      return gaps;
    }
    gapSize(line, from, to, structure) {
      let fraction = findFraction(structure, to) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to) {
          ranges.push({ from, to });
        },
        point() {
        }
      }, 20);
      let changed2 = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i2) => r.from != ranges[i2].from || r.to != ranges[i2].to);
      this.visibleRanges = ranges;
      return changed2 ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to, {
      span() {
      },
      point(from2, to2) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to2;
      }
    }, 20);
    if (pos < to) {
      ranges.push({ from: pos, to });
      total += to - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i2 = 0; ; i2++) {
      let { from, to } = ranges[i2], size2 = to - from;
      if (dist <= size2)
        return from + dist;
      dist -= size2;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
      if (pos <= to) {
        counted += pos - from;
        break;
      }
      counted += to - from;
    }
    return counted / structure.total;
  }
  function cutRange(ranges, from, to) {
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let r = ranges[i2];
      if (r.from < to && r.to > from) {
        let pieces = [];
        if (r.from < from)
          pieces.push({ from: r.from, to: from });
        if (r.to > to)
          pieces.push({ from: to, to: r.to });
        ranges.splice(i2, 1, ...pieces);
        i2 += pieces.length - 1;
      }
    }
  }
  function find(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n) {
      return n;
    },
    fromDOM(n) {
      return n;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc2, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to }) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        let bottom = heightMap.lineAt(to, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from, to, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n < vp.top)
          return domBase + (n - base2) * this.scale;
        if (n <= vp.bottom)
          return vp.domTop + (n - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n < vp.domTop)
          return base2 + (n - domBase) / this.scale;
        if (n <= vp.domBottom)
          return vp.top + (n - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
          if (m == "&")
            return main;
          if (!scopes || !scopes[m])
            throw new RangeError(`Unsupported selector: ${m}`);
          return scopes[m];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&.cm-editor": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere"
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
      zIndex: -1,
      contain: "size style"
    },
    ".cm-selectionBackground": {
      position: "absolute"
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      zIndex: 100,
      contain: "size style",
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      position: "absolute",
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
    "&dark .cm-activeLine": { backgroundColor: "#223039" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view, onChange, onScrollChanged) {
      this.view = view;
      this.onChange = onChange;
      this.onScrollChanged = onScrollChanged;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.scrollTargets = [];
      this.intersection = null;
      this.resize = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      window.addEventListener("resize", this.onResize = this.onResize.bind(this));
      if (typeof ResizeObserver == "function") {
        this.resize = new ResizeObserver(() => {
          if (this.view.docView.lastUpdate < Date.now() - 75)
            this.onResize();
        });
        this.resize.observe(view.scrollDOM);
      }
      window.addEventListener("beforeprint", this.onPrint = this.onPrint.bind(this));
      this.start();
      window.addEventListener("scroll", this.onScroll = this.onScroll.bind(this));
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
      this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    onScroll(e2) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e2);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i2) => g != gaps[i2]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context2 = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context2 && context2.ignoreEvent(event))
        return;
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { root } = this.view, domSel = getSelection(root);
      let range = browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM && safariSelectionRangeHack(this.view) || domSel;
      if (this.selectionRange.eq(range))
        return false;
      this.selectionRange.setRange(range);
      return this.selectionChanged = true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i2 = 0, changed2 = null;
      for (let dom2 = this.dom; dom2; ) {
        if (dom2.nodeType == 1) {
          if (!changed2 && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom2)
            i2++;
          else if (!changed2)
            changed2 = this.scrollTargets.slice(0, i2);
          if (changed2)
            changed2.push(dom2);
          dom2 = dom2.assignedSlot || dom2.parentNode;
        } else if (dom2.nodeType == 11) {
          dom2 = dom2.host;
        } else {
          break;
        }
      }
      if (i2 < this.scrollTargets.length && !changed2)
        changed2 = this.scrollTargets.slice(0, i2);
      if (changed2) {
        for (let dom2 of this.scrollTargets)
          dom2.removeEventListener("scroll", this.onScroll);
        for (let dom2 of this.scrollTargets = changed2)
          dom2.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key2, keyCode) {
      if (!this.delayedAndroidKey)
        requestAnimationFrame(() => {
          let key3 = this.delayedAndroidKey;
          this.delayedAndroidKey = null;
          this.delayedFlush = -1;
          if (!this.flush())
            dispatchKey(this.view.contentDOM, key3.key, key3.keyCode);
        });
      if (!this.delayedAndroidKey || key2 == "Enter")
        this.delayedAndroidKey = { key: key2, keyCode };
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = window.setTimeout(() => {
          this.delayedFlush = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        window.clearTimeout(this.delayedFlush);
        this.delayedFlush = -1;
        this.flush();
      }
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from = -1, to = -1, typeOver = false;
      for (let record of records) {
        let range = this.readMutation(record);
        if (!range)
          continue;
        if (range.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to } = range);
        } else {
          from = Math.min(range.from, from);
          to = Math.max(range.to, to);
        }
      }
      return { from, to, typeOver };
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return;
      if (readSelection)
        this.readSelectionRange();
      let { from, to, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return;
      this.selectionChanged = false;
      let startState = this.view.state;
      let handled = this.onChange(from, to, typeOver);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom2 of this.scrollTargets)
        dom2.removeEventListener("scroll", this.onScroll);
      window.removeEventListener("scroll", this.onScroll);
      window.removeEventListener("resize", this.onResize);
      window.removeEventListener("beforeprint", this.onPrint);
      this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
    }
  };
  function findChild(cView, dom2, dir) {
    while (dom2) {
      let curView = ContentView.get(dom2);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom2.parentNode;
      dom2 = parent != cView.dom ? parent : dir > 0 ? dom2.nextSibling : dom2.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function applyDOMChange(view, start, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main;
    if (start > -1) {
      let bounds = view.docView.domBoundsAround(start, end, 0);
      if (!bounds || view.state.readOnly)
        return false;
      let { from, to } = bounds;
      let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(bounds.startDOM, bounds.endDOM);
      let preferredPos = sel.from, preferredSide = null;
      if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
      newSel = selectionFromPoints(selPoints, from);
    } else if (view.hasFocus || !view.state.facet(editable)) {
      let domSel = view.observer.selectionRange;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      if (head != sel.head || anchor != sel.anchor)
        newSel = EditorSelection.single(anchor, head);
    }
    if (!change && !newSel)
      return false;
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && change.insert.toString() == ".")
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    if (change) {
      let startState = view.state;
      if (browser.ios && view.inputState.flushIOSKey(view))
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
        return true;
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          let replaced = view.state.sliceDoc(change.from, change.to);
          let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
          let offset = sel.to - change.to, size2 = sel.to - sel.from;
          tr = startState.changeByRange((range) => {
            if (range.from == sel.from && range.to == sel.to)
              return { changes, range: mainSel || range.map(changes) };
            let to = range.to - offset, from = to - replaced.length;
            if (range.to - range.from != size2 || view.state.sliceDoc(from, to) != replaced || compositionRange && range.to >= compositionRange.from && range.from <= compositionRange.to)
              return { range };
            let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, { scrollIntoView: true, userEvent });
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
      from++;
    if (from == minLen && a.length == b.length)
      return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var EditorView = class {
    constructor(config2 = {}) {
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this.root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create());
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this, (from, to, typeOver) => {
        return applyDOMChange(this, from, to, typeOver);
      }, (event) => {
        this.inputState.runScrollHandlers(this, event);
        if (this.observer.intersecting)
          this.measure();
      });
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config2.parent)
        config2.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction2 ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update2;
      let state3 = this.state;
      for (let tr of transactions) {
        if (tr.startState != state3)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state3 = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state3;
        return;
      }
      this.observer.clear();
      if (state3.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state3);
      update2 = ViewUpdate.create(this, state3, transactions);
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e2 of tr.effects)
            if (e2.is(scrollIntoView))
              scrollTarget = e2.value;
        }
        this.viewState.update(update2, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update2.changes);
        if (!update2.empty) {
          this.updatePlugins(update2);
          this.inputState.update(update2);
        }
        redrawn = this.docView.update(update2);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update2.startState.facet(theme) != update2.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update2.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update2);
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update2) {
      let prevSpecs = update2.startState.facet(viewPlugin), specs = update2.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update2;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update2)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p of this.plugins)
          p.mustUpdate = update2;
      }
      for (let i2 = 0; i2 < this.plugins.length; i2++)
        this.plugins[i2].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.flush();
      let updated = null;
      try {
        for (let i2 = 0; ; i2++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let changed2 = this.viewState.measure(this);
          if (!changed2 && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i2 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed2 & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m) => {
            try {
              return m.read(this);
            } catch (e2) {
              logException(this.state, e2);
              return BadMeasure;
            }
          });
          let update2 = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update2.flags |= changed2;
          if (!updated)
            updated = update2;
          else
            updated.flags |= changed2;
          this.updateState = 2;
          if (!update2.empty) {
            this.updatePlugins(update2);
            this.inputState.update(update2);
            this.updateAttrs();
            redrawn = this.docView.update(update2);
          }
          for (let i3 = 0; i3 < measuring.length; i3++)
            if (measured[i3] != BadMeasure) {
              try {
                let m = measuring[i3];
                if (m.write)
                  m.write(measured[i3], this);
              } catch (e2) {
                logException(this.state, e2);
              }
            }
          if (this.viewState.scrollTarget) {
            this.docView.scrollIntoView(this.viewState.scrollTarget);
            this.viewState.scrollTarget = null;
            scrolled = true;
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed2 = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed2;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
            if (this.measureRequests[i2].key === request.key) {
              this.measureRequests[i2] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start, forward, by) {
      return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    moveByGroup(start, forward) {
      return skipAtoms(this, start, moveByChar(this, start, forward, (initial) => byGroup(this, start.head, initial)));
    }
    moveToLineBoundary(start, forward, includeWrap = true) {
      return moveToLineBoundary(this, start, forward, includeWrap);
    }
    moveVertically(start, forward, distance) {
      return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (document.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options2 = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
    }
    static domEventHandlers(handlers3) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers3 });
    }
    static theme(spec, options2) {
      let prefix2 = StyleModule.newName();
      let result = [theme.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))];
      if (options2 && options2.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to, dir, order) {
      this.from = from;
      this.to = to;
      this.dir = dir;
      this.order = order;
    }
    static update(cache2, changes) {
      if (changes.empty)
        return cache2;
      let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
      for (let i2 = Math.max(0, cache2.length - 10); i2 < cache2.length; i2++) {
        let entry = cache2[i2];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
      let source2 = sources[i2], value = typeof source2 == "function" ? source2(view) : source2;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name3, platform) {
    const parts = name3.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i2 = 0; i2 < parts.length - 1; ++i2) {
      const mod = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod))
        shift2 = true;
      else if (/^mod$/i.test(mod)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name3, event, shift2) {
    if (event.altKey)
      name3 = "Alt-" + name3;
    if (event.ctrlKey)
      name3 = "Ctrl-" + name3;
    if (event.metaKey)
      name3 = "Meta-" + name3;
    if (shift2 !== false && event.shiftKey)
      name3 = "Shift-" + name3;
    return name3;
  }
  var handleKeyEvents = /* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  });
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state3) {
    let bindings2 = state3.facet(keymap);
    let map = Keymaps.get(bindings2);
    if (!map)
      Keymaps.set(bindings2, map = buildKeymap(bindings2.reduce((a, b) => a.concat(b), [])));
    return map;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings2, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name3, is) => {
      let current = isPrefix[name3];
      if (current == null)
        isPrefix[name3] = is;
      else if (current != is)
        throw new Error("Key binding " + name3 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key2, command2, preventDefault) => {
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key2.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i2 = 1; i2 < parts.length; i2++) {
        let prefix2 = parts.slice(0, i2).join(" ");
        checkPrefix(prefix2, true);
        if (!scopeObj[prefix2])
          scopeObj[prefix2] = {
            preventDefault: true,
            commands: [(view) => {
              let ourObj = storedPrefix = { view, prefix: prefix2, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
      binding.commands.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b of bindings2) {
      let name3 = b[platform] || b.key;
      if (!name3)
        continue;
      for (let scope of b.scope ? b.scope.split(" ") : ["editor"]) {
        add2(scope, name3, b.run, b.preventDefault);
        if (b.shift)
          add2(scope, "Shift-" + name3, b.shift, b.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map, event, view, scope) {
    let name3 = keyName(event), isChar = name3.length == 1 && name3 != " ";
    let prefix2 = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix2 = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.commands)
          if (cmd2(view))
            return true;
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map[scope], baseName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix2 + modifiers(name3, event, !isChar)]))
        return true;
      if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.keyCode]) && baseName != name3) {
        if (runFor(scopeObj[prefix2 + modifiers(baseName, event, true)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix2 + modifiers(name3, event, true)]))
          return true;
      }
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a, b) => Math.min(a, b),
        drawRangeCursor: (a, b) => a || b
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      drawSelectionPlugin,
      hideNativeSelection
    ];
  }
  var Piece = class {
    constructor(left, top2, width, height, className) {
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
      this.className = className;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width >= 0)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p) {
      return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
    }
  };
  var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.rangePieces = [];
      this.cursors = [];
      this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
      this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.selectionLayer.className = "cm-selectionLayer";
      this.selectionLayer.setAttribute("aria-hidden", "true");
      this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.cursorLayer.className = "cm-cursorLayer";
      this.cursorLayer.setAttribute("aria-hidden", "true");
      view.requestMeasure(this.measureReq);
      this.setBlinkRate();
    }
    setBlinkRate() {
      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update2) {
      let confChanged = update2.startState.facet(selectionConfig) != update2.state.facet(selectionConfig);
      if (confChanged || update2.selectionSet || update2.geometryChanged || update2.viewportChanged)
        this.view.requestMeasure(this.measureReq);
      if (update2.transactions.some((tr) => tr.scrollIntoView))
        this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      if (confChanged)
        this.setBlinkRate();
    }
    readPos() {
      let { state: state3 } = this.view, conf = state3.facet(selectionConfig);
      let rangePieces = state3.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a, b) => a.concat(b));
      let cursors = [];
      for (let r of state3.selection.ranges) {
        let prim = r == state3.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(this.view, r, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return { rangePieces, cursors };
    }
    drawSel({ rangePieces, cursors }) {
      if (rangePieces.length != this.rangePieces.length || rangePieces.some((p, i2) => !p.eq(this.rangePieces[i2]))) {
        this.selectionLayer.textContent = "";
        for (let p of rangePieces)
          this.selectionLayer.appendChild(p.draw());
        this.rangePieces = rangePieces;
      }
      if (cursors.length != this.cursors.length || cursors.some((c, i2) => !c.eq(this.cursors[i2]))) {
        let oldCursors = this.cursorLayer.children;
        if (oldCursors.length !== cursors.length) {
          this.cursorLayer.textContent = "";
          for (const c of cursors)
            this.cursorLayer.appendChild(c.draw());
        } else {
          cursors.forEach((c, idx) => c.adjust(oldCursors[idx]));
        }
        this.cursors = cursors;
      }
    }
    destroy() {
      this.selectionLayer.remove();
      this.cursorLayer.remove();
    }
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
  }
  function wrappedLine(view, pos, inside2) {
    let range = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
      return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view, to, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range.from, range.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new Piece(left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01, "cm-selectionBackground");
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i2 = 0; i2 < horizontal.length; i2 += 2)
        pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to2, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to3, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to3, to3 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to2 !== null && to2 !== void 0 ? to2 : line.to;
      for (let r of view.visibleRanges)
        if (r.to > start && r.from < end) {
          for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start, Math.min(spanTo, endPos), to2 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start, from2 == null, end, to2 == null, view.textDirection);
      return { top: top2, bottom, horizontal };
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return { top: y, bottom: y, horizontal: [] };
    }
  }
  function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view);
    return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
  }
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update2) {
      var _a2;
      let cursorPos = update2.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update2.startState.field(dropCursorPos) != cursorPos || update2.docChanged || update2.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let pos = this.view.state.field(dropCursorPos);
      let rect = pos != null && this.view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = this.view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        if (pos) {
          this.cursor.style.left = pos.left + "px";
          this.cursor.style.top = pos.top + "px";
          this.cursor.style.height = pos.height + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
  }, {
    eventHandlers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m = re.exec(cursor.value))
          f(pos + m.index, pos + m.index + m[0].length, m);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let { from, to } of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
      if (result.length && result[result.length - 1].to >= from)
        result[result.length - 1].to = to;
      else
        result.push({ from, to });
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config2) {
      let { regexp, decoration, boundary, maxLength = 1e3 } = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder();
      for (let { from, to } of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from, to, (a, b, m) => build.add(a, b, this.getDeco(m, view, a)));
      return build.finish();
    }
    updateDeco(update2, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update2.docChanged)
        update2.changes.iterChanges((_f, _t, from, to) => {
          if (to > update2.view.viewport.from && from < update2.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to, changeTo);
          }
        });
      if (update2.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update2.view);
      if (changeTo > -1)
        return this.updateRange(update2.view, deco.map(update2.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
        if (to > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
          let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start = from;
                break;
              }
            for (; to < toLine.to; to++)
              if (this.boundary.test(toLine.text[to - toLine.from])) {
                end = to;
                break;
              }
          }
          let ranges = [], m;
          if (fromLine == toLine) {
            this.regexp.lastIndex = start - fromLine.from;
            while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) {
              let pos = m.index + fromLine.from;
              ranges.push(this.getDeco(m, view, pos).range(pos, pos + m[0].length));
            }
          } else {
            iterMatches(view.state.doc, this.regexp, start, end, (from2, to2, m2) => ranges.push(this.getDeco(m2, view, from2).range(from2, to2)));
          }
          deco = deco.update({ filterFrom: start, filterTo: end, filter: (from2, to2) => from2 < start || to2 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m, view, pos) => {
            let { doc: doc2 } = view.state;
            let code2 = codePointAt(m[0], 0);
            if (code2 == 9) {
              let line = doc2.lineAt(pos);
              let size2 = view.state.tabSize, col = countColumn(line.text, size2, pos - line.from);
              return Decoration.replace({ widget: new TabWidget((size2 - col % size2) * this.view.defaultCharacterWidth) });
            }
            return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({ widget: new SpecialCharWidget(conf, code2) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update2) {
        let conf = update2.state.facet(specialCharConfig);
        if (update2.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update2.view);
        } else {
          this.decorations = this.decorator.updateDeco(update2, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code2) {
    if (code2 >= 32)
      return DefaultPlaceholder;
    if (code2 == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code2);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options2, code2) {
      super();
      this.options = options2;
      this.code = code2;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update2) {
      if (update2.docChanged || update2.selectionSet)
        this.decorations = this.getDeco(update2.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        if (!r.empty)
          return Decoration.none;
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state3, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
      let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state3.doc.line(i2);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state3.doc.line(i2);
        let start = findColumn(line.text, startCol, state3.tabSize, true);
        if (start > -1) {
          let end = findColumn(line.text, endCol, state3.tabSize);
          ranges.push(EditorSelection.range(line.from + start, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
  }
  function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
  }
  function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
      return null;
    return {
      update(update2) {
        if (update2.docChanged) {
          let newStart = update2.changes.mapPos(update2.startState.doc.line(start.line).from);
          let newLine = update2.state.doc.lineAt(newStart);
          start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
          startSel = startSel.map(update2.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view.state, start, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options2) {
    let filter = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
  }
  var keys3 = {
    Alt: [18, (e2) => e2.altKey],
    Control: [17, (e2) => e2.ctrlKey],
    Shift: [16, (e2) => e2.shiftKey],
    Meta: [91, (e2) => e2.metaKey]
  };
  var showCrosshair = { style: "cursor: crosshair" };
  function crosshairCursor(options2 = {}) {
    let [code2, getter] = keys3[options2.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventHandlers: {
        keydown(e2) {
          this.set(e2.keyCode == code2 || getter(e2));
        },
        keyup(e2) {
          if (e2.keyCode == code2 || !getter(e2))
            this.set(false);
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view) => {
        var _a2;
        return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update2) {
      let input = update2.state.facet(this.facet);
      let tooltips = input.filter((x) => x);
      if (input === this.input) {
        for (let t2 of this.tooltipViews)
          if (t2.update)
            t2.update(update2);
        return false;
      }
      let tooltipViews = [];
      for (let i2 = 0; i2 < tooltips.length; i2++) {
        let tip = tooltips[i2], known = -1;
        if (!tip)
          continue;
        for (let i3 = 0; i3 < this.tooltips.length; i3++) {
          let other = this.tooltips[i3];
          if (other && other.create == tip.create)
            known = i3;
        }
        if (known < 0) {
          tooltipViews[i2] = this.createTooltipView(tip);
        } else {
          let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update2);
        }
      }
      for (let t2 of this.tooltipViews)
        if (tooltipViews.indexOf(t2) < 0)
          t2.dom.remove();
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace() {
    return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      var _a2;
      this.view = view;
      this.inView = true;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      (_a2 = view.dom.ownerDocument.defaultView) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update2) {
      if (update2.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update2);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update2.geometryChanged;
      let newConfig = update2.state.facet(tooltipConfig);
      if (newConfig.position != this.position) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews)
          t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews)
          this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip) {
      let tooltipView = tooltip.create(this.view);
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      this.container.appendChild(tooltipView.dom);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      return tooltipView;
    }
    destroy() {
      var _a2, _b;
      (_a2 = this.view.dom.ownerDocument.defaultView) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("resize", this.measureSoon);
      for (let { dom: dom2 } of this.manager.tooltipViews)
        dom2.remove();
      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor = this.view.dom.getBoundingClientRect();
      return {
        editor,
        parent: this.parent ? this.container.getBoundingClientRect() : editor,
        pos: this.manager.tooltips.map((t2, i2) => {
          let tv = this.manager.tooltipViews[i2];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom: dom2 }) => dom2.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
      };
    }
    writeMeasure(measured) {
      let { editor, space } = measured;
      let others = [];
      for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
        let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom: dom2 } = tView;
        let pos = measured.pos[i2], size2 = measured.size[i2];
        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
          dom2.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size2.right - size2.left, height = size2.bottom - size2.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size2.width > space.right - space.left ? ltr ? space.left : space.right - size2.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = !!tooltip.above;
        if (!tooltip.strictSide && (above ? pos.top - (size2.bottom - size2.top) - offset.y < space.top : pos.bottom + (size2.bottom - size2.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
          above = !above;
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others)
            if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
              top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom2.style.top = top2 - measured.parent.top + "px";
          dom2.style.left = left - measured.parent.left + "px";
        } else {
          dom2.style.top = top2 + "px";
          dom2.style.left = left + "px";
        }
        if (arrow)
          arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
        if (tView.overlap !== true)
          others.push({ left, top: top2, right, bottom: top2 + height });
        dom2.classList.toggle("cm-tooltip-above", above);
        dom2.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned();
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventHandlers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class {
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
    static create(view) {
      return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned() {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned();
      }
    }
    update(update2) {
      this.manager.update(update2);
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state3) => {
    let tooltips = state3.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source2, field, setHover, hoverTime) {
      this.view = view;
      this.source = source2;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { lastMove } = this;
      let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null)
        return;
      let posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
        return;
      let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result)
              this.view.dispatch({ effects: this.setHover.of(result) });
          }
        }, (e2) => logException(this.view.state, e2, "hover tooltip"));
      } else if (open) {
        this.view.dispatch({ effects: this.setHover.of(open) });
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let tooltip = this.active;
      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
        let { pos } = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({ effects: this.setHover.of(null) });
          this.pending = null;
        }
      }
    }
    mouseleave() {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active)
        this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  function isInTooltip(elt) {
    for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
      if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
        return true;
    return false;
  }
  function isOverRange(view, from, to, x, y, margin) {
    let range = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);
    range.setEnd(toDOM.node, toDOM.offset);
    range.setStart(fromDOM.node, fromDOM.offset);
    let rects = range.getClientRects();
    range.detach();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
      if (dist <= margin)
        return true;
    }
    return false;
  }
  function hoverTooltip(source2, options2 = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && (options2.hideOnChange && (tr.docChanged || tr.selection) || options2.hideOn && options2.hideOn(tr, value)))
          return null;
        if (value && tr.docChanged) {
          let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null)
            return null;
          let copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null)
            copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = null;
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(view, source2, hoverState, setHover, options2.hoverTime || 300)),
      showHoverTooltipHost
    ];
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c of configs) {
        topContainer = topContainer || c.topContainer;
        bottomContainer = bottomContainer || c.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p) => p.top));
      this.bottom.sync(this.panels.filter((p) => !p.top));
      for (let p of this.panels) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    }
    update(update2) {
      let conf = update2.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update2.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update2.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update2.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update2.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update2);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p of mount) {
          p.dom.classList.add("cm-panel");
          if (p.mount)
            p.mount();
        }
      } else {
        for (let p of this.panels)
          if (p.update)
            p.update(update2);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p of this.panels)
        if (p.destroy && panels.indexOf(p) < 0)
          p.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom2) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update2) {
      if (this.updateGutters(update2)) {
        let vpA = this.prevViewport, vpB = update2.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update2.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update2.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        let text;
        if (Array.isArray(line.type)) {
          for (let b of line.type)
            if (b.type == BlockType.Text) {
              text = b;
              break;
            }
        } else {
          text = line.type == BlockType.Text ? line : void 0;
        }
        if (!text)
          continue;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text, classSet);
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update2) {
      let prev = update2.startState.facet(activeGutters), cur2 = update2.state.facet(activeGutters);
      let change = update2.docChanged || update2.heightChanged || update2.viewportChanged || !RangeSet.eq(update2.startState.facet(gutterLineClass), update2.state.facet(gutterLineClass), update2.view.viewport.from, update2.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update2))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update2);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g of this.gutters) {
          g.dom.remove();
          if (gutters2.indexOf(g) < 0)
            g.destroy();
        }
        for (let g of gutters2)
          this.dom.appendChild(g.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last = gutter2.elements.pop();
        gutter2.dom.removeChild(last.dom);
        last.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update2) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update2.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update2);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update2.view, 0, 0, [updated]);
      }
      let vp = update2.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update2) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c = marker.elementClass;
          if (c)
            cls += " " + c;
          for (let i2 = iOld; i2 < this.markers.length; i2++)
            if (this.markers[i2].compare(marker)) {
              skipTo = i2;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a, b) {
    if (a.length != b.length)
      return false;
    for (let i2 = 0; i2 < a.length; i2++)
      if (!a[i2].compare(b[i2]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a, b) {
          let result = Object.assign({}, a);
          for (let event in b) {
            let exists = result[event], add2 = b[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state3) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m) => m.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update2) => update2.startState.facet(lineNumberConfig) != update2.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update2) {
      let max2 = formatNumber(update2.view, maxLineNumber(update2.view.state.doc.lines));
      return max2 == spacer.number ? spacer : new NumberMarker(max2);
    },
    domEventHandlers: state3.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
      last = last * 10 + 9;
    return last;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state3) => {
    let marks2 = [], last = -1;
    for (let range of state3.selection.ranges)
      if (range.empty) {
        let linePos = state3.doc.lineAt(range.head).from;
        if (linePos > last) {
          last = linePos;
          marks2.push(activeLineGutterMarker.range(linePos));
        }
      }
    return RangeSet.of(marks2);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to) {
      this.from = from;
      this.to = to;
    }
  };
  var NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type) => {
        let result = match(type);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class {
    constructor(name3, props, id2, flags = 0) {
      this.name = name3;
      this.props = props;
      this.id = id2;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name3) {
      if (typeof name3 == "string") {
        if (this.name == name3)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name3) > -1 : false;
      }
      return this.id == name3;
    }
    static match(map) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map)
        for (let name3 of prop.split(" "))
          direct[name3] = map[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
          let found = direct[i2 < 0 ? node.name : groups[i2]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type, children, positions, length, props) {
      this.type = type;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let { enter, leave, from = 0, to = this.length } = spec;
      for (let c = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c) !== false)) {
          if (c.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c.type.isAnonymous)
            leave(c);
          if (c.nextSibling())
            break;
          if (!c.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id2 in this.props)
          result.push([+id2, this.props[id2]]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set2) {
      this.buffer = buffer;
      this.length = length;
      this.set = set2;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
      let type = this.set.types[id2], result = type.name;
      if (/\W/.test(result) && !type.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
        if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
          pick = i2;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to) {
      let b = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i2 = startI, j = 0; i2 < endI; ) {
        copy[j++] = b[i2++];
        copy[j++] = b[i2++] - from;
        copy[j++] = b[i2++] - from;
        copy[j++] = b[i2++] - startI;
      }
      return new TreeBuffer(copy, to - from, this.set);
    }
  };
  function checkSide(side, pos, from, to) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to >= pos && from < pos;
      case 0:
        return from < pos && to > pos;
      case 1:
        return from <= pos && to > pos;
      case 2:
        return to > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from, index, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i2, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e2 = dir > 0 ? children.length : -1; i2 != e2; i2 += dir) {
          let next = children[i2], start = positions[i2] + parent.from;
          if (!checkSide(side, pos, start, start + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i2, start), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start, i2, parent);
            let inner = new TreeNode(next, start, i2, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i2 = parent.index + dir;
        else
          i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  function getChildren(node, type, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null) {
      while (!cur2.type.is(before))
        if (!cur2.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context2, i2 = context2.length - 1) {
    for (let p = node.parent; i2 >= 0; p = p.parent) {
      if (!p)
        return false;
      if (!p.type.isAnonymous) {
        if (context2[i2] && context2[i2] != p.name)
          return false;
        i2--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start;
    }
  };
  var BufferNode = class {
    constructor(context2, _parent, index) {
      this.context = context2;
      this._parent = _parent;
      this.index = index;
      this.type = context2.buffer.set.types[context2.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type, before = null, after = null) {
      let r = getChildren(this, type, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
      return getChildren(this, type, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  var TreeCursor = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n = node._parent; n; n = n._parent)
          this.stack.unshift(n.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type) {
      this.index = index;
      let { start, buffer } = this.buffer;
      this.type = type || buffer.set.types[buffer.buffer[index]];
      this.from = start + buffer.buffer[index + 1];
      this.to = start + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d < 0 ? 0 : this.stack[d] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
          return this.yieldBuf(after);
      }
      return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i2 = 0; i2 < this.index; i2++)
            if (buffer.buffer.buffer[i2 + 3] < this.index)
              return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1)
          for (let i2 = index + dir, e2 = dir < 0 ? -1 : parent._tree.children.length; i2 != e2; i2 += dir) {
            let child = parent._tree.children[i2];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan:
          for (let index = this.index, d = this.stack.length; d >= 0; ) {
            for (let c = cache2; c; c = c._parent)
              if (c.index == index) {
                if (index == this.index)
                  return c;
                result = c;
                depth = d + 1;
                break scan;
              }
            index = this.stack[--d];
          }
      }
      for (let i2 = depth; i2 < this.stack.length; i2++)
        result = new BufferNode(this.buffer, result, this.stack[i2]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context2) {
      if (!this.buffer)
        return matchNodeContext(this.node, context2);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i2 = context2.length - 1, d = this.stack.length - 1; i2 >= 0; d--) {
        if (d < 0)
          return matchNodeContext(this.node, context2, i2);
        let type = types2[buffer.buffer[this.stack[d]]];
        if (!type.isAnonymous) {
          if (context2[i2] && context2[i2] != type.name)
            return false;
          i2--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let { id: id2, start, end, size: size2 } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size2 < 0) {
        cursor.next();
        if (size2 == -1) {
          let node2 = reused[id2];
          children2.push(node2);
          positions2.push(start - parentStart);
          return;
        } else if (size2 == -3) {
          contextHash = id2;
          return;
        } else if (size2 == -4) {
          lookAhead = id2;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size2}`);
        }
      }
      let type = types2[id2], node, buffer2;
      let startPos = start - parentStart;
      if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size2;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id2 >= minRepeatType ? id2 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type);
          node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
        } else {
          node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
        if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
          if (!lastI && last.type == type && last.length == length2)
            return last;
          if (lookAheadProp = last.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
        }
        return makeTree(type, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i2, from, to, type, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i2) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to));
      positions2.push(from - base2);
    }
    function makeTree(type, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair = [NodeProp.contextHash, contextHash];
        props = props ? [pair].concat(props) : [pair];
      }
      if (lookAhead2 > 25) {
        let pair = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair].concat(props) : [pair];
      }
      return new Tree(type, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size2 = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size2;
            result.start = start;
            result.skip = skip;
            skip += 4;
            size2 += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start = nodeStart2;
          size2 += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size2 == maxSize) {
        result.size = size2;
        result.start = start;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id: id2, start, end, size: size2 } = cursor;
      cursor.next();
      if (size2 >= 0 && id2 < minRepeatType) {
        let startIndex = index;
        if (size2 > 4) {
          let endPos = cursor.pos - (size2 - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start - bufferStart;
        buffer2[--index] = id2;
      } else if (size2 == -3) {
        contextHash = id2;
      } else if (size2 == -4) {
        lookAhead = id2;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size2 = nodeSizeCache.get(node);
    if (size2 == null) {
      size2 = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size2 = 1;
          break;
        }
        size2 += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size2);
    }
    return size2;
  }
  function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
    let total = 0;
    for (let i2 = from; i2 < to; i2++)
      total += nodeSize(balanceType, children[i2]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to2, offset) {
      for (let i2 = from2; i2 < to2; ) {
        let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
        i2++;
        for (; i2 < to2; i2++) {
          let nextSize = nodeSize(balanceType, children2[i2]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i2 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start);
      }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from, to, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse4 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse4.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to) {
      return this.string.slice(from, to);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set2, base2, modified) {
      this.set = set2;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set2 = [], tag = new Tag(set2, base2, mods);
      for (let m of mods)
        m.instances.push(tag);
      let configs = permute(mods);
      for (let parent of base2.set)
        for (let config2 of configs)
          set2.push(Modifier.get(parent, config2));
      return tag;
    }
  };
  function sameArray2(a, b) {
    return a.length == b.length && a.every((x, i2) => x == b[i2]);
  }
  function permute(array) {
    let result = [array];
    for (let i2 = 0; i2 < array.length; i2++) {
      for (let a of permute(array.slice(0, i2).concat(array.slice(i2 + 1))))
        result.push(a);
    }
    return result;
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
            pos += m[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last = pieces.length - 1, inner = pieces[last];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context2, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context2;
      this.next = next;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  function tagHighlighter(tags2, options2) {
    let map = /* @__PURE__ */ Object.create(null);
    for (let style2 of tags2) {
      if (!Array.isArray(style2.tag))
        map[style2.tag.id] = style2.class;
      else
        for (let tag of style2.tag)
          map[tag.id] = style2.class;
    }
    let { scope, all = null } = options2 || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to) {
      if (to > this.at && this.class)
        this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
      let { type, from: start, to: end } = cursor;
      if (start >= to || end <= from)
        return;
      if (type.isTop)
        highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type));
      let cls = inheritedClass;
      let rule = type.prop(ruleNodeProp), opaque = false;
      while (rule) {
        if (!rule.context || cursor.matchContext(rule.context)) {
          let tagCls = highlightTags(highlighters, rule.tags);
          if (tagCls) {
            if (cls)
              cls += " ";
            cls += tagCls;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + tagCls;
            else if (rule.mode == 0)
              opaque = true;
          }
          break;
        }
        rule = rule.next;
      }
      this.startSpan(cursor.from, cls);
      if (opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
        let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i2 = 0, pos = start; ; i2++) {
          let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
          let nextPos = next ? next.from + start : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(to, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to)
            break;
          pos = next.to + start;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from)
            continue;
          if (cursor.from >= to)
            break;
          this.highlightRange(cursor, from, to, inheritedClass, highlighters);
          this.startSpan(Math.min(to, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  var t = Tag.define;
  var comment = t();
  var name2 = t();
  var typeName = t(name2);
  var propertyName = t(name2);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name: name2,
    variableName: t(name2),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name2),
    labelName: t(name2),
    namespace: t(name2),
    macroName: t(name2),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    constructor(data, parser, extraExtensions = []) {
      this.data = data;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state3, pos, side) => state3.facet(languageDataFacetAt(state3, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state3, pos, side = -1) {
      return languageDataFacetAt(state3, pos, side) == this.data;
    }
    findRegions(state3) {
      let lang = state3.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state3.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({ from: r.from + from, to: r.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size2 = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size2)
              return;
          }
        }
        for (let i2 = 0; i2 < tree.children.length; i2++) {
          let ch = tree.children[i2];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i2] + from);
        }
      };
      explore(syntaxTree(state3), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state3, pos, side) {
    let topLang = state3.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state3).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  function syntaxTree(state3) {
    let field = state3.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2, length = doc2.length) {
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to >= this.cursorPos)
        return this.doc.sliceString(from, to);
      else
        return this.string.slice(from - stringStart, to - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser, state3, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser;
      this.state = state3;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser, state3, viewport) {
      return new ParseContext(parser, state3, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
            if (from < to)
              skipped.push({ from, to });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i2 = 0; i2 < this.skipped.length; i2++) {
        let { from, to } = this.skipped[i2];
        if (from < viewport.to && to > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to);
          this.skipped.splice(i2--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to) {
      this.skipped.push({ from, to });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to = ranges[ranges.length - 1].to;
          let parser = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to;
              return new Tree(NodeType.none, [], [], to - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
  }
  var LanguageState = class {
    constructor(context2) {
      this.context = context2;
      this.tree = context2.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state3) {
      let vpTo = Math.min(3e3, state3.doc.length);
      let parseState = ParseContext.create(state3.facet(language).parser, state3, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e2 of tr.effects)
        if (e2.is(Language.setState))
          return e2.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(() => {
        idle = requestIdleCallback(callback, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update2) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update2.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update2.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state: state3 } = this.view, field = state3.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state3.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state: state3, viewport: { to: vpTo } } = this.view, field = state3.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state3.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: [Language.state, parseWorker]
  });
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      if (!/^(?: +|\t+)$/.test(values[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return values[0];
    }
  });
  function getIndentUnit(state3) {
    let unit = state3.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state3.tabSize * unit.length : unit.length;
  }
  function indentString(state3, cols) {
    let result = "", ts = state3.tabSize;
    if (state3.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (let i2 = 0; i2 < cols; i2++)
      result += " ";
    return result;
  }
  function getIndentation(context2, pos) {
    if (context2 instanceof EditorState)
      context2 = new IndentContext(context2);
    for (let service of context2.state.facet(indentService)) {
      let result = service(context2, pos);
      if (result != null)
        return result;
    }
    let tree = syntaxTree(context2.state);
    return tree ? syntaxIndentation(context2, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state3, options2 = {}) {
      this.state = state3;
      this.options = options2;
      this.unit = getIndentUnit(state3);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text, from } = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context2) {
    let tree = context2.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context2.options.simulateBreak;
    let openLine = context2.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context2, align, units, closing2, closedAt) {
    let after = context2.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context2.pos + space;
    let aligned = align ? bracketedAligned(context2) : null;
    if (aligned)
      return closed ? context2.column(aligned.from) : context2.column(aligned.to);
    return context2.baseIndent + (closed ? 0 : context2.unit * units);
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr;
      let { state: state3 } = tr, last = -1, changes = [];
      for (let { head: head2 } of state3.selection.ranges) {
        let line2 = state3.doc.lineAt(head2);
        if (line2.from == last)
          continue;
        last = line2.from;
        let indent = getIndentation(state3, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state3, indent);
        if (cur2 != norm)
          changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
      }
      return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxFolding(state3, start, end) {
    let tree = syntaxTree(state3);
    if (tree.length < end)
      return null;
    let inner = tree.resolveInner(end);
    let found = null;
    for (let cur2 = inner; cur2; cur2 = cur2.parent) {
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state3.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state3);
        if (value && value.from <= end && value.from >= start && value.to > end)
          found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state3, lineStart, lineEnd) {
    for (let service of state3.facet(foldService)) {
      let result = service(state3, lineStart, lineEnd);
      if (result)
        return result;
    }
    return syntaxFolding(state3, lineStart, lineEnd);
  }
  function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? void 0 : { from, to };
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head))
        continue;
      lines.push(view.lineBlockAt(head));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e2 of tr.effects) {
        if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to))
          folded = folded.update({ add: [foldWidget.range(e2.value.from, e2.value.to)] });
        else if (e2.is(unfoldEffect))
          folded = folded.update({
            filter: (from, to) => e2.value.from != from || e2.value.to != to,
            filterFrom: e2.value.from,
            filterTo: e2.value.to
          });
      }
      if (tr.selection) {
        let onSelection = false, { head } = tr.selection.main;
        folded.between(head, head, (a, b) => {
          if (a < head && b > head)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head,
            filterTo: head,
            filter: (a, b) => b <= head || a >= head
          });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  function findFold(state3, from, to) {
    var _a2;
    let found = null;
    (_a2 = state3.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to, (from2, to2) => {
      if (!found || found.from > from2)
        found = { from: from2, to: to2 };
    });
    return found;
  }
  function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => {
      if (a == from && b == to)
        found = true;
    });
    return found;
  }
  function maybeEnable(state3, other) {
    return state3.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view) => {
    for (let line of selectedLines(view)) {
      let range = foldable(view.state, line.from, line.to);
      if (range) {
        view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view) => {
    if (!view.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view)) {
      let folded = findFold(view.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
      view.dispatch({ effects });
    return effects.length > 0;
  };
  function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view) => {
    let { state: state3 } = view, effects = [];
    for (let pos = 0; pos < state3.doc.length; ) {
      let line = view.lineBlockAt(pos), range = foldable(state3, line.from, line.to);
      if (range)
        effects.push(foldEffect.of(range));
      pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
      view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
  };
  var unfoldAll = (view) => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => {
      effects.push(unfoldEffect.of({ from, to }));
    });
    view.dispatch({ effects });
    return true;
  };
  var foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
  ];
  var defaultConfig = {
    placeholderDOM: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view) {
      let { state: state3 } = view, conf = state3.facet(foldConfig);
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick);
      let element3 = document.createElement("span");
      element3.textContent = conf.placeholderText;
      element3.setAttribute("aria-label", state3.phrase("folded code"));
      element3.title = state3.phrase("unfold");
      element3.className = "cm-foldPlaceholder";
      element3.onclick = onclick;
      return element3;
    }
  }() });
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {}
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view) {
        this.from = view.viewport.from;
        this.markers = this.buildMarkers(view);
      }
      update(update2) {
        if (update2.docChanged || update2.viewportChanged || update2.startState.facet(language) != update2.state.facet(language) || update2.startState.field(foldState, false) != update2.state.field(foldState, false) || syntaxTree(update2.startState) != syntaxTree(update2.state))
          this.markers = this.buildMarkers(update2.view);
      }
      buildMarkers(view) {
        let builder = new RangeSetBuilder();
        for (let line of view.viewportLineBlocks) {
          let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let { domEventHandlers } = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view) {
          var _a2;
          return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range = foldable(view.state, line.from, line.to);
          if (range) {
            view.dispatch({ effects: foldEffect.of(range) });
            return true;
          }
          return false;
        } })
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class {
    constructor(spec, options2) {
      let modSpec;
      function def(spec2) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec2;
        return cls;
      }
      const all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
      const scopeOpt = options2.scope;
      this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type) => type == scopeOpt : void 0;
      this.style = tagHighlighter(spec.map((style2) => ({
        tag: style2.tag,
        class: style2.class || def(Object.assign({}, style2, { tag: null }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options2.themeType;
    }
    static define(specs, options2) {
      return new HighlightStyle(specs, options2 || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state3) {
    let main = state3.facet(highlighterFacet);
    return main.length ? main : state3.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options2) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state3) => {
        return state3.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update2) {
      let tree = syntaxTree(update2.state), highlighters = getHighlighters(update2.state);
      let styleChange = highlighters != getHighlighters(update2.startState);
      if (tree.length < update2.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update2.changes);
      } else if (tree != this.tree || update2.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update2.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to2, style2) => {
          builder.add(from2, to2, this.markCache[style2] || (this.markCache[style2] = Decoration.mark({ class: style2 })));
        }, from, to);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end)
      decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range of tr.state.selection.ranges) {
        if (!range.empty)
          continue;
        let match = matchBrackets(tr.state, range.head, -1, config2) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range.head, 1, config2) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config2));
        if (match)
          decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index + dir]];
    }
    return null;
  }
  function matchBrackets(state3, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state3), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches = matchingNodes(cur2.type, dir, brackets);
      if (matches && cur2.from < cur2.to)
        return matchMarkedBrackets(state3, pos, dir, cur2, matches, brackets);
    }
    return matchPlainBrackets(state3, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = { from: token.from, to: token.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            depth--;
            if (depth == 0)
              return {
                start: firstToken,
                end: cursor.from == cursor.to ? void 0 : { from: cursor.from, to: cursor.to },
                matched: false
              };
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state3, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state3.sliceDoc(pos - 1, pos) : state3.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state3.doc.iterRange(pos, dir > 0 ? state3.doc.length : 0), depth = 0;
    for (let distance = 0; !iter.next().done && distance <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0)
        distance += text.length;
      let basePos = pos + distance * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolve(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name3] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "typeName"],
    ["attribute", "propertyName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name3);
  function warnForPart(part, msg2) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg2);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name3 = tagStr.replace(/ /g, "_"), type = NodeType.define({
      id: typeArray.length,
      name: name3,
      props: [styleTags({ [name3]: tag })]
    });
    typeArray.push(type);
    return type.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let config2 = getConfig2(target.state);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({ state: state3, dispatch }) => {
      if (state3.readOnly)
        return false;
      let tr = f(option, state3);
      if (!tr)
        return false;
      dispatch(state3.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig2(state3, pos = state3.selection.main.head) {
    let data = state3.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state3, { open, close }, from, to) {
    let textBefore = state3.sliceDoc(from - SearchMargin, from);
    let textAfter = state3.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
      startText = endText = state3.sliceDoc(from, to);
    } else {
      startText = state3.sliceDoc(from, from + SearchMargin);
      endText = state3.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state3) {
    let ranges = [];
    for (let r of state3.selection.ranges) {
      let fromLine = state3.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state3.doc.lineAt(r.to);
      let last = ranges.length - 1;
      if (last >= 0 && ranges[last].to > fromLine.from)
        ranges[last].to = toLine.to;
      else
        ranges.push({ from: fromLine.from, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state3, ranges = state3.selection.ranges) {
    let tokens = ranges.map((r) => getConfig2(state3, r.from).block);
    if (!tokens.every((c) => c))
      return null;
    let comments = ranges.map((r, i2) => findBlockComment(state3, tokens[i2], r.from, r.to));
    if (option != 2 && !comments.every((c) => c)) {
      return { changes: state3.changes(ranges.map((range, i2) => {
        if (comments[i2])
          return [];
        return [{ from: range.from, insert: tokens[i2].open + " " }, { from: range.to, insert: " " + tokens[i2].close }];
      })) };
    } else if (option != 1 && comments.some((c) => c)) {
      let changes = [];
      for (let i2 = 0, comment2; i2 < comments.length; i2++)
        if (comment2 = comments[i2]) {
          let token = tokens[i2], { open, close } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state3, ranges = state3.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      for (let pos = from; pos <= to; ) {
        let line = state3.doc.lineAt(pos);
        if (line.from > prevLine && (from == to || to > line.from)) {
          prevLine = line.from;
          let token = getConfig2(state3, pos).line;
          if (!token)
            continue;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i2 = startI; i2 < lines.length; i2++)
          if (lines[i2].indent < lines[i2].line.text.length)
            lines[i2].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty2, single } of lines)
        if (single || !empty2)
          changes.push({ from: line.from + indent, insert: token + " " });
      let changeSet = state3.changes(changes);
      return { changes: changeSet, selection: state3.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to = from + token.length;
          if (line.text[to - line.from] == " ")
            to++;
          changes.push({ from, to });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500
      }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to) => end = to);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state3, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
        let other = from == 0 ? state3.undone : state3.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state3 = state3.isolate();
      if (tr.annotation(Transaction2.addToHistory) === false)
        return !tr.changes.empty ? state3.addMapping(tr.changes.desc) : state3;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction2.time), userEvent = tr.annotation(Transaction2.userEvent);
      if (event)
        state3 = state3.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
      else if (tr.selection)
        state3 = state3.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state3 = state3.isolate();
      return state3;
    },
    toJSON(value) {
      return { done: value.done.map((e2) => e2.toJSON()), undone: value.undone.map((e2) => e2.toJSON()) };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e2, view) {
          let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e2.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({ state: state3, dispatch }) {
      if (!selection && state3.readOnly)
        return false;
      let historyState = state3.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state3, selection);
      if (!tr)
        return false;
      dispatch(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a, b) {
    let ranges = [], isAdjacent2 = false;
    a.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b.iterChangedRanges((_f, _t, f, t2) => {
      for (let i2 = 0; i2 < ranges.length; ) {
        let from = ranges[i2++], to = ranges[i2++];
        if (t2 >= from && f <= to)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length && a.ranges.filter((r, i2) => r.empty != b.ranges[i2].empty).length === 0;
  }
  function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection))
        return this;
      return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state3, selection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1];
      if (selection && event.selectionsAfter.length) {
        return state3.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch) }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state3.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state3, selection) {
    return state3.update({ selection, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state: state3, dispatch }, how) {
    let selection = updateSel(state3.selection, how);
    if (selection.eq(state3.selection))
      return false;
    dispatch(setSel(state3, selection));
    return true;
  }
  function rangeEnd(range, forward) {
    return EditorSelection.cursor(forward ? range.to : range.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range) => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  function interestingNode(state3, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state3.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state3, start, forward) {
    let pos = syntaxTree(state3).resolveInner(start.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state3, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state3, pos.from, 1) : matchBrackets(state3, pos.to, -1)) && match.matched)
      newPos = forward ? match.end.to : match.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range) => {
      if (!range.empty)
        return rangeEnd(range, forward);
      let moved = view.moveVertically(range, forward);
      return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function cursorByPage(view, forward) {
    let { state: state3 } = view, selection = updateSel(state3.selection, (range) => {
      return range.empty ? view.moveVertically(range, forward, Math.min(view.dom.clientHeight, innerHeight)) : rangeEnd(range, forward);
    });
    if (selection.eq(state3.selection))
      return false;
    let startPos = view.coordsAtPos(state3.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
    view.dispatch(setSel(state3, selection), { effects: effect });
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range) => moveByLineBoundary(view, range, false));
  var cursorLineStart = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
  function toMatchingBracket(state3, dispatch, extend3) {
    let found = false, selection = updateSel(state3.selection, (range) => {
      let matching = matchBrackets(state3, range.head, -1) || matchBrackets(state3, range.head, 1) || range.head > 0 && matchBrackets(state3, range.head - 1, 1) || range.head < state3.doc.length && matchBrackets(state3, range.head + 1, -1);
      if (!matching || !matching.end)
        return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend3 ? EditorSelection.range(range.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch(setSel(state3, selection));
    return true;
  }
  var cursorMatchingBracket = ({ state: state3, dispatch }) => toMatchingBracket(state3, dispatch, false);
  function extendSel(view, how) {
    let selection = updateSel(view.state.selection, (range) => {
      let head = how(range);
      return EditorSelection.range(range.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range) => view.moveByChar(range, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range) => view.moveByGroup(range, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range) => moveBySyntax(view.state, range, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range) => view.moveVertically(range, forward, Math.min(view.dom.clientHeight, innerHeight)));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range) => moveByLineBoundary(view, range, false));
  var selectLineStart = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).from));
  var selectLineEnd = (view) => extendSel(view, (range) => EditorSelection.cursor(view.lineBlockAt(range.head).to));
  var cursorDocStart = ({ state: state3, dispatch }) => {
    dispatch(setSel(state3, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state: state3, dispatch }) => {
    dispatch(setSel(state3, { anchor: state3.doc.length }));
    return true;
  };
  var selectDocStart = ({ state: state3, dispatch }) => {
    dispatch(setSel(state3, { anchor: state3.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state: state3, dispatch }) => {
    dispatch(setSel(state3, { anchor: state3.selection.main.anchor, head: state3.doc.length }));
    return true;
  };
  var selectAll = ({ state: state3, dispatch }) => {
    dispatch(state3.update({ selection: { anchor: 0, head: state3.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state: state3, dispatch }) => {
    let ranges = selectedLineBlocks(state3).map(({ from, to }) => EditorSelection.range(from, Math.min(to + 1, state3.doc.length)));
    dispatch(state3.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state: state3, dispatch }) => {
    let selection = updateSel(state3.selection, (range) => {
      var _a2;
      let context2 = syntaxTree(state3).resolveInner(range.head, 1);
      while (!(context2.from < range.from && context2.to >= range.to || context2.to > range.to && context2.from <= range.from || !((_a2 = context2.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context2 = context2.parent;
      return EditorSelection.range(context2.to, context2.from);
    });
    dispatch(setSel(state3, selection));
    return true;
  };
  var simplifySelection = ({ state: state3, dispatch }) => {
    let cur2 = state3.selection, selection = null;
    if (cur2.ranges.length > 1)
      selection = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection)
      return false;
    dispatch(setSel(state3, selection));
    return true;
  };
  function deleteBy({ state: state3, dispatch }, by) {
    if (state3.readOnly)
      return false;
    let event = "delete.selection";
    let changes = state3.changeByRange((range) => {
      let { from, to } = range;
      if (from == to) {
        let towards = by(from);
        if (towards < from)
          event = "delete.backward";
        else if (towards > from)
          event = "delete.forward";
        from = Math.min(from, towards);
        to = Math.max(to, towards);
      }
      return from == to ? { range } : { changes: { from, to }, range: EditorSelection.cursor(from) };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state3.update(changes, { scrollIntoView: true, userEvent: event }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to) => {
          if (from < pos && to > pos)
            pos = forward ? to : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let { state: state3 } = target, line = state3.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state3.tabSize), drop = col % getIndentUnit(state3) || getIndentUnit(state3);
      for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state3.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return skipAtomic(target, targetPos, forward);
  });
  var deleteCharBackward = (view) => deleteByChar(view, false);
  var deleteCharForward = (view) => deleteByChar(view, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start) => {
    let pos = start, { state: state3 } = target, line = state3.doc.lineAt(pos);
    let categorize = state3.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start && line.number != (forward ? state3.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != start)
        cat = nextCat;
      pos = next;
    }
    return skipAtomic(target, pos, forward);
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
    let lineEnd = view.lineBlockAt(pos).to;
    return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);
  });
  var deleteToLineStart = (view) => deleteBy(view, (pos) => {
    let lineStart = view.lineBlockAt(pos).from;
    return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
  });
  var splitLine = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    let changes = state3.changeByRange((range) => {
      return {
        changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range.from)
      };
    });
    dispatch(state3.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    let changes = state3.changeByRange((range) => {
      if (!range.empty || range.from == 0 || range.from == state3.doc.length)
        return { range };
      let pos = range.from, line = state3.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from, to, insert: state3.doc.slice(pos, to).append(state3.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch(state3.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state3) {
    let blocks = [], upto = -1;
    for (let range of state3.selection.ranges) {
      let startLine = state3.doc.lineAt(range.from), endLine = state3.doc.lineAt(range.to);
      if (!range.empty && range.to == endLine.from)
        endLine = state3.doc.lineAt(range.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state3, dispatch, forward) {
    if (state3.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state3)) {
      if (forward ? block.to == state3.doc.length : block.from == 0)
        continue;
      let nextLine = state3.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size2 = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state3.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state3.doc.length, r.anchor + size2), Math.min(state3.doc.length, r.head + size2)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state3.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size2, r.head - size2));
      }
    }
    if (!changes.length)
      return false;
    dispatch(state3.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state3.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state: state3, dispatch }) => moveLine(state3, dispatch, false);
  var moveLineDown = ({ state: state3, dispatch }) => moveLine(state3, dispatch, true);
  function copyLine(state3, dispatch, forward) {
    if (state3.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state3)) {
      if (forward)
        changes.push({ from: block.from, insert: state3.doc.slice(block.from, block.to) + state3.lineBreak });
      else
        changes.push({ from: block.to, insert: state3.lineBreak + state3.doc.slice(block.from, block.to) });
    }
    dispatch(state3.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state: state3, dispatch }) => copyLine(state3, dispatch, false);
  var copyLineDown = ({ state: state3, dispatch }) => copyLine(state3, dispatch, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let { state: state3 } = view, changes = state3.changes(selectedLineBlocks(state3).map(({ from, to }) => {
      if (from > 0)
        from--;
      else if (to < state3.doc.length)
        to++;
      return { from, to };
    }));
    let selection = updateSel(state3.selection, (range) => view.moveVertically(range, true)).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state3, pos) {
    if (/\(\)|\[\]|\{\}/.test(state3.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context2 = syntaxTree(state3).resolveInner(pos);
    let before = context2.childBefore(pos), after = context2.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state3.doc.lineAt(before.to).from == state3.doc.lineAt(after.from).from)
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state: state3, dispatch }) => {
      if (state3.readOnly)
        return false;
      let changes = state3.changeByRange((range) => {
        let { from, to } = range, line = state3.doc.lineAt(from);
        let explode = !atEof && from == to && isBetweenBrackets(state3, from);
        if (atEof)
          from = to = (to <= line.to ? line : state3.doc.lineAt(to)).to;
        let cx = new IndentContext(state3, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = /^\s*/.exec(state3.doc.lineAt(from).text)[0].length;
        while (to < line.to && /\s/.test(line.text[to - line.from]))
          to++;
        if (explode)
          ({ from, to } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state3, indent)];
        if (explode)
          insert2.push(indentString(state3, cx.lineIndent(line.from, -1)));
        return {
          changes: { from, to, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch(state3.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state3, f) {
    let atLine = -1;
    return state3.changeByRange((range) => {
      let changes = [];
      for (let pos = range.from; pos <= range.to; ) {
        let line = state3.doc.lineAt(pos);
        if (line.number > atLine && (range.empty || range.to > line.from)) {
          f(line, changes, range);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state3.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
      };
    });
  }
  var indentSelection = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context2 = new IndentContext(state3, { overrideIndentation: (start) => {
      let found = updated[start];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state3, (line, changes2, range) => {
      let indent = getIndentation(context2, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state3, indent);
      if (cur2 != norm || range.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch(state3.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    dispatch(state3.update(changeBySelectedLine(state3, (line, changes) => {
      changes.push({ from: line.from, insert: state3.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    dispatch(state3.update(changeBySelectedLine(state3, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state3.tabSize), keep = 0;
      let insert2 = indentString(state3, Math.max(0, col - getIndentUnit(state3)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
  ].concat(standardKeymap);

  // node_modules/crelt/index.es.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
      elt = document.createElement(elt);
    var i2 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name3 in next)
        if (Object.prototype.hasOwnProperty.call(next, name3)) {
          var value = next[name3];
          if (typeof value == "string")
            elt.setAttribute(name3, value);
          else if (value != null)
            elt[name3] = value;
        }
      i2++;
    }
    for (; i2 < arguments.length; i2++)
      add(elt, arguments[i2]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i2 = 0; i2 < child.length; i2++)
        add(elt, child[i2]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  var SearchCursor = class {
    constructor(text, query, from = 0, to = text.length, normalize) {
      this.value = { from: 0, to: 0 };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from, to);
      this.bufferStart = from;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        for (let i2 = 0, pos = start; ; i2++) {
          let code2 = norm.charCodeAt(i2);
          let match = this.match(code2, pos);
          if (match) {
            this.value = match;
            return this;
          }
          if (i2 == norm.length - 1)
            break;
          if (pos == start && i2 < str.length && str.charCodeAt(i2) == code2)
            pos++;
        }
      }
    }
    match(code2, pos) {
      let match = null;
      for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
        let index = this.matches[i2], keep = false;
        if (this.query.charCodeAt(index) == code2) {
          if (index == this.query.length - 1) {
            match = { from: this.matches[i2 + 1], to: pos + 1 };
          } else {
            this.matches[i2]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i2, 2);
          i2 -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code2) {
        if (this.query.length == 1)
          match = { from: pos, to: pos + 1 };
        else
          this.matches.push(1, pos);
      }
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text, query, options2, from = 0, to = text.length) {
      this.to = to;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text, query, options2, from, to);
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.iter = text.iter();
      let startLine = text.lineAt(from);
      this.curLineStart = startLine.from;
      this.matchPos = from;
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from = this.curLineStart + match.index, to = from + match[0].length;
          this.matchPos = to + (from == to ? 1 : 0);
          if (from == this.curLine.length)
            this.nextLine();
          if (from < to || from > this.value.to) {
            this.value = { from, to, match };
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from, text) {
      this.from = from;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from, to) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to || cached.to <= from) {
        let flat = new FlattenedDoc(from, doc2.sliceString(from, to));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from && cached.to == to)
        return cached;
      let { text, from: cachedFrom } = cached;
      if (cachedFrom > from) {
        text = doc2.sliceString(from, cachedFrom) + text;
        cachedFrom = from;
      }
      if (cached.to < to)
        text += doc2.sliceString(cached.to, to);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text, query, options2, from, to) {
      this.text = text;
      this.to = to;
      this.done = false;
      this.value = empty;
      this.matchPos = from;
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
          match = null;
        if (match) {
          let from = this.flat.from + match.index, to = from + match[0].length;
          this.value = { from, to, match };
          this.matchPos = to + (from == to ? 1 : 0);
          return this;
        } else {
          if (this.flat.to == this.to) {
            this.done = true;
            return this;
          }
          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source2) {
    try {
      new RegExp(source2, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function createLineDialog(view) {
    let input = crelt("input", { class: "cm-textfield", name: "line" });
    let dom2 = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view.dispatch({ effects: dialogEffect.of(false) });
          view.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match)
        return;
      let { state: state3 } = view, startLine = state3.doc.lineAt(state3.selection.main.head);
      let [, sign, ln, cl, percent] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line / 100;
        if (sign)
          pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state3.doc.lines;
        line = Math.round(state3.doc.lines * pc);
      } else if (ln && sign) {
        line = line * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state3.doc.line(Math.max(1, Math.min(state3.doc.lines, line)));
      view.dispatch({
        effects: dialogEffect.of(false),
        selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
        scrollIntoView: true
      });
      view.focus();
    }
    return { dom: dom2 };
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e2 of tr.effects)
        if (e2.is(dialogEffect))
          value = e2.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view.dispatch({ effects });
      panel = getPanel(view, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": { fontSize: "80%" }
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options2) {
      return combineConfig(options2, defaultHighlightOptions, {
        highlightWordAroundCursor: (a, b) => a || b,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options2) {
    let ext = [defaultTheme, matchHighlighter];
    if (options2)
      ext.push(highlightConfig.of(options2));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
  function insideWordBoundaries(check, state3, from, to) {
    return (from == 0 || check(state3.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state3.doc.length || check(state3.sliceDoc(to, to + 1)) != CharCategory.Word);
  }
  function insideWord(check, state3, from, to) {
    return check(state3.sliceDoc(from, from + 1)) == CharCategory.Word && check(state3.sliceDoc(to - 1, to)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update2) {
      if (update2.selectionSet || update2.docChanged || update2.viewportChanged)
        this.decorations = this.getDeco(update2.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let { state: state3 } = view, sel = state3.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range = sel.main, query, check = null;
      if (range.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state3.wordAt(range.head);
        if (!word)
          return Decoration.none;
        check = state3.charCategorizer(range.head);
        query = state3.sliceDoc(word.from, word.to);
      } else {
        let len = range.to - range.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state3.sliceDoc(range.from, range.to);
          check = state3.charCategorizer(range.head);
          if (!(insideWordBoundaries(check, state3, range.from, range.to) && insideWord(check, state3, range.from, range.to)))
            return Decoration.none;
        } else {
          query = state3.sliceDoc(range.from, range.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor = new SearchCursor(state3.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let { from, to } = cursor.value;
          if (!check || insideWordBoundaries(check, state3, from, to)) {
            if (range.empty && from <= range.from && to >= range.to)
              deco.push(mainMatchDeco.range(from, to));
            else if (from >= range.to || to <= range.from)
              deco.push(matchDeco.range(from, to));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
  });
  var selectWord = ({ state: state3, dispatch }) => {
    let { selection } = state3;
    let newSel = EditorSelection.create(selection.ranges.map((range) => state3.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
      return false;
    dispatch(state3.update({ selection: newSel }));
    return true;
  };
  function findNextOccurrence(state3, query) {
    let { main, ranges } = state3.selection;
    let word = state3.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state3.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state3.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state3.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({ state: state3, dispatch }) => {
    let { ranges } = state3.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({ state: state3, dispatch });
    let searchedText = state3.sliceDoc(ranges[0].from, ranges[0].to);
    if (state3.selection.ranges.some((r) => state3.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range = findNextOccurrence(state3, searchedText);
    if (!range)
      return false;
    dispatch(state3.update({
      selection: state3.selection.addRange(EditorSelection.range(range.from, range.to), false),
      effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      var _a2;
      return {
        top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, void 0) || false,
        caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive, void 0) || false,
        createPanel: ((_a2 = configs.find((c) => c.createPanel)) === null || _a2 === void 0 ? void 0 : _a2.createPanel) || ((view) => new SearchPanel(view))
      };
    }
  });
  var SearchQuery = class {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = config2.literal ? this.search : this.search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(doc2, from = 0, to = doc2.length) {
      return this.regexp ? regexpCursor(this, doc2, from, to) : stringCursor(this, doc2, from, to);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, doc2, from, to) {
    return new SearchCursor(doc2, spec.unquoted, from, to, spec.caseSensitive ? void 0 : (x) => x.toLowerCase());
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(doc2, curFrom, curTo) {
      let cursor = stringCursor(this.spec, doc2, curTo, doc2.length).nextOverlapping();
      if (cursor.done)
        cursor = stringCursor(this.spec, doc2, 0, curFrom).nextOverlapping();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc2, from, to) {
      for (let pos = to; ; ) {
        let start = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, doc2, start, pos), range = null;
        while (!cursor.nextOverlapping().done)
          range = cursor.value;
        if (range)
          return range;
        if (start == from)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(doc2, curFrom, curTo) {
      return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
    }
    getReplacement(_result) {
      return this.spec.replace;
    }
    matchAll(doc2, limit) {
      let cursor = stringCursor(this.spec, doc2, 0, doc2.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(doc2, from, to, add2) {
      let cursor = stringCursor(this.spec, doc2, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc2.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, doc2, from, to) {
    return new RegExpCursor(doc2, spec.search, spec.caseSensitive ? void 0 : { ignoreCase: true }, from, to);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(doc2, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, doc2, curTo, doc2.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, doc2, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc2, from, to) {
      for (let size2 = 1; ; size2++) {
        let start = Math.max(from, to - size2 * 1e4);
        let cursor = regexpCursor(this.spec, doc2, start, to), range = null;
        while (!cursor.next().done)
          range = cursor.value;
        if (range && (start == from || range.from > start + 10))
          return range;
        if (start == from)
          return null;
      }
    }
    prevMatch(doc2, curFrom, curTo) {
      return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
    }
    getReplacement(result) {
      return this.spec.replace.replace(/\$([$&\d+])/g, (m, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m);
    }
    matchAll(doc2, limit) {
      let cursor = regexpCursor(this.spec, doc2, 0, doc2.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(doc2, from, to, add2) {
      let cursor = regexpCursor(this.spec, doc2, Math.max(0, from - 250), Math.min(to + 250, doc2.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state3) {
      return new SearchState(defaultQuery(state3).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update2) {
      let state3 = update2.state.field(searchState);
      if (state3 != update2.startState.field(searchState) || update2.docChanged || update2.selectionSet || update2.viewportChanged)
        this.decorations = this.highlight(state3);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let { view } = this;
      let builder = new RangeSetBuilder();
      for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
        let { from, to } = ranges[i2];
        while (i2 < l - 1 && to > ranges[i2 + 1].from - 2 * 250)
          to = ranges[++i2].to;
        query.highlight(view.state.doc, from, to, (from2, to2) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to2);
          builder.add(from2, to2, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state3 = view.state.field(searchState, false);
      return state3 && state3.query.spec.valid ? f(view, state3) : openSearchPanel(view);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { from, to } = view.state.selection.main;
    let next = query.nextMatch(view.state.doc, from, to);
    if (!next || next.from == from && next.to == to)
      return false;
    view.dispatch({
      selection: { anchor: next.from, head: next.to },
      scrollIntoView: true,
      effects: announceMatch(view, next),
      userEvent: "select.search"
    });
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state: state3 } = view, { from, to } = state3.selection.main;
    let range = query.prevMatch(state3.doc, from, to);
    if (!range)
      return false;
    view.dispatch({
      selection: { anchor: range.from, head: range.to },
      scrollIntoView: true,
      effects: announceMatch(view, range),
      userEvent: "select.search"
    });
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state.doc, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({ state: state3, dispatch }) => {
    let sel = state3.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state3.doc, state3.sliceDoc(from, to)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch(state3.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state: state3 } = view, { from, to } = state3.selection.main;
    if (state3.readOnly)
      return false;
    let next = query.nextMatch(state3.doc, from, from);
    if (!next)
      return false;
    let changes = [], selection, replacement;
    if (next.from == from && next.to == to) {
      replacement = state3.toText(query.getReplacement(next));
      changes.push({ from: next.from, to: next.to, insert: replacement });
      next = query.nextMatch(state3.doc, next.from, next.to);
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection = { anchor: next.from - off, head: next.to - off };
    }
    view.dispatch({
      changes,
      selection,
      scrollIntoView: !!selection,
      effects: next ? announceMatch(view, next) : void 0,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
    if (view.state.readOnly)
      return false;
    let changes = query.matchAll(view.state.doc, 1e9).map((match) => {
      let { from, to } = match;
      return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
      return false;
    view.dispatch({
      changes,
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state3, fallback) {
    var _a2;
    let sel = state3.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state3.sliceDoc(sel.from, sel.to);
    let caseSensitive = (_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a2 !== void 0 ? _a2 : state3.facet(searchConfigFacet).caseSensitive;
    return fallback && !selText ? fallback : new SearchQuery({ search: selText.replace(/\n/g, "\\n"), caseSensitive });
  }
  var openSearchPanel = (view) => {
    let state3 = view.state.field(searchState, false);
    if (state3 && state3.panel) {
      let panel = getPanel(view, createSearchPanel);
      if (!panel)
        return false;
      let searchInput = panel.dom.querySelector("[name=search]");
      if (searchInput != view.root.activeElement) {
        let query = defaultQuery(view.state, state3.query.spec);
        if (query.valid)
          view.dispatch({ effects: setSearchQuery.of(query) });
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view.dispatch({ effects: [
        togglePanel.of(true),
        state3 ? setSearchQuery.of(defaultQuery(view.state, state3.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ] });
    }
    return true;
  };
  var closeSearchPanel = (view) => {
    let state3 = view.state.field(searchState, false);
    if (!state3 || !state3.panel)
      return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
      view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
  ];
  var SearchPanel = class {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        checked: query.regexp,
        onchange: this.commit
      });
      function button(name3, onclick, content2) {
        return crelt("button", { class: "cm-button", name: name3, onclick, type: "button" }, content2);
      }
      this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
        this.searchField,
        button("next", () => findNext(view), [phrase(view, "next")]),
        button("prev", () => findPrevious(view), [phrase(view, "previous")]),
        button("select", () => selectMatches(view), [phrase(view, "all")]),
        crelt("label", null, [this.caseField, phrase(view, "match case")]),
        crelt("label", null, [this.reField, phrase(view, "regexp")]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [phrase(view, "replace")]),
          button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")]),
          crelt("button", {
            name: "close",
            onclick: () => closeSearchPanel(view),
            "aria-label": phrase(view, "close"),
            type: "button"
          }, ["\xD7"])
        ]
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({ effects: setSearchQuery.of(query) });
      }
    }
    keydown(e2) {
      if (runScopeHandlers(this.view, e2, "search-panel")) {
        e2.preventDefault();
      } else if (e2.keyCode == 13 && e2.target == this.searchField) {
        e2.preventDefault();
        (e2.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
        e2.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update2) {
      for (let tr of update2.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view, { from, to }) {
    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != lineStart) {
      for (let i2 = 0; i2 < AnnounceMargin; i2++)
        if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
          text = text.slice(i2);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
        if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
          text = text.slice(0, i2);
          break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.lowest(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    constructor(state3, pos, explicit) {
      this.state = state3;
      this.pos = pos;
      this.explicit = explicit;
      this.abortListeners = [];
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type, listener) {
      if (type == "abort" && this.abortListeners)
        this.abortListeners.push(listener);
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options2) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label } of options2) {
      first[label[0]] = true;
      for (let i2 = 1; i2 < label.length; i2++)
        rest[label[i2]] = true;
    }
    let source2 = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source2), new RegExp(source2)];
  }
  function completeFromList(list) {
    let options2 = list.map((o) => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
    return (context2) => {
      let token = context2.matchBefore(match);
      return token || context2.explicit ? { from: token ? token.from : context2.pos, options: options2, validFor } : null;
    };
  }
  var Option = class {
    constructor(completion, source2, match) {
      this.completion = completion;
      this.source = source2;
      this.match = match;
    }
  };
  function cur(state3) {
    return state3.selection.main.head;
  }
  function ensureAnchor(expr, start) {
    var _a2;
    let { source: source2 } = expr;
    let addStart = start && source2[0] != "^", addEnd = source2[source2.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source2})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  function insertCompletionText(state3, text, from, to) {
    return Object.assign(Object.assign({}, state3.changeByRange((range) => {
      if (range == state3.selection.main)
        return {
          changes: { from, to, insert: text },
          range: EditorSelection.cursor(from + text.length)
        };
      let len = to - from;
      if (!range.empty || len && state3.sliceDoc(range.from - len, range.from) != state3.sliceDoc(from, to))
        return { range };
      return {
        changes: { from: range.from - len, to: range.from, insert: text },
        range: EditorSelection.cursor(range.from - len + text.length)
      };
    })), { userEvent: "input.complete" });
  }
  function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string")
      view.dispatch(insertCompletionText(view.state, apply, result.from, result.to));
    else
      apply(view, option.completion, result.from, result.to);
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source2) {
    if (!Array.isArray(source2))
      return source2;
    let known = SourceCache.get(source2);
    if (!known)
      SourceCache.set(source2, known = completeFromList(source2));
    return known;
  }
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      for (let p = 0; p < pattern.length; ) {
        let char = codePointAt(pattern, p), size2 = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p, p + size2), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p += size2;
      }
      this.astral = pattern.length != this.chars.length;
    }
    match(word) {
      if (this.pattern.length == 0)
        return [0];
      if (word.length < this.pattern.length)
        return null;
      let { chars, folded, any, precise, byWord } = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0);
        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return [0, 0, this.pattern.length];
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
          let next = codePointAt(word, i2);
          if (next == chars[anyTo] || next == folded[anyTo])
            any[anyTo++] = i2;
          i2 += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
        let next = codePointAt(word, i2);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i2;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i2;
              adjacentEnd = i2 + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i2 || type == 1 && hasLower || prevType == 0 && type != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i2;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type;
        i2 += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return [-200 - word.length, 0, adjacentEnd];
      if (direct > -1)
        return [-700 - word.length, direct, direct + this.pattern.length];
      if (adjacentTo == len)
        return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [score2 - word.length], i2 = 1;
      for (let pos of positions) {
        let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i2 > 1 && result[i2 - 1] == pos)
          result[i2 - 1] = to;
        else {
          result[i2++] = pos;
          result[i2++] = to;
        }
      }
      return result;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: []
      }, {
        defaultKeymap: (a, b) => a && b,
        closeOnBlur: (a, b) => a && b,
        icons: (a, b) => a && b,
        optionClass: (a, b) => (c) => joinClass(a(c), b(c)),
        addToOptions: (a, b) => a.concat(b)
      });
    }
  });
  function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let { label } = completion, off = 0;
        for (let j = 1; j < match.length; ) {
          let from = match[j++], to = match[j++];
          if (from > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to)));
          span.className = "cm-completionMatchedText";
          off = to;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a, b) => a.position - b.position).map((a) => a.render);
  }
  function rangeAroundSelected(total, selected, max2) {
    if (total <= max2)
      return { from: 0, to: total };
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max2);
      return { from: off2 * max2, to: (off2 + 1) * max2 };
    }
    let off = Math.floor((total - selected) / max2);
    return { from: total - (off + 1) * max2, to: total - off * max2 };
  }
  var CompletionTooltip = class {
    constructor(view, stateField) {
      this.view = view;
      this.stateField = stateField;
      this.info = null;
      this.placeInfo = {
        read: () => this.measureInfo(),
        write: (pos) => this.positionInfo(pos),
        key: this
      };
      let cState = view.state.field(stateField);
      let { options: options2, selected } = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.dom.addEventListener("mousedown", (e2) => {
        for (let dom2 = e2.target, match; dom2 && dom2 != this.dom; dom2 = dom2.parentNode) {
          if (dom2.nodeName == "LI" && (match = /-(\d+)$/.exec(dom2.id)) && +match[1] < options2.length) {
            applyCompletion(view, options2[+match[1]]);
            e2.preventDefault();
            return;
          }
        }
      });
      this.list = this.dom.appendChild(this.createListBox(options2, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    mount() {
      this.updateSel();
    }
    update(update2) {
      if (update2.state.field(this.stateField) != update2.startState.field(this.stateField))
        this.updateSel();
    }
    positioned() {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        });
      }
      if (this.updateSelectedOption(open.selected)) {
        if (this.info) {
          this.info.remove();
          this.info = null;
        }
        let { completion } = open.options[open.selected];
        let { info } = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((node) => {
            if (node && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(node);
          }).catch((e2) => logException(this.view.state, e2, "completion info"));
        } else {
          this.addInfoPane(infoResult);
        }
      }
    }
    addInfoPane(content2) {
      let dom2 = this.info = document.createElement("div");
      dom2.className = "cm-tooltip cm-completionInfo";
      dom2.appendChild(content2);
      this.dom.appendChild(dom2);
      this.view.requestMeasure(this.placeInfo);
    }
    updateSelectedOption(selected) {
      let set2 = null;
      for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
        if (i2 == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set2 = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set2)
        scrollIntoView2(this.list, set2);
      return set2;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10)
        return null;
      let top2 = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;
      let left = this.view.textDirection == Direction.RTL;
      let spaceLeft = listRect.left, spaceRight = innerWidth - listRect.right;
      if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
        left = true;
      return { top: top2, left };
    }
    positionInfo(pos) {
      if (this.info) {
        this.info.style.top = (pos ? pos.top : -1e6) + "px";
        if (pos) {
          this.info.classList.toggle("cm-completionInfo-left", pos.left);
          this.info.classList.toggle("cm-completionInfo-right", !pos.left);
        }
      }
    }
    createListBox(options2, id2, range) {
      const ul = document.createElement("ul");
      ul.id = id2;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      for (let i2 = range.from; i2 < range.to; i2++) {
        let { completion, match } = options2[i2];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id2 + "-" + i2;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source2 of this.optionContent) {
          let node = source2(completion, this.view.state, match);
          if (node)
            li.appendChild(node);
        }
      }
      if (range.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range.to < options2.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
  };
  function completionTooltip(stateField) {
    return (view) => new CompletionTooltip(view, stateField);
  }
  function scrollIntoView2(container, element3) {
    let parent = container.getBoundingClientRect();
    let self2 = element3.getBoundingClientRect();
    if (self2.top < parent.top)
      container.scrollTop -= parent.top - self2.top;
    else if (self2.bottom > parent.bottom)
      container.scrollTop += self2.bottom - parent.bottom;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state3) {
    let options2 = [], i2 = 0;
    for (let a of active)
      if (a.hasResult()) {
        if (a.result.filter === false) {
          let getMatch = a.result.getMatch;
          for (let option of a.result.options) {
            let match = [1e9 - i2++];
            if (getMatch)
              for (let n of getMatch(option))
                match.push(n);
            options2.push(new Option(option, a, match));
          }
        } else {
          let matcher = new FuzzyMatcher(state3.sliceDoc(a.from, a.to)), match;
          for (let option of a.result.options)
            if (match = matcher.match(option.label)) {
              if (option.boost != null)
                match[0] += option.boost;
              options2.push(new Option(option, a, match));
            }
        }
      }
    let result = [], prev = null;
    for (let opt of options2.sort(cmpOption)) {
      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class {
    constructor(options2, attrs, tooltip, timestamp, selected) {
      this.options = options2;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
    }
    setSelected(selected, id2) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected);
    }
    static build(active, state3, id2, prev, conf) {
      let options2 = sortOptions(active, state3);
      if (!options2.length)
        return null;
      let selected = 0;
      if (prev && prev.selected) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i2 = 0; i2 < options2.length; i2++)
          if (options2[i2].completion == selectedValue) {
            selected = i2;
            break;
          }
      }
      return new CompletionDialog(options2, makeAttrs(id2, selected), {
        pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
        create: completionTooltip(completionState),
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
    }
  };
  var CompletionState = class {
    constructor(active, id2, open) {
      this.active = active;
      this.id = id2;
      this.open = open;
    }
    static start() {
      return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state: state3 } = tr, conf = state3.facet(completionConfig);
      let sources = conf.override || state3.languageDataAt("autocomplete", cur(state3)).map(asSource);
      let active = sources.map((source2) => {
        let value = this.active.find((s) => s.source == source2) || new ActiveSource(source2, this.active.some((a) => a.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a, i2) => a == this.active[i2]))
        active = this.active;
      let open = tr.selection || active.some((a) => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state3, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
      if (!open && active.every((a) => a.state != 1) && active.some((a) => a.hasResult()))
        active = active.map((a) => a.hasResult() ? new ActiveSource(a.source, 0) : a);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : baseAttrs;
    }
  };
  function sameResults(a, b) {
    if (a == b)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a.length && !a[iA].hasResult)
        iA++;
      while (iB < b.length && !b[iB].hasResult)
        iB++;
      let endA = iA == a.length, endB = iB == b.length;
      if (endA || endB)
        return endA == endB;
      if (a[iA++].result != b[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id2, selected) {
    return {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-activedescendant": id2 + "-" + selected,
      "aria-controls": id2
    };
  }
  var none3 = [];
  function cmpOption(a, b) {
    let dScore = b.match[0] - a.match[0];
    if (dScore)
      return dScore;
    return a.completion.label.localeCompare(b.completion.label);
  }
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = class {
    constructor(source2, state3, explicitPos = -1) {
      this.source = source2;
      this.state = state3;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let event = getUserEvent(tr), value = this;
      if (event)
        value = value.handleUserEvent(tr, event, conf);
      else if (tr.docChanged)
        value = value.handleChange(tr);
      else if (tr.selection && value.state != 0)
        value = new ActiveSource(value.source, 0);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    handleUserEvent(tr, type, conf) {
      return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
  };
  var ActiveResult = class extends ActiveSource {
    constructor(source2, explicitPos, result, from, to) {
      super(source2, 2, explicitPos);
      this.result = result;
      this.from = from;
      this.to = to;
    }
    hasResult() {
      return true;
    }
    handleUserEvent(tr, type, conf) {
      var _a2;
      let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to || type == "delete" && cur(tr.startState) == this.from)
        return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 : 0);
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
      if (checkValid(this.result.validFor, tr.state, from, to))
        return new ActiveResult(this.source, explicitPos, this.result, from, to);
      if (this.result.update && (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(mapping) {
      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
  };
  function checkValid(validFor, state3, from, to) {
    if (!validFor)
      return false;
    let text = state3.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state3) : ensureAnchor(validFor, true).test(text);
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state3) => state3.attrs)
    ]
  });
  var CompletionInteractMargin = 75;
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;
      if (selected < 0)
        selected = by == "page" ? 0 : length - 1;
      else if (selected >= length)
        selected = by == "page" ? length - 1 : 0;
      view.dispatch({ effects: setSelectedEffect.of(selected) });
      return true;
    };
  }
  var acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
      return false;
    applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
  };
  var startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
      return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
  };
  var closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a) => a.state != 0))
      return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
  };
  var RunningQuery = class {
    constructor(active, context2) {
      this.active = active;
      this.context = context2;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var DebounceTime = 50;
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0;
      for (let active of view.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update2) {
      let cState = update2.state.field(completionState);
      if (!update2.selectionSet && !update2.docChanged && update2.startState.field(completionState) == cState)
        return;
      let doesReset = update2.transactions.some((tr) => {
        return (tr.selection || tr.docChanged) && !getUserEvent(tr);
      });
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (doesReset || query.updates.length + update2.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e2) {
              logException(this.view.state, e2);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i2--, 1);
        } else {
          query.updates.push(...update2.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      this.debounceUpdate = cState.active.some((a) => a.state == 1 && !this.running.some((q) => q.active.source == a.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
      if (this.composing != 0)
        for (let tr of update2.transactions) {
          if (getUserEvent(tr) == "input")
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      let { state: state3 } = this.view, cState = state3.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
          this.startQuery(active);
      }
    }
    startQuery(active) {
      let { state: state3 } = this.view, pos = cur(state3);
      let context2 = new CompletionContext(state3, pos, active.explicitPos == pos);
      let pending = new RunningQuery(active, context2);
      this.running.push(pending);
      Promise.resolve(active.source(context2)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig);
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (query.done === void 0)
          continue;
        this.running.splice(i2--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = this.view.state.field(completionState).active.find((a) => a.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length)
        this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
  }, {
    eventHandlers: {
      blur() {
        let state3 = this.view.state.field(completionState, false);
        if (state3 && state3.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
          this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
        }
        this.composing = 0;
      }
    }
  });
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer",
          padding: "1px 3px",
          lineHeight: 1.2
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: "300px"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": { content: "'\u0192'" }
    },
    ".cm-completionIcon-class": {
      "&:after": { content: "'\u25CB'" }
    },
    ".cm-completionIcon-interface": {
      "&:after": { content: "'\u25CC'" }
    },
    ".cm-completionIcon-variable": {
      "&:after": { content: "'\u{1D465}'" }
    },
    ".cm-completionIcon-constant": {
      "&:after": { content: "'\u{1D436}'" }
    },
    ".cm-completionIcon-type": {
      "&:after": { content: "'\u{1D461}'" }
    },
    ".cm-completionIcon-enum": {
      "&:after": { content: "'\u222A'" }
    },
    ".cm-completionIcon-property": {
      "&:after": { content: "'\u25A1'" }
    },
    ".cm-completionIcon-keyword": {
      "&:after": { content: "'\u{1F511}\uFE0E'" }
    },
    ".cm-completionIcon-namespace": {
      "&:after": { content: "'\u25A2'" }
    },
    ".cm-completionIcon-text": {
      "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>"
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      return mapping.mapPos(value);
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      if (tr.selection) {
        let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1))
          value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(closeBracketEffect))
          value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        else if (effect.is(skipBracketEffect))
          value = value.update({ filter: (from) => from != effect.value });
      }
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
      if (definedClosing.charCodeAt(i2) == ch)
        return definedClosing.charAt(i2 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state3, pos) {
    return state3.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
      return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to != sel.to)
      return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr)
      return false;
    view.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({ state: state3, dispatch }) => {
    if (state3.readOnly)
      return false;
    let conf = config(state3, state3.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state3.changeByRange((range) => {
      if (range.empty) {
        let before = prevChar(state3.doc, range.head);
        for (let token of tokens) {
          if (token == before && nextChar(state3.doc, range.head) == closing(codePointAt(token, 0)))
            return {
              changes: { from: range.head - token.length, to: range.head + token.length },
              range: EditorSelection.cursor(range.head - token.length),
              userEvent: "delete.backward"
            };
        }
      }
      return { range: dont = range };
    });
    if (!dont)
      dispatch(state3.update(changes, { scrollIntoView: true }));
    return !dont;
  };
  var closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
  ];
  function insertBracket(state3, bracket2) {
    let conf = config(state3, state3.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state3, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state3, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state3, state3.selection.main.from))
        return handleClose(state3, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state3, pos) {
    let found = false;
    state3.field(bracketState).between(0, state3.doc.length, (from) => {
      if (from == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state3, open, close, closeBefore) {
    let dont = null, changes = state3.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
          effects: closeBracketEffect.of(range.to + open.length),
          range: EditorSelection.range(range.anchor + open.length, range.head + open.length)
        };
      let next = nextChar(state3.doc, range.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: { insert: open + close, from: range.head },
          effects: closeBracketEffect.of(range.head + open.length),
          range: EditorSelection.cursor(range.head + open.length)
        };
      return { range: dont = range };
    });
    return dont ? null : state3.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state3, _open, close) {
    let dont = null, moved = state3.selection.ranges.map((range) => {
      if (range.empty && nextChar(state3.doc, range.head) == close)
        return EditorSelection.cursor(range.head + close.length);
      return dont = range;
    });
    return dont ? null : state3.update({
      selection: EditorSelection.create(moved, state3.selection.mainIndex),
      scrollIntoView: true,
      effects: state3.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
    });
  }
  function handleSame(state3, token, allowTriple) {
    let dont = null, changes = state3.changeByRange((range) => {
      if (!range.empty)
        return {
          changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
          effects: closeBracketEffect.of(range.to + token.length),
          range: EditorSelection.range(range.anchor + token.length, range.head + token.length)
        };
      let pos = range.head, next = nextChar(state3.doc, pos);
      if (next == token) {
        if (nodeStart(state3, pos)) {
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state3, pos)) {
          let isTriple = allowTriple && state3.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          return {
            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
            effects: skipBracketEffect.of(pos)
          };
        }
      } else if (allowTriple && state3.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state3, pos - 2 * token.length)) {
        return {
          changes: { insert: token + token + token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state3.charCategorizer(pos)(next) != CharCategory.Word) {
        let prev = state3.sliceDoc(pos - 1, pos);
        if (prev != token && state3.charCategorizer(pos)(prev) != CharCategory.Word && !probablyInString(state3, pos, token))
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return { range: dont = range };
    });
    return dont ? null : state3.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state3, pos) {
    let tree = syntaxTree(state3).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state3, pos, quoteToken) {
    let node = syntaxTree(state3).resolveInner(pos, -1);
    for (let i2 = 0; i2 < 5; i2++) {
      if (state3.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken)
        return true;
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function autocompletion(config2 = {}) {
    return [
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
    { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
    { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state3) => state3.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to, diagnostic) {
      this.from = from;
      this.to = to;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state3) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state3.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics);
      let ranges = Decoration.set(markedDiagnostics.map((d) => {
        return d.from == d.to || d.from == d.to - 1 && state3.doc.lineAt(d.from).to == d.from ? Decoration.widget({
          widget: new DiagnosticWidget(d),
          diagnostic: d
        }).range(d.from) : Decoration.mark({
          attributes: { class: "cm-lintRange cm-lintRange-" + d.severity },
          diagnostic: d
        }).range(d.from, d.to);
      }), true);
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from, to, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  function maybeEnableLint(state3, effects) {
    return state3.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
      lintState,
      EditorView.decorations.compute([lintState], (state4) => {
        let { selected, panel } = state4.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      baseTheme5
    ]));
  }
  function setDiagnostics(state3, diagnostics) {
    return {
      effects: maybeEnableLint(state3, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        let mapped = value.diagnostics.map(tr.changes), selected = null;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          value = LintState.init(effect.value, value.panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
  function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
      if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to, stackEnd);
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return { dom: diagnosticsTooltip(view, found) };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d) => renderDiagnostic(view, d, false)));
  }
  var openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
    let panel = getPanel(view, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({ effects: togglePanel2.of(false) });
    return true;
  };
  var nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
  };
  var lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel },
    { key: "F8", run: nextDiagnostic }
  ];
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let { delay } = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay);
    }
    run() {
      let now = Date.now();
      if (now < this.lintTime - 10) {
        setTimeout(this.run, this.lintTime - now);
      } else {
        this.set = false;
        let { state: state3 } = this.view, { sources } = state3.facet(lintConfig);
        Promise.all(sources.map((source2) => Promise.resolve(source2(this.view)))).then((annotations) => {
          let all = annotations.reduce((a, b) => a.concat(b));
          if (this.view.state.doc == state3.doc)
            this.view.dispatch(setDiagnostics(this.view.state, all));
        }, (error) => {
          logException(this.view.state, error);
        });
      }
    }
    update(update2) {
      let config2 = update2.state.facet(lintConfig);
      if (update2.docChanged || config2 != update2.startState.facet(lintConfig)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i2) => i2.source) }, combineConfig(input.map((i2) => i2.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null
      }));
    },
    enables: lintPlugin
  });
  function assignKeys(actions) {
    let assigned = [];
    if (actions)
      actions:
        for (let { name: name3 } of actions) {
          for (let i2 = 0; i2 < name3.length; i2++) {
            let ch = name3[i2];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c) => c.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys4 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action, i2) => {
      let click = (e2) => {
        e2.preventDefault();
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action.apply(view, found.from, found.to);
      };
      let { name: name3 } = action, keyIndex = keys4[i2] ? name3.indexOf(keys4[i2]) : -1;
      let nameElt = keyIndex < 0 ? name3 : [
        name3.slice(0, keyIndex),
        crelt("u", name3.slice(keyIndex, keyIndex + 1)),
        name3.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name3}${keyIndex < 0 ? "" : ` (access key "${keys4[i2]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys4 = assignKeys(diagnostic.actions);
          for (let i2 = 0; i2 < keys4.length; i2++)
            if (keys4[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i2].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i2 = 0; i2 < this.items.length; i2++) {
          if (this.items[i2].dom.contains(event.target))
            this.moveSelection(i2);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i2 = 0; i2 < this.items.length; i2++)
        if (this.items[i2].diagnostic == selected.diagnostic)
          return i2;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i2 = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        let found = -1, item;
        for (let j = i2; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i2, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i2) {
            this.items.splice(i2, found - i2);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i2++;
      });
      while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            if (sel.top < panel.top)
              this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += sel.bottom - panel.bottom;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: { anchor: selection.from, head: selection.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });

  // node_modules/@codemirror/basic-setup/dist/index.js
  var basicSetup = [
    /* @__PURE__ */ lineNumbers(),
    /* @__PURE__ */ highlightActiveLineGutter(),
    /* @__PURE__ */ highlightSpecialChars(),
    /* @__PURE__ */ history(),
    /* @__PURE__ */ foldGutter(),
    /* @__PURE__ */ drawSelection(),
    /* @__PURE__ */ dropCursor(),
    /* @__PURE__ */ EditorState.allowMultipleSelections.of(true),
    /* @__PURE__ */ indentOnInput(),
    /* @__PURE__ */ syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
    /* @__PURE__ */ bracketMatching(),
    /* @__PURE__ */ closeBrackets(),
    /* @__PURE__ */ autocompletion(),
    /* @__PURE__ */ rectangularSelection(),
    /* @__PURE__ */ crosshairCursor(),
    /* @__PURE__ */ highlightActiveLine(),
    /* @__PURE__ */ highlightSelectionMatches(),
    /* @__PURE__ */ keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ];

  // public/packages/code-module.js
  var $ = module2("code-module");
  function source(target) {
    return target.closest("[src]").getAttribute("src");
  }
  function sourceFile(target) {
    const src = source(target);
    return state[src] ? state[src] : function initialize() {
      state[src] = { file: "hello... what is your name?" };
      return state[src];
    }();
  }
  $.when("click", ".publish", (event) => {
    const src = source(event.target);
    const { file } = sourceFile(event.target);
    state[src].file = file;
  });
  $.draw((target) => {
    const src = source(target);
    const { file } = sourceFile(target);
    if (!file) {
      return "loading";
    }
    if (!target.view) {
      target.innerHTML = `
      <button class="publish">Publish</button>
    `;
      const config2 = {
        extensions: [
          basicSetup,
          EditorView.updateListener.of(
            persist(target, $, {})
          )
        ]
      };
      const state3 = EditorState.create({
        ...config2,
        doc: file
      });
      target.view = new EditorView({
        parent: target,
        state: state3
      });
    }
  });
  function persist(target, $6, _flags) {
    return (update2) => {
      if (update2.changes.inserted.length < 0)
        return;
      const src = source(target);
      const file = update2.view.state.doc.toString();
      state[src].file = file;
    };
  }
  $.style(`
  & {
		display: block;
    max-height: 60vh;
    overflow: scroll;
  }
`);

  // public/packages/file-system.js
  function factoryReset(cwc) {
    try {
      state2[cwc] = {
        path: "/",
        type: "FileSystem",
        children: [{
          name: "",
          type: "Directory",
          children: [{
            name: "home",
            type: "Directory",
            children: [{
              name: "tychi",
              type: "Directory",
              children: [{
                name: "braid",
                type: "Directory",
                children: [
                  {
                    name: "tag",
                    type: "Directory",
                    children: [
                      {
                        name: "plan98-highlighter.js",
                        type: "File"
                      },
                      {
                        name: "plan98-system.js",
                        type: "File"
                      }
                    ]
                  },
                  {
                    name: "sillonious",
                    type: "Directory",
                    children: [
                      {
                        name: "pretend.script",
                        type: "File"
                      },
                      {
                        name: "paper.script",
                        type: "File"
                      },
                      {
                        name: "books.script",
                        type: "File"
                      },
                      {
                        name: "bicycles.script",
                        type: "File"
                      },
                      {
                        name: "typewriters.script",
                        type: "File"
                      },
                      {
                        name: "teleplays.script",
                        type: "File"
                      },
                      {
                        name: "cameras.script",
                        type: "File"
                      },
                      {
                        name: "computers.script",
                        type: "File"
                      },
                      {
                        name: "synthesizers.script",
                        type: "File"
                      },
                      {
                        name: "slideshows.script",
                        type: "File"
                      },
                      {
                        name: "gamepads.script",
                        type: "File"
                      },
                      {
                        name: "generations.script",
                        type: "File"
                      }
                    ]
                  }
                ]
              }]
            }]
          }]
        }]
      };
    } catch (e2) {
      console.info("Factory Reset: Failed");
      console.error(e2);
      return;
    }
    console.log({ cwc, system: state2[cwc] });
    console.info("Factory Reset: Success");
    return state2[cwc];
  }
  var Types = {
    File: {
      icon: "/cdn/plan98/plan9.png"
    },
    Directory: {
      icon: "/cdn/plan98/firefox.png"
    }
  };
  var urlParams = new URLSearchParams(window.location.search);
  var path = urlParams.get("path");
  var iSbIoS = path === null;
  var $2 = module2("file-system");
  $2.draw(iSbIoS ? system : floppy);
  function currentWorkingComputer(target) {
    const cwc = target.closest("[cwc]").getAttribute("cwc");
    return state2[cwc] || {};
  }
  function system(target) {
    const tree = currentWorkingComputer(target);
    if (!tree) {
      return `<button data-reset>Factory Reset</button>`;
    }
    const { path: path2 } = tree;
    return `
    <div class="visual">
      <div class="treeview">
        ${nest([], tree)}
        <button data-reset>Factory Reset</button>
      </div>
      <div class="preview">
        <input type="text" name="path" value="${path2 || "/"}" />
        <iframe src="${window.location.href}?path=${path2}"></iframe>
      </div>
    </div>
  `;
  }
  function floppy(target) {
    const tree = currentWorkingComputer(target);
    const { path: path2 = "" } = tree;
    const content2 = getContent(tree, path2.split("/"));
    if (!content2)
      return `Nothing yet... if only... we had... a 404 page.`;
    if (content2.type === "File") {
      return `
      <code-module src="ls${path2}"></code-module>
    `;
    }
    if (content2.type === "Directory") {
      return `
      <div class="listing">
        ${content2.children.map((x) => `
          <button type="${x.type}" data-path="${path2 !== "/" ? `${path2}/${x.name}` : `/${x.name}`}">
            <img src="${Types[x.type].icon}" alt="Icon for ${x.type}" />
            ${x.name || "Sillonious"}
          </button>
        `).join("")}
      </div>
    `;
    }
  }
  function getContent(tree, pathParts) {
    return [...pathParts].reduce((subtree, name3, i2, og) => {
      const result = subtree.children.find((x) => x.name === name3);
      if (!result) {
        console.log({ result, name: name3, subtree, tree, pathParts });
        og.splice(1);
        return subtree;
      }
      return result;
    }, tree);
  }
  $2.when("click", "[data-uri]", async function(event) {
    const tokens = event.target.closest($2.link).getAttribute("tokens");
    const config2 = state2[tokens] || {};
    const { uri } = event.target.dataset;
    const data = await fetchAlbum(config2, uri);
    showModal(`
    <image-gallery>
      ${data.AlbumImage.map((image) => {
      const { ArchivedUri, Uri, ThumbnailUrl } = image;
      return `
          <img
        src="${ThumbnailUrl}"
        data-uri="${Uri}"
          />
          `;
    }).join("")}
    </image-gallery>
  `);
  });
  function nest(pathParts, tree = {}) {
    if (!tree.children)
      return "";
    return tree.children.map((child) => {
      const { name: name3, type } = child;
      const currentPathParts = [...pathParts, name3];
      const currentPath = currentPathParts.join("/");
      if (type === "File") {
        return `<button data-path="${currentPath}">
        <plan98-highlighter>
          ${name3}
        </plan98-highlighter>
      </button>`;
      }
      if (type === "Directory") {
        return `
        <details>
          <summary data-path="${currentPath}">
            ${name3 || "/"}
          </summary>
          ${nest(currentPathParts, child)}
        </details>
      `;
      }
    }).join("");
  }
  $2.when("click", "[data-reset]", ({ target }) => {
    const cwc = target.closest("[cwc]").getAttribute("cwc");
    factoryReset(cwc);
  });
  $2.when("click", "[data-path]", ({ target }) => {
    const { path: path2 } = target.dataset;
    console.log({ path: path2 });
    const tree = currentWorkingComputer(target);
    const information = getContent(tree, path2);
    console.log({ information });
    tree.path = path2;
  });
  $2.style(`
  & .visual {
    display: grid;
    grid-template-columns: 180px 1fr;
    height: 100%;
  }

  & .treeview {
    position: relative;
    overflow: auto;
    white-space: nowrap;
  }

  & [data-reset] {
    position: absolute;
    bottom: 1rem;
  }

  & [name="path"] {
    display: block;
    width: 100%;
  }

  & .preview {
    display: grid;
    grid-template-rows: auto 1fr;
  }

  & iframe {
    height: 100%;
    width: 100%;
    border: 0;
  }

  & details { padding-left: 1rem; }
  & [target="_blank"] {
    float: right;
  }
  & button {
    all: unset;
    text-decoration: underline;
    color: blue;
    display: block;
    cursor: pointer;
  }

  & .listing {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(128px, 1fr));
    text-align: center;
    grid-area: 1 / 1 / -1 / -1;
    place-content: baseline;
  }

  & .listing > * {
    display: grid;
    grid-template-rows: auto 1rem;
    aspect-ratio: 1;
  }

`);

  // public/packages/modal-module.js
  var $3 = module2("ctx-modal", {
    label: null,
    children: null,
    isOpen: null
  });
  $3.draw(() => {
    const {
      body,
      isOpen
    } = $3.learn();
    if (!isOpen)
      return " ";
    const modalClose = `
    <button class="close">
      Close
    </button>
  `;
    return `
    <div class="modal">
      ${modalClose}
      ${body}
    </div>
  `;
  });
  var context = `<ctx-overlay><ctx-modal></ctx-modal></ctx-overlay>`;
  document.body.insertAdjacentHTML("beforeend", context);
  function showModal2(body) {
    document.body.classList.add("overlay");
    $3.teach({
      body,
      isOpen: true
    });
  }
  window.showModal = showModal2;
  function hideModal() {
    document.body.classList.remove("overlay");
    $3.teach({
      isOpen: false
    });
  }
  window.hideModal = showModal2;
  $3.when("click", ".close", hideModal);
  $3.style(`
  body.overlay {
    overflow: hidden;
  }

  .overlay ctx-overlay:before {
    animation: fadein 250ms ease-in-out forwards;
    content: '';
    background: rgba(0,0,0, .5);
    position: fixed;
    top: 0;
    bottom: 0;
    right: 0;
    left: 0;
    backdrop-filter: blur(10px);
    z-index: 900;
  }

  @keyframes fadein {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  & {
    position: fixed;
    display: none;
    place-items: center;
    padding: 1rem;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    overflow-y: auto;
    z-index: 1100;
  }

  body.overlay & {
    display: grid;
  }

  & .modal {
    animation: modal-in 250ms ease-in-out forwards;
    background: white;
    box-shadow:
      0 2px 4px rgba(0,0,0,.1),
      0 6px 8px rgba(0,0,0,.04)
    ;
    box-sizing: border-box;
    position: relative;
    padding: 1rem;
    min-height: 100px;
    max-width: 80ch;
    width: 100%;
    z-index: -1;
    opacity: 0;
    max-height: 80vh;
    overflow: scroll;
  }

  @keyframes modal-in {
    0% {
      opacity: 0;
      z-index: -1;
    }

    100% {
      opacity: 1;
      z-index: 1100;
    }
  }

  & .close {
    background: none;
    border: none;
    padding: none;
    opacity: .8;
    transition: opacity: 200ms;
    position: absolute;
    top: 1rem;
    right: 1rem;
  }

  & .close:hover,
  & .close:focus {
    cursor: pointer;
    opacity: 1;
  }

  & .close * {
    pointer-events: none;
  }
`);

  // public/packages/script-type.js
  var BIOS_MODE = Symbol("bios");
  var NORMAL_MODE = Symbol("normal");
  var KEY_VALUE_MODE = Symbol("key-value");
  var DYNAMIC_MODE = Symbol("dynamic");
  var compile = (script) => {
    const ScriptType = {
      "#": append.bind({}, "scripttype-address"),
      "@": append.bind({}, "scripttype-character"),
      '"': append.bind({}, "scripttype-quote"),
      "(": append.bind({}, "scripttype-parenthetical"),
      "!": append.bind({}, "scripttype-information"),
      "^": append.bind({}, "scripttype-effect"),
      "<": plugin,
      "{": scope
    };
    function scope(type) {
      setScope(type);
      resetAttributes(type);
      setMode(KEY_VALUE_MODE);
    }
    function plugin(x) {
      setPlugin(x);
      resetAttributes(x);
      setMode(DYNAMIC_MODE);
    }
    const symbols2 = Object.keys(ScriptType);
    const modes = {
      [BIOS_MODE]: biosMode,
      [NORMAL_MODE]: normalMode,
      [KEY_VALUE_MODE]: kvMode,
      [DYNAMIC_MODE]: dynamicMode
    };
    const isolate = {
      scope: "global",
      plugin: "",
      mode: BIOS_MODE,
      result: ``
    };
    const lines = script.split("\n");
    for (const line of lines) {
      (modes[isolate.mode] || noop)(line);
    }
    return isolate.result;
    function biosMode(line) {
      console.log("todo: implement");
      console.log(line);
      return setMode(NORMAL_MODE);
    }
    function normalMode(line) {
      if (!line)
        return blank();
      const symbol = line[0];
      if (symbols2.includes(symbol)) {
        const [_, text] = line.split(symbol);
        return ScriptType[symbol](text.trim());
      }
      return freetext(line);
    }
    function kvMode(line) {
      const [key2, value] = line.split(":");
      if (!value) {
        if (isolate.scope === "typewriter") {
          title();
        }
        return setMode(NORMAL_MODE);
      }
      state[isolate.scope][key2.trim()] = value.trim();
    }
    function dynamicMode(line) {
      const [key2, value] = line.split(":");
      if (!value) {
        embed();
        return setMode(NORMAL_MODE);
      }
      state[isolate.plugin][key2.trim()] = value.trim();
    }
    function setMode(m) {
      isolate.mode = m;
    }
    function setScope(s) {
      isolate.scope = s;
    }
    function setPlugin(d) {
      isolate.plugin = d;
    }
    function resetAttributes(x) {
      state[x] = {};
    }
    function title() {
      const {
        title: title2,
        author,
        contact,
        agent
      } = state[isolate.scope];
      append("scripttype-title", `
      <title-cover>
        <title-main>
          <title-title>
            ${title2}
          </title-title>
          by
          <title-author>
            ${author}
          </title-author>
        </title-main>
        <title-contact>
          ${markup(contact) || ""}
        </title-contact>
        <title-agent>
          ${markup(agent) || ""}
        </title-agent>
      </title-cover>
    `);
    }
    function embed() {
      const properties = state[isolate.plugin];
      const attributes = Object.keys(properties).map((x) => `${x}="${properties[x]}"`).join("");
      isolate.result += `<${isolate.plugin} ${attributes}></${isolate.plugin}>`;
    }
    function markup(string2) {
      return string2 && string2.replaceAll("\\", "<br>");
    }
    function freetext(line) {
      append("scripttype-freetext", line);
    }
    function blank() {
      append("script-type-blankline", "");
    }
    function append(tag, content2) {
      const html = `
      <${tag}>
        ${content2}
      </${tag}>
    `;
      isolate.result += html;
    }
    function noop() {
    }
  };
  var $4 = module2("script-type");
  var $editor = module2("script-editor");
  var $viewer = module2("script-viewer");
  $4.draw((target) => {
    return `
    <div name="transport">
      <button class="print">print</button>
    </div>
    <script-editor><\/script-editor>
    <script-viewer><\/script-viewer>
  `;
  });
  $4.style(`
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }

  @media print {
    html, body {
      height: 100%;
    }
  }

  @page {
    size: 8.5in 11in;
    margin: 1in 1in 1in 1.5in;
  }

  @page {
    @top-right {
      content: counter(page) '.';
    }
  }

  @page:first {
    @top-right {
      content: '';
    }
  }


  & {
    display: grid;
    grid-template-areas:
    "transport transport"
    "editor viewer";
    grid-auto-columns: 1fr 1fr;
    grid-auto-rows: 2rem calc(100vh - 2rem);
  }

  & [name="transport"] {
    grid-area: transport;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    background: white;
    z-index: 2;
  }

  & script-editor {
    grid-area: editor;
  }

  & script-viewer {
    grid-area: viewer;
  }

  @media print {
    & [name="transport"],
    & script-editor {
      display: none;
    }

    & { display: block }
    & script-viewer { display: block }
  }

`);
  $4.when("click", ".print", print);
  $viewer.draw((target) => {
    const source2 = target.closest($4.link).getAttribute("source");
    const { formatted } = state[source2] || {};
    return `
    <div class="shadowbox">
      ${formatted}
    </div>
  `;
  });
  $editor.draw((target) => {
    const source2 = target.closest($4.link).getAttribute("source");
    const { file } = state[source2] || {};
    if (file && !target.view) {
      const config2 = {
        extensions: [
          basicSetup,
          EditorView.lineWrapping,
          EditorView.updateListener.of(
            persist2(target, $4, {})
          )
        ]
      };
      const state3 = EditorState.create({
        ...config2,
        doc: file
      });
      target.view = new EditorView({
        parent: target,
        state: state3
      });
    }
  });
  function persist2(target, $6, _flags) {
    return (update2) => {
      if (update2.changes.inserted.length < 0)
        return;
      const file = update2.view.state.doc.toString();
      const formatted = compile(file);
      const source2 = target.closest($6.link).getAttribute("source");
      state[source2] = { file, formatted };
    };
  }
  $editor.style(`
  & {
    display: block;
  }
`);
  $viewer.style(`
  & {
    display: block;
    font-size: 12pt;
    font-family: courier;
    margin: 0 auto;
    max-width: 6in;
  }
  & scripttype-title {
    display: block;
    height: 100%;
    width: 100%;
  }

  & title-cover {
    display: grid;
    grid-template-areas:
      "main main"
      "contact agent";
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr auto;
    width: 100%;
    height: 100%;
  }

  & title-main {
    place-self: center;
    grid-area: main;
    text-align: center;
  }

  & title-title {
    margin-bottom: 1rem;
  }

  & title-title,
  & title-author {
    display: block;
  }

  & title-contact {
    grid-area: contact;
  }

  & title-agent {
    grid-area: agent;
  }

  & scripttype-address,
  & scripttype-character,
  & scripttype-quote,
  & scripttype-parenthetical,
  & scripttype-information,
  & scripttype-effect,
  & scripttype-freetext,
  & scripttype-blank {
    display: block;
  }

  & scripttype-address,
  & scripttype-information {
    text-transform: uppercase;
    margin: 1rem 0;
  }

  & scripttype-character,
  & scripttype-parenthetical {
    text-align: center;
  }

  & scripttype-character {
    text-align: center;
    text-transform: uppercase;
    margin: 1rem 0 0;
  }

  & scripttype-effect {
    margin: 1rem 0;
    text-align: right;
  }

  & scripttype-quote {
    margin: 0 1in;
  }

  & scripttype-quote:first-child::before {
    content: "(CONT'D)" !important;
    display: block;
    text-align: center;
  }

  & scripttype-parenthetical::before {
    content: '(';
  }

  & scripttype-parenthetical::after {
    content: ')';
  }

  & scripttype-freetext {
    margin: 1rem 0;
  }

`);

  // public/packages/tree-view.js
  var $5 = module2("tree-view");
  $5.draw((target) => {
    const tokens = target.getAttribute("tokens");
    const config2 = state[tokens] || {};
    readTree(config2);
    return `
    <details>
      <summary>Cool</summary>
       Uncool
    </details>
  `;
  });
  function authenticationToken(config2) {
    return {
      key: config2.token,
      secret: config2.secret
    };
  }
  async function fetchUser(config2) {
    const { Response, Code } = await fetch("/proxy", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        url: "https://api.smugmug.com/api/v2!authuser",
        provider: config2.provider,
        token: authenticationToken(config2)
      })
    }).then((res) => res.json());
    if (Code === 200) {
      bus.state["smugmug/user"] = Response.User;
    }
  }
  async function fetchTree(config2) {
    const { NickName } = bus.state["smugmug/user"];
    console.log(NickName);
    const url = `https://api.smugmug.com/api/v2/user/${NickName}?_expand=Node.ChildNodes`;
    const { Response, Code } = await fetch("/proxy", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        url,
        provider: config2.provider,
        token: authenticationToken(config2)
      })
    }).then((res) => res.json());
    if (Code === 200) {
    }
  }
  async function readTree(config2) {
    await fetchUser(config2);
    console.log(bus.state["smugmug/user"]);
    await fetchTree(config2);
  }

  // public/packages/greet-friend.js
  var timeOfDayGreetings = {
    en_US: {
      key: "en_US",
      name: "greet-friend",
      morning: "Good morning",
      afternoon: "Good afternoon",
      evening: "Good evening",
      flagEmoji: "\u{1F1FA}\u{1F1F8}"
    },
    en_CA: {
      key: "en_CA",
      name: "greet-friend",
      morning: "Good morning",
      afternoon: "Good afternoon",
      evening: "Good evening",
      flagEmoji: "\u{1F1E8}\u{1F1E6}"
    },
    es_ES: {
      key: "es_ES",
      name: "saludo-amigo",
      morning: "Buenos d\xEDas",
      afternoon: "Buenas tardes",
      evening: "Buenas noches",
      flagEmoji: "\u{1F1EA}\u{1F1F8}"
    },
    fr_FR: {
      key: "fr_FR",
      name: "salut-ami",
      morning: "Bonjour",
      afternoon: "Bonne apr\xE8s-midi",
      evening: "Bonsoir",
      flagEmoji: "\u{1F1EB}\u{1F1F7}"
    },
    en_GB: {
      key: "en_GB",
      name: "greet-friend",
      morning: "Good morning",
      afternoon: "Good afternoon",
      evening: "Good evening",
      flagEmoji: "\u{1F1EC}\u{1F1E7}"
    },
    es_MX: {
      key: "es_MX",
      name: "saludo-amigo",
      morning: "Buenos d\xEDas",
      afternoon: "Buenas tardes",
      evening: "Buenas noches",
      flagEmoji: "\u{1F1F2}\u{1F1FD}"
    }
  };
  var translatedTags = [
    { locale: "en_GB", name: "greet-friend" },
    { locale: "es_ES", name: "saludo-amigo" },
    { locale: "fr_FR", name: "salut-ami" }
  ];
  function createGreetingTag(tagInfo) {
    const { name: name3, locale } = tagInfo;
    const $6 = module2(name3);
    $6.draw((target) => {
      const friendName = target.getAttribute("x");
      const language2 = target.getAttribute("language") || locale;
      const now = new Date();
      const hour = now.getHours();
      const greeting = timeOfDayGreetings[language2];
      const friendLanguage = timeOfDayGreetings[timeOfDayGreetings[language2].key];
      let timeOfDay = "morning";
      if (hour >= 5 && hour < 12) {
        timeOfDay = "morning";
      } else if (hour >= 12 && hour < 18) {
        timeOfDay = "afternoon";
      } else {
        timeOfDay = "evening";
      }
      const startAdornment = timeOfDayGreetings[locale].flagEmoji;
      const endAdornment = friendLanguage.flagEmoji;
      const message = greeting[timeOfDay];
      return `${startAdornment} ${message}, ${friendName} ${endAdornment}`;
    });
    return $6;
  }
  translatedTags.map((tagInfo) => createGreetingTag(tagInfo));
})();
