(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a2, b2) => (typeof require !== "undefined" ? require : a2)[b2]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name3 in all)
      __defProp(target, name3, { get: all[name3], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key2) && key2 !== except)
          __defProp(to2, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __publicField = (obj, key2, value) => {
    __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
    return value;
  };

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports2, module3) {
      "use strict";
      module3.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports2, module3) {
      "use strict";
      var hasSymbols = require_shams();
      module3.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports2, module3) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module3.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS({
    "node_modules/function-bind/implementation.js"(exports2, module3) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module3.exports = function bind2(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs.push("$" + i2);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports2, module3) {
      "use strict";
      var implementation = require_implementation();
      module3.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports2, module3) {
      "use strict";
      var bind2 = require_function_bind();
      module3.exports = bind2.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports2, module3) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x) {
        return x.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      var doEval = function doEval2(name3) {
        var value;
        if (name3 === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name3 === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name3 === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name3 === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name3 === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name3] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind2 = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind2.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
      var $replace = bind2.call(Function.call, String.prototype.replace);
      var $strSlice = bind2.call(Function.call, String.prototype.slice);
      var $exec = bind2.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string2) {
        var first = $strSlice(string2, 0, 1);
        var last2 = $strSlice(string2, -1);
        if (first === "%" && last2 !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last2 === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string2, rePropName, function(match, number2, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number2 || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name3, allowMissing) {
        var intrinsicName = name3;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name3 + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name3 + " does not exist!");
      };
      module3.exports = function GetIntrinsic(name3, allowMissing) {
        if (typeof name3 !== "string" || name3.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name3) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name3);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last2 = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name3 + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i2 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports2, module3) {
      "use strict";
      var bind2 = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e2) {
          $defineProperty = null;
        }
      }
      module3.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind2, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind2, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module3.exports, "apply", { value: applyBind });
      } else {
        module3.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports2, module3) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module3.exports = function callBoundIntrinsic(name3, allowMissing) {
        var intrinsic = GetIntrinsic(name3, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name3, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports2, module3) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module3.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS({
    "node_modules/is-generator-function/index.js"(exports2, module3) {
      "use strict";
      var toStr = Object.prototype.toString;
      var fnToStr = Function.prototype.toString;
      var isFnRegex = /^\s*(?:function)?\*/;
      var hasToStringTag = require_shams2()();
      var getProto = Object.getPrototypeOf;
      var getGeneratorFunc = function() {
        if (!hasToStringTag) {
          return false;
        }
        try {
          return Function("return function*() {}")();
        } catch (e2) {
        }
      };
      var GeneratorFunction;
      module3.exports = function isGeneratorFunction(fn) {
        if (typeof fn !== "function") {
          return false;
        }
        if (isFnRegex.test(fnToStr.call(fn))) {
          return true;
        }
        if (!hasToStringTag) {
          var str = toStr.call(fn);
          return str === "[object GeneratorFunction]";
        }
        if (!getProto) {
          return false;
        }
        if (typeof GeneratorFunction === "undefined") {
          var generatorFunc = getGeneratorFunc();
          GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
        }
        return getProto(fn) === GeneratorFunction;
      };
    }
  });

  // node_modules/is-callable/index.js
  var require_is_callable = __commonJS({
    "node_modules/is-callable/index.js"(exports2, module3) {
      "use strict";
      var fnToStr = Function.prototype.toString;
      var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
      var badArrayLike;
      var isCallableMarker;
      if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
        try {
          badArrayLike = Object.defineProperty({}, "length", {
            get: function() {
              throw isCallableMarker;
            }
          });
          isCallableMarker = {};
          reflectApply(function() {
            throw 42;
          }, null, badArrayLike);
        } catch (_) {
          if (_ !== isCallableMarker) {
            reflectApply = null;
          }
        }
      } else {
        reflectApply = null;
      }
      var constructorRegex = /^\s*class\b/;
      var isES6ClassFn = function isES6ClassFunction(value) {
        try {
          var fnStr = fnToStr.call(value);
          return constructorRegex.test(fnStr);
        } catch (e2) {
          return false;
        }
      };
      var tryFunctionObject = function tryFunctionToStr(value) {
        try {
          if (isES6ClassFn(value)) {
            return false;
          }
          fnToStr.call(value);
          return true;
        } catch (e2) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var objectClass = "[object Object]";
      var fnClass = "[object Function]";
      var genClass = "[object GeneratorFunction]";
      var ddaClass = "[object HTMLAllCollection]";
      var ddaClass2 = "[object HTML document.all class]";
      var ddaClass3 = "[object HTMLCollection]";
      var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
      var isIE68 = !(0 in [,]);
      var isDDA = function isDocumentDotAll() {
        return false;
      };
      if (typeof document === "object") {
        all = document.all;
        if (toStr.call(all) === toStr.call(document.all)) {
          isDDA = function isDocumentDotAll(value) {
            if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
              try {
                var str = toStr.call(value);
                return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
              } catch (e2) {
              }
            }
            return false;
          };
        }
      }
      var all;
      module3.exports = reflectApply ? function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        try {
          reflectApply(value, null, badArrayLike);
        } catch (e2) {
          if (e2 !== isCallableMarker) {
            return false;
          }
        }
        return !isES6ClassFn(value) && tryFunctionObject(value);
      } : function isCallable(value) {
        if (isDDA(value)) {
          return true;
        }
        if (!value) {
          return false;
        }
        if (typeof value !== "function" && typeof value !== "object") {
          return false;
        }
        if (hasToStringTag) {
          return tryFunctionObject(value);
        }
        if (isES6ClassFn(value)) {
          return false;
        }
        var strClass = toStr.call(value);
        if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
          return false;
        }
        return tryFunctionObject(value);
      };
    }
  });

  // node_modules/for-each/index.js
  var require_for_each = __commonJS({
    "node_modules/for-each/index.js"(exports2, module3) {
      "use strict";
      var isCallable = require_is_callable();
      var toStr = Object.prototype.toString;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var forEachArray = function forEachArray2(array, iterator, receiver) {
        for (var i2 = 0, len = array.length; i2 < len; i2++) {
          if (hasOwnProperty.call(array, i2)) {
            if (receiver == null) {
              iterator(array[i2], i2, array);
            } else {
              iterator.call(receiver, array[i2], i2, array);
            }
          }
        }
      };
      var forEachString = function forEachString2(string2, iterator, receiver) {
        for (var i2 = 0, len = string2.length; i2 < len; i2++) {
          if (receiver == null) {
            iterator(string2.charAt(i2), i2, string2);
          } else {
            iterator.call(receiver, string2.charAt(i2), i2, string2);
          }
        }
      };
      var forEachObject = function forEachObject2(object, iterator, receiver) {
        for (var k in object) {
          if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
              iterator(object[k], k, object);
            } else {
              iterator.call(receiver, object[k], k, object);
            }
          }
        }
      };
      var forEach = function forEach2(list, iterator, thisArg) {
        if (!isCallable(iterator)) {
          throw new TypeError("iterator must be a function");
        }
        var receiver;
        if (arguments.length >= 3) {
          receiver = thisArg;
        }
        if (toStr.call(list) === "[object Array]") {
          forEachArray(list, iterator, receiver);
        } else if (typeof list === "string") {
          forEachString(list, iterator, receiver);
        } else {
          forEachObject(list, iterator, receiver);
        }
      };
      module3.exports = forEach;
    }
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS({
    "node_modules/available-typed-arrays/index.js"(exports2, module3) {
      "use strict";
      var possibleNames = [
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ];
      var g2 = typeof globalThis === "undefined" ? global : globalThis;
      module3.exports = function availableTypedArrays() {
        var out = [];
        for (var i2 = 0; i2 < possibleNames.length; i2++) {
          if (typeof g2[possibleNames[i2]] === "function") {
            out[out.length] = possibleNames[i2];
          }
        }
        return out;
      };
    }
  });

  // node_modules/gopd/index.js
  var require_gopd = __commonJS({
    "node_modules/gopd/index.js"(exports2, module3) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      if ($gOPD) {
        try {
          $gOPD([], "length");
        } catch (e2) {
          $gOPD = null;
        }
      }
      module3.exports = $gOPD;
    }
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS({
    "node_modules/is-typed-array/index.js"(exports2, module3) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var gOPD = require_gopd();
      var g2 = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
        for (var i2 = 0; i2 < array.length; i2 += 1) {
          if (array[i2] === value) {
            return i2;
          }
        }
        return -1;
      };
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          var arr = new g2[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var anyTrue = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!anyTrue) {
            try {
              anyTrue = getter.call(value) === typedArray;
            } catch (e2) {
            }
          }
        });
        return anyTrue;
      };
      module3.exports = function isTypedArray(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          var tag = $slice($toString(value), 8, -1);
          return $indexOf(typedArrays, tag) > -1;
        }
        if (!gOPD) {
          return false;
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS({
    "node_modules/which-typed-array/index.js"(exports2, module3) {
      "use strict";
      var forEach = require_for_each();
      var availableTypedArrays = require_available_typed_arrays();
      var callBound = require_callBound();
      var gOPD = require_gopd();
      var $toString = callBound("Object.prototype.toString");
      var hasToStringTag = require_shams2()();
      var g2 = typeof globalThis === "undefined" ? global : globalThis;
      var typedArrays = availableTypedArrays();
      var $slice = callBound("String.prototype.slice");
      var toStrTags = {};
      var getPrototypeOf = Object.getPrototypeOf;
      if (hasToStringTag && gOPD && getPrototypeOf) {
        forEach(typedArrays, function(typedArray) {
          if (typeof g2[typedArray] === "function") {
            var arr = new g2[typedArray]();
            if (Symbol.toStringTag in arr) {
              var proto = getPrototypeOf(arr);
              var descriptor = gOPD(proto, Symbol.toStringTag);
              if (!descriptor) {
                var superProto = getPrototypeOf(proto);
                descriptor = gOPD(superProto, Symbol.toStringTag);
              }
              toStrTags[typedArray] = descriptor.get;
            }
          }
        });
      }
      var tryTypedArrays = function tryAllTypedArrays(value) {
        var foundName = false;
        forEach(toStrTags, function(getter, typedArray) {
          if (!foundName) {
            try {
              var name3 = getter.call(value);
              if (name3 === typedArray) {
                foundName = name3;
              }
            } catch (e2) {
            }
          }
        });
        return foundName;
      };
      var isTypedArray = require_is_typed_array();
      module3.exports = function whichTypedArray(value) {
        if (!isTypedArray(value)) {
          return false;
        }
        if (!hasToStringTag || !(Symbol.toStringTag in value)) {
          return $slice($toString(value), 8, -1);
        }
        return tryTypedArrays(value);
      };
    }
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS({
    "node_modules/util/support/types.js"(exports2) {
      "use strict";
      var isArgumentsObject = require_is_arguments();
      var isGeneratorFunction = require_is_generator_function();
      var whichTypedArray = require_which_typed_array();
      var isTypedArray = require_is_typed_array();
      function uncurryThis(f) {
        return f.call.bind(f);
      }
      var BigIntSupported = typeof BigInt !== "undefined";
      var SymbolSupported = typeof Symbol !== "undefined";
      var ObjectToString = uncurryThis(Object.prototype.toString);
      var numberValue = uncurryThis(Number.prototype.valueOf);
      var stringValue = uncurryThis(String.prototype.valueOf);
      var booleanValue = uncurryThis(Boolean.prototype.valueOf);
      if (BigIntSupported) {
        bigIntValue = uncurryThis(BigInt.prototype.valueOf);
      }
      var bigIntValue;
      if (SymbolSupported) {
        symbolValue = uncurryThis(Symbol.prototype.valueOf);
      }
      var symbolValue;
      function checkBoxedPrimitive(value, prototypeValueOf) {
        if (typeof value !== "object") {
          return false;
        }
        try {
          prototypeValueOf(value);
          return true;
        } catch (e2) {
          return false;
        }
      }
      exports2.isArgumentsObject = isArgumentsObject;
      exports2.isGeneratorFunction = isGeneratorFunction;
      exports2.isTypedArray = isTypedArray;
      function isPromise(input) {
        return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
      }
      exports2.isPromise = isPromise;
      function isArrayBufferView(value) {
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          return ArrayBuffer.isView(value);
        }
        return isTypedArray(value) || isDataView(value);
      }
      exports2.isArrayBufferView = isArrayBufferView;
      function isUint8Array(value) {
        return whichTypedArray(value) === "Uint8Array";
      }
      exports2.isUint8Array = isUint8Array;
      function isUint8ClampedArray(value) {
        return whichTypedArray(value) === "Uint8ClampedArray";
      }
      exports2.isUint8ClampedArray = isUint8ClampedArray;
      function isUint16Array(value) {
        return whichTypedArray(value) === "Uint16Array";
      }
      exports2.isUint16Array = isUint16Array;
      function isUint32Array(value) {
        return whichTypedArray(value) === "Uint32Array";
      }
      exports2.isUint32Array = isUint32Array;
      function isInt8Array(value) {
        return whichTypedArray(value) === "Int8Array";
      }
      exports2.isInt8Array = isInt8Array;
      function isInt16Array(value) {
        return whichTypedArray(value) === "Int16Array";
      }
      exports2.isInt16Array = isInt16Array;
      function isInt32Array(value) {
        return whichTypedArray(value) === "Int32Array";
      }
      exports2.isInt32Array = isInt32Array;
      function isFloat32Array(value) {
        return whichTypedArray(value) === "Float32Array";
      }
      exports2.isFloat32Array = isFloat32Array;
      function isFloat64Array(value) {
        return whichTypedArray(value) === "Float64Array";
      }
      exports2.isFloat64Array = isFloat64Array;
      function isBigInt64Array(value) {
        return whichTypedArray(value) === "BigInt64Array";
      }
      exports2.isBigInt64Array = isBigInt64Array;
      function isBigUint64Array(value) {
        return whichTypedArray(value) === "BigUint64Array";
      }
      exports2.isBigUint64Array = isBigUint64Array;
      function isMapToString(value) {
        return ObjectToString(value) === "[object Map]";
      }
      isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
      function isMap(value) {
        if (typeof Map === "undefined") {
          return false;
        }
        return isMapToString.working ? isMapToString(value) : value instanceof Map;
      }
      exports2.isMap = isMap;
      function isSetToString(value) {
        return ObjectToString(value) === "[object Set]";
      }
      isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
      function isSet(value) {
        if (typeof Set === "undefined") {
          return false;
        }
        return isSetToString.working ? isSetToString(value) : value instanceof Set;
      }
      exports2.isSet = isSet;
      function isWeakMapToString(value) {
        return ObjectToString(value) === "[object WeakMap]";
      }
      isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
      function isWeakMap(value) {
        if (typeof WeakMap === "undefined") {
          return false;
        }
        return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
      }
      exports2.isWeakMap = isWeakMap;
      function isWeakSetToString(value) {
        return ObjectToString(value) === "[object WeakSet]";
      }
      isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
      function isWeakSet(value) {
        return isWeakSetToString(value);
      }
      exports2.isWeakSet = isWeakSet;
      function isArrayBufferToString(value) {
        return ObjectToString(value) === "[object ArrayBuffer]";
      }
      isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
      function isArrayBuffer(value) {
        if (typeof ArrayBuffer === "undefined") {
          return false;
        }
        return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
      }
      exports2.isArrayBuffer = isArrayBuffer;
      function isDataViewToString(value) {
        return ObjectToString(value) === "[object DataView]";
      }
      isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
      function isDataView(value) {
        if (typeof DataView === "undefined") {
          return false;
        }
        return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
      }
      exports2.isDataView = isDataView;
      var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
      function isSharedArrayBufferToString(value) {
        return ObjectToString(value) === "[object SharedArrayBuffer]";
      }
      function isSharedArrayBuffer(value) {
        if (typeof SharedArrayBufferCopy === "undefined") {
          return false;
        }
        if (typeof isSharedArrayBufferToString.working === "undefined") {
          isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
        }
        return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
      }
      exports2.isSharedArrayBuffer = isSharedArrayBuffer;
      function isAsyncFunction(value) {
        return ObjectToString(value) === "[object AsyncFunction]";
      }
      exports2.isAsyncFunction = isAsyncFunction;
      function isMapIterator(value) {
        return ObjectToString(value) === "[object Map Iterator]";
      }
      exports2.isMapIterator = isMapIterator;
      function isSetIterator(value) {
        return ObjectToString(value) === "[object Set Iterator]";
      }
      exports2.isSetIterator = isSetIterator;
      function isGeneratorObject(value) {
        return ObjectToString(value) === "[object Generator]";
      }
      exports2.isGeneratorObject = isGeneratorObject;
      function isWebAssemblyCompiledModule(value) {
        return ObjectToString(value) === "[object WebAssembly.Module]";
      }
      exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
      function isNumberObject(value) {
        return checkBoxedPrimitive(value, numberValue);
      }
      exports2.isNumberObject = isNumberObject;
      function isStringObject(value) {
        return checkBoxedPrimitive(value, stringValue);
      }
      exports2.isStringObject = isStringObject;
      function isBooleanObject(value) {
        return checkBoxedPrimitive(value, booleanValue);
      }
      exports2.isBooleanObject = isBooleanObject;
      function isBigIntObject(value) {
        return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
      }
      exports2.isBigIntObject = isBigIntObject;
      function isSymbolObject(value) {
        return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
      }
      exports2.isSymbolObject = isSymbolObject;
      function isBoxedPrimitive(value) {
        return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
      }
      exports2.isBoxedPrimitive = isBoxedPrimitive;
      function isAnyArrayBuffer(value) {
        return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
      }
      exports2.isAnyArrayBuffer = isAnyArrayBuffer;
      ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
        Object.defineProperty(exports2, method, {
          enumerable: false,
          value: function() {
            throw new Error(method + " is not supported in userland");
          }
        });
      });
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports2, module3) {
      module3.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports2, module3) {
      if (typeof Object.create === "function") {
        module3.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module3.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports2) {
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
        var keys4 = Object.keys(obj);
        var descriptors = {};
        for (var i2 = 0; i2 < keys4.length; i2++) {
          descriptors[keys4[i2]] = Object.getOwnPropertyDescriptor(obj, keys4[i2]);
        }
        return descriptors;
      };
      var formatRegExp = /%[sdj%]/g;
      exports2.format = function(f) {
        if (!isString2(f)) {
          var objects = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            objects.push(inspect(arguments[i2]));
          }
          return objects.join(" ");
        }
        var i2 = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i2 >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i2++]);
            case "%d":
              return Number(args[i2++]);
            case "%j":
              try {
                return JSON.stringify(args[i2++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i2]; i2 < len; x = args[++i2]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports2.deprecate = function(fn, msg2) {
        if (typeof process !== "undefined" && process.noDeprecation === true) {
          return fn;
        }
        if (typeof process === "undefined") {
          return function() {
            return exports2.deprecate(fn, msg2).apply(this, arguments);
          };
        }
        var warned2 = false;
        function deprecated() {
          if (!warned2) {
            if (process.throwDeprecation) {
              throw new Error(msg2);
            } else if (process.traceDeprecation) {
              console.trace(msg2);
            } else {
              console.error(msg2);
            }
            warned2 = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnvRegex = /^$/;
      if (process.env.NODE_DEBUG) {
        debugEnv = process.env.NODE_DEBUG;
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
        debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
      }
      var debugEnv;
      exports2.debuglog = function(set3) {
        set3 = set3.toUpperCase();
        if (!debugs[set3]) {
          if (debugEnvRegex.test(set3)) {
            var pid = process.pid;
            debugs[set3] = function() {
              var msg2 = exports2.format.apply(exports2, arguments);
              console.error("%s %d: %s", set3, pid, msg2);
            };
          } else {
            debugs[set3] = function() {
            };
          }
        }
        return debugs[set3];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports2._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue2(ctx, obj, ctx.depth);
      }
      exports2.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue2(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString2(ret)) {
            ret = formatValue2(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys4 = Object.keys(value);
        var visibleKeys = arrayToHash(keys4);
        if (ctx.showHidden) {
          keys4 = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys4.indexOf("message") >= 0 || keys4.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys4.length === 0) {
          if (isFunction(value)) {
            var name3 = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name3 + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base2 = "", array = false, braces = ["{", "}"];
        if (isArray5(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n2 = value.name ? ": " + value.name : "";
          base2 = " [Function" + n2 + "]";
        }
        if (isRegExp(value)) {
          base2 = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base2 = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base2 = " " + formatError(value);
        }
        if (keys4.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base2 + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys4);
        } else {
          output = keys4.map(function(key2) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base2, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString2(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys4) {
        var output = [];
        for (var i2 = 0, l = value.length; i2 < l; ++i2) {
          if (hasOwnProperty(value, String(i2))) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              String(i2),
              true
            ));
          } else {
            output.push("");
          }
        }
        keys4.forEach(function(key2) {
          if (!key2.match(/^\d+$/)) {
            output.push(formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key2,
              true
            ));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
        var name3, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key2)) {
          name3 = "[" + key2 + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue2(ctx, desc.value, null);
            } else {
              str = formatValue2(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").slice(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name3)) {
          if (array && key2.match(/^\d+$/)) {
            return str;
          }
          name3 = JSON.stringify("" + key2);
          if (name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name3 = name3.slice(1, -1);
            name3 = ctx.stylize(name3, "name");
          } else {
            name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name3 = ctx.stylize(name3, "string");
          }
        }
        return name3 + ": " + str;
      }
      function reduceToSingleString(output, base2, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur2) {
          numLinesEst++;
          if (cur2.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur2.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
      }
      exports2.types = require_types();
      function isArray5(ar) {
        return Array.isArray(ar);
      }
      exports2.isArray = isArray5;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports2.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports2.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports2.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports2.isNumber = isNumber;
      function isString2(arg) {
        return typeof arg === "string";
      }
      exports2.isString = isString2;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports2.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports2.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports2.isRegExp = isRegExp;
      exports2.types.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports2.isObject = isObject;
      function isDate(d2) {
        return isObject(d2) && objectToString(d2) === "[object Date]";
      }
      exports2.isDate = isDate;
      exports2.types.isDate = isDate;
      function isError(e2) {
        return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
      }
      exports2.isError = isError;
      exports2.types.isNativeError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports2.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports2.isPrimitive = isPrimitive;
      exports2.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n2) {
        return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d2 = new Date();
        var time = [
          pad(d2.getHours()),
          pad(d2.getMinutes()),
          pad(d2.getSeconds())
        ].join(":");
        return [d2.getDate(), months[d2.getMonth()], time].join(" ");
      }
      exports2.log = function() {
        console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
      };
      exports2.inherits = require_inherits_browser();
      exports2._extend = function(origin, add2) {
        if (!add2 || !isObject(add2))
          return origin;
        var keys4 = Object.keys(add2);
        var i2 = keys4.length;
        while (i2--) {
          origin[keys4[i2]] = add2[keys4[i2]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
      exports2.promisify = function promisify(original) {
        if (typeof original !== "function")
          throw new TypeError('The "original" argument must be of type Function');
        if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
          var fn = original[kCustomPromisifiedSymbol];
          if (typeof fn !== "function") {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          }
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
          return fn;
        }
        function fn() {
          var promiseResolve, promiseReject;
          var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
          });
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          args.push(function(err, value) {
            if (err) {
              promiseReject(err);
            } else {
              promiseResolve(value);
            }
          });
          try {
            original.apply(this, args);
          } catch (err) {
            promiseReject(err);
          }
          return promise;
        }
        Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
        if (kCustomPromisifiedSymbol)
          Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
          });
        return Object.defineProperties(
          fn,
          getOwnPropertyDescriptors(original)
        );
      };
      exports2.promisify.custom = kCustomPromisifiedSymbol;
      function callbackifyOnRejected(reason, cb) {
        if (!reason) {
          var newReason = new Error("Promise was rejected with a falsy value");
          newReason.reason = reason;
          reason = newReason;
        }
        return cb(reason);
      }
      function callbackify(original) {
        if (typeof original !== "function") {
          throw new TypeError('The "original" argument must be of type Function');
        }
        function callbackified() {
          var args = [];
          for (var i2 = 0; i2 < arguments.length; i2++) {
            args.push(arguments[i2]);
          }
          var maybeCb = args.pop();
          if (typeof maybeCb !== "function") {
            throw new TypeError("The last argument must be of type Function");
          }
          var self2 = this;
          var cb = function() {
            return maybeCb.apply(self2, arguments);
          };
          original.apply(this, args).then(
            function(ret) {
              process.nextTick(cb.bind(null, null, ret));
            },
            function(rej) {
              process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
            }
          );
        }
        Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
        Object.defineProperties(
          callbackified,
          getOwnPropertyDescriptors(original)
        );
        return callbackified;
      }
      exports2.callbackify = callbackify;
    }
  });

  // public/statebus/statebus.js
  var require_statebus = __commonJS({
    "public/statebus/statebus.js"(exports, module) {
      (function(name3, definition) {
        window[name3] = definition();
      })("statebus", function() {
        var statelog_indent = 0;
        var busses = {}, bus_count = 0, executing_funk, global_funk, funks = {}, clean_timer, symbols, nodejs = typeof window === "undefined";
        function make_bus(options) {
          function get(key2, callback) {
            if (typeof key2 !== "string" && !(typeof key2 === "object" && typeof key2.key === "string"))
              throw "Error: get(key) called with key = " + JSON.stringify(key2);
            key2 = key2.key || key2;
            bogus_check(key2);
            var called_from_reactive_funk = !callback;
            var funk = callback || executing_funk;
            if (callback) {
              (callback.defined = callback.defined || []).push({ as: "get callback", key: key2 });
              callback.has_seen = callback.has_seen || function(bus3, key3, version) {
                callback.seen_keys = callback.seen_keys || {};
                var bus_key = JSON.stringify([bus3.id, key3]);
                var seen_versions = callback.seen_keys[bus_key] = callback.seen_keys[bus_key] || [];
                seen_versions.push(version);
                if (seen_versions.length > 50)
                  seen_versions.shift();
              };
            }
            gets_in.add(key2, funk_key(funk));
            if (to_be_forgotten[key2]) {
              clearTimeout(to_be_forgotten[key2]);
              delete to_be_forgotten[key2];
            }
            bind(key2, "on_set", funk);
            var getterters = 0;
            if (!gets_out[key2])
              getterters = bus.route(key2, "getter", key2);
            if (called_from_reactive_funk) {
              funk.has_seen(bus, key2, versions[key2]);
              backup_cache[key2] = backup_cache[key2] || { key: key2 };
              return cache[key2] = cache[key2] || { key: key2 };
            } else if (!pending_gets[key2] && getterters === 0) {
              backup_cache[key2] = backup_cache[key2] || { key: key2 };
              run_handler(funk, "on_set", cache[key2] = cache[key2] || { key: key2 });
            }
          }
          function get_once(key2, cb) {
            function cb2(o) {
              cb(o);
              forget(key2, cb2);
            }
            get(key2, cb2);
          }
          get.once = get_once;
          var pending_gets = {};
          var gets_out = {};
          var gets_in = new One_To_Many();
          var currently_saving;
          function set(obj, t2) {
            if (typeof obj === "string" && t2 && t2.patch) {
              if (typeof t2.patch == "string")
                t2.patch = [t2.patch];
              obj = apply_patch(bus.cache[obj] || { key: obj }, t2.patch[0]);
            }
            if (!("key" in obj) || typeof obj.key !== "string") {
              console.error("Error: set(obj) called on object without a key: ", obj);
              console.trace("Bad set(obj)");
            }
            bogus_check(obj.key);
            t2 = t2 || {};
            t2.version = t2.version || new_version();
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes([obj.key]);
              return;
            }
            if (honking_at(obj.key))
              var message = set_msg(obj, t2, "set");
            if (obj.key && !changed(obj)) {
              statelog(obj.key, grey, "x", message);
              return;
            } else
              statelog(obj.key, red, "o", message);
            try {
              statelog_indent++;
              var was_saving = currently_saving;
              currently_saving = obj.key;
              var num_handlers = bus.route(obj.key, "setter", obj, t2);
              if (num_handlers === 0) {
                set.fire(obj, t2);
                bus.route(obj.key, "on_set_sync", obj, t2);
              }
            } finally {
              statelog_indent--;
              currently_saving = was_saving;
            }
          }
          set.sync = function set_sync(obj, t2) {
            t2 = bus.clone(t2 || {});
            t2.version = executing_funk && executing_funk.transaction && executing_funk.transaction.version || executing_funk && executing_funk.latest_reaction_at;
            set(obj, t2);
          };
          set.fire = fire;
          function fire(obj, t2) {
            t2 = t2 || {};
            t2.version = t2.version || executing_funk && executing_funk.latest_reaction_at || new_version();
            if (obj.key && honking_at(obj.key)) {
              var message = set_msg(obj, t2, "set.fire");
              var color, icon;
              if (currently_saving === obj.key && !(obj.key && !changed(obj))) {
                statelog_indent--;
                statelog(obj.key, red, "\u2022", "\u21B5" + (t2.version ? "			[" + t2.version + "]" : ""));
                statelog_indent++;
              } else {
                if (obj.key && !changed(obj)) {
                  color = grey;
                  icon = "x";
                  if (t2.getter)
                    message = t2.m || "Got " + bus + "('" + obj.key + "')";
                  if (t2.version)
                    message += " [" + t2.version + "]";
                  statelog(obj.key, color, icon, message);
                  return;
                }
                color = red, icon = "\u2022";
                if (t2.getter || pending_gets[obj.key]) {
                  color = green;
                  icon = "^";
                  message = add_diff_msg(
                    t2.m || "Got " + bus + "('" + obj.key + "')",
                    obj
                  );
                  if (t2.version)
                    message += " [" + t2.version + "]";
                }
                statelog(obj.key, color, icon, message);
              }
            }
            var modified_keys = update_cache(obj, cache);
            delete pending_gets[obj.key];
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes(modified_keys);
            } else {
              update_cache(obj, backup_cache);
              for (var i2 = 0; i2 < modified_keys.length; i2++) {
                var key2 = modified_keys[i2];
                var parents = [versions[key2]];
                versions[key2] = t2.version;
                mark_changed(key2, t2);
              }
            }
          }
          set.abort = function(obj, t2) {
            if (!obj)
              console.error("No obj", obj);
            abort_changes([obj.key]);
            statelog(obj.key, yellow, "<", "Aborting " + obj.key);
            mark_changed(obj.key, t2);
          };
          var version_count = 0;
          function new_version() {
            return (bus.label || id + " ") + (version_count++).toString(36);
          }
          function bus(arg1, arg2) {
            if (typeof arg1 === "function") {
              var f = reactive(arg1);
              f();
              return f;
            } else
              return subspace(arg1, arg2);
          }
          var id = "bus-" + Math.random().toString(36).substring(7);
          bus.toString = function() {
            return bus.label || "bus" + this_bus_num || id;
          };
          bus.delete_bus = function() {
            delete busses[bus.id];
          };
          var cache = {};
          var backup_cache = {};
          var versions = {};
          function update_cache(object, cache2) {
            var modified_keys = new Set();
            function update_object(obj) {
              if (Array.isArray(obj))
                obj = obj.slice();
              else if (typeof obj === "object" && obj && !(obj.key && cache2[obj.key] === obj)) {
                var tmp = {};
                for (var k in obj)
                  tmp[k] = obj[k];
                obj = tmp;
              }
              if ((nodejs ? global : window).pointerify && obj && obj._key) {
                if (Object.keys(obj).length > 1)
                  console.error("Got a {_key: ...} object with additional fields");
                obj = bus.cache[obj._key] = bus.cache[obj._key] || { key: obj._key };
              } else if (obj && obj.key) {
                bogus_check(obj.key);
                if (cache2 !== backup_cache)
                  if (changed(obj))
                    modified_keys.add(obj.key);
                  else
                    log("Boring modified key", obj.key);
                if (!cache2[obj.key])
                  cache2[obj.key] = obj;
                else if (obj !== cache2[obj.key]) {
                  for (var k in obj)
                    if (cache2[obj.key][k] !== obj[k])
                      cache2[obj.key][k] = obj[k];
                  for (var k in cache2[obj.key])
                    if (!obj.hasOwnProperty(k))
                      delete cache2[obj.key][k];
                }
                obj = cache2[obj.key];
              }
              return obj;
            }
            deep_map(object, update_object);
            return modified_keys.values();
          }
          function changed(object) {
            return pending_gets[object.key] || !cache.hasOwnProperty(object.key) || !backup_cache.hasOwnProperty(object.key) || !deep_equals(object, backup_cache[object.key]);
          }
          function abort_changes(keys4) {
            for (var i2 = 0; i2 < keys4.length; i2++)
              update_cache(backup_cache[keys4[i2]], cache);
          }
          function forget(key2, set_handler, t2) {
            if (arguments.length === 0) {
              console.assert(
                executing_funk !== global_funk,
                "forget() with no arguments forgets the currently executing reactive function.\nHowever, there is no currently executing reactive function."
              );
              executing_funk.forget();
              return;
            }
            bogus_check(key2);
            set_handler = set_handler || executing_funk;
            var fkey = funk_key(set_handler);
            if (!gets_in.has(key2, fkey)) {
              console.error(
                "***\n****\nTrying to forget lost key",
                key2,
                "from",
                funk_name(set_handler),
                fkey,
                "that hasn't got that key."
              );
              console.trace();
              return;
            }
            gets_in.delete(key2, fkey);
            unbind(key2, "on_set", set_handler);
            if (!gets_in.has_any(key2)) {
              clearTimeout(to_be_forgotten[key2]);
              to_be_forgotten[key2] = setTimeout(function() {
                bus.route(key2, "forgetter", key2, t2);
                delete gets_out[key2];
                delete to_be_forgotten[key2];
              }, 200);
            }
          }
          function del(key2, t2) {
            key2 = key2.key || key2;
            bogus_check(key2);
            if (executing_funk !== global_funk && executing_funk.loading()) {
              abort_changes([key2]);
              return;
            }
            statelog(key2, yellow, "v", "Deleting " + key2);
            var handlers_called = bus.route(key2, "deleter", key2);
            if (handlers_called === 0) {
              delete cache[key2];
              delete backup_cache[key2];
            }
            bus.route(key2, "on_delete", cache[key2] || { key: key2 }, t2);
          }
          var changed_keys = new Set();
          var dirty_getters = {};
          function dirty(key2, t2) {
            statelog(key2, brown, "*", bus + ".dirty('" + key2 + "')");
            bogus_check(key2);
            var version = t2 && t2.version || "dirty-" + new_version();
            var found = false;
            if (gets_out.hasOwnProperty(key2))
              for (var i2 = 0; i2 < gets_out[key2].length; i2++) {
                dirty_getters[funk_key(gets_out[key2][i2])] = version;
                found = true;
              }
            clean_timer = clean_timer || setTimeout(clean);
            if (!found && cache.hasOwnProperty(key2))
              mark_changed(key2, t2);
          }
          function mark_changed(key2, t2) {
            log("Marking changed", bus.toString(), key2);
            changed_keys.add(key2);
            clean_timer = clean_timer || setTimeout(clean);
          }
          function clean() {
            var dirty_funks = {};
            for (var b2 in busses) {
              var fs = busses[b2].rerunnable_funks();
              for (var i2 = 0; i2 < fs.length; i2++)
                dirty_funks[fs[i2].funk_key] = fs[i2].at_version;
            }
            clean_timer = null;
            log(bus.label, "Cleaning up", Object.keys(dirty_funks).length, "funks");
            for (var k in dirty_funks) {
              var funk = funks[k], version = dirty_funks[k];
              var p2 = funk.proxies_for;
              if (p2 && p2.priority) {
                log("Clean-early:", funk_name(funk));
                if (!funk.global_funk)
                  funk.latest_reaction_at = version;
                funk.react();
                delete dirty_funks[k];
              }
            }
            for (var k in dirty_funks) {
              var funk = funks[k], version = dirty_funks[k];
              log("Clean:", funk_name(funk));
              if (bus.render_when_loading || !funk.loading()) {
                if (!funk.global_funk)
                  funk.latest_reaction_at = version;
                funk.react();
              }
            }
          }
          function rerunnable_funks() {
            var result = [];
            var keys4 = changed_keys.values();
            for (var i2 = 0; i2 < keys4.length; i2++) {
              var fs = bindings(keys4[i2], "on_set");
              for (var j = 0; j < fs.length; j++) {
                var f = fs[j].func;
                if (f.react) {
                  var v = f.getted_keys[JSON.stringify([this.id, keys4[i2]])];
                  if (v && v.indexOf(versions[keys4[i2]]) !== -1) {
                    log("skipping", funk_name(f), "already at version", versions[keys4[i2]], "proof:", v);
                    continue;
                  }
                } else {
                  f.seen_keys = f.seen_keys || {};
                  var v = f.seen_keys[JSON.stringify([this.id, keys4[i2]])];
                  if (v && v.indexOf(versions[keys4[i2]]) !== -1) {
                    continue;
                  }
                  autodetect_args(f);
                  f = run_handler(f, "on_set", cache[keys4[i2]], {
                    dont_run: true,
                    binding: keys4[i2]
                  });
                }
                result.push({
                  funk_key: funk_key(f),
                  at_version: versions[keys4[i2]]
                });
              }
            }
            for (var k in dirty_getters)
              result.push({
                funk_key: k,
                at_version: dirty_getters[k]
              });
            changed_keys.clear();
            dirty_getters = {};
            return result;
          }
          function subspace(key2, params) {
            var methods = {
              getter: null,
              setter: null,
              on_set: null,
              on_set_sync: null,
              on_delete: null,
              deleter: null,
              forgetter: null
            };
            if (params) {
              for (var method in params) {
                var func = params[method];
                var param_names = {
                  get: "getter",
                  set: "setter",
                  delete: "deleter",
                  forget: "forgetter",
                  on_set: "on_set",
                  on_set_sync: "on_set_sync"
                };
                console.assert(
                  param_names[method],
                  'Method "' + method + '" is invalid'
                );
                method = param_names[method];
                autodetect_args(func);
                func.defined = func.defined || [];
                func.defined.push({ bus, method, key: key2, as: "handler" });
                func.use_linked_json = true;
                bind(key2, method, func, "allow_wildcards");
              }
            } else {
              var result = {};
              for (var method in methods)
                (function(method2) {
                  Object.defineProperty(result, method2, {
                    set: function(func2) {
                      autodetect_args(func2);
                      func2.defined = func2.defined || [];
                      func2.defined.push(
                        { as: "handler", bus, method: method2, key: key2 }
                      );
                      bind(key2, method2, func2, "allow_wildcards");
                    },
                    get: function() {
                      var result2 = bindings(key2, method2);
                      for (var i2 = 0; i2 < result2.length; i2++)
                        result2[i2] = result2[i2].func;
                      result2.delete = function(func2) {
                        unbind(key2, method2, func2, "allow_wildcards");
                      };
                      return result2;
                    }
                  });
                })(method);
              return result;
            }
          }
          function autodetect_args(handler) {
            if (handler.args)
              return;
            var comments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, params = /([^\s,]+)/g, s = handler.toString().replace(comments, "");
            params = s.slice(s.indexOf("(") + 1, s.indexOf(")")).match(params) || [];
            handler.args = {};
            for (var i2 = 0; i2 < params.length; i2++)
              switch (params[i2]) {
                case "key":
                case "k":
                  handler.args["key"] = i2;
                  break;
                case "json":
                case "vars":
                  handler.args["vars"] = i2;
                  break;
                case "star":
                case "rest":
                  handler.args["rest"] = i2;
                  break;
                case "cb":
                case "t":
                case "transaction":
                  handler.args["t"] = i2;
                  break;
                case "o":
                case "obj":
                case "val":
                case "new":
                case "New":
                  handler.args["obj"] = i2;
                  break;
                case "old":
                  handler.args["old"] = i2;
                  break;
              }
          }
          var handlers = new One_To_Many();
          var wildcard_handlers = [];
          var to_be_forgotten = {};
          function bind(key2, method, func, allow_wildcards) {
            bogus_check(key2);
            if (allow_wildcards && key2[key2.length - 1] === "*")
              wildcard_handlers.push({
                prefix: key2,
                method,
                funk: func
              });
            else
              handlers.add(method + " " + key2, funk_key(func));
          }
          function unbind(key2, method, funk, allow_wildcards) {
            bogus_check(key2);
            if (allow_wildcards && key2[key2.length - 1] === "*")
              for (var i2 = 0; i2 < wildcard_handlers.length; i2++) {
                var handler = wildcard_handlers[i2];
                if (handler.prefix === key2 && handler.method === method && handler.funk === funk) {
                  wildcard_handlers.splice(i2, 1);
                  i2--;
                }
              }
            else
              handlers.delete(method + " " + key2, funk_key(funk));
          }
          function bindings(key2, method) {
            bogus_check(key2);
            if (typeof key2 !== "string") {
              console.error("Error:", key2, "is not a string", method);
              console.trace();
            }
            var result = [];
            var seen = {};
            var exacts = handlers.get(method + " " + key2);
            for (var i2 = 0; i2 < exacts.length; i2++) {
              var f = funks[exacts[i2]];
              if (!seen[funk_key(f)]) {
                f.statebus_binding = { key: key2, method };
                result.push({ method, key: key2, func: f });
                seen[funk_key(f)] = true;
              }
            }
            let handler;
            for (var i2 = 0; i2 < wildcard_handlers.length; i2++) {
              handler = wildcard_handlers[i2];
              var prefix2 = handler.prefix.slice(0, -1);
              if (prefix2 === key2.substr(0, prefix2.length) && method === handler.method && !seen[funk_key(handler.funk)]) {
                handler.funk.statebus_binding = { key: handler.prefix, method };
                result.push({ method, key: handler.prefix, func: handler.funk });
                seen[funk_key(handler.funk)] = true;
              }
            }
            return result;
          }
          function run_handler(funck, method, arg, options2) {
            options2 = options2 || {};
            var t2 = options2.t, just_make_it = options2.dont_run, binding = options2.binding;
            var funk = funck.react && funck, func = !funk && funck;
            console.assert(funk || func);
            if (false) {
              var event = {
                "setter": "set",
                "on_set": "set.fire",
                "getter": "get",
                "deleter": "delete",
                "forgetter": "forget"
              }[method], triggering = funk ? "re-running" : "initiating";
              console.log("   > a", bus + "." + event + "('" + (arg.key || arg) + "') is " + triggering + "\n     " + funk_name(funck));
            }
            if (funk) {
              if (method !== "on_set") {
                console.error(method === "on_set", `Funk is being re-triggered, but isn't on_set. It is: "` + method + '", oh and funk: ' + funk_name(funk));
                return;
              }
              return funk.react();
            }
            function key_arg() {
              return typeof arg.key == "string" ? arg.key : arg;
            }
            function rest_arg() {
              return key_arg().substr(binding.length - 1);
            }
            function val_arg() {
              console.assert(
                method === "setter" || method === "on_set" || method === "on_set_sync",
                "Bad method for val_arg()"
              );
              return arg.key ? func.use_linked_json ? arg.val : arg : void 0;
            }
            function vars_arg() {
              var r = rest_arg();
              try {
                return JSON.parse(r);
              } catch (e2) {
                return 'Bad JSON "' + r + '" for key ' + key_arg();
              }
            }
            var f = reactive(function() {
              t2 = clone(t2 || {});
              if (method === "setter" || method === "deleter")
                t2.abort = function() {
                  var key4 = method === "setter" ? arg.key : arg;
                  if (f.loading())
                    return;
                  bus.cache[key4] = bus.cache[key4] || { key: key4 };
                  bus.backup_cache[key4] = bus.backup_cache[key4] || { key: key4 };
                  bus.set.abort(bus.cache[key4]);
                };
              if (method !== "forgetter")
                t2.done = function(o) {
                  var key4 = method === "setter" ? arg.key : arg;
                  if (func.use_linked_json)
                    o = { key: key4, val: o };
                  bus.log("We are DONE()ing", method, key4, o || arg);
                  if (o)
                    t2.version = new_version();
                  if (method === "deleter") {
                    delete bus.cache[key4];
                    delete bus.backup_cache[key4];
                  } else if (method === "setter") {
                    bus.set.fire(o || arg, t2);
                    bus.route(key4, "on_set_sync", o || arg, t2);
                  } else {
                    o.key = key4;
                    bus.set.fire(o, t2);
                    delete t2.version;
                  }
                };
              t2.return = t2.done;
              if (method === "setter")
                t2.reget = function() {
                  bus.dirty(arg.key);
                };
              var args = [];
              args[0] = method in { setter: 1, on_set: 1, on_set_sync: 1 } ? val_arg() : arg;
              args[1] = t2;
              for (var k in func.args || {}) {
                switch (k) {
                  case "key":
                    args[func.args[k]] = key_arg();
                    break;
                  case "rest":
                    args[func.args[k]] = rest_arg();
                    break;
                  case "vars":
                    args[func.args[k]] = vars_arg();
                    break;
                  case "t":
                    args[func.args[k]] = t2;
                    break;
                  case "obj":
                    args[func.args[k]] = val_arg();
                    break;
                  case "old":
                    var key3 = key_arg();
                    args[func.args[k]] = bus.cache[key3] || (bus.cache[key3] = { key: key3 });
                    break;
                }
              }
              var result = func.apply(null, args);
              console.assert(
                !(result === "getter" && (result === "done" || result === "abort")),
                'Returning "done" or "abort" is not allowed from getter handlers'
              );
              if (result === "done")
                t2.done();
              if (result === "abort")
                t2.abort();
              if (func.use_linked_json) {
                if (method === "getter" && result !== void 0 && !f.loading()) {
                  var obj = { key: arg, val: result };
                  var new_t = clone(t2 || {});
                  new_t.getter = true;
                  set.fire(obj, new_t);
                  return result;
                }
              } else {
                if (method === "getter" && result instanceof Object && !f.loading()) {
                  result.key = arg;
                  var new_t = clone(t2 || {});
                  new_t.getter = true;
                  set.fire(result, new_t);
                  return result;
                }
              }
              if (method !== "getter" && !f.loading())
                f.forget();
            });
            f.proxies_for = func;
            f.arg = arg;
            f.transaction = t2 || {};
            if (method === "getter") {
              let handler_done2 = function() {
                f.forget();
                unbind(key2, "forgetter", handler_done2);
              };
              var handler_done = handler_done2;
              var key2 = arg;
              bind(key2, "forgetter", handler_done2);
              gets_out[key2] = gets_out[key2] || [];
              gets_out[key2].push(f);
              pending_gets[key2] = f;
            }
            if (just_make_it)
              return f;
            return f();
          }
          bus.route = function(key2, method, arg, t2) {
            var handlers3 = bus.bindings(key2, method);
            if (handlers3.length)
              log("route:", bus + '("' + key2 + '").' + method + "[" + handlers3.length + '](key:"' + (arg.key || arg) + '")');
            for (var i2 = 0; i2 < handlers3.length; i2++)
              bus.run_handler(handlers3[i2].func, method, arg, { t: t2, binding: handlers3[i2].key });
            return handlers3.length;
          };
          if (!global_funk) {
            global_funk = reactive(function global_funk2() {
            });
            global_funk.global_funk = true;
            executing_funk = global_funk;
            funks[global_funk.statebus_id = "global funk"] = global_funk;
          }
          function reactive(func) {
            function funk() {
              console.assert(executing_funk === global_funk || executing_funk !== funk, "Recursive funk", funk.func);
              if (funk.called_directly)
                funk.this = this, funk.args = arguments;
              funk.forget();
              var last_executing_funk = executing_funk;
              executing_funk = funk;
              try {
                var result = func.apply(funk.this, funk.args);
              } catch (e2) {
                if (e2.message === "Maximum call stack size exceeded") {
                  console.error(e2);
                  process.exit();
                }
                if (funk.loading())
                  return null;
                else {
                  if (nodejs) {
                    console.error(e2.stack);
                    process.exit();
                  } else {
                    var result = func.apply(funk.this, funk.args);
                    console.error("Non-deterministic Error!", e2.stack || e2);
                    console.warn("A non-deterministic error is when your reactive function triggers an error only some of the times it's called.\nThe error originated from calling:", funk_name(func, 400));
                  }
                }
              } finally {
                executing_funk = last_executing_funk;
              }
              return result;
            }
            funk.func = func;
            funk.called_directly = true;
            funk.getted_keys = {};
            funk.abortable_keys = [];
            funk.has_seen = function(bus3, key2, version) {
              var bus_key = JSON.stringify([bus3.id, key2]);
              var seen_versions = this.getted_keys[bus_key] = this.getted_keys[bus_key] || [];
              seen_versions.push(version);
              if (seen_versions.length > 50)
                seen_versions.shift();
            };
            funk.react = function() {
              var result;
              try {
                funk.called_directly = false;
                result = funk();
              } finally {
                funk.called_directly = true;
              }
              return result;
            };
            funk.forget = function() {
              if (funk.statebus_id === "global funk")
                return;
              for (var hash in funk.getted_keys) {
                var tmp = JSON.parse(hash), bus3 = busses[tmp[0]], key2 = tmp[1];
                if (bus3)
                  bus3.forget(key2, funk);
              }
              funk.getted_keys = {};
            };
            funk.loading = function() {
              for (var hash in funk.getted_keys) {
                var tmp = JSON.parse(hash), bus3 = busses[tmp[0]], key2 = tmp[1];
                if (bus3 && bus3.pending_gets[key2])
                  return true;
              }
              return false;
            };
            funk.is_loading = funk.loading;
            return funk;
          }
          function loading_keys(keys4) {
            for (var i2 = 0; i2 < keys4.length; i2++)
              if (pending_gets[keys4[i2]])
                return true;
            return false;
          }
          function loading() {
            return executing_funk.loading();
          }
          bus.default = function() {
            bus.deep_map(arguments, function(o) {
              if (o.key && !bus.cache.hasOwnProperty(o.key))
                bus.cache[o.key] = o;
              return o;
            });
          };
          function once(f) {
            var r = reactive(function() {
              f();
              if (!r.loading())
                r.forget();
            });
            r();
          }
          if (nodejs)
            var red = "\x1B[31m", normal = "\x1B[0m", grey = "\x1B[0;38;5;245m", green = "\x1B[0;38;5;46m", brown = "\x1B[0;38;5;130m", yellow = "\x1B[0;38;5;226m";
          else
            var red = "", normal = "", grey = "", green = "", brown = "";
          function add_diff_msg(message, obj) {
            var diff = sorta_diff(
              backup_cache[obj.key] && backup_cache[obj.key].val,
              obj && obj.val
            );
            if (diff) {
              var end_col = message.length + 2 + statelog_indent * 3;
              for (var i2 = 0; i2 < 40 - end_col; i2++)
                message += " ";
              message += diff.substring(0, 80);
            } else
              message += " <no diff>";
            return message;
          }
          function set_msg(obj, t2, meth) {
            if (!honking_at(obj.key))
              return;
            var message = t2 && t2.m || bus + "." + meth + "('" + obj.key + "')";
            message = add_diff_msg(message, obj);
            if (t2.version)
              message += " [" + t2.version + "]";
            return message;
          }
          var uncallback_counter = 0;
          function uncallback(f, options2) {
            name = options2 && options2.name || f.name || uncallback_counter + "";
            if (!name)
              throw "Uncallback function needs a name";
            var watching = {};
            var prefix2 = "uncallback/" + name;
            bus(prefix2 + "/*").getter = function(key2, json) {
              var args = json;
              function cb(err, result) {
                if (err) {
                  console.trace("have err:", err, "and result is", JSON.stringify(result));
                  throw err;
                } else
                  bus.set.fire({ key: key2, _: result });
              }
              args[options2.callback_at || args.length] = cb;
              f.apply({ key: key2 }, args);
              if (options2.start_watching && !watching[key2]) {
                watching[key2] = true;
                options2.start_watching(
                  args,
                  function() {
                    bus.dirty(key2);
                  },
                  function() {
                    bus.del(key2);
                  }
                );
              }
            };
            if (options2.stop_watching)
              bus(prefix2 + "/*").forgetter = function(key2, json) {
                console.assert(
                  watching[key2],
                  "Forgetting a watcher for " + JSON.stringify(key2) + " that is not enabled"
                );
                delete watching[key2];
                options2.stop_watching(json);
              };
            return function() {
              var args = [].slice.call(arguments);
              return bus.get(prefix2 + "/" + JSON.stringify(args))._;
            };
          }
          function unpromise(f) {
            return uncallback(function() {
              var args = [].slice.call(arguments);
              var cb = args.pop();
              f.apply(null, args).then(cb);
            });
          }
          function aget(key2) {
            return new Promise((resolve, reject) => bus.get_once(key2, (o) => resolve(o)));
          }
          var symbols = {
            is_proxy: Symbol("is_proxy"),
            is_link: Symbol("is_link"),
            get_json: Symbol("get_json"),
            get_base: Symbol("get_base")
          };
          function make_proxy() {
            function item_proxy(base2, o) {
              if (typeof o === "number" || typeof o === "string" || typeof o === "boolean" || o === void 0 || o === null || typeof o === "function")
                return o;
              if (typeof o === "object" && "link" in o) {
                var new_base = bus.get(o.link);
                return item_proxy(new_base, new_base.val);
              }
              return new Proxy(o, {
                get: function get3(o2, k) {
                  if (k === "inspect" || k === "valueOf")
                    return void 0;
                  if (k === symbols.is_proxy)
                    return true;
                  if (typeof k === "symbol")
                    return void 0;
                  return item_proxy(base2, o2[proxied_2_keyed(k)]);
                },
                set: function set3(o2, k, v) {
                  var value = translate_fields(v, proxied_2_keyed);
                  o2[proxied_2_keyed(k)] = value;
                  bus.set(base2);
                  return true;
                },
                has: function has(o2, k) {
                  return o2.hasOwnProperty(proxied_2_keyed(k));
                },
                deleteProperty: function del2(o2, k) {
                  delete o2[proxied_2_keyed(k)];
                }
              });
            }
            return new Proxy(cache, {
              get: function get3(o, k) {
                if (k === "inspect" || k === "valueOf" || typeof k === "symbol")
                  return void 0;
                bogus_check(k);
                var base2 = bus.get(k);
                return item_proxy(base2, base2.val);
              },
              set: function set3(o, key2, val) {
                bus.set({
                  key: key2,
                  val: translate_fields(val, proxied_2_keyed)
                });
                return true;
              },
              deleteProperty: function del2(o, k) {
                bus.delete(proxied_2_keyed(k));
              }
            });
          }
          bus.state = make_proxy();
          function link(url) {
            var result = bus.get(url);
            result[symbols.is_link] = true;
            return result;
          }
          if (!nodejs)
            window.devtoolsFormatters = [{
              header: function(x) {
                if (x[symbols.is_proxy])
                  return [
                    "span",
                    { style: "background-color: #fffbe5; padding: 3px;" },
                    JSON.stringify(x)
                  ];
              },
              hasBody: function(x) {
                return false;
              }
            }];
          function get_domain(key2) {
            var m3 = key2.match(/^i?statei?\:\/\/(([^:\/?#]*)(?:\:([0-9]+))?)/);
            return m3 && m3[0];
          }
          function message_method(m3) {
            return m3.get && "get" || m3.set && "set" || m3["delete"] && "delete" || m3.forget && "forget";
          }
          function ws_mount(prefix2, url, client_creds2) {
            var preprefix = prefix2.slice(0, -1);
            var is_absolute = /^i?statei?:\/\//;
            var has_prefix = new RegExp("^" + preprefix);
            var bus3 = this;
            var sock;
            var attempts = 0;
            var outbox = [];
            var client_getted_keys = new bus3.Set();
            var heartbeat;
            if (url[url.length - 1] == "/")
              url = url.substr(0, url.length - 1);
            function nlog(s) {
              if (nodejs) {
                console.log(s);
              } else
                console.log("%c" + s, "color: blue");
            }
            function send(o, pushpop) {
              pushpop = pushpop || "push";
              o = rem_prefixes(o);
              var m3 = message_method(o);
              if (m3 == "get" || m3 == "delete" || m3 == "forget")
                o[m3] = rem_prefix(o[m3]);
              bus3.log("ws_mount.send:", JSON.stringify(o));
              outbox[pushpop](JSON.stringify(o));
              flush_outbox();
            }
            function flush_outbox() {
              if (sock.readyState === 1)
                while (outbox.length > 0)
                  if (bus3.simulate_network_delay) {
                    var msg2 = outbox.shift();
                    setTimeout(function() {
                      sock.send(msg2);
                    }, bus3.simulate_network_delay);
                  } else
                    sock.send(outbox.shift());
              else
                setTimeout(flush_outbox, 400);
            }
            function add_prefix(key2) {
              return is_absolute.test(key2) ? key2 : preprefix + key2;
            }
            function rem_prefix(key2) {
              return has_prefix.test(key2) ? key2.substr(preprefix.length) : key2;
            }
            function add_prefixes(obj) {
              var keyed = bus3.translate_keys(bus3.clone(obj), add_prefix);
              return bus3.translate_links(bus3.clone(keyed), add_prefix);
            }
            function rem_prefixes(obj) {
              var keyed = bus3.translate_keys(bus3.clone(obj), rem_prefix);
              return bus3.translate_links(bus3.clone(keyed), rem_prefix);
            }
            bus3(prefix2).setter = function(obj, t2) {
              bus3.set.fire(obj);
              var x = { set: obj };
              if (t2.version)
                x.version = t2.version;
              if (t2.parents)
                x.parents = t2.parents;
              if (t2.patch)
                x.patch = t2.patch;
              if (t2.patch)
                x.set = rem_prefix(x.set.key);
              send(x);
            };
            bus3(prefix2).getter = function(key2) {
              send({ get: key2 }), client_getted_keys.add(key2);
            };
            bus3(prefix2).forgetter = function(key2) {
              send({ forget: key2 }), client_getted_keys.delete(key2);
            };
            bus3(prefix2).deleter = function(key2, t2) {
              t2.done();
              send({ "delete": key2 });
            };
            function connect() {
              nlog("[ ] trying to open " + url);
              sock = bus3.make_websocket(url);
              sock.onopen = function() {
                nlog("[*] opened " + url);
                var peers = bus3.get("peers");
                peers[url] = peers[url] || {};
                peers[url].connected = true;
                set(peers);
                var creds = client_creds2 || bus3.client_creds && bus3.client_creds(url);
                if (creds) {
                  let intro2 = function(o) {
                    i2.push(JSON.stringify({ set: o }));
                  };
                  var intro = intro2;
                  var i2 = [];
                  if (creds.clientid)
                    intro2({ key: "current_user", val: { client: creds.clientid } });
                  if (creds.name && creds.pass)
                    intro2({ key: "current_user", val: { login_as: { name: creds.name, pass: creds.pass } } });
                  if (creds.private_key && creds.public_key) {
                  }
                  outbox = i2.concat(outbox);
                  flush_outbox();
                }
                if (attempts > 0) {
                  var keys4 = client_getted_keys.values();
                  for (var i2 = 0; i2 < keys4.length; i2++)
                    send({ get: keys4[i2] });
                }
                attempts = 0;
              };
              sock.onclose = function() {
                if (done) {
                  nlog("[*] closed " + url + ". Goodbye!");
                  return;
                }
                nlog("[*] closed " + url);
                heartbeat && clearInterval(heartbeat);
                heartbeat = null;
                setTimeout(connect, attempts++ < 3 ? 1500 : 5e3);
                var peers = bus3.get("peers");
                peers[url] = peers[url] || {};
                peers[url].connected = false;
                set(peers);
                var new_outbox = [];
                var bad = { "get": 1, "forget": 1 };
                for (var i2 = 0; i2 < outbox.length; i2++)
                  if (!bad[JSON.parse(outbox[i2]).method])
                    new_outbox.push(outbox[i2]);
                outbox = new_outbox;
              };
              sock.onmessage = function(event) {
                try {
                  var message = JSON.parse(event.data);
                  var method = message_method(message);
                  if (method !== "set" && method !== "pong")
                    throw "barf";
                  bus3.log("net client received", message);
                  var t2 = {
                    version: message.version,
                    parents: message.parents,
                    patch: message.patch
                  };
                  if (t2.patch)
                    msg.set = apply_patch(
                      bus3.cache[msg.set] || { key: msg.set },
                      message.patch[0]
                    );
                  if (!(t2.version || t2.parents || t2.patch))
                    t2 = void 0;
                  bus3.set.fire(add_prefixes(message.set), t2);
                } catch (err) {
                  console.error("Received bad network message from " + url + ": ", event.data, err);
                  return;
                }
              };
            }
            connect();
            var done = false;
            return { send, sock, close: function() {
              done = true;
              sock.close();
            } };
          }
          bus.client_creds = function client_creds2(server_url) {
            return { clientid: Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) };
          };
          function net_automount() {
            var bus3 = this;
            var old_route = bus3.route;
            var connections = {};
            bus3.route = function(key2, method, arg, t2) {
              var d2 = get_domain(key2);
              if (d2 && !connections[d2]) {
                bus3.ws_mount(d2 + "/*", d2);
                connections[d2] = true;
              }
              return old_route(key2, method, arg, t2);
            };
          }
          function translate_keys(obj, f) {
            if (Array.isArray(obj))
              for (var i2 = 0; i2 < obj.length; i2++)
                translate_keys(obj[i2], f);
            else if (typeof obj === "object")
              for (var k in obj) {
                if (k === "key" || /.*_key$/.test(k)) {
                  if (typeof obj[k] == "string")
                    obj[k] = f(obj[k]);
                  else if (Array.isArray(obj[k]))
                    for (var i2 = 0; i2 < obj[k].length; i2++) {
                      if (typeof obj[k][i2] === "string")
                        obj[k][i2] = f(obj[k][i2]);
                    }
                }
                translate_keys(obj[k], f);
              }
            return obj;
          }
          function escape_keys(k) {
            return k.replace(/(_(keys?|time)?$|^key$)/, "$1_");
          }
          function unescape_keys(k) {
            return k.replace(/(_$)/, "");
          }
          function translate_links(obj, f) {
            if (Array.isArray(obj))
              for (var i2 = 0; i2 < obj.length; i2++)
                translate_links(obj[i2], f);
            else if (typeof obj === "object")
              for (var k in obj) {
                if (k === "link") {
                  if (typeof obj[k] == "string")
                    obj[k] = f(obj[k]);
                  else if (Array.isArray(obj[k]))
                    for (var i2 = 0; i2 < obj[k].length; i2++) {
                      if (typeof obj[k][i2] === "string")
                        obj[k][i2] = f(obj[k][i2]);
                    }
                }
                translate_links(obj[k], f);
              }
            return obj;
          }
          function translate_fields(input, f) {
            var result;
            if (Array.isArray(input)) {
              var new_array = input.slice();
              for (var i2 = 0; i2 < input.length; i2++)
                new_array[i2] = translate_fields(input[i2], f);
              result = new_array;
            } else if (typeof input === "object" && input !== null) {
              var new_obj = {};
              for (var k in input)
                new_obj[f(k, input)] = translate_fields(input[k], f);
              result = new_obj;
            } else
              result = input;
            return result;
          }
          function keyed_2_proxied(k, object) {
            if (object[symbols.is_link])
              return k;
            else
              return k.replace(/^(_*)_key$/, "$1key");
          }
          function proxied_2_keyed(k) {
            return k.replace(/^(_*)key$/, "$1_key");
          }
          function json_encode(highlevel_obj) {
          }
          function json_decode(lowlevel_obj) {
          }
          function key_id(string2) {
            return string2.match(/\/?[^\/]+\/(\d+)/)[1];
          }
          function key_name(string2) {
            return string2.match(/\/?([^\/]+).*/)[1];
          }
          function apply_patch(obj, patch) {
            obj = bus.clone(obj);
            var x = patch.match(/(.*) = (.*)/), path = x[1], new_stuff = JSON.parse(x[2]);
            var path_segment = /^(\.([^\.\[]+))|(\[((-?\d+):)?(-?\d+)\])/;
            var curr_obj = obj, last_obj = null;
            function de_neg(x2) {
              return x2[0] === "-" ? curr_obj.length - parseInt(x2.substr(1)) : parseInt(x2);
            }
            while (true) {
              var match = path_segment.exec(path), subpath = match[0], field = match[2], slice_start = match[5], slice_end = match[6];
              slice_start = slice_start && de_neg(slice_start);
              slice_end = slice_end && de_neg(slice_end);
              if (path.length == subpath.length) {
                if (field)
                  curr_obj[field] = new_stuff;
                else if (typeof curr_obj == "string") {
                  console.assert(typeof new_stuff == "string");
                  if (!slice_start) {
                    slice_start = slice_end;
                    slice_end = slice_end + 1;
                  }
                  if (last_obj) {
                    var s = last_obj[last_field];
                    last_obj[last_field] = s.slice(0, slice_start) + new_stuff + s.slice(slice_end);
                  } else
                    return obj.slice(0, slice_start) + new_stuff + obj.slice(slice_end);
                } else if (slice_start)
                  [].splice.apply(curr_obj, [slice_start, slice_end - slice_start].concat(new_stuff));
                else {
                  console.assert(slice_end >= 0, "Index " + subpath + " is too small");
                  console.assert(
                    slice_end <= curr_obj.length - 1,
                    "Index " + subpath + " is too big"
                  );
                  curr_obj[slice_end] = new_stuff;
                }
                return obj;
              }
              console.assert(!slice_start, "No splices allowed in middle of path");
              last_obj = curr_obj;
              last_field = field;
              curr_obj = curr_obj[field || slice_end];
              path = path.substr(subpath.length);
            }
          }
          function parse(s) {
            try {
              return JSON.parse(s);
            } catch (e2) {
              return {};
            }
          }
          function One_To_Many() {
            var hash = this.hash = {};
            var counts = {};
            this.get = function(k) {
              return Object.keys(hash[k] || {});
            };
            this.add = function(k, v) {
              if (hash[k] === void 0)
                hash[k] = {};
              if (counts[k] === void 0)
                counts[k] = 0;
              if (!hash[k][v])
                counts[k]++;
              hash[k][v] = true;
            };
            this.delete = function(k, v) {
              delete hash[k][v];
              counts[k]--;
            };
            this.delete_all = function(k) {
              delete hash[k];
              delete counts[k];
            };
            this.has = function(k, v) {
              return hash[k] && hash[k][v];
            };
            this.has_any = function(k) {
              return counts[k];
            };
            this.del = this.delete;
          }
          function Set() {
            var hash = {};
            this.add = function(a2) {
              hash[a2] = true;
            };
            this.has = function(a2) {
              return a2 in hash;
            };
            this.values = function() {
              return Object.keys(hash);
            };
            this.delete = function(a2) {
              delete hash[a2];
            };
            this.clear = function() {
              hash = {};
            };
            this.del = this.delete;
            this.all = this.values;
          }
          function clone(item) {
            if (!item || item instanceof Number || item instanceof String || item instanceof Boolean)
              return item;
            if (Array.isArray(item)) {
              item = item.slice();
              for (var i2 = 0; i2 < item.length; i2++)
                item[i2] = clone(item[i2]);
              return item;
            }
            if (typeof item == "object") {
              if (item.nodeType && typeof item.cloneNode == "function")
                return item.cloneNode(true);
              if (item instanceof Date)
                return new Date(item);
              else {
                var result = {};
                for (var i2 in item)
                  result[i2] = clone(item[i2]);
                return result;
              }
            }
            return item;
          }
          function extend(obj, with_obj) {
            if (with_obj === void 0)
              return obj;
            for (var attr in with_obj)
              if (obj.hasOwnProperty(attr))
                obj[attr] = with_obj[attr];
            return obj;
          }
          function deep_map(object, func) {
            object = func(object);
            if (Array.isArray(object))
              for (var i2 = 0; i2 < object.length; i2++)
                object[i2] = deep_map(object[i2], func);
            else if (typeof object === "object")
              for (var k in object)
                object[k] = deep_map(object[k], func);
            return object;
          }
          function deep_equals(a2, b2) {
            if (a2 === b2 || isNaN(a2) && isNaN(b2) && typeof a2 === "number" && typeof b2 === "number")
              return true;
            var a_array = Array.isArray(a2), b_array = Array.isArray(b2);
            if (a_array !== b_array)
              return false;
            if (a_array) {
              if (a2.length !== b2.length)
                return false;
              for (var i2 = 0; i2 < a2.length; i2++)
                if (!deep_equals(a2[i2], b2[i2]))
                  return false;
              return true;
            }
            var a_obj = a2 && typeof a2 === "object", b_obj = b2 && typeof b2 === "object";
            if (a_obj !== b_obj)
              return false;
            if (a_obj) {
              var a_length = 0, b_length = 0;
              for (var k in a2) {
                a_length++;
                if (!deep_equals(a2[k], b2[k]))
                  return false;
              }
              for (var k in b2)
                b_length++;
              if (a_length !== b_length)
                return false;
              return true;
            }
            return false;
          }
          function sorta_diff(a2, b2) {
            if (a2 === b2 || isNaN(a2) && isNaN(b2) && typeof a2 === "number" && typeof b2 === "number")
              return null;
            var a_array = Array.isArray(a2), b_array = Array.isArray(b2);
            if (a_array !== b_array)
              return " = " + JSON.stringify(b2);
            if (a_array) {
              if (a2.length === b2.length - 1 && deep_equals(a2[a2.length - 1], b2[b2.length - 2])) {
                return ".push(" + JSON.stringify(b2[b2.length - 1]) + ")";
              }
              for (var i2 = 0; i2 < a2.length; i2++) {
                var tmp = sorta_diff(a2[i2], b2[i2]);
                if (tmp)
                  return "[" + i2 + "]" + tmp;
              }
              return null;
            }
            var a_obj = a2 && typeof a2 === "object", b_obj = b2 && typeof b2 === "object";
            if (a_obj !== b_obj)
              return " = " + JSON.stringify(b2);
            if (a_obj) {
              for (var k in a2) {
                var tmp = sorta_diff(a2[k], b2[k]);
                if (tmp)
                  return "." + k + tmp;
              }
              for (var k in b2) {
                if (!a2.hasOwnProperty(k))
                  return "." + k + " = " + JSON.stringify(b2[k]);
              }
              return null;
            }
            return " = " + JSON.stringify(b2);
          }
          function prune(obj) {
            var bus3 = this;
            obj = bus3.clone(obj);
            function recurse(o) {
              if (Array.isArray(o))
                for (var i2 = 0; i2 < o.length; i2++)
                  o[i2] = recurse(o[i2]);
              else if (typeof o === "object")
                if (o !== null && o.key)
                  return bus3.get(o.key);
                else
                  for (var k2 in o)
                    o[k2] = recurse(o[k2]);
              return o;
            }
            for (var k in obj)
              obj[k] = recurse(obj[k]);
            return obj;
          }
          function validate(obj, schema) {
            var optional = false;
            if (schema === "*")
              return true;
            if (obj === schema)
              return true;
            if (typeof obj === "string")
              return schema === "string";
            if (typeof obj === "number")
              return schema === "number";
            if (typeof obj === "boolean")
              return schema === "boolean";
            if (obj === null)
              return schema === "null";
            if (obj === void 0)
              return schema === "undefined";
            if (Array.isArray(obj))
              return schema === "array";
            if (typeof obj === "object") {
              if (schema === "object")
                return true;
              if (typeof schema === "object") {
                for (var k in obj) {
                  var sk;
                  if (schema.hasOwnProperty(k))
                    sk = k;
                  else if (schema.hasOwnProperty("?" + k))
                    sk = "?" + k;
                  else if (schema.hasOwnProperty("*"))
                    sk = "*";
                  else
                    return false;
                  if (!validate(obj[k], schema[sk]))
                    return false;
                }
                for (var k in schema)
                  if (k[0] !== "?" && k !== "*") {
                    if (!obj.hasOwnProperty(k))
                      return false;
                  }
                return true;
              }
              return false;
            }
            if (typeof obj == "function")
              throw "bus.validate() cannot validate functions";
            console.trace();
            throw "You hit a Statebus bug! Tell the developers!";
          }
          function funk_key(funk) {
            if (!funk.statebus_id) {
              funk.statebus_id = Math.random().toString(36).substring(7);
              funks[funk.statebus_id] = funk;
            }
            return funk.statebus_id;
          }
          function funk_keyr(funk) {
            while (funk.proxies_for)
              funk = funk.proxies_for;
            return funk_key(funk);
          }
          function funk_name(f, char_limit) {
            char_limit = char_limit || 30;
            var arg = f.react ? f.args && f.args[0] : "";
            arg = f.react ? (JSON.stringify(f.arg) || "").substring(0, 30) : "";
            f = f.proxies_for || f;
            var f_string = "function " + (f.name || "") + "(" + (arg || "") + ") {..}";
            if (!f.defined)
              return f_string;
            if (f.defined.length > 1)
              return "**" + f_string + "**";
            var def = f.defined[0];
            switch (def.as) {
              case "handler":
                return def.bus + "('" + def.key + "')." + def.method + " = " + f_string;
              case "get callback":
                return "get(" + def.key + ", " + f_string + ")";
              case "reactive":
                return "reactive('" + f_string + "')";
              default:
                return "UNKNOWN Funky Definition!!!... ???";
            }
          }
          function deps(key2) {
            var result = "Deps: (" + key2 + ") fires into:";
            var pubbers = bindings(key2, "on_set");
            if (pubbers.length === 0)
              result += " nothing";
            for (var i2 = 0; i2 < pubbers.length; i2++)
              result += "\n  " + funk_name(pubbers[i2].func);
            return result;
          }
          function log() {
            if (bus.honk === true)
              indented_log.apply(null, arguments);
          }
          function indented_log() {
            if (nodejs) {
              var indent = "";
              for (var i2 = 0; i2 < statelog_indent; i2++)
                indent += "   ";
              console.log(indent + require_util().format.apply(null, arguments).replace(/\n/g, "\n" + indent));
            } else
              console.log.apply(console, arguments);
          }
          function statelog(key2, color, icon, message) {
            if (honking_at(key2))
              if (bus.honking_colors === false)
                indented_log(icon + " " + message);
              else
                indented_log(color + icon + " " + message + normal);
          }
          function honking_at(key2) {
            return bus.honk instanceof RegExp ? bus.honk.test(key2) : bus.honk;
          }
          var bogus_keys = {
            constructor: 1,
            hasOwnProperty: 1,
            isPrototypeOf: 1,
            propertyIsEnumerable: 1,
            toLocaleString: 1,
            toString: 1,
            valueOf: 1,
            __defineGetter__: 1,
            __defineSetter__: 1,
            __lookupGetter__: 1,
            __lookupSetter__: 1,
            __proto__: 1
          };
          function bogus_check(key2) {
            if (!(key2 in bogus_keys))
              return;
            var msg2 = 'Sorry, statebus.js currently prohibits use of the key "' + key2 + '", and in fact all of these keys: ' + Object.keys(bogus_keys).join(", ") + '.  This is because Javascript is kinda lame, and even empty objects like "{}" have the "' + key2 + '" field defined on them.  Try typing this in your Javascript console: "({}).constructor" -- it returns a function instead of undefined!  Mike needs to work around it by replacing every "obj[key]" with "obj.hasOwnProperty(key) && obj[key]" in the statebus code, or switching to a Map() object.  Please contact him and let him know where this is impacting you, so he can bump the priority on it.';
            console.error(msg2);
            throw "Invalid key";
          }
          var api = [
            "cache backup_cache get set forget del fire dirty get_once",
            "subspace bindings run_handler bind unbind reactive uncallback",
            "versions new_version",
            "link aget",
            "funk_key funk_name funks key_id key_name id",
            "pending_gets gets_in gets_out loading_keys loading once",
            "global_funk busses rerunnable_funks",
            "escape_keys unescape_keys translate_keys translate_links apply_patch",
            "keyed_2_proxied proxied_2_keyed translate_fields",
            "ws_mount net_automount message_method",
            "parse Set One_To_Many clone extend deep_map deep_equals prune validate sorta_diff log deps symbols"
          ].join(" ").split(" ");
          for (var i = 0; i < api.length; i++)
            bus[api[i]] = eval(api[i]);
          bus.delete = bus.del;
          bus.executing_funk = function() {
            return executing_funk;
          };
          function clientjs_option(option_name) {
            var script_elem = document.querySelector('script[src*="/client"][src$=".js"]') || document.querySelector('script[src^="client"][src$=".js"]');
            return script_elem && script_elem.getAttribute(option_name);
          }
          busses[bus.id] = bus;
          var this_bus_num = bus_count++;
          bus.libs = {};
          bus.render_when_loading = true;
          return bus;
        }
        return make_bus;
      });
    }
  });

  // public/statebus/client-library.js
  var require_client_library = __commonJS({
    "public/statebus/client-library.js"(exports, module) {
      (function() {
        var websocket_prefix = clientjs_option("websocket_path") || "_connect_to_statebus_";
        window.bus = window.statebus();
        bus.label = "bus";
        bus.libs = {};
        bus.libs.react12 = {};
        bus.libs.react17 = {};
        function set_cookie(key2, val) {
          document.cookie = key2 + "=" + val + "; Expires=21 Oct 2025 00:0:00 GMT;";
        }
        function get_cookie(key2) {
          var c4 = document.cookie.match("(^|;)\\s*" + key2 + "\\s*=\\s*([^;]+)");
          return c4 ? c4.pop() : "";
        }
        try {
          document.cookie;
        } catch (e2) {
          get_cookie = set_cookie = function() {
          };
        }
        function make_websocket(url) {
          if (!url.match(/^\w{0,7}:\/\//))
            url = location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + url;
          url = url.replace(/^state:\/\//, "wss://");
          url = url.replace(/^istate:\/\//, "ws://");
          url = url.replace(/^statei:\/\//, "ws://");
          url = url.replace(/^https:\/\//, "wss://");
          url = url.replace(/^http:\/\//, "ws://");
          return new WebSocket(url + "/" + websocket_prefix + "/websocket");
        }
        function client_creds(server_url) {
          var me = bus.get("ls/me");
          bus.log("connect: me is", me);
          if (!me.client) {
            var c4 = get_cookie("peer");
            me.client = c4 || Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2) + Math.random().toString(36).substring(2);
            bus.set(me);
          }
          set_cookie("peer", me.client);
          return { clientid: me.client };
        }
        bus.libs.http_out = (prefix2, url) => {
          var preprefix = prefix2.slice(0, -1);
          var has_prefix = new RegExp("^" + preprefix);
          var is_absolute = /^https?:\/\//;
          var subscriptions = {};
          var put_counter = 0;
          function add_prefix(url2) {
            return is_absolute.test(url2) ? url2 : preprefix + url2;
          }
          function rem_prefix(url2) {
            return has_prefix.test(url2) ? url2.substr(preprefix.length) : url2;
          }
          function add_prefixes(obj) {
            var keyed = bus.translate_keys(bus.clone(obj), add_prefix);
            return bus.translate_links(bus.clone(keyed), add_prefix);
          }
          function rem_prefixes(obj) {
            var keyed = bus.translate_keys(bus.clone(obj), rem_prefix);
            return bus.translate_links(bus.clone(keyed), rem_prefix);
          }
          var puts = /* @__PURE__ */ new Map();
          function enqueue_put(url2, body) {
            var id2 = put_counter++;
            puts.set(id2, { url: url2, body, id: id2 });
            send_put(id2);
          }
          function send_put(id2) {
            try {
              puts.get(id2).status = "sending";
              braid_fetch(
                puts.get(id2).url,
                {
                  method: "put",
                  headers: {
                    "content-type": "application/json",
                    "put-order": id2
                  },
                  body: puts.get(id2).body
                }
              ).then(function(res) {
                if (res.status !== 200)
                  console.error(
                    "Server gave error on PUT:",
                    e,
                    "for",
                    puts.get(id2).body
                  );
                puts.delete(id2);
              }).catch(function(e2) {
                console.error("Error on PUT, waiting...", puts.get(id2).url);
                puts.get(id2).status = "waiting";
              });
            } catch (e2) {
              console.error("Error on PUT, waiting...", puts.get(id2).url);
              puts.get(id2).status = "waiting";
            }
          }
          function retry_put(id2) {
            setTimeout(function() {
              send_put(id2);
            }, 1e3);
          }
          function send_all_puts() {
            puts.forEach(function(value, id2) {
              if (value.status === "waiting") {
                console.log("Sending waiting put", id2);
                send_put(id2);
              }
            });
          }
          bus(prefix2).setter = function(obj, t2) {
            bus.set.fire(obj);
            var put = {
              url: url + rem_prefix(obj.key),
              body: JSON.stringify(obj.val)
            };
            if (t2.version)
              put.version = t2.version;
            if (t2.parents)
              put.parents = t2.parents;
            if (t2.patch)
              put.patch = t2.patch;
            var put_id = put_counter++;
            puts.set(put_id, put);
            send_put(put_id);
          };
          bus(prefix2).getter = function(key2, t2) {
            if (subscriptions[key2]) {
              console.assert(
                subscriptions[key2].status === "aborted",
                "Regetting a subscription of status " + subscriptions[key2].status
              );
              console.trace("foo");
              subscriptions[key2].status = "reconnect";
            } else
              subscribe(key2, t2);
            function subscribe(key3, t3) {
              var aborter = new AbortController(), reconnect_attempts = 0;
              braid_fetch(
                url + rem_prefix(key3),
                {
                  method: "get",
                  subscribe: true,
                  headers: { accept: "application/json" },
                  signal: aborter.signal
                }
              ).andThen(function(new_version2) {
                if (subscriptions[key3].status === "connecting") {
                  console.log(
                    "%c[*] opened " + key3,
                    "color: blue"
                  );
                  reconnect_attempts = 0;
                  subscriptions[key3].status = "connected";
                  send_all_puts();
                }
                t3.return({
                  key: key3,
                  val: add_prefixes(JSON.parse(new_version2.body))
                });
              }).catch(function(e2) {
                if (subscriptions[key3].status === "aborted") {
                  delete subscriptions[key3];
                  return;
                }
                setTimeout(
                  function() {
                    subscribe(key3, t3);
                  },
                  reconnect_attempts > 0 ? 5e3 : 1500
                );
                subscriptions[key3].status = "reconnecting";
              });
              subscriptions[key3] = {
                aborter,
                status: "connecting"
              };
            }
          };
          bus(prefix2).forgetter = function(key2) {
            subscriptions[key2].status = "aborted";
            subscriptions[key2].aborter.abort();
          };
        };
        function http_automount() {
          function get_domain2(key2) {
            var m3 = key2.match(/^https?\:\/\/(([^:\/?#]*)(?:\:([0-9]+))?)/);
            return m3 && m3[0];
          }
          var old_route = bus.route;
          var connections = {};
          bus.route = function(key2, method, arg, t2) {
            var d2 = get_domain2(key2);
            if (d2 && !connections[d2]) {
              bus.libs.http_out(d2 + "/*", d2 + "/");
              connections[d2] = true;
            }
            return old_route(key2, method, arg, t2);
          };
        }
        bus.libs.localstorage = (prefix2) => {
          try {
            localStorage;
          } catch (e2) {
            return;
          }
          var sets_are_pending = false;
          var pending_sets = {};
          function set_the_pending_sets() {
            bus.log("localstore: saving", pending_sets);
            for (var k in pending_sets)
              localStorage.setItem(k, JSON.stringify(pending_sets[k]));
            sets_are_pending = false;
          }
          bus(prefix2).getter = function(key2) {
            var result = localStorage.getItem(key2);
            return result ? JSON.parse(result) : { key: key2 };
          };
          bus(prefix2).setter = function(obj) {
            bus.log("localStore: on_set:", obj.key);
            pending_sets[obj.key] = obj;
            if (!sets_are_pending) {
              setTimeout(set_the_pending_sets, 50);
              sets_are_pending = true;
            }
            bus.set.fire(obj);
            return obj;
          };
          bus(prefix2).deleter = function(key2) {
            localStorage.removeItem(key2);
          };
          function update3(event) {
            bus.log("Got a localstorage update", event);
            bus.dirty(event.key);
          }
          if (window.addEventListener)
            window.addEventListener("storage", update3, false);
          else
            window.attachEvent("onstorage", update3);
        };
        function url_store(prefix2) {
          var bus3 = this;
          function get_query_string_value(key2) {
            return unescape(window.location.search.replace(
              new RegExp("^(?:.*[&\\?]" + escape(key2).replace(/[\.\+\*]/g, "\\$&") + "(?:\\=([^&]*))?)?.*$", "i"),
              "$1"
            ));
          }
          var data = get_query_string_value(key);
          data = data && JSON.parse(data) || { key };
          bus3(prefix2).setter = function(obj) {
            window.history.replaceState(
              "",
              "",
              document.location.origin + document.location.pathname + escape("?" + key + "=" + JSON.stringify(obj))
            );
            bus3.set.fire(obj);
          };
        }
        function react_version() {
          if (!window.React)
            return void 0;
          return Number(window.React.version.split(".")[0]);
        }
        if (window.React && !React.createClass && window.createReactClass)
          React.createClass = createReactClass;
        var components = {};
        var components_count = 0;
        var dirty_components = {};
        function create_react_class(component) {
          function wrap(name3, new_func) {
            var old_func = component[name3];
            component[name3] = function wrapper() {
              return new_func.bind(this)(old_func);
            };
          }
          wrap(
            (react_version() >= 16 ? "UNSAFE_" : "") + "componentWillMount",
            function new_cwm(orig_func) {
              this.key = "component/" + components_count++;
              components[this.key] = this;
              function add_shortcut(obj, shortcut_name, to_key) {
                delete obj[shortcut_name];
                Object.defineProperty(obj, shortcut_name, {
                  get: function() {
                    return bus.get(to_key);
                  },
                  configurable: true
                });
              }
              add_shortcut(this, "local", this.key);
              orig_func && orig_func.apply(this, arguments);
              var orig_render = this.render;
              this.render = bus.reactive(function() {
                console.assert(this !== window);
                if (this.render.called_directly) {
                  delete dirty_components[this.key];
                  for (var k in this.props)
                    if (this.props.hasOwnProperty(k) && this.props[k] !== null && typeof this.props[k] === "object" && this.props[k].key)
                      bus.get(this.props[k].key);
                  return orig_render.apply(this, arguments);
                } else {
                  dirty_components[this.key] = true;
                  schedule_re_render();
                }
              });
            }
          );
          wrap("componentWillUnmount", function new_cwu(orig_func) {
            orig_func && orig_func.apply(this, arguments);
            bus.delete(this.key);
            delete components[this.key];
            delete dirty_components[this.key];
          });
          function shallow_clone(original) {
            var clone3 = Object.create(Object.getPrototypeOf(original));
            var i2, keys4 = Object.getOwnPropertyNames(original);
            for (i2 = 0; i2 < keys4.length; i2++) {
              Object.defineProperty(
                clone3,
                keys4[i2],
                Object.getOwnPropertyDescriptor(original, keys4[i2])
              );
            }
            return clone3;
          }
          component.shouldComponentUpdate = function new_scu(next_props, next_state) {
            if (dirty_components[this.key] !== void 0)
              return true;
            next_props = shallow_clone(next_props);
            this_props = shallow_clone(this.props);
            delete next_props["children"];
            delete this_props["children"];
            next_props = bus.clone(next_props);
            this_props = bus.clone(this_props);
            return !bus.deep_equals([next_state, next_props], [this.state, this_props]);
          };
          component.loading = function loading2() {
            return this.render.loading();
          };
          var react_class = React.createClass(component);
          var result = function(props, children) {
            props = props || {};
            props["data-key"] = props.key;
            props["data-widget"] = component.displayName;
            return React.createElement(react_class, props, children);
          };
          Object.defineProperty(
            result,
            "name",
            { value: component.displayName, writable: false }
          );
          return result;
        }
        var re_render_scheduled = false;
        var re_rendering = false;
        function schedule_re_render() {
          if (!re_render_scheduled) {
            requestAnimationFrame(function() {
              re_render_scheduled = false;
              for (var comp_key in dirty_components) {
                if (dirty_components[comp_key] && components[comp_key])
                  try {
                    re_rendering = true;
                    components[comp_key].forceUpdate();
                  } finally {
                    re_rendering = false;
                  }
              }
            });
            re_render_scheduled = true;
          }
        }
        function clientjs_option(option_name) {
          var script_elem = document.querySelector('script[src$="statebus/client.js"]');
          return script_elem && script_elem.getAttribute(option_name);
        }
        var loaded_from_file_url = window.location.href.match(/^file:\/\//);
        window.statebus_server = clientjs_option("server");
        function is_css_prop(name3) {
          if (!is_css_prop.memoized) {
            is_css_prop.memoized = {};
            var all_css_props = ["alignContent", "alignItems", "alignSelf", "alignmentBaseline", "all", "animation", "animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction", "backfaceVisibility", "background", "backgroundAttachment", "backgroundBlendMode", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPosition", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundRepeatX", "backgroundRepeatY", "backgroundSize", "baselineShift", "blockSize", "border", "borderBottom", "borderBottomColor", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStyle", "borderBottomWidth", "borderCollapse", "borderColor", "borderImage", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeft", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRadius", "borderRight", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderSpacing", "borderStyle", "borderTop", "borderTopColor", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStyle", "borderTopWidth", "borderWidth", "bottom", "boxShadow", "boxSizing", "breakAfter", "breakBefore", "breakInside", "bufferedRendering", "captionSide", "caretColor", "clear", "clip", "clipPath", "clipRule", "color", "colorInterpolation", "colorInterpolationFilters", "colorRendering", "columnCount", "columnFill", "columnGap", "columnRule", "columnRuleColor", "columnRuleStyle", "columnRuleWidth", "columnSpan", "columnWidth", "columns", "contain", "content", "counterIncrement", "counterReset", "cursor", "cx", "cy", "d", "direction", "display", "dominantBaseline", "emptyCells", "fill", "fillOpacity", "fillRule", "filter", "flex", "flexBasis", "flexDirection", "flexFlow", "flexGrow", "flexShrink", "flexWrap", "float", "floodColor", "floodOpacity", "font", "fontDisplay", "fontFamily", "fontFeatureSettings", "fontKerning", "fontSize", "fontStretch", "fontStyle", "fontVariant", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariationSettings", "fontWeight", "gap", "grid", "gridArea", "gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridColumn", "gridColumnEnd", "gridColumnGap", "gridColumnStart", "gridGap", "gridRow", "gridRowEnd", "gridRowGap", "gridRowStart", "gridTemplate", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows", "height", "hyphens", "imageRendering", "inlineSize", "isolation", "justifyContent", "justifyItems", "justifySelf", "left", "letterSpacing", "lightingColor", "lineBreak", "lineHeight", "listStyle", "listStyleImage", "listStylePosition", "listStyleType", "margin", "marginBottom", "marginLeft", "marginRight", "marginTop", "marker", "markerEnd", "markerMid", "markerStart", "mask", "maskType", "maxBlockSize", "maxHeight", "maxInlineSize", "maxWidth", "maxZoom", "minBlockSize", "minHeight", "minInlineSize", "minWidth", "minZoom", "mixBlendMode", "objectFit", "objectPosition", "offset", "offsetDistance", "offsetPath", "offsetRotate", "opacity", "order", "orientation", "orphans", "outline", "outlineColor", "outlineOffset", "outlineStyle", "outlineWidth", "overflow", "overflowAnchor", "overflowWrap", "overflowX", "overflowY", "overscrollBehavior", "overscrollBehaviorX", "overscrollBehaviorY", "padding", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "page", "pageBreakAfter", "pageBreakBefore", "pageBreakInside", "paintOrder", "perspective", "perspectiveOrigin", "placeContent", "placeItems", "placeSelf", "pointerEvents", "position", "quotes", "r", "resize", "right", "rowGap", "rx", "ry", "scrollBehavior", "shapeImageThreshold", "shapeMargin", "shapeOutside", "shapeRendering", "size", "speak", "src", "stopColor", "stopOpacity", "stroke", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeWidth", "tabSize", "tableLayout", "textAlign", "textAlignLast", "textAnchor", "textCombineUpright", "textDecoration", "textDecorationColor", "textDecorationLine", "textDecorationSkipInk", "textDecorationStyle", "textIndent", "textOrientation", "textOverflow", "textRendering", "textShadow", "textSizeAdjust", "textTransform", "textUnderlinePosition", "top", "touchAction", "transform", "transformBox", "transformOrigin", "transformStyle", "transition", "transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction", "unicodeBidi", "unicodeRange", "userSelect", "userZoom", "vectorEffect", "verticalAlign", "visibility", "webkitAlignContent", "webkitAlignItems", "webkitAlignSelf", "webkitAnimation", "webkitAnimationDelay", "webkitAnimationDirection", "webkitAnimationDuration", "webkitAnimationFillMode", "webkitAnimationIterationCount", "webkitAnimationName", "webkitAnimationPlayState", "webkitAnimationTimingFunction", "webkitAppRegion", "webkitAppearance", "webkitBackfaceVisibility", "webkitBackgroundClip", "webkitBackgroundOrigin", "webkitBackgroundSize", "webkitBorderAfter", "webkitBorderAfterColor", "webkitBorderAfterStyle", "webkitBorderAfterWidth", "webkitBorderBefore", "webkitBorderBeforeColor", "webkitBorderBeforeStyle", "webkitBorderBeforeWidth", "webkitBorderBottomLeftRadius", "webkitBorderBottomRightRadius", "webkitBorderEnd", "webkitBorderEndColor", "webkitBorderEndStyle", "webkitBorderEndWidth", "webkitBorderHorizontalSpacing", "webkitBorderImage", "webkitBorderRadius", "webkitBorderStart", "webkitBorderStartColor", "webkitBorderStartStyle", "webkitBorderStartWidth", "webkitBorderTopLeftRadius", "webkitBorderTopRightRadius", "webkitBorderVerticalSpacing", "webkitBoxAlign", "webkitBoxDecorationBreak", "webkitBoxDirection", "webkitBoxFlex", "webkitBoxOrdinalGroup", "webkitBoxOrient", "webkitBoxPack", "webkitBoxReflect", "webkitBoxShadow", "webkitBoxSizing", "webkitClipPath", "webkitColumnBreakAfter", "webkitColumnBreakBefore", "webkitColumnBreakInside", "webkitColumnCount", "webkitColumnGap", "webkitColumnRule", "webkitColumnRuleColor", "webkitColumnRuleStyle", "webkitColumnRuleWidth", "webkitColumnSpan", "webkitColumnWidth", "webkitColumns", "webkitFilter", "webkitFlex", "webkitFlexBasis", "webkitFlexDirection", "webkitFlexFlow", "webkitFlexGrow", "webkitFlexShrink", "webkitFlexWrap", "webkitFontFeatureSettings", "webkitFontSizeDelta", "webkitFontSmoothing", "webkitHighlight", "webkitHyphenateCharacter", "webkitJustifyContent", "webkitLineBreak", "webkitLineClamp", "webkitLocale", "webkitLogicalHeight", "webkitLogicalWidth", "webkitMarginAfter", "webkitMarginAfterCollapse", "webkitMarginBefore", "webkitMarginBeforeCollapse", "webkitMarginBottomCollapse", "webkitMarginCollapse", "webkitMarginEnd", "webkitMarginStart", "webkitMarginTopCollapse", "webkitMask", "webkitMaskBoxImage", "webkitMaskBoxImageOutset", "webkitMaskBoxImageRepeat", "webkitMaskBoxImageSlice", "webkitMaskBoxImageSource", "webkitMaskBoxImageWidth", "webkitMaskClip", "webkitMaskComposite", "webkitMaskImage", "webkitMaskOrigin", "webkitMaskPosition", "webkitMaskPositionX", "webkitMaskPositionY", "webkitMaskRepeat", "webkitMaskRepeatX", "webkitMaskRepeatY", "webkitMaskSize", "webkitMaxLogicalHeight", "webkitMaxLogicalWidth", "webkitMinLogicalHeight", "webkitMinLogicalWidth", "webkitOpacity", "webkitOrder", "webkitPaddingAfter", "webkitPaddingBefore", "webkitPaddingEnd", "webkitPaddingStart", "webkitPerspective", "webkitPerspectiveOrigin", "webkitPerspectiveOriginX", "webkitPerspectiveOriginY", "webkitPrintColorAdjust", "webkitRtlOrdering", "webkitRubyPosition", "webkitShapeImageThreshold", "webkitShapeMargin", "webkitShapeOutside", "webkitTapHighlightColor", "webkitTextCombine", "webkitTextDecorationsInEffect", "webkitTextEmphasis", "webkitTextEmphasisColor", "webkitTextEmphasisPosition", "webkitTextEmphasisStyle", "webkitTextFillColor", "webkitTextOrientation", "webkitTextSecurity", "webkitTextSizeAdjust", "webkitTextStroke", "webkitTextStrokeColor", "webkitTextStrokeWidth", "webkitTransform", "webkitTransformOrigin", "webkitTransformOriginX", "webkitTransformOriginY", "webkitTransformOriginZ", "webkitTransformStyle", "webkitTransition", "webkitTransitionDelay", "webkitTransitionDuration", "webkitTransitionProperty", "webkitTransitionTimingFunction", "webkitUserDrag", "webkitUserModify", "webkitUserSelect", "webkitWritingMode", "whiteSpace", "widows", "width", "willChange", "wordBreak", "wordSpacing", "wordWrap", "writingMode", "x", "y", "zIndex", "zoom"];
            var ignore = {
              d: 1,
              cx: 1,
              cy: 1,
              rx: 1,
              ry: 1,
              x: 1,
              y: 1,
              content: 1,
              fill: 1,
              stroke: 1,
              src: 1
            };
            for (var i2 = 0; i2 < all_css_props.length; i2++)
              if (!ignore[all_css_props[i2]])
                is_css_prop.memoized[all_css_props[i2]] = true;
          }
          return is_css_prop.memoized[name3];
        }
        bus.libs.react12.improve_react = () => {
          function better_element(el2) {
            return function() {
              var children = [];
              var attrs = { style: {} };
              for (var i2 = 0; i2 < arguments.length; i2++) {
                var arg = arguments[i2];
                if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg === void 0)
                  children.push(arg);
                else if (arg instanceof Array)
                  Array.prototype.push.apply(children, arg);
                else if (arg instanceof Object)
                  for (var k in arg)
                    if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && el2 in { canvas: 1, input: 1, embed: 1, object: 1 }))
                      attrs.style[k] = arg[k];
                    else if (k === "style")
                      for (var k2 in arg[k])
                        attrs.style[k2] = arg[k][k2];
                    else {
                      attrs[k] = arg[k];
                      if (k === "key")
                        attrs["data-key"] = arg[k];
                    }
              }
              if (children.length === 0)
                children = void 0;
              if (attrs["ref"] === "input")
                bus.log(attrs, children);
              return React.DOM[el2](attrs, children);
            };
          }
          for (var el in React.DOM)
            window[el.toUpperCase()] = better_element(el);
          function make_better_input(name3, element3) {
            window[name3] = React.createFactory(React.createClass({
              getInitialState: function() {
                return { value: this.props.value };
              },
              componentWillReceiveProps: function(new_props) {
                this.setState({ value: new_props.value });
              },
              onChange: function(e2) {
                this.props.onChange && this.props.onChange(e2);
                if (this.props.value)
                  this.setState({ value: e2.target.value });
              },
              render: function() {
                var new_props = {};
                for (var k in this.props)
                  if (this.props.hasOwnProperty(k))
                    new_props[k] = this.props[k];
                if (this.state.value)
                  new_props.value = this.state.value;
                new_props.onChange = this.onChange;
                return element3(new_props);
              }
            }));
          }
          make_better_input("INPUT", window.INPUT);
          make_better_input("TEXTAREA", window.TEXTAREA);
          make_syncarea();
          var og_img = window.IMG;
          window.IMG = function() {
            var args = [];
            for (var i2 = 0; i2 < arguments.length; i2++) {
              args.push(arguments[i2]);
              if (arguments[i2].state)
                args[i2].src = "data:;base64," + bus.get(args[i2].state)._;
            }
            return og_img.apply(this, args);
          };
          function escape_html(s) {
            return s.replace(/</g, "&lt;").replace(/>/g, "&gt;");
          }
          window.STYLE = function(s) {
            return React.DOM.style({ dangerouslySetInnerHTML: { __html: escape_html(s) } });
          };
          window.TITLE = function(s) {
            return React.DOM.title({ dangerouslySetInnerHTML: { __html: escape_html(s) } });
          };
        };
        bus.libs.react17.reactive_dom = () => {
          window.dom = window.dom || new Proxy({}, {
            get: function(o, k) {
              return o[k];
            },
            set: function(o, k, v) {
              o[k] = v;
              window[k] = make_component(k, v);
              return true;
            }
          });
          var function_for_tag = (tag) => (...args) => {
            var children = [];
            var attrs = { style: {} };
            for (var i2 = 0; i2 < args.length; i2++) {
              var arg = args[i2];
              if (arg === void 0)
                continue;
              else if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg instanceof Array)
                children.push(arg);
              else if (arg instanceof Object)
                for (var k in arg)
                  if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && tag in { canvas: 1, input: 1, embed: 1, object: 1 }))
                    attrs.style[k] = arg[k];
                  else if (k === "style")
                    for (var k2 in arg[k])
                      attrs.style[k2] = arg[k][k2];
                  else
                    attrs[k] = arg[k];
            }
            return React.createElement.apply(
              null,
              [tag, attrs].concat(children)
            );
          };
          var all_tags = "a,abbr,address,area,article,aside,audio,b,base,bdi,bdo,blockquote,br,button,canvas,caption,cite,code,col,colgroup,data,datalist,dd,del,details,dfn,dialog,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,i,iframe,img,ins,kbd,label,legend,li,link,main,map,mark,menu,meta,meter,nav,noscript,object,ol,optgroup,option,output,p,param,picture,pre,progress,q,s,samp,script,section,select,slot,small,source,span,strong,style,sub,summary,sup,svg,table,tbody,td,template,tfoot,th,thead,title,tr,u,ul,video,input,circle,ellipse,g,image,line,path,polygon,polyline,rect,switch,symbol,text,textPath,tspan,use".split(",");
          all_tags.forEach((tagname) => {
            window[tagname.toUpperCase()] = function_for_tag(tagname);
          });
          window.INPUT = function_for_tag(bus.libs.react17.input);
          window.TEXTAREA = function_for_tag(bus.libs.react17.textarea);
          function better_element(el) {
            return function() {
              var children = [];
              var attrs = { style: {} };
              for (var i2 = 0; i2 < arguments.length; i2++) {
                var arg = arguments[i2];
                if (typeof arg === "string" || arg instanceof String || arg && React.isValidElement(arg) || arg === void 0)
                  children.push(arg);
                else if (arg instanceof Array)
                  Array.prototype.push.apply(children, arg);
                else if (arg instanceof Object)
                  for (var k in arg)
                    if (is_css_prop(k) && !(k in { width: 1, height: 1, size: 1 } && el in { canvas: 1, input: 1, embed: 1, object: 1 }))
                      attrs.style[k] = arg[k];
                    else if (k === "style")
                      for (var k2 in arg[k])
                        attrs.style[k2] = arg[k][k2];
                    else {
                      attrs[k] = arg[k];
                      if (k === "key")
                        attrs["data-key"] = arg[k];
                    }
              }
              if (children.length === 0)
                children = void 0;
              return React.DOM[el](attrs, children);
            };
          }
        };
        function make_fixed_textbox(tagname) {
          var component = createReactClass({
            getInitialState: function() {
              return { value: this.props.value };
            },
            UNSAFE_componentWillReceiveProps: function(new_props) {
              this.setState({ value: new_props.value });
            },
            onChange: function(e2) {
              this.props.onChange && this.props.onChange(e2);
              if (this.props.value)
                this.setState({ value: e2.target.value });
            },
            onInput: function(e2) {
              this.props.onInput && this.props.onInput(e2);
              if (this.props.value)
                this.setState({ value: e2.target.value });
            },
            render: function() {
              var new_props = {
                ...this.props,
                ref: this.props.forwarded_ref
              };
              delete new_props.forwarded_ref;
              if (new_props.hasOwnProperty("onChange"))
                new_props.onChange = this.onChange;
              if (new_props.hasOwnProperty("onInput"))
                new_props.onInput = this.onInput;
              return React.createElement(tagname, new_props);
            }
          });
          return React.forwardRef((props, ref) => {
            return React.createElement(component, { ...props, forwarded_ref: ref });
          });
        }
        if (window.React && !React.createClass && window.createReactClass) {
          bus.libs.react17.input = make_fixed_textbox("input");
          bus.libs.react17.textarea = make_fixed_textbox("textarea");
        }
        function autodetect_args(func) {
          if (func.args)
            return;
          var comments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, params = /([^\s,]+)/g, s = func.toString().replace(comments, "");
          func.args = s.slice(s.indexOf("(") + 1, s.indexOf(")")).match(params) || [];
        }
        var users_widgets = {};
        function make_component(name3, func) {
          return users_widgets[name3] = create_react_class({
            displayName: name3,
            render: function() {
              var args = [];
              autodetect_args(func);
              for (var i2 = 0; i2 < func.args.length; i2++)
                args.push(this.props[func.args[i2]]);
              var vdom = func.apply(this, args);
              if (vdom && vdom.props) {
                vdom.props["data-widget"] = name3;
                vdom.props["data-key"] = this.props["data-key"];
              }
              return vdom;
            },
            componentDidMount: function() {
              var refresh = func.refresh;
              refresh && refresh.bind(this)();
            },
            componentWillUnmount: function() {
              var down = func.down;
              return down && down.bind(this)();
            },
            componentDidUpdate: function() {
              if (!this.initial_render_complete && !this.loading()) {
                this.initial_render_complete = true;
                var up = func.up;
                up && up.bind(this)();
              }
              var refresh = func.refresh;
              return refresh && refresh.bind(this)();
            },
            getInitialState: function() {
              return {};
            }
          });
        }
        function compile_coffee(coffee, filename) {
          var compiled;
          try {
            compiled = CoffeeScript.compile(
              coffee,
              {
                bare: true,
                sourceMap: true,
                filename
              }
            );
            var source_map = JSON.parse(compiled.v3SourceMap);
            source_map.sourcesContent = coffee;
            compiled = compiled.js;
            try {
              compiled += "\n";
              compiled += "//# sourceMappingURL=data:application/json;base64,";
              compiled += btoa(JSON.stringify(source_map)) + "\n";
              compiled += "//# sourceURL=" + filename;
            } catch (e2) {
            }
          } catch (error) {
            if (error.location)
              console.error(
                "Syntax error in " + filename + " on line",
                error.location.first_line + ", column " + error.location.first_column + ":",
                error.message
              );
            else
              throw error;
          }
          return compiled;
        }
        function load_client_code(code) {
          var dom = {};
          if (code)
            eval(code);
          else
            dom = window.dom;
          for (var widget_name in dom)
            window.dom[widget_name] = dom[widget_name];
        }
        function load_coffee() {
          load_client_code();
          var scripts = document.getElementsByTagName("script");
          var filename = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
          for (var i2 = 0; i2 < scripts.length; i2++)
            if (scripts[i2].getAttribute("type") in {
              "statebus": 1,
              "coffeedom": 1,
              "statebus-js": 1,
              "coffee": 1,
              "coffeescript": 1
            }) {
              if (!window.CoffeeScript) {
                console.error(`Cannot load <script type="coffee"> because coffeescript library isn't present`);
                return;
              }
              var compiled = scripts[i2].text;
              if (scripts[i2].getAttribute("type") !== "statebus-js")
                compiled = compile_coffee(scripts[i2].text, filename);
              if (compiled)
                load_client_code(compiled);
            }
        }
        function dom_to_widget(node) {
          if (node.nodeName === "#text")
            return node.textContent;
          if (!(node.nodeName in users_widgets))
            return node;
          node.seen = true;
          var children = [], props = {};
          for (var i2 = 0; i2 < node.childNodes.length; i2++)
            children.push(dom_to_widget(node.childNodes[i2]));
          var props = {};
          for (var i2 = 0; node.attributes && i2 < node.attributes.length; i2++)
            props[node.attributes[i2].name] = node.attributes[i2].value;
          var widge = window[node.nodeName.toLowerCase()] || window[node.nodeName.toUpperCase()];
          console.assert(widge, node.nodeName + " has not been defined as a UI widget.");
          return widge(props, children);
        }
        bus.libs.react17.react_class = create_react_class;
        bus.libs.react17.coffreact = () => {
          bus.libs.react17.reactive_dom();
          load_coffee();
          if (dom.BODY)
            document.addEventListener(
              "DOMContentLoaded",
              () => {
                var root = document.createElement("root");
                document.body.appendChild(root);
                ReactDOM.render(BODY(), root);
              },
              false
            );
        };
        http_automount();
        statebus.compile_coffee = compile_coffee;
        statebus.load_client_code = load_client_code;
        document.addEventListener("DOMContentLoaded", function() {
          if (window.statebus_ready)
            for (var i2 = 0; i2 < statebus_ready.length; i2++)
              statebus_ready[i2]();
        }, false);
      })();
    }
  });

  // node_modules/node-fetch/browser.js
  var require_browser = __commonJS({
    "node_modules/node-fetch/browser.js"(exports2, module3) {
      "use strict";
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global3 !== "undefined") {
          return global3;
        }
        throw new Error("unable to locate global object");
      };
      var global3 = getGlobal();
      module3.exports = exports2 = global3.fetch;
      if (global3.fetch) {
        exports2.default = global3.fetch.bind(global3);
      }
      exports2.Headers = global3.Headers;
      exports2.Request = global3.Request;
      exports2.Response = global3.Response;
    }
  });

  // node_modules/abort-controller/browser.js
  var require_browser2 = __commonJS({
    "node_modules/abort-controller/browser.js"(exports2, module3) {
      "use strict";
      var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
      module3.exports = AbortController2;
      module3.exports.AbortSignal = AbortSignal;
      module3.exports.default = AbortController2;
    }
  });

  // node_modules/emitter-component/index.js
  var require_emitter_component = __commonJS({
    "node_modules/emitter-component/index.js"(exports2, module3) {
      module3.exports = Emitter;
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key2 in Emitter.prototype) {
          obj[key2] = Emitter.prototype[key2];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        var self2 = this;
        this._callbacks = this._callbacks || {};
        function on() {
          self2.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
        var cb;
        for (var i2 = 0; i2 < callbacks.length; i2++) {
          cb = callbacks[i2];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i2, 1);
            break;
          }
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
            callbacks[i2].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }
  });

  // node_modules/stream/index.js
  var require_stream = __commonJS({
    "node_modules/stream/index.js"(exports2, module3) {
      var Emitter = require_emitter_component();
      function Stream() {
        Emitter.call(this);
      }
      Stream.prototype = new Emitter();
      module3.exports = Stream;
      Stream.Stream = Stream;
      Stream.prototype.pipe = function(dest, options2) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options2 || options2.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (!this.hasListeners("error")) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.off("data", ondata);
          dest.off("drain", ondrain);
          source.off("end", onend);
          source.off("close", onclose);
          source.off("error", onerror);
          dest.off("error", onerror);
          source.off("end", cleanup);
          source.off("close", cleanup);
          dest.off("end", cleanup);
          dest.off("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("end", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }
  });

  // node_modules/is-stream/index.js
  var require_is_stream = __commonJS({
    "node_modules/is-stream/index.js"(exports2, module3) {
      "use strict";
      var isStream = module3.exports = function(stream) {
        return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
      };
      isStream.writable = function(stream) {
        return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
      };
      isStream.readable = function(stream) {
        return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
      };
      isStream.duplex = function(stream) {
        return isStream.writable(stream) && isStream.readable(stream);
      };
      isStream.transform = function(stream) {
        return isStream.duplex(stream) && typeof stream._transform === "function" && typeof stream._transformState === "object";
      };
    }
  });

  // node_modules/node-web-streams/node_modules/web-streams-polyfill/dist/polyfill.min.js
  var require_polyfill_min = __commonJS({
    "node_modules/node-web-streams/node_modules/web-streams-polyfill/dist/polyfill.min.js"(exports2, module3) {
      !function(f) {
        if ("object" == typeof exports2 && "undefined" != typeof module3)
          module3.exports = f();
        else if ("function" == typeof define && define.amd)
          define([], f);
        else {
          var g2;
          g2 = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g2.default = f();
        }
      }(function() {
        return function e2(t2, n2, r) {
          function s(o2, u) {
            if (!n2[o2]) {
              if (!t2[o2]) {
                var a2 = "function" == typeof __require && __require;
                if (!u && a2)
                  return a2(o2, true);
                if (i2)
                  return i2(o2, true);
                var f = new Error("Cannot find module '" + o2 + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
              }
              var l = n2[o2] = { exports: {} };
              t2[o2][0].call(l.exports, function(e3) {
                var n3 = t2[o2][1][e3];
                return s(n3 ? n3 : e3);
              }, l, l.exports, e2, t2, n2, r);
            }
            return n2[o2].exports;
          }
          for (var i2 = "function" == typeof __require && __require, o = 0; o < r.length; o++)
            s(r[o]);
          return s;
        }({ 1: [function(require2, module4, exports3) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", { value: true });
          var _require = require2("./spec/reference-implementation/lib/readable-stream"), ReadableStream = _require.ReadableStream, _require2 = require2("./spec/reference-implementation/lib/writable-stream"), WritableStream = _require2.WritableStream, ByteLengthQueuingStrategy = require2("./spec/reference-implementation/lib/byte-length-queuing-strategy"), CountQueuingStrategy = require2("./spec/reference-implementation/lib/count-queuing-strategy"), TransformStream = require2("./spec/reference-implementation/lib/transform-stream");
          exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy, exports3.CountQueuingStrategy = CountQueuingStrategy, exports3.TransformStream = TransformStream, exports3.ReadableStream = ReadableStream, exports3.WritableStream = WritableStream;
          var interfaces = { ReadableStream, WritableStream, ByteLengthQueuingStrategy, CountQueuingStrategy, TransformStream };
          exports3.default = interfaces, "undefined" != typeof window && Object.assign(window, interfaces);
        }, { "./spec/reference-implementation/lib/byte-length-queuing-strategy": 7, "./spec/reference-implementation/lib/count-queuing-strategy": 8, "./spec/reference-implementation/lib/readable-stream": 11, "./spec/reference-implementation/lib/transform-stream": 12, "./spec/reference-implementation/lib/writable-stream": 14 }], 2: [function(require2, module4, exports3) {
          function replacer(key2, value) {
            return util2.isUndefined(value) ? "" + value : util2.isNumber(value) && !isFinite(value) ? value.toString() : util2.isFunction(value) || util2.isRegExp(value) ? value.toString() : value;
          }
          function truncate(s, n2) {
            return util2.isString(s) ? s.length < n2 ? s : s.slice(0, n2) : s;
          }
          function getMessage(self2) {
            return truncate(JSON.stringify(self2.actual, replacer), 128) + " " + self2.operator + " " + truncate(JSON.stringify(self2.expected, replacer), 128);
          }
          function fail(actual, expected, message, operator2, stackStartFunction) {
            throw new assert.AssertionError({ message, actual, expected, operator: operator2, stackStartFunction });
          }
          function ok(value, message) {
            value || fail(value, true, message, "==", assert.ok);
          }
          function _deepEqual(actual, expected) {
            if (actual === expected)
              return true;
            if (util2.isBuffer(actual) && util2.isBuffer(expected)) {
              if (actual.length != expected.length)
                return false;
              for (var i2 = 0; i2 < actual.length; i2++)
                if (actual[i2] !== expected[i2])
                  return false;
              return true;
            }
            return util2.isDate(actual) && util2.isDate(expected) ? actual.getTime() === expected.getTime() : util2.isRegExp(actual) && util2.isRegExp(expected) ? actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase : util2.isObject(actual) || util2.isObject(expected) ? objEquiv(actual, expected) : actual == expected;
          }
          function isArguments(object) {
            return "[object Arguments]" == Object.prototype.toString.call(object);
          }
          function objEquiv(a2, b2) {
            if (util2.isNullOrUndefined(a2) || util2.isNullOrUndefined(b2))
              return false;
            if (a2.prototype !== b2.prototype)
              return false;
            if (util2.isPrimitive(a2) || util2.isPrimitive(b2))
              return a2 === b2;
            var aIsArgs = isArguments(a2), bIsArgs = isArguments(b2);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
              return false;
            if (aIsArgs)
              return a2 = pSlice.call(a2), b2 = pSlice.call(b2), _deepEqual(a2, b2);
            var key2, i2, ka = objectKeys(a2), kb = objectKeys(b2);
            if (ka.length != kb.length)
              return false;
            for (ka.sort(), kb.sort(), i2 = ka.length - 1; i2 >= 0; i2--)
              if (ka[i2] != kb[i2])
                return false;
            for (i2 = ka.length - 1; i2 >= 0; i2--)
              if (key2 = ka[i2], !_deepEqual(a2[key2], b2[key2]))
                return false;
            return true;
          }
          function expectedException(actual, expected) {
            return !(!actual || !expected) && ("[object RegExp]" == Object.prototype.toString.call(expected) ? expected.test(actual) : actual instanceof expected || expected.call({}, actual) === true);
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            util2.isString(expected) && (message = expected, expected = null);
            try {
              block();
            } catch (e2) {
              actual = e2;
            }
            if (message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message), !shouldThrow && expectedException(actual, expected) && fail(actual, expected, "Got unwanted exception" + message), shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual)
              throw actual;
          }
          var util2 = require2("util/"), pSlice = Array.prototype.slice, hasOwn = Object.prototype.hasOwnProperty, assert = module4.exports = ok;
          assert.AssertionError = function(options2) {
            this.name = "AssertionError", this.actual = options2.actual, this.expected = options2.expected, this.operator = options2.operator, options2.message ? (this.message = options2.message, this.generatedMessage = false) : (this.message = getMessage(this), this.generatedMessage = true);
            var stackStartFunction = options2.stackStartFunction || fail;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, stackStartFunction);
            else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack, fn_name = stackStartFunction.name, idx = out.indexOf("\n" + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf("\n", idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          }, util2.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, assert.equal = function(actual, expected, message) {
            actual != expected && fail(actual, expected, message, "==", assert.equal);
          }, assert.notEqual = function(actual, expected, message) {
            actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
          }, assert.deepEqual = function(actual, expected, message) {
            _deepEqual(actual, expected) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
          }, assert.notDeepEqual = function(actual, expected, message) {
            _deepEqual(actual, expected) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
          }, assert.strictEqual = function(actual, expected, message) {
            actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
          }, assert.notStrictEqual = function(actual, expected, message) {
            actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
          }, assert.throws = function(block, error, message) {
            _throws.apply(this, [true].concat(pSlice.call(arguments)));
          }, assert.doesNotThrow = function(block, message) {
            _throws.apply(this, [false].concat(pSlice.call(arguments)));
          }, assert.ifError = function(err) {
            if (err)
              throw err;
          };
          var objectKeys = Object.keys || function(obj) {
            var keys4 = [];
            for (var key2 in obj)
              hasOwn.call(obj, key2) && keys4.push(key2);
            return keys4;
          };
        }, { "util/": 6 }], 3: [function(require2, module4, exports3) {
          "function" == typeof Object.create ? module4.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
          } : module4.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
          };
        }, {}], 4: [function(require2, module4, exports3) {
          function cleanUpNextTick() {
            draining && currentQueue && (draining = false, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
          }
          function drainQueue() {
            if (!draining) {
              var timeout = cachedSetTimeout(cleanUpNextTick);
              draining = true;
              for (var len = queue.length; len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; )
                  currentQueue && currentQueue[queueIndex].run();
                queueIndex = -1, len = queue.length;
              }
              currentQueue = null, draining = false, cachedClearTimeout(timeout);
            }
          }
          function Item(fun, array) {
            this.fun = fun, this.array = array;
          }
          function noop() {
          }
          var cachedSetTimeout, cachedClearTimeout, process2 = module4.exports = {};
          !function() {
            try {
              cachedSetTimeout = setTimeout;
            } catch (e2) {
              cachedSetTimeout = function() {
                throw new Error("setTimeout is not defined");
              };
            }
            try {
              cachedClearTimeout = clearTimeout;
            } catch (e2) {
              cachedClearTimeout = function() {
                throw new Error("clearTimeout is not defined");
              };
            }
          }();
          var currentQueue, queue = [], draining = false, queueIndex = -1;
          process2.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var i2 = 1; i2 < arguments.length; i2++)
                args[i2 - 1] = arguments[i2];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || cachedSetTimeout(drainQueue, 0);
          }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, process2.title = "browser", process2.browser = true, process2.env = {}, process2.argv = [], process2.version = "", process2.versions = {}, process2.on = noop, process2.addListener = noop, process2.once = noop, process2.off = noop, process2.removeListener = noop, process2.removeAllListeners = noop, process2.emit = noop, process2.binding = function(name3) {
            throw new Error("process.binding is not supported");
          }, process2.cwd = function() {
            return "/";
          }, process2.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          }, process2.umask = function() {
            return 0;
          };
        }, {}], 5: [function(require2, module4, exports3) {
          module4.exports = function(arg) {
            return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
          };
        }, {}], 6: [function(require2, module4, exports3) {
          (function(process2, global3) {
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), isBoolean(opts) ? ctx.showHidden = opts : opts && exports3._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = false), isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = false), isUndefined(ctx.customInspect) && (ctx.customInspect = true), ctx.colors && (ctx.stylize = stylizeWithColor), formatValue2(ctx, obj, ctx.depth);
            }
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              return style ? "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m" : str;
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function arrayToHash(array) {
              var hash = {};
              return array.forEach(function(val, idx) {
                hash[val] = true;
              }), hash;
            }
            function formatValue2(ctx, value, recurseTimes) {
              if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports3.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                var ret = value.inspect(recurseTimes, ctx);
                return isString2(ret) || (ret = formatValue2(ctx, ret, recurseTimes)), ret;
              }
              var primitive = formatPrimitive(ctx, value);
              if (primitive)
                return primitive;
              var keys4 = Object.keys(value), visibleKeys = arrayToHash(keys4);
              if (ctx.showHidden && (keys4 = Object.getOwnPropertyNames(value)), isError(value) && (keys4.indexOf("message") >= 0 || keys4.indexOf("description") >= 0))
                return formatError(value);
              if (0 === keys4.length) {
                if (isFunction(value)) {
                  var name3 = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name3 + "]", "special");
                }
                if (isRegExp(value))
                  return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                if (isDate(value))
                  return ctx.stylize(Date.prototype.toString.call(value), "date");
                if (isError(value))
                  return formatError(value);
              }
              var base2 = "", array = false, braces = ["{", "}"];
              if (isArray5(value) && (array = true, braces = ["[", "]"]), isFunction(value)) {
                var n2 = value.name ? ": " + value.name : "";
                base2 = " [Function" + n2 + "]";
              }
              if (isRegExp(value) && (base2 = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base2 = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base2 = " " + formatError(value)), 0 === keys4.length && (!array || 0 == value.length))
                return braces[0] + base2 + braces[1];
              if (recurseTimes < 0)
                return isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special");
              ctx.seen.push(value);
              var output;
              return output = array ? formatArray(ctx, value, recurseTimes, visibleKeys, keys4) : keys4.map(function(key2) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array);
              }), ctx.seen.pop(), reduceToSingleString(output, base2, braces);
            }
            function formatPrimitive(ctx, value) {
              if (isUndefined(value))
                return ctx.stylize("undefined", "undefined");
              if (isString2(value)) {
                var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return ctx.stylize(simple, "string");
              }
              return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatArray(ctx, value, recurseTimes, visibleKeys, keys4) {
              for (var output = [], i2 = 0, l = value.length; i2 < l; ++i2)
                hasOwnProperty(value, String(i2)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true)) : output.push("");
              return keys4.forEach(function(key2) {
                key2.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key2, true));
              }), output;
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key2, array) {
              var name3, str, desc;
              if (desc = Object.getOwnPropertyDescriptor(value, key2) || { value: value[key2] }, desc.get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), hasOwnProperty(visibleKeys, key2) || (name3 = "[" + key2 + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue2(ctx, desc.value, null) : formatValue2(ctx, desc.value, recurseTimes - 1), str.indexOf("\n") > -1 && (str = array ? str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2) : "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n"))) : str = ctx.stylize("[Circular]", "special")), isUndefined(name3)) {
                if (array && key2.match(/^\d+$/))
                  return str;
                name3 = JSON.stringify("" + key2), name3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name3 = name3.substr(1, name3.length - 2), name3 = ctx.stylize(name3, "name")) : (name3 = name3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name3 = ctx.stylize(name3, "string"));
              }
              return name3 + ": " + str;
            }
            function reduceToSingleString(output, base2, braces) {
              var numLinesEst = 0, length = output.reduce(function(prev, cur2) {
                return numLinesEst++, cur2.indexOf("\n") >= 0 && numLinesEst++, prev + cur2.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0);
              return length > 60 ? braces[0] + ("" === base2 ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
            }
            function isArray5(ar) {
              return Array.isArray(ar);
            }
            function isBoolean(arg) {
              return "boolean" == typeof arg;
            }
            function isNull(arg) {
              return null === arg;
            }
            function isNullOrUndefined(arg) {
              return null == arg;
            }
            function isNumber(arg) {
              return "number" == typeof arg;
            }
            function isString2(arg) {
              return "string" == typeof arg;
            }
            function isSymbol(arg) {
              return "symbol" == typeof arg;
            }
            function isUndefined(arg) {
              return void 0 === arg;
            }
            function isRegExp(re) {
              return isObject(re) && "[object RegExp]" === objectToString(re);
            }
            function isObject(arg) {
              return "object" == typeof arg && null !== arg;
            }
            function isDate(d2) {
              return isObject(d2) && "[object Date]" === objectToString(d2);
            }
            function isError(e2) {
              return isObject(e2) && ("[object Error]" === objectToString(e2) || e2 instanceof Error);
            }
            function isFunction(arg) {
              return "function" == typeof arg;
            }
            function isPrimitive(arg) {
              return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || "undefined" == typeof arg;
            }
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n2) {
              return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
            }
            function timestamp() {
              var d2 = new Date(), time = [pad(d2.getHours()), pad(d2.getMinutes()), pad(d2.getSeconds())].join(":");
              return [d2.getDate(), months[d2.getMonth()], time].join(" ");
            }
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            var formatRegExp = /%[sdj%]/g;
            exports3.format = function(f) {
              if (!isString2(f)) {
                for (var objects = [], i2 = 0; i2 < arguments.length; i2++)
                  objects.push(inspect(arguments[i2]));
                return objects.join(" ");
              }
              for (var i2 = 1, args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x2) {
                if ("%%" === x2)
                  return "%";
                if (i2 >= len)
                  return x2;
                switch (x2) {
                  case "%s":
                    return String(args[i2++]);
                  case "%d":
                    return Number(args[i2++]);
                  case "%j":
                    try {
                      return JSON.stringify(args[i2++]);
                    } catch (_) {
                      return "[Circular]";
                    }
                  default:
                    return x2;
                }
              }), x = args[i2]; i2 < len; x = args[++i2])
                str += isNull(x) || !isObject(x) ? " " + x : " " + inspect(x);
              return str;
            }, exports3.deprecate = function(fn, msg2) {
              function deprecated() {
                if (!warned2) {
                  if (process2.throwDeprecation)
                    throw new Error(msg2);
                  process2.traceDeprecation ? console.trace(msg2) : console.error(msg2), warned2 = true;
                }
                return fn.apply(this, arguments);
              }
              if (isUndefined(global3.process))
                return function() {
                  return exports3.deprecate(fn, msg2).apply(this, arguments);
                };
              if (process2.noDeprecation === true)
                return fn;
              var warned2 = false;
              return deprecated;
            };
            var debugEnviron, debugs = {};
            exports3.debuglog = function(set3) {
              if (isUndefined(debugEnviron) && (debugEnviron = process2.env.NODE_DEBUG || ""), set3 = set3.toUpperCase(), !debugs[set3])
                if (new RegExp("\\b" + set3 + "\\b", "i").test(debugEnviron)) {
                  var pid = process2.pid;
                  debugs[set3] = function() {
                    var msg2 = exports3.format.apply(exports3, arguments);
                    console.error("%s %d: %s", set3, pid, msg2);
                  };
                } else
                  debugs[set3] = function() {
                  };
              return debugs[set3];
            }, exports3.inspect = inspect, inspect.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, inspect.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, exports3.isArray = isArray5, exports3.isBoolean = isBoolean, exports3.isNull = isNull, exports3.isNullOrUndefined = isNullOrUndefined, exports3.isNumber = isNumber, exports3.isString = isString2, exports3.isSymbol = isSymbol, exports3.isUndefined = isUndefined, exports3.isRegExp = isRegExp, exports3.isObject = isObject, exports3.isDate = isDate, exports3.isError = isError, exports3.isFunction = isFunction, exports3.isPrimitive = isPrimitive, exports3.isBuffer = require2("./support/isBuffer");
            var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            exports3.log = function() {
              console.log("%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
            }, exports3.inherits = require2("inherits"), exports3._extend = function(origin, add2) {
              if (!add2 || !isObject(add2))
                return origin;
              for (var keys4 = Object.keys(add2), i2 = keys4.length; i2--; )
                origin[keys4[i2]] = add2[keys4[i2]];
              return origin;
            };
          }).call(this, require2("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
        }, { "./support/isBuffer": 5, _process: 4, inherits: 3 }], 7: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), _require = require2("./helpers.js"), createDataProperty = _require.createDataProperty;
          module4.exports = function() {
            function ByteLengthQueuingStrategy(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, ByteLengthQueuingStrategy), createDataProperty(this, "highWaterMark", highWaterMark);
            }
            return _createClass(ByteLengthQueuingStrategy, [{ key: "size", value: function(chunk) {
              return chunk.byteLength;
            } }]), ByteLengthQueuingStrategy;
          }();
        }, { "./helpers.js": 9 }], 8: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), _require = require2("./helpers.js"), createDataProperty = _require.createDataProperty;
          module4.exports = function() {
            function CountQueuingStrategy(_ref) {
              var highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, CountQueuingStrategy), createDataProperty(this, "highWaterMark", highWaterMark);
            }
            return _createClass(CountQueuingStrategy, [{ key: "size", value: function(chunk) {
              return 1;
            } }]), CountQueuingStrategy;
          }();
        }, { "./helpers.js": 9 }], 9: [function(require2, module4, exports3) {
          "use strict";
          var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol ? "symbol" : typeof obj;
          }, assert = require2("assert");
          exports3.promiseCall = function(func) {
            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
              args[_key - 1] = arguments[_key];
            try {
              return Promise.resolve(func.apply(void 0, args));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.typeIsObject = function(x) {
            return "object" === ("undefined" == typeof x ? "undefined" : _typeof(x)) && null !== x || "function" == typeof x;
          }, exports3.toInteger = function(v) {
            return v = Number(v), isNaN(v) ? 0 : v < 0 ? -1 * Math.floor(Math.abs(v)) : Math.floor(Math.abs(v));
          }, exports3.createDataProperty = function(o, p2, v) {
            assert(exports3.typeIsObject(o)), o[p2] = v;
          }, exports3.createArrayFromList = function(elements) {
            return elements.slice();
          }, exports3.ArrayBufferCopy = function(dest, destOffset, src, srcOffset, n2) {
            new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n2), destOffset);
          }, exports3.CreateIterResultObject = function(value, done) {
            return assert("boolean" == typeof done), { value, done };
          }, exports3.IsFiniteNonNegativeNumber = function(v) {
            return !Number.isNaN(v) && (v !== +(1 / 0) && !(v < 0));
          }, exports3.InvokeOrNoop = function(O, P, args) {
            var method = O[P];
            if (void 0 !== method)
              return method.apply(O, args);
          }, exports3.PromiseInvokeOrNoop = function(O, P, args) {
            var method = void 0;
            try {
              return method = O[P], void 0 === method ? Promise.resolve(void 0) : Promise.resolve(method.apply(O, args));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.PromiseInvokeOrFallbackOrNoop = function(O, P1, args1, P2, args2) {
            var method = void 0;
            try {
              method = O[P1];
            } catch (methodE) {
              return Promise.reject(methodE);
            }
            if (void 0 === method)
              return exports3.PromiseInvokeOrNoop(O, P2, args2);
            try {
              return Promise.resolve(method.apply(O, args1));
            } catch (e2) {
              return Promise.reject(e2);
            }
          }, exports3.SameRealmTransfer = function(O) {
            return O;
          }, exports3.ValidateAndNormalizeHighWaterMark = function(highWaterMark) {
            if (highWaterMark = Number(highWaterMark), Number.isNaN(highWaterMark) || highWaterMark < 0)
              throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative and non-NaN");
            return highWaterMark;
          }, exports3.ValidateAndNormalizeQueuingStrategy = function(size2, highWaterMark) {
            if (void 0 !== size2 && "function" != typeof size2)
              throw new TypeError("size property of a queuing strategy must be a function");
            return highWaterMark = exports3.ValidateAndNormalizeHighWaterMark(highWaterMark), { size: size2, highWaterMark };
          };
        }, { assert: 2 }], 10: [function(require2, module4, exports3) {
          "use strict";
          var assert = require2("assert"), _require = require2("./helpers.js"), IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber;
          exports3.DequeueValue = function(queue) {
            assert(queue.length > 0, "Spec-level failure: should never dequeue from an empty queue.");
            var pair = queue.shift();
            return pair.value;
          }, exports3.EnqueueValueWithSize = function(queue, value, size2) {
            if (size2 = Number(size2), !IsFiniteNonNegativeNumber(size2))
              throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
            queue.push({ value, size: size2 });
          }, exports3.GetTotalQueueSize = function(queue) {
            var totalSize = 0;
            return queue.forEach(function(pair) {
              assert("number" == typeof pair.size && !Number.isNaN(pair.size) && pair.size !== +(1 / 0) && pair.size !== -(1 / 0), "Spec-level failure: should never find an invalid size in the queue."), totalSize += pair.size;
            }), totalSize;
          }, exports3.PeekQueueValue = function(queue) {
            assert(queue.length > 0, "Spec-level failure: should never peek at an empty queue.");
            var pair = queue[0];
            return pair.value;
          };
        }, { "./helpers.js": 9, assert: 2 }], 11: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          function AcquireReadableStreamBYOBReader(stream) {
            return new ReadableStreamBYOBReader(stream);
          }
          function AcquireReadableStreamDefaultReader(stream) {
            return new ReadableStreamDefaultReader(stream);
          }
          function IsReadableStream(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readableStreamController");
          }
          function IsReadableStreamDisturbed(stream) {
            return assert(IsReadableStream(stream) === true, "IsReadableStreamDisturbed should only be used on known readable streams"), stream._disturbed;
          }
          function IsReadableStreamLocked(stream) {
            return assert(IsReadableStream(stream) === true, "IsReadableStreamLocked should only be used on known readable streams"), void 0 !== stream._reader;
          }
          function ReadableStreamTee(stream, shouldClone) {
            assert(IsReadableStream(stream) === true), assert("boolean" == typeof shouldClone);
            var reader = AcquireReadableStreamDefaultReader(stream), teeState = { closedOrErrored: false, canceled1: false, canceled2: false, reason1: void 0, reason2: void 0 };
            teeState.promise = new Promise(function(resolve) {
              return teeState._resolve = resolve;
            });
            var pull = create_ReadableStreamTeePullFunction();
            pull._reader = reader, pull._teeState = teeState, pull._shouldClone = shouldClone;
            var cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
            cancel1._stream = stream, cancel1._teeState = teeState;
            var cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
            cancel2._stream = stream, cancel2._teeState = teeState;
            var underlyingSource1 = Object.create(Object.prototype);
            createDataProperty(underlyingSource1, "pull", pull), createDataProperty(underlyingSource1, "cancel", cancel1);
            var branch1Stream = new ReadableStream(underlyingSource1), underlyingSource2 = Object.create(Object.prototype);
            createDataProperty(underlyingSource2, "pull", pull), createDataProperty(underlyingSource2, "cancel", cancel2);
            var branch2Stream = new ReadableStream(underlyingSource2);
            return pull._branch1 = branch1Stream._readableStreamController, pull._branch2 = branch2Stream._readableStreamController, reader._closedPromise.catch(function(r) {
              teeState.closedOrErrored !== true && (ReadableStreamDefaultControllerError(pull._branch1, r), ReadableStreamDefaultControllerError(pull._branch2, r), teeState.closedOrErrored = true);
            }), [branch1Stream, branch2Stream];
          }
          function create_ReadableStreamTeePullFunction() {
            var f = function f2() {
              var reader = f2._reader, branch1 = f2._branch1, branch2 = f2._branch2, teeState = f2._teeState;
              f2._shouldClone;
              return ReadableStreamDefaultReaderRead(reader).then(function(result) {
                assert(typeIsObject(result));
                var value = result.value, done = result.done;
                if (assert("boolean" == typeof done), done === true && teeState.closedOrErrored === false && (teeState.canceled1 === false && ReadableStreamDefaultControllerClose(branch1), teeState.canceled2 === false && ReadableStreamDefaultControllerClose(branch2), teeState.closedOrErrored = true), teeState.closedOrErrored !== true) {
                  if (teeState.canceled1 === false) {
                    var value1 = value;
                    ReadableStreamDefaultControllerEnqueue(branch1, value1);
                  }
                  if (teeState.canceled2 === false) {
                    var value2 = value;
                    ReadableStreamDefaultControllerEnqueue(branch2, value2);
                  }
                }
              });
            };
            return f;
          }
          function create_ReadableStreamTeeBranch1CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream, teeState = f2._teeState;
              if (teeState.canceled1 = true, teeState.reason1 = reason, teeState.canceled2 === true) {
                var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          function create_ReadableStreamTeeBranch2CancelFunction() {
            var f = function f2(reason) {
              var stream = f2._stream, teeState = f2._teeState;
              if (teeState.canceled2 = true, teeState.reason2 = reason, teeState.canceled1 === true) {
                var compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]), cancelResult = ReadableStreamCancel(stream, compositeReason);
                teeState._resolve(cancelResult);
              }
              return teeState.promise;
            };
            return f;
          }
          function ReadableStreamAddReadIntoRequest(stream) {
            assert(IsReadableStreamBYOBReader(stream._reader) === true), assert("readable" === stream._state || "closed" === stream._state);
            var promise = new Promise(function(resolve, reject) {
              var readIntoRequest = { _resolve: resolve, _reject: reject };
              stream._reader._readIntoRequests.push(readIntoRequest);
            });
            return promise;
          }
          function ReadableStreamAddReadRequest(stream) {
            assert(IsReadableStreamDefaultReader(stream._reader) === true), assert("readable" === stream._state);
            var promise = new Promise(function(resolve, reject) {
              var readRequest = { _resolve: resolve, _reject: reject };
              stream._reader._readRequests.push(readRequest);
            });
            return promise;
          }
          function ReadableStreamCancel(stream, reason) {
            if (stream._disturbed = true, "closed" === stream._state)
              return Promise.resolve(void 0);
            if ("errored" === stream._state)
              return Promise.reject(stream._storedError);
            ReadableStreamClose(stream);
            var sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);
            return sourceCancelPromise.then(function() {
            });
          }
          function ReadableStreamClose(stream) {
            assert("readable" === stream._state), stream._state = "closed";
            var reader = stream._reader;
            if (void 0 !== reader) {
              if (IsReadableStreamDefaultReader(reader) === true) {
                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = void 0;
                try {
                  for (var _step, _iterator = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var _resolve = _step.value._resolve;
                    _resolve(CreateIterResultObject(void 0, true));
                  }
                } catch (err) {
                  _didIteratorError = true, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator.return && _iterator.return();
                  } finally {
                    if (_didIteratorError)
                      throw _iteratorError;
                  }
                }
                reader._readRequests = [];
              }
              reader._closedPromise_resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;
            }
          }
          function ReadableStreamError(stream, e2) {
            assert(IsReadableStream(stream) === true, "stream must be ReadableStream"), assert("readable" === stream._state, "state must be readable"), stream._state = "errored", stream._storedError = e2;
            var reader = stream._reader;
            if (void 0 !== reader) {
              if (IsReadableStreamDefaultReader(reader) === true) {
                var _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = void 0;
                try {
                  for (var _step2, _iterator2 = reader._readRequests[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var readRequest = _step2.value;
                    readRequest._reject(e2);
                  }
                } catch (err) {
                  _didIteratorError2 = true, _iteratorError2 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion2 && _iterator2.return && _iterator2.return();
                  } finally {
                    if (_didIteratorError2)
                      throw _iteratorError2;
                  }
                }
                reader._readRequests = [];
              } else {
                assert(IsReadableStreamBYOBReader(reader), "reader must be ReadableStreamBYOBReader");
                var _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = void 0;
                try {
                  for (var _step3, _iterator3 = reader._readIntoRequests[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var readIntoRequest = _step3.value;
                    readIntoRequest._reject(e2);
                  }
                } catch (err) {
                  _didIteratorError3 = true, _iteratorError3 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion3 && _iterator3.return && _iterator3.return();
                  } finally {
                    if (_didIteratorError3)
                      throw _iteratorError3;
                  }
                }
                reader._readIntoRequests = [];
              }
              reader._closedPromise_reject(e2), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0;
            }
          }
          function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
            var reader = stream._reader;
            assert(reader._readIntoRequests.length > 0);
            var readIntoRequest = reader._readIntoRequests.shift();
            readIntoRequest._resolve(CreateIterResultObject(chunk, done));
          }
          function ReadableStreamFulfillReadRequest(stream, chunk, done) {
            var reader = stream._reader;
            assert(reader._readRequests.length > 0);
            var readRequest = reader._readRequests.shift();
            readRequest._resolve(CreateIterResultObject(chunk, done));
          }
          function ReadableStreamGetNumReadIntoRequests(stream) {
            return stream._reader._readIntoRequests.length;
          }
          function ReadableStreamGetNumReadRequests(stream) {
            return stream._reader._readRequests.length;
          }
          function ReadableStreamHasBYOBReader(stream) {
            var reader = stream._reader;
            return void 0 !== reader && IsReadableStreamBYOBReader(reader) !== false;
          }
          function ReadableStreamHasDefaultReader(stream) {
            var reader = stream._reader;
            return void 0 !== reader && IsReadableStreamDefaultReader(reader) !== false;
          }
          function IsReadableStreamBYOBReader(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests");
          }
          function IsReadableStreamDefaultReader(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_readRequests");
          }
          function ReadableStreamReaderGenericInitialize(reader, stream) {
            reader._ownerReadableStream = stream, stream._reader = reader, "readable" === stream._state ? reader._closedPromise = new Promise(function(resolve, reject) {
              reader._closedPromise_resolve = resolve, reader._closedPromise_reject = reject;
            }) : "closed" === stream._state ? (reader._closedPromise = Promise.resolve(void 0), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0) : (assert("errored" === stream._state, "state must be errored"), reader._closedPromise = Promise.reject(stream._storedError), reader._closedPromise_resolve = void 0, reader._closedPromise_reject = void 0);
          }
          function ReadableStreamReaderGenericCancel(reader, reason) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), ReadableStreamCancel(stream, reason);
          }
          function ReadableStreamReaderGenericRelease(reader) {
            assert(void 0 !== reader._ownerReadableStream), assert(reader._ownerReadableStream._reader === reader), "readable" === reader._ownerReadableStream._state ? reader._closedPromise_reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : reader._closedPromise = Promise.reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), reader._ownerReadableStream._reader = void 0, reader._ownerReadableStream = void 0;
          }
          function ReadableStreamBYOBReaderRead(reader, view) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), stream._disturbed = true, "errored" === stream._state ? Promise.reject(stream._storedError) : ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
          }
          function ReadableStreamDefaultReaderRead(reader) {
            var stream = reader._ownerReadableStream;
            return assert(void 0 !== stream), stream._disturbed = true, "closed" === stream._state ? Promise.resolve(CreateIterResultObject(void 0, true)) : "errored" === stream._state ? Promise.reject(stream._storedError) : (assert("readable" === stream._state), stream._readableStreamController[InternalPull]());
          }
          function IsReadableStreamDefaultController(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingSource");
          }
          function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
            var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
            if (shouldPull !== false) {
              if (controller._pulling === true)
                return void (controller._pullAgain = true);
              controller._pulling = true;
              var pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, "pull", [controller]);
              pullPromise.then(function() {
                if (controller._pulling = false, controller._pullAgain === true)
                  return controller._pullAgain = false, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }, function(e2) {
                if ("readable" === controller._controlledReadableStream._state)
                  return ReadableStreamDefaultControllerError(controller, e2);
              }).catch(rethrowAssertionErrorRejection);
            }
          }
          function ReadableStreamDefaultControllerShouldCallPull(controller) {
            var stream = controller._controlledReadableStream;
            if ("closed" === stream._state || "errored" === stream._state)
              return false;
            if (controller._closeRequested === true)
              return false;
            if (controller._started === false)
              return false;
            if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0)
              return true;
            var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
            return desiredSize > 0;
          }
          function ReadableStreamDefaultControllerClose(controller) {
            var stream = controller._controlledReadableStream;
            assert(controller._closeRequested === false), assert("readable" === stream._state), controller._closeRequested = true, 0 === controller._queue.length && ReadableStreamClose(stream);
          }
          function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
            var stream = controller._controlledReadableStream;
            if (assert(controller._closeRequested === false), assert("readable" === stream._state), IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0)
              ReadableStreamFulfillReadRequest(stream, chunk, false);
            else {
              var chunkSize = 1;
              if (void 0 !== controller._strategySize)
                try {
                  chunkSize = controller._strategySize(chunk);
                } catch (chunkSizeE) {
                  throw "readable" === stream._state && ReadableStreamDefaultControllerError(controller, chunkSizeE), chunkSizeE;
                }
              try {
                EnqueueValueWithSize(controller._queue, chunk, chunkSize);
              } catch (enqueueE) {
                throw "readable" === stream._state && ReadableStreamDefaultControllerError(controller, enqueueE), enqueueE;
              }
            }
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }
          function ReadableStreamDefaultControllerError(controller, e2) {
            var stream = controller._controlledReadableStream;
            assert("readable" === stream._state), controller._queue = [], ReadableStreamError(stream, e2);
          }
          function ReadableStreamDefaultControllerGetDesiredSize(controller) {
            var queueSize = GetTotalQueueSize(controller._queue);
            return controller._strategyHWM - queueSize;
          }
          function IsReadableByteStreamController(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingByteSource");
          }
          function IsReadableStreamBYOBRequest(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController");
          }
          function ReadableByteStreamControllerCallPullIfNeeded(controller) {
            var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
            if (shouldPull !== false) {
              if (controller._pulling === true)
                return void (controller._pullAgain = true);
              controller._pullAgain = false, controller._pulling = true;
              var pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, "pull", [controller]);
              pullPromise.then(function() {
                controller._pulling = false, controller._pullAgain === true && (controller._pullAgain = false, ReadableByteStreamControllerCallPullIfNeeded(controller));
              }, function(e2) {
                "readable" === controller._controlledReadableStream._state && ReadableByteStreamControllerError(controller, e2);
              }).catch(rethrowAssertionErrorRejection);
            }
          }
          function ReadableByteStreamControllerClearPendingPullIntos(controller) {
            ReadableByteStreamControllerInvalidateBYOBRequest(controller), controller._pendingPullIntos = [];
          }
          function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
            assert("errored" !== stream._state, "state must not be errored");
            var done = false;
            "closed" === stream._state && (assert(0 === pullIntoDescriptor.bytesFilled), done = true);
            var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
            "default" === pullIntoDescriptor.readerType ? ReadableStreamFulfillReadRequest(stream, filledView, done) : (assert("byob" === pullIntoDescriptor.readerType), ReadableStreamFulfillReadIntoRequest(stream, filledView, done));
          }
          function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
            var bytesFilled = pullIntoDescriptor.bytesFilled, elementSize = pullIntoDescriptor.elementSize;
            return assert(bytesFilled <= pullIntoDescriptor.byteLength), assert(bytesFilled % elementSize === 0), new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
          }
          function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
            controller._queue.push({ buffer, byteOffset, byteLength }), controller._totalQueuedBytes += byteLength;
          }
          function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
            var elementSize = pullIntoDescriptor.elementSize, currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize, maxBytesToCopy = Math.min(controller._totalQueuedBytes, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled), maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy, maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize, totalBytesToCopyRemaining = maxBytesToCopy, ready = false;
            maxAlignedBytes > currentAlignedBytes && (totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled, ready = true);
            for (var queue = controller._queue; totalBytesToCopyRemaining > 0; ) {
              var headOfQueue = queue[0], bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength), destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
              ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy), headOfQueue.byteLength === bytesToCopy ? queue.shift() : (headOfQueue.byteOffset += bytesToCopy, headOfQueue.byteLength -= bytesToCopy), controller._totalQueuedBytes -= bytesToCopy, ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor), totalBytesToCopyRemaining -= bytesToCopy;
            }
            return ready === false && (assert(0 === controller._totalQueuedBytes, "queue must be empty"), assert(pullIntoDescriptor.bytesFilled > 0), assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)), ready;
          }
          function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size2, pullIntoDescriptor) {
            assert(0 === controller._pendingPullIntos.length || controller._pendingPullIntos[0] === pullIntoDescriptor), ReadableByteStreamControllerInvalidateBYOBRequest(controller), pullIntoDescriptor.bytesFilled += size2;
          }
          function ReadableByteStreamControllerHandleQueueDrain(controller) {
            assert("readable" === controller._controlledReadableStream._state), 0 === controller._totalQueuedBytes && controller._closeRequested === true ? ReadableStreamClose(controller._controlledReadableStream) : ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
          function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
            void 0 !== controller._byobRequest && (controller._byobRequest._associatedReadableByteStreamController = void 0, controller._byobRequest._view = void 0, controller._byobRequest = void 0);
          }
          function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
            for (assert(controller._closeRequested === false); controller._pendingPullIntos.length > 0; ) {
              if (0 === controller._totalQueuedBytes)
                return;
              var pullIntoDescriptor = controller._pendingPullIntos[0];
              ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true && (ReadableByteStreamControllerShiftPendingPullInto(controller), ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor));
            }
          }
          function ReadableByteStreamControllerPullInto(controller, view) {
            var stream = controller._controlledReadableStream, elementSize = 1;
            view.constructor !== DataView && (elementSize = view.constructor.BYTES_PER_ELEMENT);
            var ctor = view.constructor, pullIntoDescriptor = { buffer: view.buffer, byteOffset: view.byteOffset, byteLength: view.byteLength, bytesFilled: 0, elementSize, ctor, readerType: "byob" };
            if (controller._pendingPullIntos.length > 0)
              return pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor), ReadableStreamAddReadIntoRequest(stream);
            if ("closed" === stream._state) {
              var emptyView = new view.constructor(view.buffer, view.byteOffset, 0);
              return Promise.resolve(CreateIterResultObject(emptyView, true));
            }
            if (controller._totalQueuedBytes > 0) {
              if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
                var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
                return ReadableByteStreamControllerHandleQueueDrain(controller), Promise.resolve(CreateIterResultObject(filledView, false));
              }
              if (controller._closeRequested === true) {
                var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                return ReadableByteStreamControllerError(controller, e2), Promise.reject(e2);
              }
            }
            pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), controller._pendingPullIntos.push(pullIntoDescriptor);
            var promise = ReadableStreamAddReadIntoRequest(stream);
            return ReadableByteStreamControllerCallPullIfNeeded(controller), promise;
          }
          function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
            firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer), assert(0 === firstDescriptor.bytesFilled, "bytesFilled must be 0");
            for (var stream = controller._controlledReadableStream; ReadableStreamGetNumReadIntoRequests(stream) > 0; ) {
              var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
          function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
            if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength)
              throw new RangeError("bytesWritten out of range");
            if (ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor), !(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
              if (remainderSize > 0) {
                var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled, remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
              }
              pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer), pullIntoDescriptor.bytesFilled -= remainderSize, ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
            }
          }
          function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
            var firstDescriptor = controller._pendingPullIntos[0], stream = controller._controlledReadableStream;
            if ("closed" === stream._state) {
              if (0 !== bytesWritten)
                throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
              ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
            } else
              assert("readable" === stream._state), ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          function ReadableByteStreamControllerShiftPendingPullInto(controller) {
            var descriptor = controller._pendingPullIntos.shift();
            return ReadableByteStreamControllerInvalidateBYOBRequest(controller), descriptor;
          }
          function ReadableByteStreamControllerShouldCallPull(controller) {
            var stream = controller._controlledReadableStream;
            return "readable" === stream._state && (controller._closeRequested !== true && (controller._started !== false && (!!(ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) || (!!(ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) || ReadableByteStreamControllerGetDesiredSize(controller) > 0))));
          }
          function ReadableByteStreamControllerClose(controller) {
            var stream = controller._controlledReadableStream;
            if (assert(controller._closeRequested === false), assert("readable" === stream._state), controller._totalQueuedBytes > 0)
              return void (controller._closeRequested = true);
            if (controller._pendingPullIntos.length > 0) {
              var firstPendingPullInto = controller._pendingPullIntos[0];
              if (firstPendingPullInto.bytesFilled > 0) {
                var e2 = new TypeError("Insufficient bytes to fill elements in the given buffer");
                throw ReadableByteStreamControllerError(controller, e2), e2;
              }
            }
            ReadableStreamClose(stream);
          }
          function ReadableByteStreamControllerEnqueue(controller, chunk) {
            var stream = controller._controlledReadableStream;
            assert(controller._closeRequested === false), assert("readable" === stream._state);
            var buffer = chunk.buffer, byteOffset = chunk.byteOffset, byteLength = chunk.byteLength, transferredBuffer = SameRealmTransfer(buffer);
            if (ReadableStreamHasDefaultReader(stream) === true)
              if (0 === ReadableStreamGetNumReadRequests(stream))
                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
              else {
                assert(0 === controller._queue.length);
                var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
                ReadableStreamFulfillReadRequest(stream, transferredView, false);
              }
            else
              ReadableStreamHasBYOBReader(stream) === true ? (ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength), ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller)) : (assert(IsReadableStreamLocked(stream) === false, "stream must not be locked"), ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength));
          }
          function ReadableByteStreamControllerError(controller, e2) {
            var stream = controller._controlledReadableStream;
            assert("readable" === stream._state), ReadableByteStreamControllerClearPendingPullIntos(controller), controller._queue = [], ReadableStreamError(stream, e2);
          }
          function ReadableByteStreamControllerGetDesiredSize(controller) {
            return controller._strategyHWM - controller._totalQueuedBytes;
          }
          function ReadableByteStreamControllerRespond(controller, bytesWritten) {
            if (bytesWritten = Number(bytesWritten), IsFiniteNonNegativeNumber(bytesWritten) === false)
              throw new RangeError("bytesWritten must be a finite");
            assert(controller._pendingPullIntos.length > 0), ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
          }
          function ReadableByteStreamControllerRespondWithNewView(controller, view) {
            assert(controller._pendingPullIntos.length > 0);
            var firstDescriptor = controller._pendingPullIntos[0];
            if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset)
              throw new RangeError("The region specified by view does not match byobRequest");
            if (firstDescriptor.byteLength !== view.byteLength)
              throw new RangeError("The buffer of view has different capacity than byobRequest");
            firstDescriptor.buffer = view.buffer, ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
          }
          var _slicedToArray = function() {
            function sliceIterator(arr, i2) {
              var _arr = [], _n = true, _d = false, _e = void 0;
              try {
                for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !i2 || _arr.length !== i2); _n = true)
                  ;
              } catch (err) {
                _d = true, _e = err;
              } finally {
                try {
                  !_n && _i.return && _i.return();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            return function(arr, i2) {
              if (Array.isArray(arr))
                return arr;
              if (Symbol.iterator in Object(arr))
                return sliceIterator(arr, i2);
              throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
          }(), _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), assert = require2("assert"), _require = require2("./helpers.js"), ArrayBufferCopy = _require.ArrayBufferCopy, CreateIterResultObject = _require.CreateIterResultObject, IsFiniteNonNegativeNumber = _require.IsFiniteNonNegativeNumber, InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, SameRealmTransfer = _require.SameRealmTransfer, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark = _require.ValidateAndNormalizeHighWaterMark, _require2 = require2("./helpers.js"), createArrayFromList = _require2.createArrayFromList, createDataProperty = _require2.createDataProperty, typeIsObject = _require2.typeIsObject, _require3 = require2("./utils.js"), rethrowAssertionErrorRejection = _require3.rethrowAssertionErrorRejection, _require4 = require2("./queue-with-sizes.js"), DequeueValue = _require4.DequeueValue, EnqueueValueWithSize = _require4.EnqueueValueWithSize, GetTotalQueueSize = _require4.GetTotalQueueSize, InternalCancel = Symbol("[[Cancel]]"), InternalPull = Symbol("[[Pull]]"), ReadableStream = function() {
            function ReadableStream2() {
              var underlyingSource = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], size2 = _ref.size, highWaterMark = _ref.highWaterMark;
              _classCallCheck(this, ReadableStream2), this._state = "readable", this._reader = void 0, this._storedError = void 0, this._disturbed = false, this._readableStreamController = void 0;
              var type2 = underlyingSource.type, typeString = String(type2);
              if ("bytes" === typeString)
                void 0 === highWaterMark && (highWaterMark = 0), this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
              else {
                if (void 0 !== type2)
                  throw new RangeError("Invalid type is specified");
                void 0 === highWaterMark && (highWaterMark = 1), this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size2, highWaterMark);
              }
            }
            return _createClass(ReadableStream2, [{ key: "cancel", value: function(reason) {
              return IsReadableStream(this) === false ? Promise.reject(new TypeError("ReadableStream.prototype.cancel can only be used on a ReadableStream")) : IsReadableStreamLocked(this) === true ? Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")) : ReadableStreamCancel(this, reason);
            } }, { key: "getReader", value: function() {
              var _ref2 = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], mode = _ref2.mode;
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.getReader can only be used on a ReadableStream");
              if ("byob" === mode) {
                if (IsReadableByteStreamController(this._readableStreamController) === false)
                  throw new TypeError("Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source");
                return AcquireReadableStreamBYOBReader(this);
              }
              if (void 0 === mode)
                return AcquireReadableStreamDefaultReader(this);
              throw new RangeError("Invalid mode is specified");
            } }, { key: "pipeThrough", value: function(_ref3, options2) {
              var writable = _ref3.writable, readable = _ref3.readable;
              return this.pipeTo(writable, options2), readable;
            } }, { key: "pipeTo", value: function(dest) {
              function doPipe() {
                lastRead = reader.read(), Promise.all([lastRead, dest.ready]).then(function(_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 1), _ref6$ = _ref6[0], value = _ref6$.value, done = _ref6$.done;
                  Boolean(done) === true ? closeDest() : "writable" === dest.state && (lastWrite = dest.write(value), doPipe());
                }).catch(rethrowAssertionErrorRejection);
              }
              function cancelSource(reason) {
                preventCancel === false ? (reader.cancel(reason), reader.releaseLock(), rejectPipeToPromise(reason)) : lastRead.then(function() {
                  reader.releaseLock(), rejectPipeToPromise(reason);
                });
              }
              function closeDest() {
                reader.releaseLock();
                var destState = dest.state;
                preventClose !== false || "waiting" !== destState && "writable" !== destState ? void 0 !== lastWrite ? lastWrite.then(resolvePipeToPromise, rejectPipeToPromise) : resolvePipeToPromise() : (closedPurposefully = true, dest.close().then(resolvePipeToPromise, rejectPipeToPromise));
              }
              function abortDest(reason) {
                reader.releaseLock(), preventAbort === false && dest.abort(reason), rejectPipeToPromise(reason);
              }
              var _ref4 = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], preventClose = _ref4.preventClose, preventAbort = _ref4.preventAbort, preventCancel = _ref4.preventCancel;
              preventClose = Boolean(preventClose), preventAbort = Boolean(preventAbort), preventCancel = Boolean(preventCancel);
              var source = this, reader = void 0, lastRead = void 0, lastWrite = void 0, closedPurposefully = false, resolvePipeToPromise = void 0, rejectPipeToPromise = void 0;
              return new Promise(function(resolve, reject) {
                resolvePipeToPromise = resolve, rejectPipeToPromise = reject, reader = source.getReader(), reader.closed.catch(abortDest), dest.closed.then(function() {
                  closedPurposefully || cancelSource(new TypeError("destination is closing or closed and cannot be piped to anymore"));
                }, cancelSource), doPipe();
              });
            } }, { key: "tee", value: function() {
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.tee can only be used on a ReadableStream");
              var branches = ReadableStreamTee(this, false);
              return createArrayFromList(branches);
            } }, { key: "locked", get: function() {
              if (IsReadableStream(this) === false)
                throw new TypeError("ReadableStream.prototype.locked can only be used on a ReadableStream");
              return IsReadableStreamLocked(this);
            } }]), ReadableStream2;
          }();
          exports3.ReadableStream = ReadableStream, exports3.IsReadableStreamDisturbed = IsReadableStreamDisturbed;
          var ReadableStreamDefaultReader = function() {
            function ReadableStreamDefaultReader2(stream) {
              if (_classCallCheck(this, ReadableStreamDefaultReader2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
              if (IsReadableStreamLocked(stream) === true)
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              ReadableStreamReaderGenericInitialize(this, stream), this._readRequests = [];
            }
            return _createClass(ReadableStreamDefaultReader2, [{ key: "cancel", value: function(reason) {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : ReadableStreamReaderGenericCancel(this, reason);
            } }, { key: "read", value: function() {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : ReadableStreamDefaultReaderRead(this);
            } }, { key: "releaseLock", value: function() {
              if (IsReadableStreamDefaultReader(this) === false)
                throw new TypeError("ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader");
              if (void 0 !== this._ownerReadableStream) {
                if (this._readRequests.length > 0)
                  throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                ReadableStreamReaderGenericRelease(this);
              }
            } }, { key: "closed", get: function() {
              return IsReadableStreamDefaultReader(this) === false ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader")) : this._closedPromise;
            } }]), ReadableStreamDefaultReader2;
          }(), ReadableStreamBYOBReader = function() {
            function ReadableStreamBYOBReader2(stream) {
              if (_classCallCheck(this, ReadableStreamBYOBReader2), !IsReadableStream(stream))
                throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
              if (IsReadableStreamLocked(stream))
                throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              ReadableStreamReaderGenericInitialize(this, stream), this._readIntoRequests = [];
            }
            return _createClass(ReadableStreamBYOBReader2, [{ key: "cancel", value: function(reason) {
              return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : ReadableStreamReaderGenericCancel(this, reason) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader"));
            } }, { key: "read", value: function(view) {
              return IsReadableStreamBYOBReader(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : ArrayBuffer.isView(view) ? 0 === view.byteLength ? Promise.reject(new TypeError("view must have non-zero byteLength")) : ReadableStreamBYOBReaderRead(this, view) : Promise.reject(new TypeError("view must be an array buffer view")) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader"));
            } }, { key: "releaseLock", value: function() {
              if (!IsReadableStreamBYOBReader(this))
                throw new TypeError("ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader");
              if (void 0 !== this._ownerReadableStream) {
                if (this._readIntoRequests.length > 0)
                  throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                ReadableStreamReaderGenericRelease(this);
              }
            } }, { key: "closed", get: function() {
              return IsReadableStreamBYOBReader(this) ? this._closedPromise : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader"));
            } }]), ReadableStreamBYOBReader2;
          }(), ReadableStreamDefaultController = function() {
            function ReadableStreamDefaultController2(stream, underlyingSource, size2, highWaterMark) {
              if (_classCallCheck(this, ReadableStreamDefaultController2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance");
              if (void 0 !== stream._readableStreamController)
                throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor");
              this._controlledReadableStream = stream, this._underlyingSource = underlyingSource, this._queue = [], this._started = false, this._closeRequested = false, this._pullAgain = false, this._pulling = false;
              var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size2, highWaterMark);
              this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark;
              var controller = this, startResult = InvokeOrNoop(underlyingSource, "start", [this]);
              Promise.resolve(startResult).then(function() {
                controller._started = true, ReadableStreamDefaultControllerCallPullIfNeeded(controller);
              }, function(r) {
                "readable" === stream._state && ReadableStreamDefaultControllerError(controller, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(ReadableStreamDefaultController2, [{ key: "close", value: function() {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController");
              if (this._closeRequested === true)
                throw new TypeError("The stream has already been closed; do not close it again!");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be closed");
              ReadableStreamDefaultControllerClose(this);
            } }, { key: "enqueue", value: function(chunk) {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController");
              if (this._closeRequested === true)
                throw new TypeError("stream is closed or draining");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be enqueued to");
              return ReadableStreamDefaultControllerEnqueue(this, chunk);
            } }, { key: "error", value: function(e2) {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController");
              var stream = this._controlledReadableStream;
              if ("readable" !== stream._state)
                throw new TypeError("The stream is " + stream._state + " and so cannot be errored");
              ReadableStreamDefaultControllerError(this, e2);
            } }, { key: InternalCancel, value: function(reason) {
              return this._queue = [], PromiseInvokeOrNoop(this._underlyingSource, "cancel", [reason]);
            } }, { key: InternalPull, value: function() {
              var stream = this._controlledReadableStream;
              if (this._queue.length > 0) {
                var chunk = DequeueValue(this._queue);
                return this._closeRequested === true && 0 === this._queue.length ? ReadableStreamClose(stream) : ReadableStreamDefaultControllerCallPullIfNeeded(this), Promise.resolve(CreateIterResultObject(chunk, false));
              }
              var pendingPromise = ReadableStreamAddReadRequest(stream);
              return ReadableStreamDefaultControllerCallPullIfNeeded(this), pendingPromise;
            } }, { key: "desiredSize", get: function() {
              if (IsReadableStreamDefaultController(this) === false)
                throw new TypeError("ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController");
              return ReadableStreamDefaultControllerGetDesiredSize(this);
            } }]), ReadableStreamDefaultController2;
          }(), ReadableStreamBYOBRequest = function() {
            function ReadableStreamBYOBRequest2(controller, view) {
              _classCallCheck(this, ReadableStreamBYOBRequest2), this._associatedReadableByteStreamController = controller, this._view = view;
            }
            return _createClass(ReadableStreamBYOBRequest2, [{ key: "respond", value: function(bytesWritten) {
              if (IsReadableStreamBYOBRequest(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController");
              if (void 0 === this._associatedReadableByteStreamController)
                throw new TypeError("This BYOB request has been invalidated");
              ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
            } }, { key: "respondWithNewView", value: function(view) {
              if (IsReadableStreamBYOBRequest(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController");
              if (void 0 === this._associatedReadableByteStreamController)
                throw new TypeError("This BYOB request has been invalidated");
              if (!ArrayBuffer.isView(view))
                throw new TypeError("You can only respond with array buffer views");
              ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
            } }, { key: "view", get: function() {
              return this._view;
            } }]), ReadableStreamBYOBRequest2;
          }(), ReadableByteStreamController = function() {
            function ReadableByteStreamController2(stream, underlyingByteSource, highWaterMark) {
              if (_classCallCheck(this, ReadableByteStreamController2), IsReadableStream(stream) === false)
                throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableStream instance given a byte source");
              if (void 0 !== stream._readableStreamController)
                throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte source");
              this._controlledReadableStream = stream, this._underlyingByteSource = underlyingByteSource, this._pullAgain = false, this._pulling = false, ReadableByteStreamControllerClearPendingPullIntos(this), this._queue = [], this._totalQueuedBytes = 0, this._closeRequested = false, this._started = false, this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);
              var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
              if (void 0 !== autoAllocateChunkSize && (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize < 0))
                throw new RangeError("autoAllocateChunkSize must be a non negative integer");
              this._autoAllocateChunkSize = autoAllocateChunkSize, this._pendingPullIntos = [];
              var controller = this, startResult = InvokeOrNoop(underlyingByteSource, "start", [this]);
              Promise.resolve(startResult).then(function() {
                controller._started = true, assert(controller._pulling === false), assert(controller._pullAgain === false), ReadableByteStreamControllerCallPullIfNeeded(controller);
              }, function(r) {
                "readable" === stream._state && ReadableByteStreamControllerError(controller, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(ReadableByteStreamController2, [{ key: "close", value: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController");
              if (this._closeRequested === true)
                throw new TypeError("The stream has already been closed; do not close it again!");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be closed");
              ReadableByteStreamControllerClose(this);
            } }, { key: "enqueue", value: function(chunk) {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController");
              if (this._closeRequested === true)
                throw new TypeError("stream is closed or draining");
              var state3 = this._controlledReadableStream._state;
              if ("readable" !== state3)
                throw new TypeError("The stream (in " + state3 + " state) is not in the readable state and cannot be enqueued to");
              if (!ArrayBuffer.isView(chunk))
                throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
              ReadableByteStreamControllerEnqueue(this, chunk);
            } }, { key: "error", value: function(e2) {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController");
              var stream = this._controlledReadableStream;
              if ("readable" !== stream._state)
                throw new TypeError("The stream is " + stream._state + " and so cannot be errored");
              ReadableByteStreamControllerError(this, e2);
            } }, { key: InternalCancel, value: function(reason) {
              if (this._pendingPullIntos.length > 0) {
                var firstDescriptor = this._pendingPullIntos[0];
                firstDescriptor.bytesFilled = 0;
              }
              return this._queue = [], this._totalQueuedBytes = 0, PromiseInvokeOrNoop(this._underlyingByteSource, "cancel", [reason]);
            } }, { key: InternalPull, value: function() {
              var stream = this._controlledReadableStream;
              if (0 === ReadableStreamGetNumReadRequests(stream)) {
                if (this._totalQueuedBytes > 0) {
                  var entry = this._queue.shift();
                  this._totalQueuedBytes -= entry.byteLength, ReadableByteStreamControllerHandleQueueDrain(this);
                  var view = void 0;
                  try {
                    view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
                  } catch (viewE) {
                    return Promise.reject(viewE);
                  }
                  return Promise.resolve(CreateIterResultObject(view, false));
                }
                var autoAllocateChunkSize = this._autoAllocateChunkSize;
                if (void 0 !== autoAllocateChunkSize) {
                  var buffer = void 0;
                  try {
                    buffer = new ArrayBuffer(autoAllocateChunkSize);
                  } catch (bufferE) {
                    return Promise.reject(bufferE);
                  }
                  var pullIntoDescriptor = { buffer, byteOffset: 0, byteLength: autoAllocateChunkSize, bytesFilled: 0, elementSize: 1, ctor: Uint8Array, readerType: "default" };
                  this._pendingPullIntos.push(pullIntoDescriptor);
                }
              } else
                assert(void 0 === this._autoAllocateChunkSize);
              var promise = ReadableStreamAddReadRequest(stream);
              return ReadableByteStreamControllerCallPullIfNeeded(this), promise;
            } }, { key: "byobRequest", get: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.byobRequest can only be used on a ReadableByteStreamController");
              if (void 0 === this._byobRequest && this._pendingPullIntos.length > 0) {
                var firstDescriptor = this._pendingPullIntos[0], view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
                this._byobRequest = new ReadableStreamBYOBRequest(this, view);
              }
              return this._byobRequest;
            } }, { key: "desiredSize", get: function() {
              if (IsReadableByteStreamController(this) === false)
                throw new TypeError("ReadableByteStreamController.prototype.desiredSize can only be used on a ReadableByteStreamController");
              return ReadableByteStreamControllerGetDesiredSize(this);
            } }]), ReadableByteStreamController2;
          }();
        }, { "./helpers.js": 9, "./queue-with-sizes.js": 10, "./utils.js": 13, assert: 2 }], 12: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          var _require = require2("./readable-stream.js"), ReadableStream = _require.ReadableStream, _require2 = require2("./writable-stream.js"), WritableStream = _require2.WritableStream;
          module4.exports = function TransformStream(transformer) {
            function maybeDoTransform() {
              if (transforming === false) {
                transforming = true;
                try {
                  transformer.transform(writeChunk, enqueueInReadable, transformDone), writeChunk = void 0, chunkWrittenButNotYetTransformed = false;
                } catch (e2) {
                  transforming = false, errorWritable(e2), errorReadable(e2);
                }
              }
            }
            function transformDone() {
              transforming = false, writeDone();
            }
            if (_classCallCheck(this, TransformStream), void 0 === transformer.flush && (transformer.flush = function(enqueue, close) {
              return close();
            }), "function" != typeof transformer.transform)
              throw new TypeError("transform must be a function");
            var writeChunk = void 0, writeDone = void 0, errorWritable = void 0, transforming = false, chunkWrittenButNotYetTransformed = false;
            this.writable = new WritableStream({ start: function(error) {
              errorWritable = error;
            }, write: function(chunk) {
              writeChunk = chunk, chunkWrittenButNotYetTransformed = true;
              var p2 = new Promise(function(resolve) {
                return writeDone = resolve;
              });
              return maybeDoTransform(), p2;
            }, close: function() {
              try {
                transformer.flush(enqueueInReadable, closeReadable);
              } catch (e2) {
                errorWritable(e2), errorReadable(e2);
              }
            } }, transformer.writableStrategy);
            var enqueueInReadable = void 0, closeReadable = void 0, errorReadable = void 0;
            this.readable = new ReadableStream({ start: function(c4) {
              enqueueInReadable = c4.enqueue.bind(c4), closeReadable = c4.close.bind(c4), errorReadable = c4.error.bind(c4);
            }, pull: function() {
              chunkWrittenButNotYetTransformed === true && maybeDoTransform();
            } }, transformer.readableStrategy);
          };
        }, { "./readable-stream.js": 11, "./writable-stream.js": 14 }], 13: [function(require2, module4, exports3) {
          "use strict";
          var assert = require2("assert");
          exports3.rethrowAssertionErrorRejection = function(e2) {
            e2 && e2.constructor === assert.AssertionError && setTimeout(function() {
              throw e2;
            }, 0);
          };
        }, { assert: 2 }], 14: [function(require2, module4, exports3) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          function closure_WritableStreamErrorFunction() {
            var f = function f2(e2) {
              return ErrorWritableStream(f2._stream, e2);
            };
            return f;
          }
          function CallOrScheduleWritableStreamAdvanceQueue(stream) {
            return stream._started === false ? void stream._startedPromise.then(function() {
              WritableStreamAdvanceQueue(stream);
            }).catch(rethrowAssertionErrorRejection) : stream._started === true ? WritableStreamAdvanceQueue(stream) : void 0;
          }
          function CloseWritableStream(stream) {
            assert("closing" === stream._state, "stream must be in closing state while calling CloseWritableStream");
            var sinkClosePromise = PromiseInvokeOrNoop(stream._underlyingSink, "close");
            sinkClosePromise.then(function() {
              "errored" !== stream._state && (assert("closing" === stream._state), stream._closedPromise_resolve(void 0), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = "closed");
            }, function(r) {
              return ErrorWritableStream(stream, r);
            }).catch(rethrowAssertionErrorRejection);
          }
          function ErrorWritableStream(stream, e2) {
            if ("closed" !== stream._state && "errored" !== stream._state) {
              for (; stream._queue.length > 0; ) {
                var writeRecord = DequeueValue(stream._queue);
                "close" !== writeRecord && writeRecord._reject(e2);
              }
              stream._storedError = e2, "waiting" === stream._state && stream._readyPromise_resolve(void 0), stream._closedPromise_reject(e2), stream._closedPromise_resolve = void 0, stream._closedPromise_reject = void 0, stream._state = "errored";
            }
          }
          function IsWritableStream(x) {
            return !!typeIsObject(x) && !!Object.prototype.hasOwnProperty.call(x, "_underlyingSink");
          }
          function SyncWritableStreamStateWithQueue(stream) {
            if ("closing" !== stream._state) {
              assert("writable" === stream._state || "waiting" === stream._state, "stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue");
              var queueSize = GetTotalQueueSize(stream._queue), shouldApplyBackpressure = queueSize > stream._strategyHWM;
              shouldApplyBackpressure === true && "writable" === stream._state && (stream._state = "waiting", stream._readyPromise = new Promise(function(resolve, reject) {
                stream._readyPromise_resolve = resolve;
              })), shouldApplyBackpressure === false && "waiting" === stream._state && (stream._state = "writable", stream._readyPromise_resolve(void 0));
            }
          }
          function WritableStreamAdvanceQueue(stream) {
            if (0 !== stream._queue.length && stream._writing !== true) {
              var writeRecord = PeekQueueValue(stream._queue);
              return "close" === writeRecord ? (assert("closing" === stream._state, "can't process final write record unless already closing"), DequeueValue(stream._queue), assert(0 === stream._queue.length, "queue must be empty once the final write record is dequeued"), CloseWritableStream(stream)) : (stream._writing = true, void PromiseInvokeOrNoop(stream._underlyingSink, "write", [writeRecord.chunk]).then(function() {
                "errored" !== stream._state && (stream._writing = false, writeRecord._resolve(void 0), DequeueValue(stream._queue), SyncWritableStreamStateWithQueue(stream), WritableStreamAdvanceQueue(stream));
              }, function(r) {
                return ErrorWritableStream(stream, r);
              }).catch(rethrowAssertionErrorRejection));
            }
          }
          var _createClass = function() {
            function defineProperties(target, props) {
              for (var i2 = 0; i2 < props.length; i2++) {
                var descriptor = props[i2];
                descriptor.enumerable = descriptor.enumerable || false, descriptor.configurable = true, "value" in descriptor && (descriptor.writable = true), Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function(Constructor, protoProps, staticProps) {
              return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor;
            };
          }(), assert = require2("assert"), _require = require2("./helpers.js"), InvokeOrNoop = _require.InvokeOrNoop, PromiseInvokeOrNoop = _require.PromiseInvokeOrNoop, PromiseInvokeOrFallbackOrNoop = _require.PromiseInvokeOrFallbackOrNoop, ValidateAndNormalizeQueuingStrategy = _require.ValidateAndNormalizeQueuingStrategy, typeIsObject = _require.typeIsObject, _require2 = require2("./utils.js"), rethrowAssertionErrorRejection = _require2.rethrowAssertionErrorRejection, _require3 = require2("./queue-with-sizes.js"), DequeueValue = _require3.DequeueValue, EnqueueValueWithSize = _require3.EnqueueValueWithSize, GetTotalQueueSize = _require3.GetTotalQueueSize, PeekQueueValue = _require3.PeekQueueValue, WritableStream = (require2("./count-queuing-strategy.js"), function() {
            function WritableStream2() {
              var _this = this, underlyingSink = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], _ref = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], size2 = _ref.size, _ref$highWaterMark = _ref.highWaterMark, highWaterMark = void 0 === _ref$highWaterMark ? 0 : _ref$highWaterMark;
              _classCallCheck(this, WritableStream2), this._underlyingSink = underlyingSink, this._closedPromise = new Promise(function(resolve, reject) {
                _this._closedPromise_resolve = resolve, _this._closedPromise_reject = reject;
              }), this._readyPromise = Promise.resolve(void 0), this._readyPromise_resolve = null, this._queue = [], this._state = "writable", this._started = false, this._writing = false;
              var normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size2, highWaterMark);
              this._strategySize = normalizedStrategy.size, this._strategyHWM = normalizedStrategy.highWaterMark, SyncWritableStreamStateWithQueue(this);
              var error = closure_WritableStreamErrorFunction();
              error._stream = this;
              var startResult = InvokeOrNoop(underlyingSink, "start", [error]);
              this._startedPromise = Promise.resolve(startResult), this._startedPromise.then(function() {
                _this._started = true, _this._startedPromise = void 0;
              }), this._startedPromise.catch(function(r) {
                return ErrorWritableStream(_this, r);
              }).catch(rethrowAssertionErrorRejection);
            }
            return _createClass(WritableStream2, [{ key: "abort", value: function(reason) {
              if (!IsWritableStream(this))
                return Promise.reject(new TypeError("WritableStream.prototype.abort can only be used on a WritableStream"));
              if ("closed" === this._state)
                return Promise.resolve(void 0);
              if ("errored" === this._state)
                return Promise.reject(this._storedError);
              ErrorWritableStream(this, reason);
              var sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(this._underlyingSink, "abort", [reason], "close", []);
              return sinkAbortPromise.then(function() {
              });
            } }, { key: "close", value: function() {
              return IsWritableStream(this) ? "closing" === this._state ? Promise.reject(new TypeError("cannot close an already-closing stream")) : "closed" === this._state ? Promise.reject(new TypeError("cannot close an already-closed stream")) : "errored" === this._state ? Promise.reject(this._storedError) : ("waiting" === this._state && this._readyPromise_resolve(void 0), this._state = "closing", EnqueueValueWithSize(this._queue, "close", 0), CallOrScheduleWritableStreamAdvanceQueue(this), this._closedPromise) : Promise.reject(new TypeError("WritableStream.prototype.close can only be used on a WritableStream"));
            } }, { key: "write", value: function(chunk) {
              if (!IsWritableStream(this))
                return Promise.reject(new TypeError("WritableStream.prototype.write can only be used on a WritableStream"));
              if ("closing" === this._state)
                return Promise.reject(new TypeError("cannot write while stream is closing"));
              if ("closed" === this._state)
                return Promise.reject(new TypeError("cannot write after stream is closed"));
              if ("errored" === this._state)
                return Promise.reject(this._storedError);
              assert("waiting" === this._state || "writable" === this._state);
              var chunkSize = 1;
              if (void 0 !== this._strategySize)
                try {
                  chunkSize = this._strategySize(chunk);
                } catch (chunkSizeE) {
                  return ErrorWritableStream(this, chunkSizeE), Promise.reject(chunkSizeE);
                }
              var resolver = void 0, rejecter = void 0, promise = new Promise(function(resolve, reject) {
                resolver = resolve, rejecter = reject;
              }), writeRecord = { promise, chunk, _resolve: resolver, _reject: rejecter };
              try {
                EnqueueValueWithSize(this._queue, writeRecord, chunkSize);
              } catch (enqueueResultE) {
                return ErrorWritableStream(this, enqueueResultE), Promise.reject(enqueueResultE);
              }
              return SyncWritableStreamStateWithQueue(this), CallOrScheduleWritableStreamAdvanceQueue(this), promise;
            } }, { key: "closed", get: function() {
              return IsWritableStream(this) ? this._closedPromise : Promise.reject(new TypeError("WritableStream.prototype.closed can only be used on a WritableStream"));
            } }, { key: "state", get: function() {
              if (!IsWritableStream(this))
                throw new TypeError("WritableStream.prototype.state can only be used on a WritableStream");
              return this._state;
            } }, { key: "ready", get: function() {
              return IsWritableStream(this) ? this._readyPromise : Promise.reject(new TypeError("WritableStream.prototype.ready can only be used on a WritableStream"));
            } }]), WritableStream2;
          }());
          exports3.WritableStream = WritableStream, exports3.IsWritableStream = IsWritableStream;
        }, { "./count-queuing-strategy.js": 8, "./helpers.js": 9, "./queue-with-sizes.js": 10, "./utils.js": 13, assert: 2 }] }, {}, [1])(1);
      });
    }
  });

  // node_modules/node-web-streams/lib/conversions.js
  var require_conversions = __commonJS({
    "node_modules/node-web-streams/lib/conversions.js"(exports2, module3) {
      "use strict";
      var Readable = require_stream().Readable;
      var ReadableStream = require_polyfill_min().ReadableStream;
      function readableNodeToWeb(nodeStream) {
        return new ReadableStream({
          start(controller) {
            nodeStream.pause();
            nodeStream.on("data", (chunk) => {
              controller.enqueue(chunk);
              nodeStream.pause();
            });
            nodeStream.on("end", () => controller.close());
            nodeStream.on("error", (e2) => controller.error(e2));
          },
          pull(controller) {
            nodeStream.resume();
          },
          cancel(reason) {
            nodeStream.pause();
          }
        });
      }
      function arrayToWeb(arr) {
        return new ReadableStream({
          start(controller) {
            for (var i2 = 0; i2 < arr.length; i2++) {
              controller.enqueue(arr[i2]);
            }
            controller.close();
          }
        });
      }
      var NodeReadable = class extends Readable {
        constructor(webStream, options2) {
          super(options2);
          this._webStream = webStream;
          this._reader = webStream.getReader();
          this._reading = false;
        }
        _read(size2) {
          if (this._reading) {
            return;
          }
          this._reading = true;
          const doRead = () => {
            this._reader.read().then((res) => {
              if (res.done) {
                this.push(null);
                return;
              }
              if (this.push(res.value)) {
                return doRead(size2);
              } else {
                this._reading = false;
              }
            });
          };
          doRead();
        }
      };
      function readableWebToNode(webStream) {
        return new NodeReadable(webStream);
      }
      module3.exports = {
        readable: {
          nodeToWeb: readableNodeToWeb,
          arrayToWeb,
          webToNode: readableWebToNode
        }
      };
    }
  });

  // node_modules/node-web-streams/index.js
  var require_node_web_streams = __commonJS({
    "node_modules/node-web-streams/index.js"(exports2, module3) {
      "use strict";
      var nodeStream = require_stream();
      var isNodeStream = require_is_stream();
      var conversions = require_conversions();
      module3.exports = require_polyfill_min();
      module3.exports.toNodeReadable = function(stream) {
        if (stream instanceof module3.exports.ReadableStream || stream && typeof stream.getReader === "function") {
          return conversions.readable.webToNode(stream);
        } else {
          throw new TypeError("Expected a ReadableStream.");
        }
      };
      module3.exports.toWebReadableStream = function(stream) {
        if (isNodeStream(stream) && stream.readable) {
          return conversions.readable.nodeToWeb(stream);
        } else if (Array.isArray(stream)) {
          return conversions.readable.arrayToWeb(stream);
        } else if (Buffer.isBuffer(stream) || typeof stream === "string") {
          return conversions.readable.arrayToWeb([stream]);
        } else {
          throw new TypeError("Expected a Node streams.Readable, an Array, Buffer or String.");
        }
      };
    }
  });

  // public/statebus/braidify-client.js
  var require_braidify_client = __commonJS({
    "public/statebus/braidify-client.js"(exports2, module3) {
      var peer = Math.random().toString(36).substr(2);
      function braidify_http(http) {
        http.normal_get = http.get;
        http.get = function braid_req(arg1, arg2, arg3) {
          var url, options2, cb;
          if (typeof arg1 === "string" || arg1 instanceof URL) {
            url = arg1;
            if (typeof arg2 === "function")
              cb = arg2;
            else {
              options2 = arg2;
              cb = arg3;
            }
          } else {
            options2 = arg2;
            cb = arg3;
          }
          options2 = options2 || {};
          if (!options2.headers)
            options2.headers = {};
          if (options2.subscribe)
            options2.headers.subscribe = "true";
          options2.headers.peer = options2.headers.peer || peer;
          var on_version, on_error, orig_cb = cb;
          cb = (res) => {
            res.orig_on = res.on;
            res.on = (key2, f) => {
              if (key2 === "version") {
                on_version = f;
                var parser = subscription_parser((version, error) => {
                  if (!error)
                    on_version && on_version(version);
                  else
                    on_error && on_error(error);
                });
                res.orig_on("data", (chunk) => {
                  parser.read(chunk.toString());
                });
              } else if (key2 === "error") {
                on_error = f;
                res.orig_on(key2, f);
              } else
                res.orig_on(key2, f);
            };
            orig_cb && orig_cb(res);
          };
          if (url) {
            arg1 = url;
            if (options2) {
              arg2 = options2;
              arg3 = cb;
            } else {
              arg2 = cb;
            }
          } else {
            arg1 = options2;
            arg2 = cb;
          }
          return http.normal_get(arg1, arg2, arg3);
        };
        return http;
      }
      var normal_fetch;
      var AbortController2;
      var Headers;
      var is_nodejs = typeof window === "undefined";
      if (is_nodejs) {
        normal_fetch = require_browser();
        AbortController2 = require_browser2();
        Headers = normal_fetch.Headers;
        to_whatwg_stream = require_node_web_streams().toWebReadableStream;
      } else {
        normal_fetch = window.fetch;
        AbortController2 = window.AbortController;
        Headers = window.Headers;
        window.fetch = braid_fetch2;
      }
      var to_whatwg_stream;
      function braid_fetch2(url, params = {}) {
        if (!params.headers)
          params.headers = new Headers();
        if (!(params.headers instanceof Headers))
          params.headers = new Headers(params.headers);
        if (params.version)
          params.headers.set("version", JSON.stringify(params.version));
        if (params.parents)
          params.headers.set("parents", params.parents.map(JSON.stringify).join(", "));
        if (params.subscribe)
          params.headers.set("subscribe", "true");
        params.cache = "no-cache";
        if (params.patches) {
          console.assert(Array.isArray(params.patches), "Patches must be array");
          console.assert(!params.body, "Cannot send both patches and body");
          params.patches = params.patches || [];
          params.headers.set("patches", params.patches.length);
          params.body = params.patches.map((patch) => {
            var length = `content-length: ${patch.content.length}`;
            var range2 = `content-range: ${patch.unit} ${patch.range}`;
            return `${length}\r
${range2}\r
\r
${patch.content}\r
`;
          }).join("\r\n");
        }
        var original_signal = params.signal;
        var underlying_aborter = new AbortController2();
        params.signal = underlying_aborter.signal;
        if (original_signal)
          original_signal.addEventListener(
            "abort",
            () => underlying_aborter.abort()
          );
        var andThen, iterator;
        var promise = new Promise((resolve, reject) => {
          var fetched = normal_fetch(url, params);
          function start_subscription(cb, error) {
            fetched.then(function(res) {
              if (!res.ok)
                error(new Error("Subscription request failed", res));
              handle_fetch_stream(
                res.body,
                (result, err) => {
                  if (!err)
                    cb(result);
                  else {
                    underlying_aborter.abort();
                    error(err);
                  }
                }
              );
            }).catch(error);
          }
          if (params.subscribe) {
            andThen = (cb) => {
              start_subscription(cb, reject);
              return promise;
            };
            iterator = () => ({
              initialized: false,
              resolve: null,
              reject: null,
              async next() {
                if (!this.initialized) {
                  this.initialized = true;
                  start_subscription(
                    (x) => this.resolve(x),
                    (x) => this.reject(x)
                  );
                }
                var result = await new Promise((resolve2, reject2) => {
                  this.resolve = resolve2;
                  this.reject = reject2;
                });
                var tellme = "Error! Please tell toomim@gmail.com that this happened.";
                this.resolve = () => {
                  throw tellme;
                };
                this.reject = () => {
                  throw tellme;
                };
                return { done: false, value: result };
              }
            });
          } else
            fetched.then(resolve).catch(reject);
        });
        promise.andThen = andThen;
        promise[Symbol.asyncIterator] = iterator;
        return promise;
      }
      async function handle_fetch_stream(stream, cb) {
        if (is_nodejs)
          stream = to_whatwg_stream(stream);
        var reader = stream.getReader(), decoder = new TextDecoder("utf-8"), parser = subscription_parser(cb);
        while (true) {
          var versions2 = [];
          try {
            var { done, value } = await reader.read();
            if (done) {
              console.debug("Connection closed.");
              cb(null, "Connection closed");
              return;
            }
            parser.read(decoder.decode(value));
          } catch (e2) {
            cb(null, e2);
            return;
          }
        }
      }
      var subscription_parser = (cb) => ({
        state: { input: "" },
        cb,
        read(input) {
          this.state.input += input;
          do {
            this.state = parse_version(this.state);
            if (this.state.result === "success") {
              this.cb({
                version: this.state.version,
                parents: this.state.parents,
                body: this.state.body,
                patches: this.state.patches
              });
              this.state = { input: this.state.input };
            } else if (this.state.result === "error") {
              this.cb(null, this.state.message);
              return;
            }
          } while (this.state.result !== "waiting" && this.state.input.trim() !== "");
        }
      });
      function parse_version(state3) {
        if (!state3.headers) {
          var parsed = parse_headers(state3.input);
          if (parsed.result === "error")
            return parsed;
          if (parsed.result === "waiting") {
            state3.result = "waiting";
            return state3;
          }
          state3.headers = parsed.headers;
          state3.version = state3.headers.version;
          state3.parents = state3.headers.parents;
          state3.input = parsed.input;
        }
        return parse_body(state3);
      }
      function swallow_blank_lines(input) {
        var blank_lines = /(\r\n|\n)*/.exec(input)[0];
        return input.substr(blank_lines.length);
      }
      function parse_headers(input) {
        input = swallow_blank_lines(input);
        var headers_end = input.match(/(\r?\n)\r?\n/);
        if (!headers_end)
          return { result: "waiting" };
        var headers_length = headers_end.index + headers_end[1].length, headers_source = input.substring(0, headers_length);
        var headers = {}, header_regex = /([\w-_]+):\s?(.*)\r?\n/gy, match, found_last_match = false;
        while (match = header_regex.exec(headers_source)) {
          headers[match[1].toLowerCase()] = match[2];
          if (header_regex.lastIndex === headers_length)
            found_last_match = true;
        }
        if (!found_last_match)
          return {
            result: "error",
            message: 'Parse error in headers: "' + JSON.stringify(headers_source.substr(header_regex.lastIndex)) + '"',
            headers_so_far: headers,
            last_index: header_regex.lastIndex,
            headers_length
          };
        if ("version" in headers)
          headers.version = JSON.parse(headers.version);
        if ("parents" in headers)
          headers.parents = JSON.parse("[" + headers.parents + "]");
        if ("patches" in headers)
          headers.patches = JSON.parse(headers.patches);
        input = input.substring(headers_length);
        if (input.substr(0, 2) === "\r\n")
          input = input.substr(2);
        else
          input = input.substr(1);
        return { result: "success", headers, input };
      }
      function parse_body(state3) {
        var content_length = parseInt(state3.headers["content-length"]);
        if (content_length !== NaN) {
          if (content_length > state3.input.length) {
            state3.result = "waiting";
            return state3;
          }
          var consumed_length = content_length + 2;
          state3.result = "success";
          state3.body = state3.input.substring(0, content_length);
          state3.input = state3.input.substring(consumed_length);
          return state3;
        } else if (state3.headers.patches) {
          state3.patches = state3.patches || [];
          var last_patch = state3.patches[state3.patches.length - 1];
          while (!(state3.patches.length === state3.headers.patches && "content" in last_patch)) {
            state3.input = state3.input.trimStart();
            if (!last_patch || "content" in last_patch) {
              last_patch = {};
              state3.patches.push(last_patch);
            }
            if (!("headers" in last_patch)) {
              var parsed = parse_headers(state3.input);
              if (parsed.result === "error")
                return parsed;
              if (parsed.result === "waiting") {
                state3.result = "waiting";
                return state3;
              }
              last_patch.headers = parsed.headers;
              state3.input = parsed.input;
            }
            {
              if (!("content-length" in last_patch.headers))
                return {
                  result: "error",
                  message: "no content-length in patch",
                  patch: last_patch,
                  input: state3.input
                };
              if (!("content-range" in last_patch.headers))
                return {
                  result: "error",
                  message: "no content-range in patch",
                  patch: last_patch,
                  input: state3.input
                };
              var content_length = parseInt(last_patch.headers["content-length"]);
              if (state3.input.length < content_length) {
                state3.result = "waiting";
                return state3;
              }
              var match = last_patch.headers["content-range"].match(/(\S+) (.*)/);
              if (!match)
                return {
                  result: "error",
                  message: "cannot parse content-range in patch",
                  patch: last_patch,
                  input: state3.input
                };
              last_patch.unit = match[1];
              last_patch.range = match[2];
              last_patch.content = state3.input.substr(0, content_length);
              state3.input = state3.input.substring(content_length);
            }
          }
          state3.result = "success";
          return state3;
        }
        return {
          result: "error",
          message: "cannot parse body without content-length or patches header"
        };
      }
      if (typeof module3 !== "undefined" && module3.exports)
        module3.exports = {
          fetch: braid_fetch2,
          http: braidify_http,
          subscription_parser,
          parse_version,
          parse_headers,
          parse_body
        };
    }
  });

  // node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports2, module3) {
      (function(global3, factory) {
        typeof exports2 === "object" && typeof module3 !== "undefined" ? module3.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global3 = typeof globalThis !== "undefined" ? globalThis : global3 || self, global3.maplibregl = factory());
      })(exports2, function() {
        "use strict";
        var shared, worker, maplibregl2;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared(sharedChunk);
            maplibregl2 = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              maplibregl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t2) {
          "use strict";
          function e2(t3) {
            return t3 && t3.__esModule && Object.prototype.hasOwnProperty.call(t3, "default") ? t3.default : t3;
          }
          var r = n2;
          function n2(t3, e3) {
            this.x = t3, this.y = e3;
          }
          n2.prototype = { clone: function() {
            return new n2(this.x, this.y);
          }, add: function(t3) {
            return this.clone()._add(t3);
          }, sub: function(t3) {
            return this.clone()._sub(t3);
          }, multByPoint: function(t3) {
            return this.clone()._multByPoint(t3);
          }, divByPoint: function(t3) {
            return this.clone()._divByPoint(t3);
          }, mult: function(t3) {
            return this.clone()._mult(t3);
          }, div: function(t3) {
            return this.clone()._div(t3);
          }, rotate: function(t3) {
            return this.clone()._rotate(t3);
          }, rotateAround: function(t3, e3) {
            return this.clone()._rotateAround(t3, e3);
          }, matMult: function(t3) {
            return this.clone()._matMult(t3);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t3) {
            return this.x === t3.x && this.y === t3.y;
          }, dist: function(t3) {
            return Math.sqrt(this.distSqr(t3));
          }, distSqr: function(t3) {
            var e3 = t3.x - this.x, r2 = t3.y - this.y;
            return e3 * e3 + r2 * r2;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t3) {
            return Math.atan2(this.y - t3.y, this.x - t3.x);
          }, angleWith: function(t3) {
            return this.angleWithSep(t3.x, t3.y);
          }, angleWithSep: function(t3, e3) {
            return Math.atan2(this.x * e3 - this.y * t3, this.x * t3 + this.y * e3);
          }, _matMult: function(t3) {
            var e3 = t3[2] * this.x + t3[3] * this.y;
            return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e3, this;
          }, _add: function(t3) {
            return this.x += t3.x, this.y += t3.y, this;
          }, _sub: function(t3) {
            return this.x -= t3.x, this.y -= t3.y, this;
          }, _mult: function(t3) {
            return this.x *= t3, this.y *= t3, this;
          }, _div: function(t3) {
            return this.x /= t3, this.y /= t3, this;
          }, _multByPoint: function(t3) {
            return this.x *= t3.x, this.y *= t3.y, this;
          }, _divByPoint: function(t3) {
            return this.x /= t3.x, this.y /= t3.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t3 = this.y;
            return this.y = this.x, this.x = -t3, this;
          }, _rotate: function(t3) {
            var e3 = Math.cos(t3), r2 = Math.sin(t3), n3 = r2 * this.x + e3 * this.y;
            return this.x = e3 * this.x - r2 * this.y, this.y = n3, this;
          }, _rotateAround: function(t3, e3) {
            var r2 = Math.cos(t3), n3 = Math.sin(t3), i3 = e3.y + n3 * (this.x - e3.x) + r2 * (this.y - e3.y);
            return this.x = e3.x + r2 * (this.x - e3.x) - n3 * (this.y - e3.y), this.y = i3, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, n2.convert = function(t3) {
            return t3 instanceof n2 ? t3 : Array.isArray(t3) ? new n2(t3[0], t3[1]) : t3;
          };
          var i2 = e2(r), a2 = s;
          function s(t3, e3, r2, n3) {
            this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e3, this.by = 3 * (n3 - e3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e3, this.p2x = r2, this.p2y = n3;
          }
          s.prototype = { sampleCurveX: function(t3) {
            return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
          }, sampleCurveY: function(t3) {
            return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
          }, sampleCurveDerivativeX: function(t3) {
            return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
          }, solveCurveX: function(t3, e3) {
            if (void 0 === e3 && (e3 = 1e-6), t3 < 0)
              return 0;
            if (t3 > 1)
              return 1;
            for (var r2 = t3, n3 = 0; n3 < 8; n3++) {
              var i3 = this.sampleCurveX(r2) - t3;
              if (Math.abs(i3) < e3)
                return r2;
              var a3 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(a3) < 1e-6)
                break;
              r2 -= i3 / a3;
            }
            var s2 = 0, o2 = 1;
            for (r2 = t3, n3 = 0; n3 < 20 && (i3 = this.sampleCurveX(r2), !(Math.abs(i3 - t3) < e3)); n3++)
              t3 > i3 ? s2 = r2 : o2 = r2, r2 = 0.5 * (o2 - s2) + s2;
            return r2;
          }, solve: function(t3, e3) {
            return this.sampleCurveY(this.solveCurveX(t3, e3));
          } };
          var o = e2(a2);
          function l(t3, e3, r2, n3) {
            const i3 = new o(t3, e3, r2, n3);
            return function(t4) {
              return i3.solve(t4);
            };
          }
          const u = l(0.25, 0.1, 0.25, 1);
          function c4(t3, e3, r2) {
            return Math.min(r2, Math.max(e3, t3));
          }
          function h(t3, e3, r2) {
            const n3 = r2 - e3, i3 = ((t3 - e3) % n3 + n3) % n3 + e3;
            return i3 === e3 ? r2 : i3;
          }
          function p2(t3, ...e3) {
            for (const r2 of e3)
              for (const e4 in r2)
                t3[e4] = r2[e4];
            return t3;
          }
          let f = 1;
          function d2(t3, e3, r2) {
            const n3 = {};
            for (const i3 in t3)
              n3[i3] = e3.call(r2 || this, t3[i3], i3, t3);
            return n3;
          }
          function y(t3, e3, r2) {
            const n3 = {};
            for (const i3 in t3)
              e3.call(r2 || this, t3[i3], i3, t3) && (n3[i3] = t3[i3]);
            return n3;
          }
          function m3(t3) {
            return Array.isArray(t3) ? t3.map(m3) : "object" == typeof t3 && t3 ? d2(t3, m3) : t3;
          }
          const g2 = {};
          function x(t3) {
            g2[t3] || ("undefined" != typeof console && console.warn(t3), g2[t3] = true);
          }
          function v(t3, e3, r2) {
            return (r2.y - t3.y) * (e3.x - t3.x) > (e3.y - t3.y) * (r2.x - t3.x);
          }
          function b2(t3) {
            let e3 = 0;
            for (let r2, n3, i3 = 0, a3 = t3.length, s2 = a3 - 1; i3 < a3; s2 = i3++)
              r2 = t3[i3], n3 = t3[s2], e3 += (n3.x - r2.x) * (r2.y + n3.y);
            return e3;
          }
          function w() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          let _ = null;
          function A(t3) {
            if (null == _) {
              const e3 = t3.navigator ? t3.navigator.userAgent : null;
              _ = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
            }
            return _;
          }
          function k(t3) {
            return "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap;
          }
          const S = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let I, z;
          const M = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t3) {
            const e3 = requestAnimationFrame(t3);
            return { cancel: () => cancelAnimationFrame(e3) };
          }, getImageData(t3, e3 = 0) {
            return this.getImageCanvasContext(t3).getImageData(-e3, -e3, t3.width + 2 * e3, t3.height + 2 * e3);
          }, getImageCanvasContext(t3) {
            const e3 = window.document.createElement("canvas"), r2 = e3.getContext("2d", { willReadFrequently: true });
            if (!r2)
              throw new Error("failed to create canvas 2d context");
            return e3.width = t3.width, e3.height = t3.height, r2.drawImage(t3, 0, 0, t3.width, t3.height), r2;
          }, resolveURL: (t3) => (I || (I = document.createElement("a")), I.href = t3, I.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (null == z && (z = matchMedia("(prefers-reduced-motion: reduce)")), z.matches);
          } }, P = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
          class B extends Error {
            constructor(t3, e3, r2, n3) {
              super(`AJAXError: ${e3} (${t3}): ${r2}`), this.status = t3, this.statusText = e3, this.url = r2, this.body = n3;
            }
          }
          const C2 = w() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href, V = (t3) => P.REGISTERED_PROTOCOLS[t3.substring(0, t3.indexOf("://"))];
          function E(t3, e3) {
            const r2 = new AbortController(), n3 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: C2(), signal: r2.signal });
            let i3 = false, a3 = false;
            "json" === t3.type && n3.headers.set("Accept", "application/json");
            return a3 || fetch(n3).then((r3) => r3.ok ? ((r4) => {
              ("arrayBuffer" === t3.type || "image" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                a3 || (i3 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
              }).catch((t4) => {
                a3 || e3(new Error(t4.message));
              });
            })(r3) : r3.blob().then((n4) => e3(new B(r3.status, r3.statusText, t3.url, n4)))).catch((t4) => {
              20 !== t4.code && e3(new Error(t4.message));
            }), { cancel: () => {
              a3 = true, i3 || r2.abort();
            } };
          }
          const F = function(t3, e3) {
            if (/:\/\//.test(t3.url) && !/^https?:|^file:/.test(t3.url)) {
              if (w() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t3, e3);
              if (!w())
                return (V(t3.url) || E)(t3, e3);
            }
            if (!(/^file:/.test(r2 = t3.url) || /^file:/.test(C2()) && !/^\w+:/.test(r2))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                return E(t3, e3);
              if (w() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t3, e3, void 0, true);
            }
            var r2;
            return function(t4, e4) {
              const r3 = new XMLHttpRequest();
              r3.open(t4.method || "GET", t4.url, true), "arrayBuffer" !== t4.type && "image" !== t4.type || (r3.responseType = "arraybuffer");
              for (const e5 in t4.headers)
                r3.setRequestHeader(e5, t4.headers[e5]);
              return "json" === t4.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t4.credentials, r3.onerror = () => {
                e4(new Error(r3.statusText));
              }, r3.onload = () => {
                if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                  let n3 = r3.response;
                  if ("json" === t4.type)
                    try {
                      n3 = JSON.parse(r3.response);
                    } catch (t5) {
                      return e4(t5);
                    }
                  e4(null, n3, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else {
                  const n3 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                  e4(new B(r3.status, r3.statusText, t4.url, n3));
                }
              }, r3.send(t4.body), { cancel: () => r3.abort() };
            }(t3, e3);
          }, T = function(t3, e3) {
            return F(p2(t3, { type: "arrayBuffer" }), e3);
          };
          function L(t3) {
            if (!t3 || t3.indexOf("://") <= 0 || 0 === t3.indexOf("data:image/") || 0 === t3.indexOf("blob:"))
              return true;
            const e3 = new URL(t3), r2 = window.location;
            return e3.protocol === r2.protocol && e3.host === r2.host;
          }
          function $11(t3, e3, r2) {
            r2[t3] && -1 !== r2[t3].indexOf(e3) || (r2[t3] = r2[t3] || [], r2[t3].push(e3));
          }
          function D(t3, e3, r2) {
            if (r2 && r2[t3]) {
              const n3 = r2[t3].indexOf(e3);
              -1 !== n3 && r2[t3].splice(n3, 1);
            }
          }
          class O {
            constructor(t3, e3 = {}) {
              p2(this, e3), this.type = t3;
            }
          }
          class U extends O {
            constructor(t3, e3 = {}) {
              super("error", p2({ error: t3 }, e3));
            }
          }
          class R {
            on(t3, e3) {
              return this._listeners = this._listeners || {}, $11(t3, e3, this._listeners), this;
            }
            off(t3, e3) {
              return D(t3, e3, this._listeners), D(t3, e3, this._oneTimeListeners), this;
            }
            once(t3, e3) {
              return e3 ? (this._oneTimeListeners = this._oneTimeListeners || {}, $11(t3, e3, this._oneTimeListeners), this) : new Promise((e4) => this.once(t3, e4));
            }
            fire(t3, e3) {
              "string" == typeof t3 && (t3 = new O(t3, e3 || {}));
              const r2 = t3.type;
              if (this.listens(r2)) {
                t3.target = this;
                const e4 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
                for (const r3 of e4)
                  r3.call(this, t3);
                const n3 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
                for (const e5 of n3)
                  D(r2, e5, this._oneTimeListeners), e5.call(this, t3);
                const i3 = this._eventedParent;
                i3 && (p2(t3, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i3.fire(t3));
              } else
                t3 instanceof U && console.error(t3.error);
              return this;
            }
            listens(t3) {
              return this._listeners && this._listeners[t3] && this._listeners[t3].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t3] && this._oneTimeListeners[t3].length > 0 || this._eventedParent && this._eventedParent.listens(t3);
            }
            setEventedParent(t3, e3) {
              return this._eventedParent = t3, this._eventedParentData = e3, this;
            }
          }
          var q = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          const j = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
          function N(t3, e3) {
            const r2 = {};
            for (const e4 in t3)
              "ref" !== e4 && (r2[e4] = t3[e4]);
            return j.forEach((t4) => {
              t4 in e3 && (r2[t4] = e3[t4]);
            }), r2;
          }
          function Z(t3, e3) {
            if (Array.isArray(t3)) {
              if (!Array.isArray(e3) || t3.length !== e3.length)
                return false;
              for (let r2 = 0; r2 < t3.length; r2++)
                if (!Z(t3[r2], e3[r2]))
                  return false;
              return true;
            }
            if ("object" == typeof t3 && null !== t3 && null !== e3) {
              if ("object" != typeof e3)
                return false;
              if (Object.keys(t3).length !== Object.keys(e3).length)
                return false;
              for (const r2 in t3)
                if (!Z(t3[r2], e3[r2]))
                  return false;
              return true;
            }
            return t3 === e3;
          }
          const K = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
          function G(t3, e3, r2) {
            r2.push({ command: K.addSource, args: [t3, e3[t3]] });
          }
          function J(t3, e3, r2) {
            e3.push({ command: K.removeSource, args: [t3] }), r2[t3] = true;
          }
          function X(t3, e3, r2, n3) {
            J(t3, r2, n3), G(t3, e3, r2);
          }
          function Y(t3, e3, r2) {
            let n3;
            for (n3 in t3[r2])
              if (Object.prototype.hasOwnProperty.call(t3[r2], n3) && "data" !== n3 && !Z(t3[r2][n3], e3[r2][n3]))
                return false;
            for (n3 in e3[r2])
              if (Object.prototype.hasOwnProperty.call(e3[r2], n3) && "data" !== n3 && !Z(t3[r2][n3], e3[r2][n3]))
                return false;
            return true;
          }
          function H(t3, e3, r2, n3, i3, a3) {
            let s2;
            for (s2 in e3 = e3 || {}, t3 = t3 || {})
              Object.prototype.hasOwnProperty.call(t3, s2) && (Z(t3[s2], e3[s2]) || r2.push({ command: a3, args: [n3, s2, e3[s2], i3] }));
            for (s2 in e3)
              Object.prototype.hasOwnProperty.call(e3, s2) && !Object.prototype.hasOwnProperty.call(t3, s2) && (Z(t3[s2], e3[s2]) || r2.push({ command: a3, args: [n3, s2, e3[s2], i3] }));
          }
          function W(t3) {
            return t3.id;
          }
          function Q(t3, e3) {
            return t3[e3.id] = e3, t3;
          }
          class tt {
            constructor(t3, e3, r2, n3) {
              this.message = (t3 ? `${t3}: ` : "") + r2, n3 && (this.identifier = n3), null != e3 && e3.__line__ && (this.line = e3.__line__);
            }
          }
          function et(t3, ...e3) {
            for (const r2 of e3)
              for (const e4 in r2)
                t3[e4] = r2[e4];
            return t3;
          }
          class rt extends Error {
            constructor(t3, e3) {
              super(e3), this.message = e3, this.key = t3;
            }
          }
          class nt {
            constructor(t3, e3 = []) {
              this.parent = t3, this.bindings = {};
              for (const [t4, r2] of e3)
                this.bindings[t4] = r2;
            }
            concat(t3) {
              return new nt(this, t3);
            }
            get(t3) {
              if (this.bindings[t3])
                return this.bindings[t3];
              if (this.parent)
                return this.parent.get(t3);
              throw new Error(`${t3} not found in scope.`);
            }
            has(t3) {
              return !!this.bindings[t3] || !!this.parent && this.parent.has(t3);
            }
          }
          const it = { kind: "null" }, at = { kind: "number" }, st = { kind: "string" }, ot = { kind: "boolean" }, lt = { kind: "color" }, ut = { kind: "object" }, ct = { kind: "value" }, ht = { kind: "collator" }, pt = { kind: "formatted" }, ft = { kind: "padding" }, dt = { kind: "resolvedImage" };
          function yt(t3, e3) {
            return { kind: "array", itemType: t3, N: e3 };
          }
          function mt(t3) {
            if ("array" === t3.kind) {
              const e3 = mt(t3.itemType);
              return "number" == typeof t3.N ? `array<${e3}, ${t3.N}>` : "value" === t3.itemType.kind ? "array" : `array<${e3}>`;
            }
            return t3.kind;
          }
          const gt = [it, at, st, ot, lt, pt, ut, yt(ct), ft, dt];
          function xt(t3, e3) {
            if ("error" === e3.kind)
              return null;
            if ("array" === t3.kind) {
              if ("array" === e3.kind && (0 === e3.N && "value" === e3.itemType.kind || !xt(t3.itemType, e3.itemType)) && ("number" != typeof t3.N || t3.N === e3.N))
                return null;
            } else {
              if (t3.kind === e3.kind)
                return null;
              if ("value" === t3.kind) {
                for (const t4 of gt)
                  if (!xt(t4, e3))
                    return null;
              }
            }
            return `Expected ${mt(t3)} but found ${mt(e3)} instead.`;
          }
          function vt(t3, e3) {
            return e3.some((e4) => e4.kind === t3.kind);
          }
          function bt(t3, e3) {
            return e3.some((e4) => "null" === e4 ? null === t3 : "array" === e4 ? Array.isArray(t3) : "object" === e4 ? t3 && !Array.isArray(t3) && "object" == typeof t3 : e4 === typeof t3);
          }
          function wt(t3, e3) {
            return "array" === t3.kind && "array" === e3.kind ? t3.itemType.kind === e3.itemType.kind && "number" == typeof t3.N : t3.kind === e3.kind;
          }
          const _t = 0.96422, At = 0.82521, kt = 4 / 29, St = 6 / 29, It = 3 * St * St, zt = St * St * St, Mt = Math.PI / 180, Pt = 180 / Math.PI;
          function Bt(t3) {
            return (t3 %= 360) < 0 && (t3 += 360), t3;
          }
          function Ct([t3, e3, r2, n3]) {
            let i3, a3;
            const s2 = Et3((0.2225045 * (t3 = Vt(t3)) + 0.7168786 * (e3 = Vt(e3)) + 0.0606169 * (r2 = Vt(r2))) / 1);
            t3 === e3 && e3 === r2 ? i3 = a3 = s2 : (i3 = Et3((0.4360747 * t3 + 0.3850649 * e3 + 0.1430804 * r2) / _t), a3 = Et3((0.0139322 * t3 + 0.0971045 * e3 + 0.7141733 * r2) / At));
            const o2 = 116 * s2 - 16;
            return [o2 < 0 ? 0 : o2, 500 * (i3 - s2), 200 * (s2 - a3), n3];
          }
          function Vt(t3) {
            return t3 <= 0.04045 ? t3 / 12.92 : Math.pow((t3 + 0.055) / 1.055, 2.4);
          }
          function Et3(t3) {
            return t3 > zt ? Math.pow(t3, 1 / 3) : t3 / It + kt;
          }
          function Ft([t3, e3, r2, n3]) {
            let i3 = (t3 + 16) / 116, a3 = isNaN(e3) ? i3 : i3 + e3 / 500, s2 = isNaN(r2) ? i3 : i3 - r2 / 200;
            return i3 = 1 * Lt(i3), a3 = _t * Lt(a3), s2 = At * Lt(s2), [Tt(3.1338561 * a3 - 1.6168667 * i3 - 0.4906146 * s2), Tt(-0.9787684 * a3 + 1.9161415 * i3 + 0.033454 * s2), Tt(0.0719453 * a3 - 0.2289914 * i3 + 1.4052427 * s2), n3];
          }
          function Tt(t3) {
            return (t3 = t3 <= 304e-5 ? 12.92 * t3 : 1.055 * Math.pow(t3, 1 / 2.4) - 0.055) < 0 ? 0 : t3 > 1 ? 1 : t3;
          }
          function Lt(t3) {
            return t3 > St ? t3 * t3 * t3 : It * (t3 - kt);
          }
          function $t(t3) {
            return parseInt(t3.padEnd(2, t3), 16) / 255;
          }
          function Dt(t3, e3) {
            return Ot(e3 ? t3 / 100 : t3, 0, 1);
          }
          function Ot(t3, e3, r2) {
            return Math.min(Math.max(e3, t3), r2);
          }
          function Ut(t3) {
            return !t3.some(Number.isNaN);
          }
          const Rt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
          class qt {
            constructor(t3, e3, r2, n3 = 1, i3 = true) {
              this.r = t3, this.g = e3, this.b = r2, this.a = n3, i3 || (this.r *= n3, this.g *= n3, this.b *= n3, n3 || this.overwriteGetter("rgb", [t3, e3, r2, n3]));
            }
            static parse(t3) {
              if (t3 instanceof qt)
                return t3;
              if ("string" != typeof t3)
                return;
              const e3 = function(t4) {
                if ("transparent" === (t4 = t4.toLowerCase()))
                  return [0, 0, 0, 0];
                const e4 = Rt[t4];
                if (e4) {
                  const [t5, r3, n3] = e4;
                  return [t5 / 255, r3 / 255, n3 / 255, 1];
                }
                if (t4.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t4)) {
                  const e5 = t4.length < 6 ? 1 : 2;
                  let r3 = 1;
                  return [$t(t4.slice(r3, r3 += e5)), $t(t4.slice(r3, r3 += e5)), $t(t4.slice(r3, r3 += e5)), $t(t4.slice(r3, r3 + e5) || "ff")];
                }
                if (t4.startsWith("rgb")) {
                  const e5 = t4.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                  if (e5) {
                    const [t5, r3, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3] = e5, f2 = [i3 || " ", o2 || " ", c5].join("");
                    if ("  " === f2 || "  /" === f2 || ",," === f2 || ",,," === f2) {
                      const t6 = [n3, s2, u2].join(""), e6 = "%%%" === t6 ? 100 : "" === t6 ? 255 : 0;
                      if (e6) {
                        const t7 = [Ot(+r3 / e6, 0, 1), Ot(+a3 / e6, 0, 1), Ot(+l2 / e6, 0, 1), h2 ? Dt(+h2, p3) : 1];
                        if (Ut(t7))
                          return t7;
                      }
                    }
                    return;
                  }
                }
                const r2 = t4.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (r2) {
                  const [t5, e5, n3, i3, a3, s2, o2, l2, u2] = r2, c5 = [n3 || " ", a3 || " ", o2].join("");
                  if ("  " === c5 || "  /" === c5 || ",," === c5 || ",,," === c5) {
                    const t6 = [+e5, Ot(+i3, 0, 100), Ot(+s2, 0, 100), l2 ? Dt(+l2, u2) : 1];
                    if (Ut(t6))
                      return function([t7, e6, r3, n4]) {
                        function i4(n5) {
                          const i5 = (n5 + t7 / 30) % 12, a4 = e6 * Math.min(r3, 1 - r3);
                          return r3 - a4 * Math.max(-1, Math.min(i5 - 3, 9 - i5, 1));
                        }
                        return t7 = Bt(t7), e6 /= 100, r3 /= 100, [i4(0), i4(8), i4(4), n4];
                      }(t6);
                  }
                }
              }(t3);
              return e3 ? new qt(...e3, false) : void 0;
            }
            get rgb() {
              const { r: t3, g: e3, b: r2, a: n3 } = this, i3 = n3 || 1 / 0;
              return this.overwriteGetter("rgb", [t3 / i3, e3 / i3, r2 / i3, n3]);
            }
            get hcl() {
              return this.overwriteGetter("hcl", function(t3) {
                const [e3, r2, n3, i3] = Ct(t3), a3 = Math.sqrt(r2 * r2 + n3 * n3);
                return [Math.round(1e4 * a3) ? Bt(Math.atan2(n3, r2) * Pt) : NaN, a3, e3, i3];
              }(this.rgb));
            }
            get lab() {
              return this.overwriteGetter("lab", Ct(this.rgb));
            }
            overwriteGetter(t3, e3) {
              return Object.defineProperty(this, t3, { value: e3 }), e3;
            }
            toString() {
              const [t3, e3, r2, n3] = this.rgb;
              return `rgba(${[t3, e3, r2].map((t4) => Math.round(255 * t4)).join(",")},${n3})`;
            }
          }
          qt.black = new qt(0, 0, 0, 1), qt.white = new qt(1, 1, 1, 1), qt.transparent = new qt(0, 0, 0, 0), qt.red = new qt(1, 0, 0, 1);
          class jt {
            constructor(t3, e3, r2) {
              this.sensitivity = t3 ? e3 ? "variant" : "case" : e3 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t3, e3) {
              return this.collator.compare(t3, e3);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Nt {
            constructor(t3, e3, r2, n3, i3) {
              this.text = t3, this.image = e3, this.scale = r2, this.fontStack = n3, this.textColor = i3;
            }
          }
          class Zt {
            constructor(t3) {
              this.sections = t3;
            }
            static fromString(t3) {
              return new Zt([new Nt(t3, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t3) => 0 !== t3.text.length || t3.image && 0 !== t3.image.name.length);
            }
            static factory(t3) {
              return t3 instanceof Zt ? t3 : Zt.fromString(t3);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t3) => t3.text).join("");
            }
          }
          class Kt {
            constructor(t3) {
              this.values = t3.slice();
            }
            static parse(t3) {
              if (t3 instanceof Kt)
                return t3;
              if ("number" == typeof t3)
                return new Kt([t3, t3, t3, t3]);
              if (Array.isArray(t3) && !(t3.length < 1 || t3.length > 4)) {
                for (const e3 of t3)
                  if ("number" != typeof e3)
                    return;
                switch (t3.length) {
                  case 1:
                    t3 = [t3[0], t3[0], t3[0], t3[0]];
                    break;
                  case 2:
                    t3 = [t3[0], t3[1], t3[0], t3[1]];
                    break;
                  case 3:
                    t3 = [t3[0], t3[1], t3[2], t3[1]];
                }
                return new Kt(t3);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
          }
          class Gt {
            constructor(t3) {
              this.name = t3.name, this.available = t3.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t3) {
              return t3 ? new Gt({ name: t3, available: false }) : null;
            }
          }
          function Jt(t3, e3, r2, n3) {
            return "number" == typeof t3 && t3 >= 0 && t3 <= 255 && "number" == typeof e3 && e3 >= 0 && e3 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t3, e3, r2, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t3, e3, r2, n3] : [t3, e3, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Xt(t3) {
            if (null === t3)
              return true;
            if ("string" == typeof t3)
              return true;
            if ("boolean" == typeof t3)
              return true;
            if ("number" == typeof t3)
              return true;
            if (t3 instanceof qt)
              return true;
            if (t3 instanceof jt)
              return true;
            if (t3 instanceof Zt)
              return true;
            if (t3 instanceof Kt)
              return true;
            if (t3 instanceof Gt)
              return true;
            if (Array.isArray(t3)) {
              for (const e3 of t3)
                if (!Xt(e3))
                  return false;
              return true;
            }
            if ("object" == typeof t3) {
              for (const e3 in t3)
                if (!Xt(t3[e3]))
                  return false;
              return true;
            }
            return false;
          }
          function Yt(t3) {
            if (null === t3)
              return it;
            if ("string" == typeof t3)
              return st;
            if ("boolean" == typeof t3)
              return ot;
            if ("number" == typeof t3)
              return at;
            if (t3 instanceof qt)
              return lt;
            if (t3 instanceof jt)
              return ht;
            if (t3 instanceof Zt)
              return pt;
            if (t3 instanceof Kt)
              return ft;
            if (t3 instanceof Gt)
              return dt;
            if (Array.isArray(t3)) {
              const e3 = t3.length;
              let r2;
              for (const e4 of t3) {
                const t4 = Yt(e4);
                if (r2) {
                  if (r2 === t4)
                    continue;
                  r2 = ct;
                  break;
                }
                r2 = t4;
              }
              return yt(r2 || ct, e3);
            }
            return ut;
          }
          function Ht(t3) {
            const e3 = typeof t3;
            return null === t3 ? "" : "string" === e3 || "number" === e3 || "boolean" === e3 ? String(t3) : t3 instanceof qt || t3 instanceof Zt || t3 instanceof Kt || t3 instanceof Gt ? t3.toString() : JSON.stringify(t3);
          }
          class Wt {
            constructor(t3, e3) {
              this.type = t3, this.value = e3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length)
                return e3.error(`'literal' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
              if (!Xt(t3[1]))
                return e3.error("invalid value");
              const r2 = t3[1];
              let n3 = Yt(r2);
              const i3 = e3.expectedType;
              return "array" !== n3.kind || 0 !== n3.N || !i3 || "array" !== i3.kind || "number" == typeof i3.N && 0 !== i3.N || (n3 = i3), new Wt(n3, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class Qt {
            constructor(t3) {
              this.name = "ExpressionEvaluationError", this.message = t3;
            }
            toJSON() {
              return this.message;
            }
          }
          const te = { string: st, number: at, boolean: ot, object: ut };
          class ee {
            constructor(t3, e3) {
              this.type = t3, this.args = e3;
            }
            static parse(t3, e3) {
              if (t3.length < 2)
                return e3.error("Expected at least one argument.");
              let r2, n3 = 1;
              const i3 = t3[0];
              if ("array" === i3) {
                let i4, a4;
                if (t3.length > 2) {
                  const r3 = t3[1];
                  if ("string" != typeof r3 || !(r3 in te) || "object" === r3)
                    return e3.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i4 = te[r3], n3++;
                } else
                  i4 = ct;
                if (t3.length > 3) {
                  if (null !== t3[2] && ("number" != typeof t3[2] || t3[2] < 0 || t3[2] !== Math.floor(t3[2])))
                    return e3.error('The length argument to "array" must be a positive integer literal', 2);
                  a4 = t3[2], n3++;
                }
                r2 = yt(i4, a4);
              } else {
                if (!te[i3])
                  throw new Error(`Types doesn't contain name = ${i3}`);
                r2 = te[i3];
              }
              const a3 = [];
              for (; n3 < t3.length; n3++) {
                const r3 = e3.parse(t3[n3], n3, ct);
                if (!r3)
                  return null;
                a3.push(r3);
              }
              return new ee(r2, a3);
            }
            evaluate(t3) {
              for (let e3 = 0; e3 < this.args.length; e3++) {
                const r2 = this.args[e3].evaluate(t3);
                if (!xt(this.type, Yt(r2)))
                  return r2;
                if (e3 === this.args.length - 1)
                  throw new Qt(`Expected value to be of type ${mt(this.type)}, but found ${mt(Yt(r2))} instead.`);
              }
              throw new Error();
            }
            eachChild(t3) {
              this.args.forEach(t3);
            }
            outputDefined() {
              return this.args.every((t3) => t3.outputDefined());
            }
          }
          const re = { "to-boolean": ot, "to-color": lt, "to-number": at, "to-string": st };
          class ne {
            constructor(t3, e3) {
              this.type = t3, this.args = e3;
            }
            static parse(t3, e3) {
              if (t3.length < 2)
                return e3.error("Expected at least one argument.");
              const r2 = t3[0];
              if (!re[r2])
                throw new Error(`Can't parse ${r2} as it is not part of the known types`);
              if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t3.length)
                return e3.error("Expected one argument.");
              const n3 = re[r2], i3 = [];
              for (let r3 = 1; r3 < t3.length; r3++) {
                const n4 = e3.parse(t3[r3], r3, ct);
                if (!n4)
                  return null;
                i3.push(n4);
              }
              return new ne(n3, i3);
            }
            evaluate(t3) {
              if ("boolean" === this.type.kind)
                return Boolean(this.args[0].evaluate(t3));
              if ("color" === this.type.kind) {
                let e3, r2;
                for (const n3 of this.args) {
                  if (e3 = n3.evaluate(t3), r2 = null, e3 instanceof qt)
                    return e3;
                  if ("string" == typeof e3) {
                    const r3 = t3.parseColor(e3);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e3) && (r2 = e3.length < 3 || e3.length > 4 ? `Invalid rbga value ${JSON.stringify(e3)}: expected an array containing either three or four numeric values.` : Jt(e3[0], e3[1], e3[2], e3[3]), !r2))
                    return new qt(e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
                }
                throw new Qt(r2 || `Could not parse color from value '${"string" == typeof e3 ? e3 : JSON.stringify(e3)}'`);
              }
              if ("padding" === this.type.kind) {
                let e3;
                for (const r2 of this.args) {
                  e3 = r2.evaluate(t3);
                  const n3 = Kt.parse(e3);
                  if (n3)
                    return n3;
                }
                throw new Qt(`Could not parse padding from value '${"string" == typeof e3 ? e3 : JSON.stringify(e3)}'`);
              }
              if ("number" === this.type.kind) {
                let e3 = null;
                for (const r2 of this.args) {
                  if (e3 = r2.evaluate(t3), null === e3)
                    return 0;
                  const n3 = Number(e3);
                  if (!isNaN(n3))
                    return n3;
                }
                throw new Qt(`Could not convert ${JSON.stringify(e3)} to number.`);
              }
              return "formatted" === this.type.kind ? Zt.fromString(Ht(this.args[0].evaluate(t3))) : "resolvedImage" === this.type.kind ? Gt.fromString(Ht(this.args[0].evaluate(t3))) : Ht(this.args[0].evaluate(t3));
            }
            eachChild(t3) {
              this.args.forEach(t3);
            }
            outputDefined() {
              return this.args.every((t3) => t3.outputDefined());
            }
          }
          const ie3 = ["Unknown", "Point", "LineString", "Polygon"];
          class ae {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? ie3[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t3) {
              let e3 = this._parseColorCache[t3];
              return e3 || (e3 = this._parseColorCache[t3] = qt.parse(t3)), e3;
            }
          }
          class se {
            constructor(t3, e3, r2 = [], n3, i3 = new nt(), a3 = []) {
              this.registry = t3, this.path = r2, this.key = r2.map((t4) => `[${t4}]`).join(""), this.scope = i3, this.errors = a3, this.expectedType = n3, this._isConstant = e3;
            }
            parse(t3, e3, r2, n3, i3 = {}) {
              return e3 ? this.concat(e3, r2, n3)._parse(t3, i3) : this._parse(t3, i3);
            }
            _parse(t3, e3) {
              function r2(t4, e4, r3) {
                return "assert" === r3 ? new ee(e4, [t4]) : "coerce" === r3 ? new ne(e4, [t4]) : t4;
              }
              if (null !== t3 && "string" != typeof t3 && "boolean" != typeof t3 && "number" != typeof t3 || (t3 = ["literal", t3]), Array.isArray(t3)) {
                if (0 === t3.length)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n3 = t3[0];
                if ("string" != typeof n3)
                  return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i3 = this.registry[n3];
                if (i3) {
                  let n4 = i3.parse(t3, this);
                  if (!n4)
                    return null;
                  if (this.expectedType) {
                    const t4 = this.expectedType, i4 = n4.type;
                    if ("string" !== t4.kind && "number" !== t4.kind && "boolean" !== t4.kind && "object" !== t4.kind && "array" !== t4.kind || "value" !== i4.kind)
                      if ("color" !== t4.kind && "formatted" !== t4.kind && "resolvedImage" !== t4.kind || "value" !== i4.kind && "string" !== i4.kind)
                        if ("padding" !== t4.kind || "value" !== i4.kind && "number" !== i4.kind && "array" !== i4.kind) {
                          if (this.checkSubtype(t4, i4))
                            return null;
                        } else
                          n4 = r2(n4, t4, e3.typeAnnotation || "coerce");
                      else
                        n4 = r2(n4, t4, e3.typeAnnotation || "coerce");
                    else
                      n4 = r2(n4, t4, e3.typeAnnotation || "assert");
                  }
                  if (!(n4 instanceof Wt) && "resolvedImage" !== n4.type.kind && this._isConstant(n4)) {
                    const t4 = new ae();
                    try {
                      n4 = new Wt(n4.type, n4.evaluate(t4));
                    } catch (t5) {
                      return this.error(t5.message), null;
                    }
                  }
                  return n4;
                }
                return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t3 ? "'undefined' value invalid. Use null instead." : "object" == typeof t3 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t3} instead.`);
            }
            concat(t3, e3, r2) {
              const n3 = "number" == typeof t3 ? this.path.concat(t3) : this.path, i3 = r2 ? this.scope.concat(r2) : this.scope;
              return new se(this.registry, this._isConstant, n3, e3 || null, i3, this.errors);
            }
            error(t3, ...e3) {
              const r2 = `${this.key}${e3.map((t4) => `[${t4}]`).join("")}`;
              this.errors.push(new rt(r2, t3));
            }
            checkSubtype(t3, e3) {
              const r2 = xt(t3, e3);
              return r2 && this.error(r2), r2;
            }
          }
          class oe {
            constructor(t3, e3, r2) {
              this.type = ht, this.locale = r2, this.caseSensitive = t3, this.diacriticSensitive = e3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length)
                return e3.error("Expected one argument.");
              const r2 = t3[1];
              if ("object" != typeof r2 || Array.isArray(r2))
                return e3.error("Collator options argument must be an object.");
              const n3 = e3.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, ot);
              if (!n3)
                return null;
              const i3 = e3.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, ot);
              if (!i3)
                return null;
              let a3 = null;
              return r2.locale && (a3 = e3.parse(r2.locale, 1, st), !a3) ? null : new oe(n3, i3, a3);
            }
            evaluate(t3) {
              return new jt(this.caseSensitive.evaluate(t3), this.diacriticSensitive.evaluate(t3), this.locale ? this.locale.evaluate(t3) : null);
            }
            eachChild(t3) {
              t3(this.caseSensitive), t3(this.diacriticSensitive), this.locale && t3(this.locale);
            }
            outputDefined() {
              return false;
            }
          }
          const le = 8192;
          function ue(t3, e3) {
            t3[0] = Math.min(t3[0], e3[0]), t3[1] = Math.min(t3[1], e3[1]), t3[2] = Math.max(t3[2], e3[0]), t3[3] = Math.max(t3[3], e3[1]);
          }
          function ce(t3, e3) {
            return !(t3[0] <= e3[0] || t3[2] >= e3[2] || t3[1] <= e3[1] || t3[3] >= e3[3]);
          }
          function he(t3, e3) {
            const r2 = (180 + t3[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3[1] * Math.PI / 360))) / 360, i3 = Math.pow(2, e3.z);
            return [Math.round(r2 * i3 * le), Math.round(n3 * i3 * le)];
          }
          function pe(t3, e3, r2) {
            const n3 = t3[0] - e3[0], i3 = t3[1] - e3[1], a3 = t3[0] - r2[0], s2 = t3[1] - r2[1];
            return n3 * s2 - a3 * i3 == 0 && n3 * a3 <= 0 && i3 * s2 <= 0;
          }
          function fe(t3, e3) {
            let r2 = false;
            for (let s2 = 0, o2 = e3.length; s2 < o2; s2++) {
              const o3 = e3[s2];
              for (let e4 = 0, s3 = o3.length; e4 < s3 - 1; e4++) {
                if (pe(t3, o3[e4], o3[e4 + 1]))
                  return false;
                (i3 = o3[e4])[1] > (n3 = t3)[1] != (a3 = o3[e4 + 1])[1] > n3[1] && n3[0] < (a3[0] - i3[0]) * (n3[1] - i3[1]) / (a3[1] - i3[1]) + i3[0] && (r2 = !r2);
              }
            }
            var n3, i3, a3;
            return r2;
          }
          function de(t3, e3) {
            for (let r2 = 0; r2 < e3.length; r2++)
              if (fe(t3, e3[r2]))
                return true;
            return false;
          }
          function ye(t3, e3, r2, n3) {
            const i3 = n3[0] - r2[0], a3 = n3[1] - r2[1], s2 = (t3[0] - r2[0]) * a3 - i3 * (t3[1] - r2[1]), o2 = (e3[0] - r2[0]) * a3 - i3 * (e3[1] - r2[1]);
            return s2 > 0 && o2 < 0 || s2 < 0 && o2 > 0;
          }
          function me(t3, e3, r2) {
            for (const u2 of r2)
              for (let r3 = 0; r3 < u2.length - 1; ++r3)
                if (0 != (o2 = [(s2 = u2[r3 + 1])[0] - (a3 = u2[r3])[0], s2[1] - a3[1]])[0] * (l2 = [(i3 = e3)[0] - (n3 = t3)[0], i3[1] - n3[1]])[1] - o2[1] * l2[0] && ye(n3, i3, a3, s2) && ye(a3, s2, n3, i3))
                  return true;
            var n3, i3, a3, s2, o2, l2;
            return false;
          }
          function ge(t3, e3) {
            for (let r2 = 0; r2 < t3.length; ++r2)
              if (!fe(t3[r2], e3))
                return false;
            for (let r2 = 0; r2 < t3.length - 1; ++r2)
              if (me(t3[r2], t3[r2 + 1], e3))
                return false;
            return true;
          }
          function xe(t3, e3) {
            for (let r2 = 0; r2 < e3.length; r2++)
              if (ge(t3, e3[r2]))
                return true;
            return false;
          }
          function ve(t3, e3, r2) {
            const n3 = [];
            for (let i3 = 0; i3 < t3.length; i3++) {
              const a3 = [];
              for (let n4 = 0; n4 < t3[i3].length; n4++) {
                const s2 = he(t3[i3][n4], r2);
                ue(e3, s2), a3.push(s2);
              }
              n3.push(a3);
            }
            return n3;
          }
          function be(t3, e3, r2) {
            const n3 = [];
            for (let i3 = 0; i3 < t3.length; i3++) {
              const a3 = ve(t3[i3], e3, r2);
              n3.push(a3);
            }
            return n3;
          }
          function we(t3, e3, r2, n3) {
            if (t3[0] < r2[0] || t3[0] > r2[2]) {
              const e4 = 0.5 * n3;
              let i3 = t3[0] - r2[0] > e4 ? -n3 : r2[0] - t3[0] > e4 ? n3 : 0;
              0 === i3 && (i3 = t3[0] - r2[2] > e4 ? -n3 : r2[2] - t3[0] > e4 ? n3 : 0), t3[0] += i3;
            }
            ue(e3, t3);
          }
          function _e(t3, e3, r2, n3) {
            const i3 = Math.pow(2, n3.z) * le, a3 = [n3.x * le, n3.y * le], s2 = [];
            for (const n4 of t3)
              for (const t4 of n4) {
                const n5 = [t4.x + a3[0], t4.y + a3[1]];
                we(n5, e3, r2, i3), s2.push(n5);
              }
            return s2;
          }
          function Ae(t3, e3, r2, n3) {
            const i3 = Math.pow(2, n3.z) * le, a3 = [n3.x * le, n3.y * le], s2 = [];
            for (const r3 of t3) {
              const t4 = [];
              for (const n4 of r3) {
                const r4 = [n4.x + a3[0], n4.y + a3[1]];
                ue(e3, r4), t4.push(r4);
              }
              s2.push(t4);
            }
            if (e3[2] - e3[0] <= i3 / 2) {
              (o2 = e3)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t4 of s2)
                for (const n4 of t4)
                  we(n4, e3, r2, i3);
            }
            var o2;
            return s2;
          }
          class ke {
            constructor(t3, e3) {
              this.type = ot, this.geojson = t3, this.geometries = e3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length)
                return e3.error(`'within' expression requires exactly one argument, but found ${t3.length - 1} instead.`);
              if (Xt(t3[1])) {
                const e4 = t3[1];
                if ("FeatureCollection" === e4.type)
                  for (let t4 = 0; t4 < e4.features.length; ++t4) {
                    const r2 = e4.features[t4].geometry.type;
                    if ("Polygon" === r2 || "MultiPolygon" === r2)
                      return new ke(e4, e4.features[t4].geometry);
                  }
                else if ("Feature" === e4.type) {
                  const t4 = e4.geometry.type;
                  if ("Polygon" === t4 || "MultiPolygon" === t4)
                    return new ke(e4, e4.geometry);
                } else if ("Polygon" === e4.type || "MultiPolygon" === e4.type)
                  return new ke(e4, e4);
              }
              return e3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t3) {
              if (null != t3.geometry() && null != t3.canonicalID()) {
                if ("Point" === t3.geometryType())
                  return function(t4, e3) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                    if ("Polygon" === e3.type) {
                      const a3 = ve(e3.coordinates, n3, i3), s2 = _e(t4.geometry(), r2, n3, i3);
                      if (!ce(r2, n3))
                        return false;
                      for (const t5 of s2)
                        if (!fe(t5, a3))
                          return false;
                    }
                    if ("MultiPolygon" === e3.type) {
                      const a3 = be(e3.coordinates, n3, i3), s2 = _e(t4.geometry(), r2, n3, i3);
                      if (!ce(r2, n3))
                        return false;
                      for (const t5 of s2)
                        if (!de(t5, a3))
                          return false;
                    }
                    return true;
                  }(t3, this.geometries);
                if ("LineString" === t3.geometryType())
                  return function(t4, e3) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i3 = t4.canonicalID();
                    if ("Polygon" === e3.type) {
                      const a3 = ve(e3.coordinates, n3, i3), s2 = Ae(t4.geometry(), r2, n3, i3);
                      if (!ce(r2, n3))
                        return false;
                      for (const t5 of s2)
                        if (!ge(t5, a3))
                          return false;
                    }
                    if ("MultiPolygon" === e3.type) {
                      const a3 = be(e3.coordinates, n3, i3), s2 = Ae(t4.geometry(), r2, n3, i3);
                      if (!ce(r2, n3))
                        return false;
                      for (const t5 of s2)
                        if (!xe(t5, a3))
                          return false;
                    }
                    return true;
                  }(t3, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class Se {
            constructor(t3, e3) {
              this.type = e3.type, this.name = t3, this.boundExpression = e3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length || "string" != typeof t3[1])
                return e3.error("'var' expression requires exactly one string literal argument.");
              const r2 = t3[1];
              return e3.scope.has(r2) ? new Se(r2, e3.scope.get(r2)) : e3.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t3) {
              return this.boundExpression.evaluate(t3);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          class Ie {
            constructor(t3, e3, r2, n3) {
              this.name = t3, this.type = e3, this._evaluate = r2, this.args = n3;
            }
            evaluate(t3) {
              return this._evaluate(t3, this.args);
            }
            eachChild(t3) {
              this.args.forEach(t3);
            }
            outputDefined() {
              return false;
            }
            static parse(t3, e3) {
              const r2 = t3[0], n3 = Ie.definitions[r2];
              if (!n3)
                return e3.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i3 = Array.isArray(n3) ? n3[0] : n3.type, a3 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, s2 = a3.filter(([e4]) => !Array.isArray(e4) || e4.length === t3.length - 1);
              let o2 = null;
              for (const [n4, a4] of s2) {
                o2 = new se(e3.registry, ze, e3.path, null, e3.scope);
                const s3 = [];
                let l2 = false;
                for (let e4 = 1; e4 < t3.length; e4++) {
                  const r3 = t3[e4], i4 = Array.isArray(n4) ? n4[e4 - 1] : n4.type, a5 = o2.parse(r3, 1 + s3.length, i4);
                  if (!a5) {
                    l2 = true;
                    break;
                  }
                  s3.push(a5);
                }
                if (!l2)
                  if (Array.isArray(n4) && n4.length !== s3.length)
                    o2.error(`Expected ${n4.length} arguments, but found ${s3.length} instead.`);
                  else {
                    for (let t4 = 0; t4 < s3.length; t4++) {
                      const e4 = Array.isArray(n4) ? n4[t4] : n4.type, r3 = s3[t4];
                      o2.concat(t4 + 1).checkSubtype(e4, r3.type);
                    }
                    if (0 === o2.errors.length)
                      return new Ie(r2, i3, a4, s3);
                  }
              }
              if (1 === s2.length)
                e3.errors.push(...o2.errors);
              else {
                const r3 = (s2.length ? s2 : a3).map(([t4]) => {
                  return e4 = t4, Array.isArray(e4) ? `(${e4.map(mt).join(", ")})` : `(${mt(e4.type)}...)`;
                  var e4;
                }).join(" | "), n4 = [];
                for (let r4 = 1; r4 < t3.length; r4++) {
                  const i4 = e3.parse(t3[r4], 1 + n4.length);
                  if (!i4)
                    return null;
                  n4.push(mt(i4.type));
                }
                e3.error(`Expected arguments of type ${r3}, but found (${n4.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t3, e3) {
              Ie.definitions = e3;
              for (const r2 in e3)
                t3[r2] = Ie;
            }
          }
          function ze(t3) {
            if (t3 instanceof Se)
              return ze(t3.boundExpression);
            if (t3 instanceof Ie && "error" === t3.name)
              return false;
            if (t3 instanceof oe)
              return false;
            if (t3 instanceof ke)
              return false;
            const e3 = t3 instanceof ne || t3 instanceof ee;
            let r2 = true;
            return t3.eachChild((t4) => {
              r2 = e3 ? r2 && ze(t4) : r2 && t4 instanceof Wt;
            }), !!r2 && Me(t3) && Be(t3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function Me(t3) {
            if (t3 instanceof Ie) {
              if ("get" === t3.name && 1 === t3.args.length)
                return false;
              if ("feature-state" === t3.name)
                return false;
              if ("has" === t3.name && 1 === t3.args.length)
                return false;
              if ("properties" === t3.name || "geometry-type" === t3.name || "id" === t3.name)
                return false;
              if (/^filter-/.test(t3.name))
                return false;
            }
            if (t3 instanceof ke)
              return false;
            let e3 = true;
            return t3.eachChild((t4) => {
              e3 && !Me(t4) && (e3 = false);
            }), e3;
          }
          function Pe(t3) {
            if (t3 instanceof Ie && "feature-state" === t3.name)
              return false;
            let e3 = true;
            return t3.eachChild((t4) => {
              e3 && !Pe(t4) && (e3 = false);
            }), e3;
          }
          function Be(t3, e3) {
            if (t3 instanceof Ie && e3.indexOf(t3.name) >= 0)
              return false;
            let r2 = true;
            return t3.eachChild((t4) => {
              r2 && !Be(t4, e3) && (r2 = false);
            }), r2;
          }
          function Ce(t3, e3) {
            const r2 = t3.length - 1;
            let n3, i3, a3 = 0, s2 = r2, o2 = 0;
            for (; a3 <= s2; )
              if (o2 = Math.floor((a3 + s2) / 2), n3 = t3[o2], i3 = t3[o2 + 1], n3 <= e3) {
                if (o2 === r2 || e3 < i3)
                  return o2;
                a3 = o2 + 1;
              } else {
                if (!(n3 > e3))
                  throw new Qt("Input is not a number.");
                s2 = o2 - 1;
              }
            return 0;
          }
          class Ve {
            constructor(t3, e3, r2) {
              this.type = t3, this.input = e3, this.labels = [], this.outputs = [];
              for (const [t4, e4] of r2)
                this.labels.push(t4), this.outputs.push(e4);
            }
            static parse(t3, e3) {
              if (t3.length - 1 < 4)
                return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
              if ((t3.length - 1) % 2 != 0)
                return e3.error("Expected an even number of arguments.");
              const r2 = e3.parse(t3[1], 1, at);
              if (!r2)
                return null;
              const n3 = [];
              let i3 = null;
              e3.expectedType && "value" !== e3.expectedType.kind && (i3 = e3.expectedType);
              for (let r3 = 1; r3 < t3.length; r3 += 2) {
                const a3 = 1 === r3 ? -1 / 0 : t3[r3], s2 = t3[r3 + 1], o2 = r3, l2 = r3 + 1;
                if ("number" != typeof a3)
                  return e3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n3.length && n3[n3.length - 1][0] >= a3)
                  return e3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e3.parse(s2, l2, i3);
                if (!u2)
                  return null;
                i3 = i3 || u2.type, n3.push([a3, u2]);
              }
              return new Ve(i3, r2, n3);
            }
            evaluate(t3) {
              const e3 = this.labels, r2 = this.outputs;
              if (1 === e3.length)
                return r2[0].evaluate(t3);
              const n3 = this.input.evaluate(t3);
              if (n3 <= e3[0])
                return r2[0].evaluate(t3);
              const i3 = e3.length;
              return n3 >= e3[i3 - 1] ? r2[i3 - 1].evaluate(t3) : r2[Ce(e3, n3)].evaluate(t3);
            }
            eachChild(t3) {
              t3(this.input);
              for (const e3 of this.outputs)
                t3(e3);
            }
            outputDefined() {
              return this.outputs.every((t3) => t3.outputDefined());
            }
          }
          function Ee(t3, e3, r2) {
            return t3 + r2 * (e3 - t3);
          }
          function Fe(t3, e3, r2) {
            return t3.map((t4, n3) => Ee(t4, e3[n3], r2));
          }
          const Te = { number: Ee, color: function(t3, e3, r2, n3 = "rgb") {
            switch (n3) {
              case "rgb": {
                const [n4, i3, a3, s2] = Fe(t3.rgb, e3.rgb, r2);
                return new qt(n4, i3, a3, s2, false);
              }
              case "hcl": {
                const [n4, i3, a3, s2] = t3.hcl, [o2, l2, u2, c5] = e3.hcl;
                let h2, p3;
                if (isNaN(n4) || isNaN(o2))
                  isNaN(n4) ? isNaN(o2) ? h2 = NaN : (h2 = o2, 1 !== a3 && 0 !== a3 || (p3 = l2)) : (h2 = n4, 1 !== u2 && 0 !== u2 || (p3 = i3));
                else {
                  let t4 = o2 - n4;
                  o2 > n4 && t4 > 180 ? t4 -= 360 : o2 < n4 && n4 - o2 > 180 && (t4 += 360), h2 = n4 + r2 * t4;
                }
                const [f2, d3, y2, m4] = function([t4, e4, r3, n5]) {
                  return t4 = isNaN(t4) ? 0 : t4 * Mt, Ft([r3, Math.cos(t4) * e4, Math.sin(t4) * e4, n5]);
                }([h2, null != p3 ? p3 : Ee(i3, l2, r2), Ee(a3, u2, r2), Ee(s2, c5, r2)]);
                return new qt(f2, d3, y2, m4, false);
              }
              case "lab": {
                const [n4, i3, a3, s2] = Ft(Fe(t3.lab, e3.lab, r2));
                return new qt(n4, i3, a3, s2, false);
              }
            }
          }, array: Fe, padding: function(t3, e3, r2) {
            return new Kt(Fe(t3.values, e3.values, r2));
          } };
          class Le {
            constructor(t3, e3, r2, n3, i3) {
              this.type = t3, this.operator = e3, this.interpolation = r2, this.input = n3, this.labels = [], this.outputs = [];
              for (const [t4, e4] of i3)
                this.labels.push(t4), this.outputs.push(e4);
            }
            static interpolationFactor(t3, e3, r2, n3) {
              let i3 = 0;
              if ("exponential" === t3.name)
                i3 = $e(e3, t3.base, r2, n3);
              else if ("linear" === t3.name)
                i3 = $e(e3, 1, r2, n3);
              else if ("cubic-bezier" === t3.name) {
                const a3 = t3.controlPoints;
                i3 = new o(a3[0], a3[1], a3[2], a3[3]).solve($e(e3, 1, r2, n3));
              }
              return i3;
            }
            static parse(t3, e3) {
              let [r2, n3, i3, ...a3] = t3;
              if (!Array.isArray(n3) || 0 === n3.length)
                return e3.error("Expected an interpolation type expression.", 1);
              if ("linear" === n3[0])
                n3 = { name: "linear" };
              else if ("exponential" === n3[0]) {
                const t4 = n3[1];
                if ("number" != typeof t4)
                  return e3.error("Exponential interpolation requires a numeric base.", 1, 1);
                n3 = { name: "exponential", base: t4 };
              } else {
                if ("cubic-bezier" !== n3[0])
                  return e3.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
                {
                  const t4 = n3.slice(1);
                  if (4 !== t4.length || t4.some((t5) => "number" != typeof t5 || t5 < 0 || t5 > 1))
                    return e3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n3 = { name: "cubic-bezier", controlPoints: t4 };
                }
              }
              if (t3.length - 1 < 4)
                return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
              if ((t3.length - 1) % 2 != 0)
                return e3.error("Expected an even number of arguments.");
              if (i3 = e3.parse(i3, 2, at), !i3)
                return null;
              const s2 = [];
              let o2 = null;
              "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = lt : e3.expectedType && "value" !== e3.expectedType.kind && (o2 = e3.expectedType);
              for (let t4 = 0; t4 < a3.length; t4 += 2) {
                const r3 = a3[t4], n4 = a3[t4 + 1], i4 = t4 + 3, l2 = t4 + 4;
                if ("number" != typeof r3)
                  return e3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i4);
                if (s2.length && s2[s2.length - 1][0] >= r3)
                  return e3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i4);
                const u2 = e3.parse(n4, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, s2.push([r3, u2]);
              }
              return wt(o2, at) || wt(o2, lt) || wt(o2, ft) || wt(o2, yt(at)) ? new Le(o2, r2, n3, i3, s2) : e3.error(`Type ${mt(o2)} is not interpolatable.`);
            }
            evaluate(t3) {
              const e3 = this.labels, r2 = this.outputs;
              if (1 === e3.length)
                return r2[0].evaluate(t3);
              const n3 = this.input.evaluate(t3);
              if (n3 <= e3[0])
                return r2[0].evaluate(t3);
              const i3 = e3.length;
              if (n3 >= e3[i3 - 1])
                return r2[i3 - 1].evaluate(t3);
              const a3 = Ce(e3, n3), s2 = Le.interpolationFactor(this.interpolation, n3, e3[a3], e3[a3 + 1]), o2 = r2[a3].evaluate(t3), l2 = r2[a3 + 1].evaluate(t3);
              switch (this.operator) {
                case "interpolate":
                  return Te[this.type.kind](o2, l2, s2);
                case "interpolate-hcl":
                  return Te.color(o2, l2, s2, "hcl");
                case "interpolate-lab":
                  return Te.color(o2, l2, s2, "lab");
              }
            }
            eachChild(t3) {
              t3(this.input);
              for (const e3 of this.outputs)
                t3(e3);
            }
            outputDefined() {
              return this.outputs.every((t3) => t3.outputDefined());
            }
          }
          function $e(t3, e3, r2, n3) {
            const i3 = n3 - r2, a3 = t3 - r2;
            return 0 === i3 ? 0 : 1 === e3 ? a3 / i3 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i3) - 1);
          }
          class De {
            constructor(t3, e3) {
              this.type = t3, this.args = e3;
            }
            static parse(t3, e3) {
              if (t3.length < 2)
                return e3.error("Expectected at least one argument.");
              let r2 = null;
              const n3 = e3.expectedType;
              n3 && "value" !== n3.kind && (r2 = n3);
              const i3 = [];
              for (const n4 of t3.slice(1)) {
                const t4 = e3.parse(n4, 1 + i3.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t4)
                  return null;
                r2 = r2 || t4.type, i3.push(t4);
              }
              if (!r2)
                throw new Error("No output type");
              const a3 = n3 && i3.some((t4) => xt(n3, t4.type));
              return new De(a3 ? ct : r2, i3);
            }
            evaluate(t3) {
              let e3, r2 = null, n3 = 0;
              for (const i3 of this.args)
                if (n3++, r2 = i3.evaluate(t3), r2 && r2 instanceof Gt && !r2.available && (e3 || (e3 = r2.name), r2 = null, n3 === this.args.length && (r2 = e3)), null !== r2)
                  break;
              return r2;
            }
            eachChild(t3) {
              this.args.forEach(t3);
            }
            outputDefined() {
              return this.args.every((t3) => t3.outputDefined());
            }
          }
          class Oe {
            constructor(t3, e3) {
              this.type = e3.type, this.bindings = [].concat(t3), this.result = e3;
            }
            evaluate(t3) {
              return this.result.evaluate(t3);
            }
            eachChild(t3) {
              for (const e3 of this.bindings)
                t3(e3[1]);
              t3(this.result);
            }
            static parse(t3, e3) {
              if (t3.length < 4)
                return e3.error(`Expected at least 3 arguments, but found ${t3.length - 1} instead.`);
              const r2 = [];
              for (let n4 = 1; n4 < t3.length - 1; n4 += 2) {
                const i3 = t3[n4];
                if ("string" != typeof i3)
                  return e3.error(`Expected string, but found ${typeof i3} instead.`, n4);
                if (/[^a-zA-Z0-9_]/.test(i3))
                  return e3.error("Variable names must contain only alphanumeric characters or '_'.", n4);
                const a3 = e3.parse(t3[n4 + 1], n4 + 1);
                if (!a3)
                  return null;
                r2.push([i3, a3]);
              }
              const n3 = e3.parse(t3[t3.length - 1], t3.length - 1, e3.expectedType, r2);
              return n3 ? new Oe(r2, n3) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
          }
          class Ue {
            constructor(t3, e3, r2) {
              this.type = t3, this.index = e3, this.input = r2;
            }
            static parse(t3, e3) {
              if (3 !== t3.length)
                return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
              const r2 = e3.parse(t3[1], 1, at), n3 = e3.parse(t3[2], 2, yt(e3.expectedType || ct));
              return r2 && n3 ? new Ue(n3.type.itemType, r2, n3) : null;
            }
            evaluate(t3) {
              const e3 = this.index.evaluate(t3), r2 = this.input.evaluate(t3);
              if (e3 < 0)
                throw new Qt(`Array index out of bounds: ${e3} < 0.`);
              if (e3 >= r2.length)
                throw new Qt(`Array index out of bounds: ${e3} > ${r2.length - 1}.`);
              if (e3 !== Math.floor(e3))
                throw new Qt(`Array index must be an integer, but found ${e3} instead.`);
              return r2[e3];
            }
            eachChild(t3) {
              t3(this.index), t3(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class Re {
            constructor(t3, e3) {
              this.type = ot, this.needle = t3, this.haystack = e3;
            }
            static parse(t3, e3) {
              if (3 !== t3.length)
                return e3.error(`Expected 2 arguments, but found ${t3.length - 1} instead.`);
              const r2 = e3.parse(t3[1], 1, ct), n3 = e3.parse(t3[2], 2, ct);
              return r2 && n3 ? vt(r2.type, [ot, st, at, it, ct]) ? new Re(r2, n3) : e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${mt(r2.type)} instead`) : null;
            }
            evaluate(t3) {
              const e3 = this.needle.evaluate(t3), r2 = this.haystack.evaluate(t3);
              if (!r2)
                return false;
              if (!bt(e3, ["boolean", "string", "number", "null"]))
                throw new Qt(`Expected first argument to be of type boolean, string, number or null, but found ${mt(Yt(e3))} instead.`);
              if (!bt(r2, ["string", "array"]))
                throw new Qt(`Expected second argument to be of type array or string, but found ${mt(Yt(r2))} instead.`);
              return r2.indexOf(e3) >= 0;
            }
            eachChild(t3) {
              t3(this.needle), t3(this.haystack);
            }
            outputDefined() {
              return true;
            }
          }
          class qe {
            constructor(t3, e3, r2) {
              this.type = at, this.needle = t3, this.haystack = e3, this.fromIndex = r2;
            }
            static parse(t3, e3) {
              if (t3.length <= 2 || t3.length >= 5)
                return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
              const r2 = e3.parse(t3[1], 1, ct), n3 = e3.parse(t3[2], 2, ct);
              if (!r2 || !n3)
                return null;
              if (!vt(r2.type, [ot, st, at, it, ct]))
                return e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${mt(r2.type)} instead`);
              if (4 === t3.length) {
                const i3 = e3.parse(t3[3], 3, at);
                return i3 ? new qe(r2, n3, i3) : null;
              }
              return new qe(r2, n3);
            }
            evaluate(t3) {
              const e3 = this.needle.evaluate(t3), r2 = this.haystack.evaluate(t3);
              if (!bt(e3, ["boolean", "string", "number", "null"]))
                throw new Qt(`Expected first argument to be of type boolean, string, number or null, but found ${mt(Yt(e3))} instead.`);
              if (!bt(r2, ["string", "array"]))
                throw new Qt(`Expected second argument to be of type array or string, but found ${mt(Yt(r2))} instead.`);
              if (this.fromIndex) {
                const n3 = this.fromIndex.evaluate(t3);
                return r2.indexOf(e3, n3);
              }
              return r2.indexOf(e3);
            }
            eachChild(t3) {
              t3(this.needle), t3(this.haystack), this.fromIndex && t3(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
          }
          class je {
            constructor(t3, e3, r2, n3, i3, a3) {
              this.inputType = t3, this.type = e3, this.input = r2, this.cases = n3, this.outputs = i3, this.otherwise = a3;
            }
            static parse(t3, e3) {
              if (t3.length < 5)
                return e3.error(`Expected at least 4 arguments, but found only ${t3.length - 1}.`);
              if (t3.length % 2 != 1)
                return e3.error("Expected an even number of arguments.");
              let r2, n3;
              e3.expectedType && "value" !== e3.expectedType.kind && (n3 = e3.expectedType);
              const i3 = {}, a3 = [];
              for (let s3 = 2; s3 < t3.length - 1; s3 += 2) {
                let o3 = t3[s3];
                const l2 = t3[s3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e3.concat(s3);
                if (0 === o3.length)
                  return u2.error("Expected at least one branch label.");
                for (const t4 of o3) {
                  if ("number" != typeof t4 && "string" != typeof t4)
                    return u2.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t4 && Math.abs(t4) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t4 && Math.floor(t4) !== t4)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, Yt(t4)))
                      return null;
                  } else
                    r2 = Yt(t4);
                  if (void 0 !== i3[String(t4)])
                    return u2.error("Branch labels must be unique.");
                  i3[String(t4)] = a3.length;
                }
                const c5 = e3.parse(l2, s3, n3);
                if (!c5)
                  return null;
                n3 = n3 || c5.type, a3.push(c5);
              }
              const s2 = e3.parse(t3[1], 1, ct);
              if (!s2)
                return null;
              const o2 = e3.parse(t3[t3.length - 1], t3.length - 1, n3);
              return o2 ? "value" !== s2.type.kind && e3.concat(1).checkSubtype(r2, s2.type) ? null : new je(r2, n3, s2, i3, a3, o2) : null;
            }
            evaluate(t3) {
              const e3 = this.input.evaluate(t3);
              return (Yt(e3) === this.inputType && this.outputs[this.cases[e3]] || this.otherwise).evaluate(t3);
            }
            eachChild(t3) {
              t3(this.input), this.outputs.forEach(t3), t3(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t3) => t3.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class Ne {
            constructor(t3, e3, r2) {
              this.type = t3, this.branches = e3, this.otherwise = r2;
            }
            static parse(t3, e3) {
              if (t3.length < 4)
                return e3.error(`Expected at least 3 arguments, but found only ${t3.length - 1}.`);
              if (t3.length % 2 != 0)
                return e3.error("Expected an odd number of arguments.");
              let r2;
              e3.expectedType && "value" !== e3.expectedType.kind && (r2 = e3.expectedType);
              const n3 = [];
              for (let i4 = 1; i4 < t3.length - 1; i4 += 2) {
                const a3 = e3.parse(t3[i4], i4, ot);
                if (!a3)
                  return null;
                const s2 = e3.parse(t3[i4 + 1], i4 + 1, r2);
                if (!s2)
                  return null;
                n3.push([a3, s2]), r2 = r2 || s2.type;
              }
              const i3 = e3.parse(t3[t3.length - 1], t3.length - 1, r2);
              if (!i3)
                return null;
              if (!r2)
                throw new Error("Can't infer output type");
              return new Ne(r2, n3, i3);
            }
            evaluate(t3) {
              for (const [e3, r2] of this.branches)
                if (e3.evaluate(t3))
                  return r2.evaluate(t3);
              return this.otherwise.evaluate(t3);
            }
            eachChild(t3) {
              for (const [e3, r2] of this.branches)
                t3(e3), t3(r2);
              t3(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t3, e3]) => e3.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class Ze {
            constructor(t3, e3, r2, n3) {
              this.type = t3, this.input = e3, this.beginIndex = r2, this.endIndex = n3;
            }
            static parse(t3, e3) {
              if (t3.length <= 2 || t3.length >= 5)
                return e3.error(`Expected 3 or 4 arguments, but found ${t3.length - 1} instead.`);
              const r2 = e3.parse(t3[1], 1, ct), n3 = e3.parse(t3[2], 2, at);
              if (!r2 || !n3)
                return null;
              if (!vt(r2.type, [yt(ct), st, ct]))
                return e3.error(`Expected first argument to be of type array or string, but found ${mt(r2.type)} instead`);
              if (4 === t3.length) {
                const i3 = e3.parse(t3[3], 3, at);
                return i3 ? new Ze(r2.type, r2, n3, i3) : null;
              }
              return new Ze(r2.type, r2, n3);
            }
            evaluate(t3) {
              const e3 = this.input.evaluate(t3), r2 = this.beginIndex.evaluate(t3);
              if (!bt(e3, ["string", "array"]))
                throw new Qt(`Expected first argument to be of type array or string, but found ${mt(Yt(e3))} instead.`);
              if (this.endIndex) {
                const n3 = this.endIndex.evaluate(t3);
                return e3.slice(r2, n3);
              }
              return e3.slice(r2);
            }
            eachChild(t3) {
              t3(this.input), t3(this.beginIndex), this.endIndex && t3(this.endIndex);
            }
            outputDefined() {
              return false;
            }
          }
          function Ke(t3, e3) {
            return "==" === t3 || "!=" === t3 ? "boolean" === e3.kind || "string" === e3.kind || "number" === e3.kind || "null" === e3.kind || "value" === e3.kind : "string" === e3.kind || "number" === e3.kind || "value" === e3.kind;
          }
          function Ge(t3, e3, r2, n3) {
            return 0 === n3.compare(e3, r2);
          }
          function Je(t3, e3, r2) {
            const n3 = "==" !== t3 && "!=" !== t3;
            return class i3 {
              constructor(t4, e4, r3) {
                this.type = ot, this.lhs = t4, this.rhs = e4, this.collator = r3, this.hasUntypedArgument = "value" === t4.type.kind || "value" === e4.type.kind;
              }
              static parse(t4, e4) {
                if (3 !== t4.length && 4 !== t4.length)
                  return e4.error("Expected two or three arguments.");
                const r3 = t4[0];
                let a3 = e4.parse(t4[1], 1, ct);
                if (!a3)
                  return null;
                if (!Ke(r3, a3.type))
                  return e4.concat(1).error(`"${r3}" comparisons are not supported for type '${mt(a3.type)}'.`);
                let s2 = e4.parse(t4[2], 2, ct);
                if (!s2)
                  return null;
                if (!Ke(r3, s2.type))
                  return e4.concat(2).error(`"${r3}" comparisons are not supported for type '${mt(s2.type)}'.`);
                if (a3.type.kind !== s2.type.kind && "value" !== a3.type.kind && "value" !== s2.type.kind)
                  return e4.error(`Cannot compare types '${mt(a3.type)}' and '${mt(s2.type)}'.`);
                n3 && ("value" === a3.type.kind && "value" !== s2.type.kind ? a3 = new ee(s2.type, [a3]) : "value" !== a3.type.kind && "value" === s2.type.kind && (s2 = new ee(a3.type, [s2])));
                let o2 = null;
                if (4 === t4.length) {
                  if ("string" !== a3.type.kind && "string" !== s2.type.kind && "value" !== a3.type.kind && "value" !== s2.type.kind)
                    return e4.error("Cannot use collator to compare non-string types.");
                  if (o2 = e4.parse(t4[3], 3, ht), !o2)
                    return null;
                }
                return new i3(a3, s2, o2);
              }
              evaluate(i4) {
                const a3 = this.lhs.evaluate(i4), s2 = this.rhs.evaluate(i4);
                if (n3 && this.hasUntypedArgument) {
                  const e4 = Yt(a3), r3 = Yt(s2);
                  if (e4.kind !== r3.kind || "string" !== e4.kind && "number" !== e4.kind)
                    throw new Qt(`Expected arguments for "${t3}" to be (string, string) or (number, number), but found (${e4.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n3 && this.hasUntypedArgument) {
                  const t4 = Yt(a3), r3 = Yt(s2);
                  if ("string" !== t4.kind || "string" !== r3.kind)
                    return e3(i4, a3, s2);
                }
                return this.collator ? r2(i4, a3, s2, this.collator.evaluate(i4)) : e3(i4, a3, s2);
              }
              eachChild(t4) {
                t4(this.lhs), t4(this.rhs), this.collator && t4(this.collator);
              }
              outputDefined() {
                return true;
              }
            };
          }
          const Xe = Je("==", function(t3, e3, r2) {
            return e3 === r2;
          }, Ge), Ye = Je("!=", function(t3, e3, r2) {
            return e3 !== r2;
          }, function(t3, e3, r2, n3) {
            return !Ge(0, e3, r2, n3);
          }), He = Je("<", function(t3, e3, r2) {
            return e3 < r2;
          }, function(t3, e3, r2, n3) {
            return n3.compare(e3, r2) < 0;
          }), We = Je(">", function(t3, e3, r2) {
            return e3 > r2;
          }, function(t3, e3, r2, n3) {
            return n3.compare(e3, r2) > 0;
          }), Qe = Je("<=", function(t3, e3, r2) {
            return e3 <= r2;
          }, function(t3, e3, r2, n3) {
            return n3.compare(e3, r2) <= 0;
          }), tr = Je(">=", function(t3, e3, r2) {
            return e3 >= r2;
          }, function(t3, e3, r2, n3) {
            return n3.compare(e3, r2) >= 0;
          });
          class er {
            constructor(t3, e3, r2, n3, i3) {
              this.type = st, this.number = t3, this.locale = e3, this.currency = r2, this.minFractionDigits = n3, this.maxFractionDigits = i3;
            }
            static parse(t3, e3) {
              if (3 !== t3.length)
                return e3.error("Expected two arguments.");
              const r2 = e3.parse(t3[1], 1, at);
              if (!r2)
                return null;
              const n3 = t3[2];
              if ("object" != typeof n3 || Array.isArray(n3))
                return e3.error("NumberFormat options argument must be an object.");
              let i3 = null;
              if (n3.locale && (i3 = e3.parse(n3.locale, 1, st), !i3))
                return null;
              let a3 = null;
              if (n3.currency && (a3 = e3.parse(n3.currency, 1, st), !a3))
                return null;
              let s2 = null;
              if (n3["min-fraction-digits"] && (s2 = e3.parse(n3["min-fraction-digits"], 1, at), !s2))
                return null;
              let o2 = null;
              return n3["max-fraction-digits"] && (o2 = e3.parse(n3["max-fraction-digits"], 1, at), !o2) ? null : new er(r2, i3, a3, s2, o2);
            }
            evaluate(t3) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t3) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t3) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t3) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t3) : void 0 }).format(this.number.evaluate(t3));
            }
            eachChild(t3) {
              t3(this.number), this.locale && t3(this.locale), this.currency && t3(this.currency), this.minFractionDigits && t3(this.minFractionDigits), this.maxFractionDigits && t3(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
          }
          class rr {
            constructor(t3) {
              this.type = pt, this.sections = t3;
            }
            static parse(t3, e3) {
              if (t3.length < 2)
                return e3.error("Expected at least one argument.");
              const r2 = t3[1];
              if (!Array.isArray(r2) && "object" == typeof r2)
                return e3.error("First argument must be an image or text section.");
              const n3 = [];
              let i3 = false;
              for (let r3 = 1; r3 <= t3.length - 1; ++r3) {
                const a3 = t3[r3];
                if (i3 && "object" == typeof a3 && !Array.isArray(a3)) {
                  i3 = false;
                  let t4 = null;
                  if (a3["font-scale"] && (t4 = e3.parse(a3["font-scale"], 1, at), !t4))
                    return null;
                  let r4 = null;
                  if (a3["text-font"] && (r4 = e3.parse(a3["text-font"], 1, yt(st)), !r4))
                    return null;
                  let s2 = null;
                  if (a3["text-color"] && (s2 = e3.parse(a3["text-color"], 1, lt), !s2))
                    return null;
                  const o2 = n3[n3.length - 1];
                  o2.scale = t4, o2.font = r4, o2.textColor = s2;
                } else {
                  const a4 = e3.parse(t3[r3], 1, ct);
                  if (!a4)
                    return null;
                  const s2 = a4.type.kind;
                  if ("string" !== s2 && "value" !== s2 && "null" !== s2 && "resolvedImage" !== s2)
                    return e3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i3 = true, n3.push({ content: a4, scale: null, font: null, textColor: null });
                }
              }
              return new rr(n3);
            }
            evaluate(t3) {
              return new Zt(this.sections.map((e3) => {
                const r2 = e3.content.evaluate(t3);
                return Yt(r2) === dt ? new Nt("", r2, null, null, null) : new Nt(Ht(r2), null, e3.scale ? e3.scale.evaluate(t3) : null, e3.font ? e3.font.evaluate(t3).join(",") : null, e3.textColor ? e3.textColor.evaluate(t3) : null);
              }));
            }
            eachChild(t3) {
              for (const e3 of this.sections)
                t3(e3.content), e3.scale && t3(e3.scale), e3.font && t3(e3.font), e3.textColor && t3(e3.textColor);
            }
            outputDefined() {
              return false;
            }
          }
          class nr {
            constructor(t3) {
              this.type = dt, this.input = t3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length)
                return e3.error("Expected two arguments.");
              const r2 = e3.parse(t3[1], 1, st);
              return r2 ? new nr(r2) : e3.error("No image name provided.");
            }
            evaluate(t3) {
              const e3 = this.input.evaluate(t3), r2 = Gt.fromString(e3);
              return r2 && t3.availableImages && (r2.available = t3.availableImages.indexOf(e3) > -1), r2;
            }
            eachChild(t3) {
              t3(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class ir {
            constructor(t3) {
              this.type = at, this.input = t3;
            }
            static parse(t3, e3) {
              if (2 !== t3.length)
                return e3.error(`Expected 1 argument, but found ${t3.length - 1} instead.`);
              const r2 = e3.parse(t3[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e3.error(`Expected argument of type string or array, but found ${mt(r2.type)} instead.`) : new ir(r2) : null;
            }
            evaluate(t3) {
              const e3 = this.input.evaluate(t3);
              if ("string" == typeof e3)
                return e3.length;
              if (Array.isArray(e3))
                return e3.length;
              throw new Qt(`Expected value to be of type string or array, but found ${mt(Yt(e3))} instead.`);
            }
            eachChild(t3) {
              t3(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          const ar = { "==": Xe, "!=": Ye, ">": We, "<": He, ">=": tr, "<=": Qe, array: ee, at: Ue, boolean: ee, case: Ne, coalesce: De, collator: oe, format: rr, image: nr, in: Re, "index-of": qe, interpolate: Le, "interpolate-hcl": Le, "interpolate-lab": Le, length: ir, let: Oe, literal: Wt, match: je, number: ee, "number-format": er, object: ee, slice: Ze, step: Ve, string: ee, "to-boolean": ne, "to-color": ne, "to-number": ne, "to-string": ne, var: Se, within: ke };
          function sr(t3, [e3, r2, n3, i3]) {
            e3 = e3.evaluate(t3), r2 = r2.evaluate(t3), n3 = n3.evaluate(t3);
            const a3 = i3 ? i3.evaluate(t3) : 1, s2 = Jt(e3, r2, n3, a3);
            if (s2)
              throw new Qt(s2);
            return new qt(e3 / 255, r2 / 255, n3 / 255, a3, false);
          }
          function or(t3, e3) {
            return t3 in e3;
          }
          function lr(t3, e3) {
            const r2 = e3[t3];
            return void 0 === r2 ? null : r2;
          }
          function ur(t3) {
            return { type: t3 };
          }
          function cr(t3) {
            return { result: "success", value: t3 };
          }
          function hr(t3) {
            return { result: "error", value: t3 };
          }
          function pr(t3) {
            return "data-driven" === t3["property-type"] || "cross-faded-data-driven" === t3["property-type"];
          }
          function fr(t3) {
            return !!t3.expression && t3.expression.parameters.indexOf("zoom") > -1;
          }
          function dr(t3) {
            return !!t3.expression && t3.expression.interpolated;
          }
          function yr(t3) {
            return t3 instanceof Number ? "number" : t3 instanceof String ? "string" : t3 instanceof Boolean ? "boolean" : Array.isArray(t3) ? "array" : null === t3 ? "null" : typeof t3;
          }
          function mr(t3) {
            return "object" == typeof t3 && null !== t3 && !Array.isArray(t3);
          }
          function gr(t3) {
            return t3;
          }
          function xr(t3, e3) {
            const r2 = "color" === e3.type, n3 = t3.stops && "object" == typeof t3.stops[0][0], i3 = n3 || !(n3 || void 0 !== t3.property), a3 = t3.type || (dr(e3) ? "exponential" : "interval");
            if (r2 || "padding" === e3.type) {
              const n4 = r2 ? qt.parse : Kt.parse;
              (t3 = et({}, t3)).stops && (t3.stops = t3.stops.map((t4) => [t4[0], n4(t4[1])])), t3.default = n4(t3.default ? t3.default : e3.default);
            }
            if (t3.colorSpace && "rgb" !== (s2 = t3.colorSpace) && "hcl" !== s2 && "lab" !== s2)
              throw new Error(`Unknown color space: "${t3.colorSpace}"`);
            var s2;
            let o2, l2, u2;
            if ("exponential" === a3)
              o2 = _r;
            else if ("interval" === a3)
              o2 = wr;
            else if ("categorical" === a3) {
              o2 = br, l2 = /* @__PURE__ */ Object.create(null);
              for (const e4 of t3.stops)
                l2[e4[0]] = e4[1];
              u2 = typeof t3.stops[0][0];
            } else {
              if ("identity" !== a3)
                throw new Error(`Unknown function type "${a3}"`);
              o2 = Ar;
            }
            if (n3) {
              const r3 = {}, n4 = [];
              for (let e4 = 0; e4 < t3.stops.length; e4++) {
                const i5 = t3.stops[e4], a5 = i5[0].zoom;
                void 0 === r3[a5] && (r3[a5] = { zoom: a5, type: t3.type, property: t3.property, default: t3.default, stops: [] }, n4.push(a5)), r3[a5].stops.push([i5[0].value, i5[1]]);
              }
              const i4 = [];
              for (const t4 of n4)
                i4.push([r3[t4].zoom, xr(r3[t4], e3)]);
              const a4 = { name: "linear" };
              return { kind: "composite", interpolationType: a4, interpolationFactor: Le.interpolationFactor.bind(void 0, a4), zoomStops: i4.map((t4) => t4[0]), evaluate: ({ zoom: r4 }, n5) => _r({ stops: i4, base: t3.base }, e3, r4).evaluate(r4, n5) };
            }
            if (i3) {
              const r3 = "exponential" === a3 ? { name: "exponential", base: void 0 !== t3.base ? t3.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: Le.interpolationFactor.bind(void 0, r3), zoomStops: t3.stops.map((t4) => t4[0]), evaluate: ({ zoom: r4 }) => o2(t3, e3, r4, l2, u2) };
            }
            return { kind: "source", evaluate(r3, n4) {
              const i4 = n4 && n4.properties ? n4.properties[t3.property] : void 0;
              return void 0 === i4 ? vr(t3.default, e3.default) : o2(t3, e3, i4, l2, u2);
            } };
          }
          function vr(t3, e3, r2) {
            return void 0 !== t3 ? t3 : void 0 !== e3 ? e3 : void 0 !== r2 ? r2 : void 0;
          }
          function br(t3, e3, r2, n3, i3) {
            return vr(typeof r2 === i3 ? n3[r2] : void 0, t3.default, e3.default);
          }
          function wr(t3, e3, r2) {
            if ("number" !== yr(r2))
              return vr(t3.default, e3.default);
            const n3 = t3.stops.length;
            if (1 === n3)
              return t3.stops[0][1];
            if (r2 <= t3.stops[0][0])
              return t3.stops[0][1];
            if (r2 >= t3.stops[n3 - 1][0])
              return t3.stops[n3 - 1][1];
            const i3 = Ce(t3.stops.map((t4) => t4[0]), r2);
            return t3.stops[i3][1];
          }
          function _r(t3, e3, r2) {
            const n3 = void 0 !== t3.base ? t3.base : 1;
            if ("number" !== yr(r2))
              return vr(t3.default, e3.default);
            const i3 = t3.stops.length;
            if (1 === i3)
              return t3.stops[0][1];
            if (r2 <= t3.stops[0][0])
              return t3.stops[0][1];
            if (r2 >= t3.stops[i3 - 1][0])
              return t3.stops[i3 - 1][1];
            const a3 = Ce(t3.stops.map((t4) => t4[0]), r2), s2 = function(t4, e4, r3, n4) {
              const i4 = n4 - r3, a4 = t4 - r3;
              return 0 === i4 ? 0 : 1 === e4 ? a4 / i4 : (Math.pow(e4, a4) - 1) / (Math.pow(e4, i4) - 1);
            }(r2, n3, t3.stops[a3][0], t3.stops[a3 + 1][0]), o2 = t3.stops[a3][1], l2 = t3.stops[a3 + 1][1], u2 = Te[e3.type] || gr;
            return "function" == typeof o2.evaluate ? { evaluate(...e4) {
              const r3 = o2.evaluate.apply(void 0, e4), n4 = l2.evaluate.apply(void 0, e4);
              if (void 0 !== r3 && void 0 !== n4)
                return u2(r3, n4, s2, t3.colorSpace);
            } } : u2(o2, l2, s2, t3.colorSpace);
          }
          function Ar(t3, e3, r2) {
            switch (e3.type) {
              case "color":
                r2 = qt.parse(r2);
                break;
              case "formatted":
                r2 = Zt.fromString(r2.toString());
                break;
              case "resolvedImage":
                r2 = Gt.fromString(r2.toString());
                break;
              case "padding":
                r2 = Kt.parse(r2);
                break;
              default:
                yr(r2) === e3.type || "enum" === e3.type && e3.values[r2] || (r2 = void 0);
            }
            return vr(r2, t3.default, e3.default);
          }
          Ie.register(ar, { error: [{ kind: "error" }, [st], (t3, [e3]) => {
            throw new Qt(e3.evaluate(t3));
          }], typeof: [st, [ct], (t3, [e3]) => mt(Yt(e3.evaluate(t3)))], "to-rgba": [yt(at, 4), [lt], (t3, [e3]) => {
            const [r2, n3, i3, a3] = e3.evaluate(t3).rgb;
            return [255 * r2, 255 * n3, 255 * i3, a3];
          }], rgb: [lt, [at, at, at], sr], rgba: [lt, [at, at, at, at], sr], has: { type: ot, overloads: [[[st], (t3, [e3]) => or(e3.evaluate(t3), t3.properties())], [[st, ut], (t3, [e3, r2]) => or(e3.evaluate(t3), r2.evaluate(t3))]] }, get: { type: ct, overloads: [[[st], (t3, [e3]) => lr(e3.evaluate(t3), t3.properties())], [[st, ut], (t3, [e3, r2]) => lr(e3.evaluate(t3), r2.evaluate(t3))]] }, "feature-state": [ct, [st], (t3, [e3]) => lr(e3.evaluate(t3), t3.featureState || {})], properties: [ut, [], (t3) => t3.properties()], "geometry-type": [st, [], (t3) => t3.geometryType()], id: [ct, [], (t3) => t3.id()], zoom: [at, [], (t3) => t3.globals.zoom], "heatmap-density": [at, [], (t3) => t3.globals.heatmapDensity || 0], "line-progress": [at, [], (t3) => t3.globals.lineProgress || 0], accumulated: [ct, [], (t3) => void 0 === t3.globals.accumulated ? null : t3.globals.accumulated], "+": [at, ur(at), (t3, e3) => {
            let r2 = 0;
            for (const n3 of e3)
              r2 += n3.evaluate(t3);
            return r2;
          }], "*": [at, ur(at), (t3, e3) => {
            let r2 = 1;
            for (const n3 of e3)
              r2 *= n3.evaluate(t3);
            return r2;
          }], "-": { type: at, overloads: [[[at, at], (t3, [e3, r2]) => e3.evaluate(t3) - r2.evaluate(t3)], [[at], (t3, [e3]) => -e3.evaluate(t3)]] }, "/": [at, [at, at], (t3, [e3, r2]) => e3.evaluate(t3) / r2.evaluate(t3)], "%": [at, [at, at], (t3, [e3, r2]) => e3.evaluate(t3) % r2.evaluate(t3)], ln2: [at, [], () => Math.LN2], pi: [at, [], () => Math.PI], e: [at, [], () => Math.E], "^": [at, [at, at], (t3, [e3, r2]) => Math.pow(e3.evaluate(t3), r2.evaluate(t3))], sqrt: [at, [at], (t3, [e3]) => Math.sqrt(e3.evaluate(t3))], log10: [at, [at], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN10], ln: [at, [at], (t3, [e3]) => Math.log(e3.evaluate(t3))], log2: [at, [at], (t3, [e3]) => Math.log(e3.evaluate(t3)) / Math.LN2], sin: [at, [at], (t3, [e3]) => Math.sin(e3.evaluate(t3))], cos: [at, [at], (t3, [e3]) => Math.cos(e3.evaluate(t3))], tan: [at, [at], (t3, [e3]) => Math.tan(e3.evaluate(t3))], asin: [at, [at], (t3, [e3]) => Math.asin(e3.evaluate(t3))], acos: [at, [at], (t3, [e3]) => Math.acos(e3.evaluate(t3))], atan: [at, [at], (t3, [e3]) => Math.atan(e3.evaluate(t3))], min: [at, ur(at), (t3, e3) => Math.min(...e3.map((e4) => e4.evaluate(t3)))], max: [at, ur(at), (t3, e3) => Math.max(...e3.map((e4) => e4.evaluate(t3)))], abs: [at, [at], (t3, [e3]) => Math.abs(e3.evaluate(t3))], round: [at, [at], (t3, [e3]) => {
            const r2 = e3.evaluate(t3);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [at, [at], (t3, [e3]) => Math.floor(e3.evaluate(t3))], ceil: [at, [at], (t3, [e3]) => Math.ceil(e3.evaluate(t3))], "filter-==": [ot, [st, ct], (t3, [e3, r2]) => t3.properties()[e3.value] === r2.value], "filter-id-==": [ot, [ct], (t3, [e3]) => t3.id() === e3.value], "filter-type-==": [ot, [st], (t3, [e3]) => t3.geometryType() === e3.value], "filter-<": [ot, [st, ct], (t3, [e3, r2]) => {
            const n3 = t3.properties()[e3.value], i3 = r2.value;
            return typeof n3 == typeof i3 && n3 < i3;
          }], "filter-id-<": [ot, [ct], (t3, [e3]) => {
            const r2 = t3.id(), n3 = e3.value;
            return typeof r2 == typeof n3 && r2 < n3;
          }], "filter->": [ot, [st, ct], (t3, [e3, r2]) => {
            const n3 = t3.properties()[e3.value], i3 = r2.value;
            return typeof n3 == typeof i3 && n3 > i3;
          }], "filter-id->": [ot, [ct], (t3, [e3]) => {
            const r2 = t3.id(), n3 = e3.value;
            return typeof r2 == typeof n3 && r2 > n3;
          }], "filter-<=": [ot, [st, ct], (t3, [e3, r2]) => {
            const n3 = t3.properties()[e3.value], i3 = r2.value;
            return typeof n3 == typeof i3 && n3 <= i3;
          }], "filter-id-<=": [ot, [ct], (t3, [e3]) => {
            const r2 = t3.id(), n3 = e3.value;
            return typeof r2 == typeof n3 && r2 <= n3;
          }], "filter->=": [ot, [st, ct], (t3, [e3, r2]) => {
            const n3 = t3.properties()[e3.value], i3 = r2.value;
            return typeof n3 == typeof i3 && n3 >= i3;
          }], "filter-id->=": [ot, [ct], (t3, [e3]) => {
            const r2 = t3.id(), n3 = e3.value;
            return typeof r2 == typeof n3 && r2 >= n3;
          }], "filter-has": [ot, [ct], (t3, [e3]) => e3.value in t3.properties()], "filter-has-id": [ot, [], (t3) => null !== t3.id() && void 0 !== t3.id()], "filter-type-in": [ot, [yt(st)], (t3, [e3]) => e3.value.indexOf(t3.geometryType()) >= 0], "filter-id-in": [ot, [yt(ct)], (t3, [e3]) => e3.value.indexOf(t3.id()) >= 0], "filter-in-small": [ot, [st, yt(ct)], (t3, [e3, r2]) => r2.value.indexOf(t3.properties()[e3.value]) >= 0], "filter-in-large": [ot, [st, yt(ct)], (t3, [e3, r2]) => function(t4, e4, r3, n3) {
            for (; r3 <= n3; ) {
              const i3 = r3 + n3 >> 1;
              if (e4[i3] === t4)
                return true;
              e4[i3] > t4 ? n3 = i3 - 1 : r3 = i3 + 1;
            }
            return false;
          }(t3.properties()[e3.value], r2.value, 0, r2.value.length - 1)], all: { type: ot, overloads: [[[ot, ot], (t3, [e3, r2]) => e3.evaluate(t3) && r2.evaluate(t3)], [ur(ot), (t3, e3) => {
            for (const r2 of e3)
              if (!r2.evaluate(t3))
                return false;
            return true;
          }]] }, any: { type: ot, overloads: [[[ot, ot], (t3, [e3, r2]) => e3.evaluate(t3) || r2.evaluate(t3)], [ur(ot), (t3, e3) => {
            for (const r2 of e3)
              if (r2.evaluate(t3))
                return true;
            return false;
          }]] }, "!": [ot, [ot], (t3, [e3]) => !e3.evaluate(t3)], "is-supported-script": [ot, [st], (t3, [e3]) => {
            const r2 = t3.globals && t3.globals.isSupportedScript;
            return !r2 || r2(e3.evaluate(t3));
          }], upcase: [st, [st], (t3, [e3]) => e3.evaluate(t3).toUpperCase()], downcase: [st, [st], (t3, [e3]) => e3.evaluate(t3).toLowerCase()], concat: [st, ur(ct), (t3, e3) => e3.map((e4) => Ht(e4.evaluate(t3))).join("")], "resolved-locale": [st, [ht], (t3, [e3]) => e3.evaluate(t3).resolvedLocale()] });
          class kr {
            constructor(t3, e3) {
              var r2;
              this.expression = t3, this._warningHistory = {}, this._evaluator = new ae(), this._defaultValue = e3 ? "color" === (r2 = e3).type && mr(r2.default) ? new qt(0, 0, 0, 0) : "color" === r2.type ? qt.parse(r2.default) || null : "padding" === r2.type ? Kt.parse(r2.default) || null : void 0 === r2.default ? null : r2.default : null, this._enumValues = e3 && "enum" === e3.type ? e3.values : null;
            }
            evaluateWithoutErrorHandling(t3, e3, r2, n3, i3, a3) {
              return this._evaluator.globals = t3, this._evaluator.feature = e3, this._evaluator.featureState = r2, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3, this.expression.evaluate(this._evaluator);
            }
            evaluate(t3, e3, r2, n3, i3, a3) {
              this._evaluator.globals = t3, this._evaluator.feature = e3 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n3, this._evaluator.availableImages = i3 || null, this._evaluator.formattedSection = a3 || null;
              try {
                const t4 = this.expression.evaluate(this._evaluator);
                if (null == t4 || "number" == typeof t4 && t4 != t4)
                  return this._defaultValue;
                if (this._enumValues && !(t4 in this._enumValues))
                  throw new Qt(`Expected value to be one of ${Object.keys(this._enumValues).map((t5) => JSON.stringify(t5)).join(", ")}, but found ${JSON.stringify(t4)} instead.`);
                return t4;
              } catch (t4) {
                return this._warningHistory[t4.message] || (this._warningHistory[t4.message] = true, "undefined" != typeof console && console.warn(t4.message)), this._defaultValue;
              }
            }
          }
          function Sr(t3) {
            return Array.isArray(t3) && t3.length > 0 && "string" == typeof t3[0] && t3[0] in ar;
          }
          function Ir(t3, e3) {
            const r2 = new se(ar, ze, [], e3 ? function(t4) {
              const e4 = { color: lt, string: st, number: at, enum: st, boolean: ot, formatted: pt, padding: ft, resolvedImage: dt };
              return "array" === t4.type ? yt(e4[t4.value] || ct, t4.length) : e4[t4.type];
            }(e3) : void 0), n3 = r2.parse(t3, void 0, void 0, void 0, e3 && "string" === e3.type ? { typeAnnotation: "coerce" } : void 0);
            return n3 ? cr(new kr(n3, e3)) : hr(r2.errors);
          }
          class zr {
            constructor(t3, e3) {
              this.kind = t3, this._styleExpression = e3, this.isStateDependent = "constant" !== t3 && !Pe(e3.expression);
            }
            evaluateWithoutErrorHandling(t3, e3, r2, n3, i3, a3) {
              return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r2, n3, i3, a3);
            }
            evaluate(t3, e3, r2, n3, i3, a3) {
              return this._styleExpression.evaluate(t3, e3, r2, n3, i3, a3);
            }
          }
          class Mr {
            constructor(t3, e3, r2, n3) {
              this.kind = t3, this.zoomStops = r2, this._styleExpression = e3, this.isStateDependent = "camera" !== t3 && !Pe(e3.expression), this.interpolationType = n3;
            }
            evaluateWithoutErrorHandling(t3, e3, r2, n3, i3, a3) {
              return this._styleExpression.evaluateWithoutErrorHandling(t3, e3, r2, n3, i3, a3);
            }
            evaluate(t3, e3, r2, n3, i3, a3) {
              return this._styleExpression.evaluate(t3, e3, r2, n3, i3, a3);
            }
            interpolationFactor(t3, e3, r2) {
              return this.interpolationType ? Le.interpolationFactor(this.interpolationType, t3, e3, r2) : 0;
            }
          }
          function Pr(t3, e3) {
            const r2 = Ir(t3, e3);
            if ("error" === r2.result)
              return r2;
            const n3 = r2.value.expression, i3 = Me(n3);
            if (!i3 && !pr(e3))
              return hr([new rt("", "data expressions not supported")]);
            const a3 = Be(n3, ["zoom"]);
            if (!a3 && !fr(e3))
              return hr([new rt("", "zoom expressions not supported")]);
            const s2 = Cr(n3);
            return s2 || a3 ? s2 instanceof rt ? hr([s2]) : s2 instanceof Le && !dr(e3) ? hr([new rt("", '"interpolate" expressions cannot be used with this property')]) : cr(s2 ? new Mr(i3 ? "camera" : "composite", r2.value, s2.labels, s2 instanceof Le ? s2.interpolation : void 0) : new zr(i3 ? "constant" : "source", r2.value)) : hr([new rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class Br {
            constructor(t3, e3) {
              this._parameters = t3, this._specification = e3, et(this, xr(this._parameters, this._specification));
            }
            static deserialize(t3) {
              return new Br(t3._parameters, t3._specification);
            }
            static serialize(t3) {
              return { _parameters: t3._parameters, _specification: t3._specification };
            }
          }
          function Cr(t3) {
            let e3 = null;
            if (t3 instanceof Oe)
              e3 = Cr(t3.result);
            else if (t3 instanceof De) {
              for (const r2 of t3.args)
                if (e3 = Cr(r2), e3)
                  break;
            } else
              (t3 instanceof Ve || t3 instanceof Le) && t3.input instanceof Ie && "zoom" === t3.input.name && (e3 = t3);
            return e3 instanceof rt || t3.eachChild((t4) => {
              const r2 = Cr(t4);
              r2 instanceof rt ? e3 = r2 : !e3 && r2 ? e3 = new rt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e3 && r2 && e3 !== r2 && (e3 = new rt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e3;
          }
          function Vr(t3) {
            if (true === t3 || false === t3)
              return true;
            if (!Array.isArray(t3) || 0 === t3.length)
              return false;
            switch (t3[0]) {
              case "has":
                return t3.length >= 2 && "$id" !== t3[1] && "$type" !== t3[1];
              case "in":
                return t3.length >= 3 && ("string" != typeof t3[1] || Array.isArray(t3[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t3.length || Array.isArray(t3[1]) || Array.isArray(t3[2]);
              case "any":
              case "all":
                for (const e3 of t3.slice(1))
                  if (!Vr(e3) && "boolean" != typeof e3)
                    return false;
                return true;
              default:
                return true;
            }
          }
          const Er = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function Fr(t3) {
            if (null == t3)
              return { filter: () => true, needGeometry: false };
            Vr(t3) || (t3 = $r(t3));
            const e3 = Ir(t3, Er);
            if ("error" === e3.result)
              throw new Error(e3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
            return { filter: (t4, r2, n3) => e3.value.evaluate(t4, r2, {}, n3), needGeometry: Lr(t3) };
          }
          function Tr(t3, e3) {
            return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
          }
          function Lr(t3) {
            if (!Array.isArray(t3))
              return false;
            if ("within" === t3[0])
              return true;
            for (let e3 = 1; e3 < t3.length; e3++)
              if (Lr(t3[e3]))
                return true;
            return false;
          }
          function $r(t3) {
            if (!t3)
              return true;
            const e3 = t3[0];
            return t3.length <= 1 ? "any" !== e3 : "==" === e3 ? Dr(t3[1], t3[2], "==") : "!=" === e3 ? Rr(Dr(t3[1], t3[2], "==")) : "<" === e3 || ">" === e3 || "<=" === e3 || ">=" === e3 ? Dr(t3[1], t3[2], e3) : "any" === e3 ? (r2 = t3.slice(1), ["any"].concat(r2.map($r))) : "all" === e3 ? ["all"].concat(t3.slice(1).map($r)) : "none" === e3 ? ["all"].concat(t3.slice(1).map($r).map(Rr)) : "in" === e3 ? Or(t3[1], t3.slice(2)) : "!in" === e3 ? Rr(Or(t3[1], t3.slice(2))) : "has" === e3 ? Ur(t3[1]) : "!has" === e3 ? Rr(Ur(t3[1])) : "within" !== e3 || t3;
            var r2;
          }
          function Dr(t3, e3, r2) {
            switch (t3) {
              case "$type":
                return [`filter-type-${r2}`, e3];
              case "$id":
                return [`filter-id-${r2}`, e3];
              default:
                return [`filter-${r2}`, t3, e3];
            }
          }
          function Or(t3, e3) {
            if (0 === e3.length)
              return false;
            switch (t3) {
              case "$type":
                return ["filter-type-in", ["literal", e3]];
              case "$id":
                return ["filter-id-in", ["literal", e3]];
              default:
                return e3.length > 200 && !e3.some((t4) => typeof t4 != typeof e3[0]) ? ["filter-in-large", t3, ["literal", e3.sort(Tr)]] : ["filter-in-small", t3, ["literal", e3]];
            }
          }
          function Ur(t3) {
            switch (t3) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t3];
            }
          }
          function Rr(t3) {
            return ["!", t3];
          }
          function qr(t3) {
            const e3 = typeof t3;
            if ("number" === e3 || "boolean" === e3 || "string" === e3 || null == t3)
              return JSON.stringify(t3);
            if (Array.isArray(t3)) {
              let e4 = "[";
              for (const r3 of t3)
                e4 += `${qr(r3)},`;
              return `${e4}]`;
            }
            const r2 = Object.keys(t3).sort();
            let n3 = "{";
            for (let e4 = 0; e4 < r2.length; e4++)
              n3 += `${JSON.stringify(r2[e4])}:${qr(t3[r2[e4]])},`;
            return `${n3}}`;
          }
          function jr(t3) {
            let e3 = "";
            for (const r2 of j)
              e3 += `/${qr(t3[r2])}`;
            return e3;
          }
          function Nr(t3) {
            const e3 = t3.value;
            return e3 ? [new tt(t3.key, e3, "constants have been deprecated as of v8")] : [];
          }
          function Zr(t3) {
            return t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean ? t3.valueOf() : t3;
          }
          function Kr(t3) {
            if (Array.isArray(t3))
              return t3.map(Kr);
            if (t3 instanceof Object && !(t3 instanceof Number || t3 instanceof String || t3 instanceof Boolean)) {
              const e3 = {};
              for (const r2 in t3)
                e3[r2] = Kr(t3[r2]);
              return e3;
            }
            return Zr(t3);
          }
          function Gr(t3) {
            const e3 = t3.key, r2 = t3.value, n3 = t3.valueSpec || {}, i3 = t3.objectElementValidators || {}, a3 = t3.style, s2 = t3.styleSpec, o2 = t3.validateSpec;
            let l2 = [];
            const u2 = yr(r2);
            if ("object" !== u2)
              return [new tt(e3, r2, `object expected, ${u2} found`)];
            for (const t4 in r2) {
              const u3 = t4.split(".")[0], c5 = n3[u3] || n3["*"];
              let h2;
              if (i3[u3])
                h2 = i3[u3];
              else if (n3[u3])
                h2 = o2;
              else if (i3["*"])
                h2 = i3["*"];
              else {
                if (!n3["*"]) {
                  l2.push(new tt(e3, r2[t4], `unknown property "${t4}"`));
                  continue;
                }
                h2 = o2;
              }
              l2 = l2.concat(h2({ key: (e3 ? `${e3}.` : e3) + t4, value: r2[t4], valueSpec: c5, style: a3, styleSpec: s2, object: r2, objectKey: t4, validateSpec: o2 }, r2));
            }
            for (const t4 in n3)
              i3[t4] || n3[t4].required && void 0 === n3[t4].default && void 0 === r2[t4] && l2.push(new tt(e3, r2, `missing required property "${t4}"`));
            return l2;
          }
          function Jr(t3) {
            const e3 = t3.value, r2 = t3.valueSpec, n3 = t3.style, i3 = t3.styleSpec, a3 = t3.key, s2 = t3.arrayElementValidator || t3.validateSpec;
            if ("array" !== yr(e3))
              return [new tt(a3, e3, `array expected, ${yr(e3)} found`)];
            if (r2.length && e3.length !== r2.length)
              return [new tt(a3, e3, `array length ${r2.length} expected, length ${e3.length} found`)];
            if (r2["min-length"] && e3.length < r2["min-length"])
              return [new tt(a3, e3, `array length at least ${r2["min-length"]} expected, length ${e3.length} found`)];
            let o2 = { type: r2.value, values: r2.values };
            i3.$version < 7 && (o2.function = r2.function), "object" === yr(r2.value) && (o2 = r2.value);
            let l2 = [];
            for (let r3 = 0; r3 < e3.length; r3++)
              l2 = l2.concat(s2({ array: e3, arrayIndex: r3, value: e3[r3], valueSpec: o2, validateSpec: t3.validateSpec, style: n3, styleSpec: i3, key: `${a3}[${r3}]` }));
            return l2;
          }
          function Xr(t3) {
            const e3 = t3.key, r2 = t3.value, n3 = t3.valueSpec;
            let i3 = yr(r2);
            return "number" === i3 && r2 != r2 && (i3 = "NaN"), "number" !== i3 ? [new tt(e3, r2, `number expected, ${i3} found`)] : "minimum" in n3 && r2 < n3.minimum ? [new tt(e3, r2, `${r2} is less than the minimum value ${n3.minimum}`)] : "maximum" in n3 && r2 > n3.maximum ? [new tt(e3, r2, `${r2} is greater than the maximum value ${n3.maximum}`)] : [];
          }
          function Yr(t3) {
            const e3 = t3.valueSpec, r2 = Zr(t3.value.type);
            let n3, i3, a3, s2 = {};
            const o2 = "categorical" !== r2 && void 0 === t3.value.property, l2 = !o2, u2 = "array" === yr(t3.value.stops) && "array" === yr(t3.value.stops[0]) && "object" === yr(t3.value.stops[0][0]), c5 = Gr({ key: t3.key, value: t3.value, valueSpec: t3.styleSpec.function, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { stops: function(t4) {
              if ("identity" === r2)
                return [new tt(t4.key, t4.value, 'identity function may not have a "stops" property')];
              let e4 = [];
              const n4 = t4.value;
              return e4 = e4.concat(Jr({ key: t4.key, value: n4, valueSpec: t4.valueSpec, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, arrayElementValidator: h2 })), "array" === yr(n4) && 0 === n4.length && e4.push(new tt(t4.key, n4, "array must have at least one stop")), e4;
            }, default: function(t4) {
              return t4.validateSpec({ key: t4.key, value: t4.value, valueSpec: e3, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec });
            } } });
            return "identity" === r2 && o2 && c5.push(new tt(t3.key, t3.value, 'missing required property "property"')), "identity" === r2 || t3.value.stops || c5.push(new tt(t3.key, t3.value, 'missing required property "stops"')), "exponential" === r2 && t3.valueSpec.expression && !dr(t3.valueSpec) && c5.push(new tt(t3.key, t3.value, "exponential functions not supported")), t3.styleSpec.$version >= 8 && (l2 && !pr(t3.valueSpec) ? c5.push(new tt(t3.key, t3.value, "property functions not supported")) : o2 && !fr(t3.valueSpec) && c5.push(new tt(t3.key, t3.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t3.value.property || c5.push(new tt(t3.key, t3.value, '"property" property is required')), c5;
            function h2(t4) {
              let r3 = [];
              const n4 = t4.value, o3 = t4.key;
              if ("array" !== yr(n4))
                return [new tt(o3, n4, `array expected, ${yr(n4)} found`)];
              if (2 !== n4.length)
                return [new tt(o3, n4, `array length 2 expected, length ${n4.length} found`)];
              if (u2) {
                if ("object" !== yr(n4[0]))
                  return [new tt(o3, n4, `object expected, ${yr(n4[0])} found`)];
                if (void 0 === n4[0].zoom)
                  return [new tt(o3, n4, "object stop key must have zoom")];
                if (void 0 === n4[0].value)
                  return [new tt(o3, n4, "object stop key must have value")];
                if (a3 && a3 > Zr(n4[0].zoom))
                  return [new tt(o3, n4[0].zoom, "stop zoom values must appear in ascending order")];
                Zr(n4[0].zoom) !== a3 && (a3 = Zr(n4[0].zoom), i3 = void 0, s2 = {}), r3 = r3.concat(Gr({ key: `${o3}[0]`, value: n4[0], valueSpec: { zoom: {} }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { zoom: Xr, value: p3 } }));
              } else
                r3 = r3.concat(p3({ key: `${o3}[0]`, value: n4[0], valueSpec: {}, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }, n4));
              return Sr(Kr(n4[1])) ? r3.concat([new tt(`${o3}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r3.concat(t4.validateSpec({ key: `${o3}[1]`, value: n4[1], valueSpec: e3, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec }));
            }
            function p3(t4, a4) {
              const o3 = yr(t4.value), l3 = Zr(t4.value), u3 = null !== t4.value ? t4.value : a4;
              if (n3) {
                if (o3 !== n3)
                  return [new tt(t4.key, u3, `${o3} stop domain type must match previous stop domain type ${n3}`)];
              } else
                n3 = o3;
              if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
                return [new tt(t4.key, u3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o3 && "categorical" !== r2) {
                let n4 = `number expected, ${o3} found`;
                return pr(e3) && void 0 === r2 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new tt(t4.key, u3, n4)];
              }
              return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i3 && l3 < i3 ? [new tt(t4.key, u3, "stop domain values must appear in ascending order")] : (i3 = l3, "categorical" === r2 && l3 in s2 ? [new tt(t4.key, u3, "stop domain values must be unique")] : (s2[l3] = true, [])) : [new tt(t4.key, u3, `integer expected, found ${l3}`)];
            }
          }
          function Hr(t3) {
            const e3 = ("property" === t3.expressionContext ? Pr : Ir)(Kr(t3.value), t3.valueSpec);
            if ("error" === e3.result)
              return e3.value.map((e4) => new tt(`${t3.key}${e4.key}`, t3.value, e4.message));
            const r2 = e3.value.expression || e3.value._styleExpression.expression;
            if ("property" === t3.expressionContext && "text-font" === t3.propertyKey && !r2.outputDefined())
              return [new tt(t3.key, t3.value, `Invalid data expression for "${t3.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t3.expressionContext && "layout" === t3.propertyType && !Pe(r2))
              return [new tt(t3.key, t3.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t3.expressionContext && !Pe(r2))
              return [new tt(t3.key, t3.value, '"feature-state" data expressions are not supported with filters.')];
            if (t3.expressionContext && 0 === t3.expressionContext.indexOf("cluster")) {
              if (!Be(r2, ["zoom", "feature-state"]))
                return [new tt(t3.key, t3.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t3.expressionContext && !Me(r2))
                return [new tt(t3.key, t3.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function Wr(t3) {
            const e3 = t3.key, r2 = t3.value, n3 = t3.valueSpec, i3 = [];
            return Array.isArray(n3.values) ? -1 === n3.values.indexOf(Zr(r2)) && i3.push(new tt(e3, r2, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n3.values).indexOf(Zr(r2)) && i3.push(new tt(e3, r2, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r2)} found`)), i3;
          }
          function Qr(t3) {
            return Vr(Kr(t3.value)) ? Hr(et({}, t3, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : tn(t3);
          }
          function tn(t3) {
            const e3 = t3.value, r2 = t3.key;
            if ("array" !== yr(e3))
              return [new tt(r2, e3, `array expected, ${yr(e3)} found`)];
            const n3 = t3.styleSpec;
            let i3, a3 = [];
            if (e3.length < 1)
              return [new tt(r2, e3, "filter array must have at least 1 element")];
            switch (a3 = a3.concat(Wr({ key: `${r2}[0]`, value: e3[0], valueSpec: n3.filter_operator, style: t3.style, styleSpec: t3.styleSpec })), Zr(e3[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e3.length >= 2 && "$type" === Zr(e3[1]) && a3.push(new tt(r2, e3, `"$type" cannot be use with operator "${e3[0]}"`));
              case "==":
              case "!=":
                3 !== e3.length && a3.push(new tt(r2, e3, `filter array for operator "${e3[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e3.length >= 2 && (i3 = yr(e3[1]), "string" !== i3 && a3.push(new tt(`${r2}[1]`, e3[1], `string expected, ${i3} found`)));
                for (let s2 = 2; s2 < e3.length; s2++)
                  i3 = yr(e3[s2]), "$type" === Zr(e3[1]) ? a3 = a3.concat(Wr({ key: `${r2}[${s2}]`, value: e3[s2], valueSpec: n3.geometry_type, style: t3.style, styleSpec: t3.styleSpec })) : "string" !== i3 && "number" !== i3 && "boolean" !== i3 && a3.push(new tt(`${r2}[${s2}]`, e3[s2], `string, number, or boolean expected, ${i3} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n4 = 1; n4 < e3.length; n4++)
                  a3 = a3.concat(tn({ key: `${r2}[${n4}]`, value: e3[n4], style: t3.style, styleSpec: t3.styleSpec }));
                break;
              case "has":
              case "!has":
                i3 = yr(e3[1]), 2 !== e3.length ? a3.push(new tt(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "string" !== i3 && a3.push(new tt(`${r2}[1]`, e3[1], `string expected, ${i3} found`));
                break;
              case "within":
                i3 = yr(e3[1]), 2 !== e3.length ? a3.push(new tt(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "object" !== i3 && a3.push(new tt(`${r2}[1]`, e3[1], `object expected, ${i3} found`));
            }
            return a3;
          }
          function en(t3, e3) {
            const r2 = t3.key, n3 = t3.validateSpec, i3 = t3.style, a3 = t3.styleSpec, s2 = t3.value, o2 = t3.objectKey, l2 = a3[`${e3}_${t3.layerType}`];
            if (!l2)
              return [];
            const u2 = o2.match(/^(.*)-transition$/);
            if ("paint" === e3 && u2 && l2[u2[1]] && l2[u2[1]].transition)
              return n3({ key: r2, value: s2, valueSpec: a3.transition, style: i3, styleSpec: a3 });
            const c5 = t3.valueSpec || l2[o2];
            if (!c5)
              return [new tt(r2, s2, `unknown property "${o2}"`)];
            let h2;
            if ("string" === yr(s2) && pr(c5) && !c5.tokens && (h2 = /^{([^}]+)}$/.exec(s2)))
              return [new tt(r2, s2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
            const p3 = [];
            return "symbol" === t3.layerType && ("text-field" === o2 && i3 && !i3.glyphs && p3.push(new tt(r2, s2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && mr(Kr(s2)) && "identity" === Zr(s2.type) && p3.push(new tt(r2, s2, '"text-font" does not support identity functions'))), p3.concat(n3({ key: t3.key, value: s2, valueSpec: c5, style: i3, styleSpec: a3, expressionContext: "property", propertyType: e3, propertyKey: o2 }));
          }
          function rn(t3) {
            return en(t3, "paint");
          }
          function nn(t3) {
            return en(t3, "layout");
          }
          function an(t3) {
            let e3 = [];
            const r2 = t3.value, n3 = t3.key, i3 = t3.style, a3 = t3.styleSpec;
            r2.type || r2.ref || e3.push(new tt(n3, r2, 'either "type" or "ref" is required'));
            let s2 = Zr(r2.type);
            const o2 = Zr(r2.ref);
            if (r2.id) {
              const a4 = Zr(r2.id);
              for (let s3 = 0; s3 < t3.arrayIndex; s3++) {
                const t4 = i3.layers[s3];
                Zr(t4.id) === a4 && e3.push(new tt(n3, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t4.id.__line__}`));
              }
            }
            if ("ref" in r2) {
              let t4;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t5) => {
                t5 in r2 && e3.push(new tt(n3, r2[t5], `"${t5}" is prohibited for ref layers`));
              }), i3.layers.forEach((e4) => {
                Zr(e4.id) === o2 && (t4 = e4);
              }), t4 ? t4.ref ? e3.push(new tt(n3, r2.ref, "ref cannot reference another ref layer")) : s2 = Zr(t4.type) : e3.push(new tt(n3, r2.ref, `ref layer "${o2}" not found`));
            } else if ("background" !== s2)
              if (r2.source) {
                const t4 = i3.sources && i3.sources[r2.source], a4 = t4 && Zr(t4.type);
                t4 ? "vector" === a4 && "raster" === s2 ? e3.push(new tt(n3, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === a4 && "raster" !== s2 ? e3.push(new tt(n3, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== a4 || r2["source-layer"] ? "raster-dem" === a4 && "hillshade" !== s2 ? e3.push(new tt(n3, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === a4 && t4.lineMetrics || e3.push(new tt(n3, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e3.push(new tt(n3, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e3.push(new tt(n3, r2.source, `source "${r2.source}" not found`));
              } else
                e3.push(new tt(n3, r2, 'missing required property "source"'));
            return e3 = e3.concat(Gr({ key: n3, value: r2, valueSpec: a3.layer, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": () => [], type: () => t3.validateSpec({ key: `${n3}.type`, value: r2.type, valueSpec: a3.layer.type, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, object: r2, objectKey: "type" }), filter: Qr, layout: (t4) => Gr({ layer: r2, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => nn(et({ layerType: s2 }, t5)) } }), paint: (t4) => Gr({ layer: r2, key: t4.key, value: t4.value, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": (t5) => rn(et({ layerType: s2 }, t5)) } }) } })), e3;
          }
          function sn(t3) {
            const e3 = t3.value, r2 = t3.key, n3 = yr(e3);
            return "string" !== n3 ? [new tt(r2, e3, `string expected, ${n3} found`)] : [];
          }
          const on = { promoteId: function({ key: t3, value: e3 }) {
            if ("string" === yr(e3))
              return sn({ key: t3, value: e3 });
            {
              const r2 = [];
              for (const n3 in e3)
                r2.push(...sn({ key: `${t3}.${n3}`, value: e3[n3] }));
              return r2;
            }
          } };
          function ln(t3) {
            const e3 = t3.value, r2 = t3.key, n3 = t3.styleSpec, i3 = t3.style, a3 = t3.validateSpec;
            if (!e3.type)
              return [new tt(r2, e3, '"type" is required')];
            const s2 = Zr(e3.type);
            let o2;
            switch (s2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return o2 = Gr({ key: r2, value: e3, valueSpec: n3[`source_${s2.replace("-", "_")}`], style: t3.style, styleSpec: n3, objectElementValidators: on, validateSpec: a3 }), o2;
              case "geojson":
                if (o2 = Gr({ key: r2, value: e3, valueSpec: n3.source_geojson, style: i3, styleSpec: n3, validateSpec: a3, objectElementValidators: on }), e3.cluster)
                  for (const t4 in e3.clusterProperties) {
                    const [n4, i4] = e3.clusterProperties[t4], s3 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4;
                    o2.push(...Hr({ key: `${r2}.${t4}.map`, value: i4, validateSpec: a3, expressionContext: "cluster-map" })), o2.push(...Hr({ key: `${r2}.${t4}.reduce`, value: s3, validateSpec: a3, expressionContext: "cluster-reduce" }));
                  }
                return o2;
              case "video":
                return Gr({ key: r2, value: e3, valueSpec: n3.source_video, style: i3, validateSpec: a3, styleSpec: n3 });
              case "image":
                return Gr({ key: r2, value: e3, valueSpec: n3.source_image, style: i3, validateSpec: a3, styleSpec: n3 });
              case "canvas":
                return [new tt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return Wr({ key: `${r2}.type`, value: e3.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i3, validateSpec: a3, styleSpec: n3 });
            }
          }
          function un(t3) {
            const e3 = t3.value, r2 = t3.styleSpec, n3 = r2.light, i3 = t3.style;
            let a3 = [];
            const s2 = yr(e3);
            if (void 0 === e3)
              return a3;
            if ("object" !== s2)
              return a3 = a3.concat([new tt("light", e3, `object expected, ${s2} found`)]), a3;
            for (const s3 in e3) {
              const o2 = s3.match(/^(.*)-transition$/);
              a3 = a3.concat(o2 && n3[o2[1]] && n3[o2[1]].transition ? t3.validateSpec({ key: s3, value: e3[s3], valueSpec: r2.transition, validateSpec: t3.validateSpec, style: i3, styleSpec: r2 }) : n3[s3] ? t3.validateSpec({ key: s3, value: e3[s3], valueSpec: n3[s3], validateSpec: t3.validateSpec, style: i3, styleSpec: r2 }) : [new tt(s3, e3[s3], `unknown property "${s3}"`)]);
            }
            return a3;
          }
          function cn(t3) {
            const e3 = t3.value, r2 = t3.styleSpec, n3 = r2.terrain, i3 = t3.style;
            let a3 = [];
            const s2 = yr(e3);
            if (void 0 === e3)
              return a3;
            if ("object" !== s2)
              return a3 = a3.concat([new tt("terrain", e3, `object expected, ${s2} found`)]), a3;
            for (const s3 in e3)
              a3 = a3.concat(n3[s3] ? t3.validateSpec({ key: s3, value: e3[s3], valueSpec: n3[s3], validateSpec: t3.validateSpec, style: i3, styleSpec: r2 }) : [new tt(s3, e3[s3], `unknown property "${s3}"`)]);
            return a3;
          }
          function hn(t3) {
            let e3 = [];
            const r2 = t3.value, n3 = t3.key;
            if (Array.isArray(r2)) {
              const i3 = [], a3 = [];
              for (const s2 in r2)
                r2[s2].id && i3.includes(r2[s2].id) && e3.push(new tt(n3, r2, `all the sprites' ids must be unique, but ${r2[s2].id} is duplicated`)), i3.push(r2[s2].id), r2[s2].url && a3.includes(r2[s2].url) && e3.push(new tt(n3, r2, `all the sprites' URLs must be unique, but ${r2[s2].url} is duplicated`)), a3.push(r2[s2].url), e3 = e3.concat(Gr({ key: `${n3}[${s2}]`, value: r2[s2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t3.validateSpec }));
              return e3;
            }
            return sn({ key: n3, value: r2 });
          }
          const pn = { "*": () => [], array: Jr, boolean: function(t3) {
            const e3 = t3.value, r2 = t3.key, n3 = yr(e3);
            return "boolean" !== n3 ? [new tt(r2, e3, `boolean expected, ${n3} found`)] : [];
          }, number: Xr, color: function(t3) {
            const e3 = t3.key, r2 = t3.value, n3 = yr(r2);
            return "string" !== n3 ? [new tt(e3, r2, `color expected, ${n3} found`)] : qt.parse(String(r2)) ? [] : [new tt(e3, r2, `color expected, "${r2}" found`)];
          }, constants: Nr, enum: Wr, filter: Qr, function: Yr, layer: an, object: Gr, source: ln, light: un, terrain: cn, string: sn, formatted: function(t3) {
            return 0 === sn(t3).length ? [] : Hr(t3);
          }, resolvedImage: function(t3) {
            return 0 === sn(t3).length ? [] : Hr(t3);
          }, padding: function(t3) {
            const e3 = t3.key, r2 = t3.value;
            if ("array" === yr(r2)) {
              if (r2.length < 1 || r2.length > 4)
                return [new tt(e3, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
              const n3 = { type: "number" };
              let i3 = [];
              for (let a3 = 0; a3 < r2.length; a3++)
                i3 = i3.concat(t3.validateSpec({ key: `${e3}[${a3}]`, value: r2[a3], validateSpec: t3.validateSpec, valueSpec: n3 }));
              return i3;
            }
            return Xr({ key: e3, value: r2, valueSpec: {} });
          }, sprite: hn };
          function fn(t3) {
            const e3 = t3.value, r2 = t3.valueSpec, n3 = t3.styleSpec;
            return t3.validateSpec = fn, r2.expression && mr(Zr(e3)) ? Yr(t3) : r2.expression && Sr(Kr(e3)) ? Hr(t3) : r2.type && pn[r2.type] ? pn[r2.type](t3) : Gr(et({}, t3, { valueSpec: r2.type ? n3[r2.type] : r2 }));
          }
          function dn(t3) {
            const e3 = t3.value, r2 = t3.key, n3 = sn(t3);
            return n3.length || (-1 === e3.indexOf("{fontstack}") && n3.push(new tt(r2, e3, '"glyphs" url must include a "{fontstack}" token')), -1 === e3.indexOf("{range}") && n3.push(new tt(r2, e3, '"glyphs" url must include a "{range}" token'))), n3;
          }
          function yn(t3, e3 = q) {
            let r2 = [];
            return r2 = r2.concat(fn({ key: "", value: t3, valueSpec: e3.$root, styleSpec: e3, style: t3, validateSpec: fn, objectElementValidators: { glyphs: dn, "*": () => [] } })), t3.constants && (r2 = r2.concat(Nr({ key: "constants", value: t3.constants, style: t3, styleSpec: e3, validateSpec: fn }))), gn(r2);
          }
          function mn(t3) {
            return function(e3) {
              return t3({ ...e3, validateSpec: fn });
            };
          }
          function gn(t3) {
            return [].concat(t3).sort((t4, e3) => t4.line - e3.line);
          }
          function xn(t3) {
            return function(...e3) {
              return gn(t3.apply(this, e3));
            };
          }
          yn.source = xn(mn(ln)), yn.sprite = xn(mn(hn)), yn.glyphs = xn(mn(dn)), yn.light = xn(mn(un)), yn.terrain = xn(mn(cn)), yn.layer = xn(mn(an)), yn.filter = xn(mn(Qr)), yn.paintProperty = xn(mn(rn)), yn.layoutProperty = xn(mn(nn));
          const vn = yn, bn = vn.light, wn = vn.paintProperty, _n = vn.layoutProperty;
          function An(t3, e3) {
            let r2 = false;
            if (e3 && e3.length)
              for (const n3 of e3)
                t3.fire(new U(new Error(n3.message))), r2 = true;
            return r2;
          }
          class kn {
            constructor(t3, e3, r2) {
              const n3 = this.cells = [];
              if (t3 instanceof ArrayBuffer) {
                this.arrayBuffer = t3;
                const i4 = new Int32Array(this.arrayBuffer);
                t3 = i4[0], this.d = (e3 = i4[1]) + 2 * (r2 = i4[2]);
                for (let t4 = 0; t4 < this.d * this.d; t4++) {
                  const e4 = i4[3 + t4], r3 = i4[3 + t4 + 1];
                  n3.push(e4 === r3 ? null : i4.subarray(e4, r3));
                }
                const a3 = i4[3 + n3.length + 1];
                this.keys = i4.subarray(i4[3 + n3.length], a3), this.bboxes = i4.subarray(a3), this.insert = this._insertReadonly;
              } else {
                this.d = e3 + 2 * r2;
                for (let t4 = 0; t4 < this.d * this.d; t4++)
                  n3.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e3, this.extent = t3, this.padding = r2, this.scale = e3 / t3, this.uid = 0;
              const i3 = r2 / e3 * t3;
              this.min = -i3, this.max = t3 + i3;
            }
            insert(t3, e3, r2, n3, i3) {
              this._forEachCell(e3, r2, n3, i3, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n3), this.bboxes.push(i3);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t3, e3, r2, n3, i3, a3) {
              this.cells[i3].push(a3);
            }
            query(t3, e3, r2, n3, i3) {
              const a3 = this.min, s2 = this.max;
              if (t3 <= a3 && e3 <= a3 && s2 <= r2 && s2 <= n3 && !i3)
                return Array.prototype.slice.call(this.keys);
              {
                const a4 = [];
                return this._forEachCell(t3, e3, r2, n3, this._queryCell, a4, {}, i3), a4;
              }
            }
            _queryCell(t3, e3, r2, n3, i3, a3, s2, o2) {
              const l2 = this.cells[i3];
              if (null !== l2) {
                const i4 = this.keys, u2 = this.bboxes;
                for (let c5 = 0; c5 < l2.length; c5++) {
                  const h2 = l2[c5];
                  if (void 0 === s2[h2]) {
                    const l3 = 4 * h2;
                    (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t3 <= u2[l3 + 2] && e3 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n3 >= u2[l3 + 1]) ? (s2[h2] = true, a3.push(i4[h2])) : s2[h2] = false;
                  }
                }
              }
            }
            _forEachCell(t3, e3, r2, n3, i3, a3, s2, o2) {
              const l2 = this._convertToCellCoord(t3), u2 = this._convertToCellCoord(e3), c5 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n3);
              for (let p3 = l2; p3 <= c5; p3++)
                for (let l3 = u2; l3 <= h2; l3++) {
                  const u3 = this.d * l3 + p3;
                  if ((!o2 || o2(this._convertFromCellCoord(p3), this._convertFromCellCoord(l3), this._convertFromCellCoord(p3 + 1), this._convertFromCellCoord(l3 + 1))) && i3.call(this, t3, e3, r2, n3, u3, a3, s2, o2))
                    return;
                }
            }
            _convertFromCellCoord(t3) {
              return (t3 - this.padding) / this.scale;
            }
            _convertToCellCoord(t3) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer)
                return this.arrayBuffer;
              const t3 = this.cells, e3 = 3 + this.cells.length + 1 + 1;
              let r2 = 0;
              for (let t4 = 0; t4 < this.cells.length; t4++)
                r2 += this.cells[t4].length;
              const n3 = new Int32Array(e3 + r2 + this.keys.length + this.bboxes.length);
              n3[0] = this.extent, n3[1] = this.n, n3[2] = this.padding;
              let i3 = e3;
              for (let e4 = 0; e4 < t3.length; e4++) {
                const r3 = t3[e4];
                n3[3 + e4] = i3, n3.set(r3, i3), i3 += r3.length;
              }
              return n3[3 + t3.length] = i3, n3.set(this.keys, i3), i3 += this.keys.length, n3[3 + t3.length + 1] = i3, n3.set(this.bboxes, i3), i3 += this.bboxes.length, n3.buffer;
            }
            static serialize(t3, e3) {
              const r2 = t3.toArrayBuffer();
              return e3 && e3.push(r2), { buffer: r2 };
            }
            static deserialize(t3) {
              return new kn(t3.buffer);
            }
          }
          const Sn = {};
          function In(t3, e3, r2 = {}) {
            if (Sn[t3])
              throw new Error(`${t3} is already registered.`);
            Object.defineProperty(e3, "_classRegistryKey", { value: t3, writeable: false }), Sn[t3] = { klass: e3, omit: r2.omit || [], shallow: r2.shallow || [] };
          }
          In("Object", Object), In("TransferableGridIndex", kn), In("Color", qt), In("Error", Error), In("AJAXError", B), In("ResolvedImage", Gt), In("StylePropertyFunction", Br), In("StyleExpression", kr, { omit: ["_evaluator"] }), In("ZoomDependentExpression", Mr), In("ZoomConstantExpression", zr), In("CompoundExpression", Ie, { omit: ["_evaluate"] });
          for (const t3 in ar)
            ar[t3]._classRegistryKey || In(`Expression_${t3}`, ar[t3]);
          function zn(t3) {
            return t3 && "undefined" != typeof ArrayBuffer && (t3 instanceof ArrayBuffer || t3.constructor && "ArrayBuffer" === t3.constructor.name);
          }
          function Mn(t3, e3) {
            if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob)
              return t3;
            if (zn(t3))
              return e3 && e3.push(t3), t3;
            if (k(t3))
              return e3 && e3.push(t3), t3;
            if (ArrayBuffer.isView(t3)) {
              const r2 = t3;
              return e3 && e3.push(r2.buffer), r2;
            }
            if (t3 instanceof ImageData)
              return e3 && e3.push(t3.data.buffer), t3;
            if (Array.isArray(t3)) {
              const r2 = [];
              for (const n3 of t3)
                r2.push(Mn(n3, e3));
              return r2;
            }
            if ("object" == typeof t3) {
              const r2 = t3.constructor, n3 = r2._classRegistryKey;
              if (!n3)
                throw new Error("can't serialize object of unregistered class");
              if (!Sn[n3])
                throw new Error(`${n3} is not registered.`);
              const i3 = r2.serialize ? r2.serialize(t3, e3) : {};
              if (r2.serialize) {
                if (e3 && i3 === e3[e3.length - 1])
                  throw new Error("statically serialized object won't survive transfer of $name property");
              } else {
                for (const r3 in t3) {
                  if (!t3.hasOwnProperty(r3))
                    continue;
                  if (Sn[n3].omit.indexOf(r3) >= 0)
                    continue;
                  const a3 = t3[r3];
                  i3[r3] = Sn[n3].shallow.indexOf(r3) >= 0 ? a3 : Mn(a3, e3);
                }
                t3 instanceof Error && (i3.message = t3.message);
              }
              if (i3.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n3 && (i3.$name = n3), i3;
            }
            throw new Error("can't serialize object of type " + typeof t3);
          }
          function Pn(t3) {
            if (null == t3 || "boolean" == typeof t3 || "number" == typeof t3 || "string" == typeof t3 || t3 instanceof Boolean || t3 instanceof Number || t3 instanceof String || t3 instanceof Date || t3 instanceof RegExp || t3 instanceof Blob || zn(t3) || k(t3) || ArrayBuffer.isView(t3) || t3 instanceof ImageData)
              return t3;
            if (Array.isArray(t3))
              return t3.map(Pn);
            if ("object" == typeof t3) {
              const e3 = t3.$name || "Object";
              if (!Sn[e3])
                throw new Error(`can't deserialize unregistered class ${e3}`);
              const { klass: r2 } = Sn[e3];
              if (!r2)
                throw new Error(`can't deserialize unregistered class ${e3}`);
              if (r2.deserialize)
                return r2.deserialize(t3);
              const n3 = Object.create(r2.prototype);
              for (const r3 of Object.keys(t3)) {
                if ("$name" === r3)
                  continue;
                const i3 = t3[r3];
                n3[r3] = Sn[e3].shallow.indexOf(r3) >= 0 ? i3 : Pn(i3);
              }
              return n3;
            }
            throw new Error("can't deserialize object of type " + typeof t3);
          }
          class Bn {
            constructor() {
              this.first = true;
            }
            update(t3, e3) {
              const r2 = Math.floor(t3);
              return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t3, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e3) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e3), t3 !== this.lastZoom && (this.lastZoom = t3, this.lastFloorZoom = r2, true));
            }
          }
          const Cn = { "Latin-1 Supplement": (t3) => t3 >= 128 && t3 <= 255, Arabic: (t3) => t3 >= 1536 && t3 <= 1791, "Arabic Supplement": (t3) => t3 >= 1872 && t3 <= 1919, "Arabic Extended-A": (t3) => t3 >= 2208 && t3 <= 2303, "Hangul Jamo": (t3) => t3 >= 4352 && t3 <= 4607, "Unified Canadian Aboriginal Syllabics": (t3) => t3 >= 5120 && t3 <= 5759, Khmer: (t3) => t3 >= 6016 && t3 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t3) => t3 >= 6320 && t3 <= 6399, "General Punctuation": (t3) => t3 >= 8192 && t3 <= 8303, "Letterlike Symbols": (t3) => t3 >= 8448 && t3 <= 8527, "Number Forms": (t3) => t3 >= 8528 && t3 <= 8591, "Miscellaneous Technical": (t3) => t3 >= 8960 && t3 <= 9215, "Control Pictures": (t3) => t3 >= 9216 && t3 <= 9279, "Optical Character Recognition": (t3) => t3 >= 9280 && t3 <= 9311, "Enclosed Alphanumerics": (t3) => t3 >= 9312 && t3 <= 9471, "Geometric Shapes": (t3) => t3 >= 9632 && t3 <= 9727, "Miscellaneous Symbols": (t3) => t3 >= 9728 && t3 <= 9983, "Miscellaneous Symbols and Arrows": (t3) => t3 >= 11008 && t3 <= 11263, "CJK Radicals Supplement": (t3) => t3 >= 11904 && t3 <= 12031, "Kangxi Radicals": (t3) => t3 >= 12032 && t3 <= 12255, "Ideographic Description Characters": (t3) => t3 >= 12272 && t3 <= 12287, "CJK Symbols and Punctuation": (t3) => t3 >= 12288 && t3 <= 12351, Hiragana: (t3) => t3 >= 12352 && t3 <= 12447, Katakana: (t3) => t3 >= 12448 && t3 <= 12543, Bopomofo: (t3) => t3 >= 12544 && t3 <= 12591, "Hangul Compatibility Jamo": (t3) => t3 >= 12592 && t3 <= 12687, Kanbun: (t3) => t3 >= 12688 && t3 <= 12703, "Bopomofo Extended": (t3) => t3 >= 12704 && t3 <= 12735, "CJK Strokes": (t3) => t3 >= 12736 && t3 <= 12783, "Katakana Phonetic Extensions": (t3) => t3 >= 12784 && t3 <= 12799, "Enclosed CJK Letters and Months": (t3) => t3 >= 12800 && t3 <= 13055, "CJK Compatibility": (t3) => t3 >= 13056 && t3 <= 13311, "CJK Unified Ideographs Extension A": (t3) => t3 >= 13312 && t3 <= 19903, "Yijing Hexagram Symbols": (t3) => t3 >= 19904 && t3 <= 19967, "CJK Unified Ideographs": (t3) => t3 >= 19968 && t3 <= 40959, "Yi Syllables": (t3) => t3 >= 40960 && t3 <= 42127, "Yi Radicals": (t3) => t3 >= 42128 && t3 <= 42191, "Hangul Jamo Extended-A": (t3) => t3 >= 43360 && t3 <= 43391, "Hangul Syllables": (t3) => t3 >= 44032 && t3 <= 55215, "Hangul Jamo Extended-B": (t3) => t3 >= 55216 && t3 <= 55295, "Private Use Area": (t3) => t3 >= 57344 && t3 <= 63743, "CJK Compatibility Ideographs": (t3) => t3 >= 63744 && t3 <= 64255, "Arabic Presentation Forms-A": (t3) => t3 >= 64336 && t3 <= 65023, "Vertical Forms": (t3) => t3 >= 65040 && t3 <= 65055, "CJK Compatibility Forms": (t3) => t3 >= 65072 && t3 <= 65103, "Small Form Variants": (t3) => t3 >= 65104 && t3 <= 65135, "Arabic Presentation Forms-B": (t3) => t3 >= 65136 && t3 <= 65279, "Halfwidth and Fullwidth Forms": (t3) => t3 >= 65280 && t3 <= 65519 };
          function Vn(t3) {
            for (const e3 of t3)
              if (Tn(e3.charCodeAt(0)))
                return true;
            return false;
          }
          function En(t3) {
            for (const e3 of t3)
              if (!Fn(e3.charCodeAt(0)))
                return false;
            return true;
          }
          function Fn(t3) {
            return !(Cn.Arabic(t3) || Cn["Arabic Supplement"](t3) || Cn["Arabic Extended-A"](t3) || Cn["Arabic Presentation Forms-A"](t3) || Cn["Arabic Presentation Forms-B"](t3));
          }
          function Tn(t3) {
            return !(746 !== t3 && 747 !== t3 && (t3 < 4352 || !(Cn["Bopomofo Extended"](t3) || Cn.Bopomofo(t3) || Cn["CJK Compatibility Forms"](t3) && !(t3 >= 65097 && t3 <= 65103) || Cn["CJK Compatibility Ideographs"](t3) || Cn["CJK Compatibility"](t3) || Cn["CJK Radicals Supplement"](t3) || Cn["CJK Strokes"](t3) || !(!Cn["CJK Symbols and Punctuation"](t3) || t3 >= 12296 && t3 <= 12305 || t3 >= 12308 && t3 <= 12319 || 12336 === t3) || Cn["CJK Unified Ideographs Extension A"](t3) || Cn["CJK Unified Ideographs"](t3) || Cn["Enclosed CJK Letters and Months"](t3) || Cn["Hangul Compatibility Jamo"](t3) || Cn["Hangul Jamo Extended-A"](t3) || Cn["Hangul Jamo Extended-B"](t3) || Cn["Hangul Jamo"](t3) || Cn["Hangul Syllables"](t3) || Cn.Hiragana(t3) || Cn["Ideographic Description Characters"](t3) || Cn.Kanbun(t3) || Cn["Kangxi Radicals"](t3) || Cn["Katakana Phonetic Extensions"](t3) || Cn.Katakana(t3) && 12540 !== t3 || !(!Cn["Halfwidth and Fullwidth Forms"](t3) || 65288 === t3 || 65289 === t3 || 65293 === t3 || t3 >= 65306 && t3 <= 65310 || 65339 === t3 || 65341 === t3 || 65343 === t3 || t3 >= 65371 && t3 <= 65503 || 65507 === t3 || t3 >= 65512 && t3 <= 65519) || !(!Cn["Small Form Variants"](t3) || t3 >= 65112 && t3 <= 65118 || t3 >= 65123 && t3 <= 65126) || Cn["Unified Canadian Aboriginal Syllabics"](t3) || Cn["Unified Canadian Aboriginal Syllabics Extended"](t3) || Cn["Vertical Forms"](t3) || Cn["Yijing Hexagram Symbols"](t3) || Cn["Yi Syllables"](t3) || Cn["Yi Radicals"](t3))));
          }
          function Ln(t3) {
            return !(Tn(t3) || function(t4) {
              return !!(Cn["Latin-1 Supplement"](t4) && (167 === t4 || 169 === t4 || 174 === t4 || 177 === t4 || 188 === t4 || 189 === t4 || 190 === t4 || 215 === t4 || 247 === t4) || Cn["General Punctuation"](t4) && (8214 === t4 || 8224 === t4 || 8225 === t4 || 8240 === t4 || 8241 === t4 || 8251 === t4 || 8252 === t4 || 8258 === t4 || 8263 === t4 || 8264 === t4 || 8265 === t4 || 8273 === t4) || Cn["Letterlike Symbols"](t4) || Cn["Number Forms"](t4) || Cn["Miscellaneous Technical"](t4) && (t4 >= 8960 && t4 <= 8967 || t4 >= 8972 && t4 <= 8991 || t4 >= 8996 && t4 <= 9e3 || 9003 === t4 || t4 >= 9085 && t4 <= 9114 || t4 >= 9150 && t4 <= 9165 || 9167 === t4 || t4 >= 9169 && t4 <= 9179 || t4 >= 9186 && t4 <= 9215) || Cn["Control Pictures"](t4) && 9251 !== t4 || Cn["Optical Character Recognition"](t4) || Cn["Enclosed Alphanumerics"](t4) || Cn["Geometric Shapes"](t4) || Cn["Miscellaneous Symbols"](t4) && !(t4 >= 9754 && t4 <= 9759) || Cn["Miscellaneous Symbols and Arrows"](t4) && (t4 >= 11026 && t4 <= 11055 || t4 >= 11088 && t4 <= 11097 || t4 >= 11192 && t4 <= 11243) || Cn["CJK Symbols and Punctuation"](t4) || Cn.Katakana(t4) || Cn["Private Use Area"](t4) || Cn["CJK Compatibility Forms"](t4) || Cn["Small Form Variants"](t4) || Cn["Halfwidth and Fullwidth Forms"](t4) || 8734 === t4 || 8756 === t4 || 8757 === t4 || t4 >= 9984 && t4 <= 10087 || t4 >= 10102 && t4 <= 10131 || 65532 === t4 || 65533 === t4);
            }(t3));
          }
          function $n(t3) {
            return t3 >= 1424 && t3 <= 2303 || Cn["Arabic Presentation Forms-A"](t3) || Cn["Arabic Presentation Forms-B"](t3);
          }
          function Dn(t3, e3) {
            return !(!e3 && $n(t3) || t3 >= 2304 && t3 <= 3583 || t3 >= 3840 && t3 <= 4255 || Cn.Khmer(t3));
          }
          function On(t3) {
            for (const e3 of t3)
              if ($n(e3.charCodeAt(0)))
                return true;
            return false;
          }
          const Un = "deferred", Rn = "loading", qn = "loaded";
          let jn = null, Nn = "unavailable", Zn = null;
          const Kn = function(t3) {
            t3 && "string" == typeof t3 && t3.indexOf("NetworkError") > -1 && (Nn = "error"), jn && jn(t3);
          };
          function Gn() {
            Jn.fire(new O("pluginStateChange", { pluginStatus: Nn, pluginURL: Zn }));
          }
          const Jn = new R(), Xn = function() {
            return Nn;
          }, Yn = function() {
            if (Nn !== Un || !Zn)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Nn = Rn, Gn(), Zn && T({ url: Zn }, (t3) => {
              t3 ? Kn(t3) : (Nn = qn, Gn());
            });
          }, Hn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Nn === qn || null != Hn.applyArabicShaping, isLoading: () => Nn === Rn, setState(t3) {
            if (!w())
              throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
            Nn = t3.pluginStatus, Zn = t3.pluginURL;
          }, isParsed() {
            if (!w())
              throw new Error("rtl-text-plugin is only parsed on the worker-threads");
            return null != Hn.applyArabicShaping && null != Hn.processBidirectionalText && null != Hn.processStyledBidirectionalText;
          }, getPluginURL() {
            if (!w())
              throw new Error("rtl-text-plugin url can only be queried from the worker threads");
            return Zn;
          } };
          class Wn {
            constructor(t3, e3) {
              this.zoom = t3, e3 ? (this.now = e3.now, this.fadeDuration = e3.fadeDuration, this.zoomHistory = e3.zoomHistory, this.transition = e3.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Bn(), this.transition = {});
            }
            isSupportedScript(t3) {
              return function(t4, e3) {
                for (const r2 of t4)
                  if (!Dn(r2.charCodeAt(0), e3))
                    return false;
                return true;
              }(t3, Hn.isLoaded());
            }
            crossFadingFactor() {
              return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t3 = this.zoom, e3 = t3 - Math.floor(t3), r2 = this.crossFadingFactor();
              return t3 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e3 + (1 - e3) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e3 };
            }
          }
          class Qn {
            constructor(t3, e3) {
              this.property = t3, this.value = e3, this.expression = function(t4, e4) {
                if (mr(t4))
                  return new Br(t4, e4);
                if (Sr(t4)) {
                  const r2 = Pr(t4, e4);
                  if ("error" === r2.result)
                    throw new Error(r2.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
                  return r2.value;
                }
                {
                  let r2 = t4;
                  return "color" === e4.type && "string" == typeof t4 ? r2 = qt.parse(t4) : "padding" !== e4.type || "number" != typeof t4 && !Array.isArray(t4) || (r2 = Kt.parse(t4)), { kind: "constant", evaluate: () => r2 };
                }
              }(void 0 === e3 ? t3.specification.default : e3, t3.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t3, e3, r2) {
              return this.property.possiblyEvaluate(this, t3, e3, r2);
            }
          }
          class ti {
            constructor(t3) {
              this.property = t3, this.value = new Qn(t3, void 0);
            }
            transitioned(t3, e3) {
              return new ri(this.property, this.value, e3, p2({}, t3.transition, this.transition), t3.now);
            }
            untransitioned() {
              return new ri(this.property, this.value, null, {}, 0);
            }
          }
          class ei {
            constructor(t3) {
              this._properties = t3, this._values = Object.create(t3.defaultTransitionablePropertyValues);
            }
            getValue(t3) {
              return m3(this._values[t3].value.value);
            }
            setValue(t3, e3) {
              Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ti(this._values[t3].property)), this._values[t3].value = new Qn(this._values[t3].property, null === e3 ? void 0 : m3(e3));
            }
            getTransition(t3) {
              return m3(this._values[t3].transition);
            }
            setTransition(t3, e3) {
              Object.prototype.hasOwnProperty.call(this._values, t3) || (this._values[t3] = new ti(this._values[t3].property)), this._values[t3].transition = m3(e3) || void 0;
            }
            serialize() {
              const t3 = {};
              for (const e3 of Object.keys(this._values)) {
                const r2 = this.getValue(e3);
                void 0 !== r2 && (t3[e3] = r2);
                const n3 = this.getTransition(e3);
                void 0 !== n3 && (t3[`${e3}-transition`] = n3);
              }
              return t3;
            }
            transitioned(t3, e3) {
              const r2 = new ni(this._properties);
              for (const n3 of Object.keys(this._values))
                r2._values[n3] = this._values[n3].transitioned(t3, e3._values[n3]);
              return r2;
            }
            untransitioned() {
              const t3 = new ni(this._properties);
              for (const e3 of Object.keys(this._values))
                t3._values[e3] = this._values[e3].untransitioned();
              return t3;
            }
          }
          class ri {
            constructor(t3, e3, r2, n3, i3) {
              this.property = t3, this.value = e3, this.begin = i3 + n3.delay || 0, this.end = this.begin + n3.duration || 0, t3.specification.transition && (n3.delay || n3.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t3, e3, r2) {
              const n3 = t3.now || 0, i3 = this.value.possiblyEvaluate(t3, e3, r2), a3 = this.prior;
              if (a3) {
                if (n3 > this.end)
                  return this.prior = null, i3;
                if (this.value.isDataDriven())
                  return this.prior = null, i3;
                if (n3 < this.begin)
                  return a3.possiblyEvaluate(t3, e3, r2);
                {
                  const s2 = (n3 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(a3.possiblyEvaluate(t3, e3, r2), i3, function(t4) {
                    if (t4 <= 0)
                      return 0;
                    if (t4 >= 1)
                      return 1;
                    const e4 = t4 * t4, r3 = e4 * t4;
                    return 4 * (t4 < 0.5 ? r3 : 3 * (t4 - e4) + r3 - 0.75);
                  }(s2));
                }
              }
              return i3;
            }
          }
          class ni {
            constructor(t3) {
              this._properties = t3, this._values = Object.create(t3.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t3, e3, r2) {
              const n3 = new si(this._properties);
              for (const i3 of Object.keys(this._values))
                n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r2);
              return n3;
            }
            hasTransition() {
              for (const t3 of Object.keys(this._values))
                if (this._values[t3].prior)
                  return true;
              return false;
            }
          }
          class ii {
            constructor(t3) {
              this._properties = t3, this._values = Object.create(t3.defaultPropertyValues);
            }
            getValue(t3) {
              return m3(this._values[t3].value);
            }
            setValue(t3, e3) {
              this._values[t3] = new Qn(this._values[t3].property, null === e3 ? void 0 : m3(e3));
            }
            serialize() {
              const t3 = {};
              for (const e3 of Object.keys(this._values)) {
                const r2 = this.getValue(e3);
                void 0 !== r2 && (t3[e3] = r2);
              }
              return t3;
            }
            possiblyEvaluate(t3, e3, r2) {
              const n3 = new si(this._properties);
              for (const i3 of Object.keys(this._values))
                n3._values[i3] = this._values[i3].possiblyEvaluate(t3, e3, r2);
              return n3;
            }
          }
          class ai {
            constructor(t3, e3, r2) {
              this.property = t3, this.value = e3, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t3) {
              return "constant" === this.value.kind ? this.value.value : t3;
            }
            evaluate(t3, e3, r2, n3) {
              return this.property.evaluate(this.value, this.parameters, t3, e3, r2, n3);
            }
          }
          class si {
            constructor(t3) {
              this._properties = t3, this._values = Object.create(t3.defaultPossiblyEvaluatedValues);
            }
            get(t3) {
              return this._values[t3];
            }
          }
          class oi {
            constructor(t3) {
              this.specification = t3;
            }
            possiblyEvaluate(t3, e3) {
              if (t3.isDataDriven())
                throw new Error("Value should not be data driven");
              return t3.expression.evaluate(e3);
            }
            interpolate(t3, e3, r2) {
              const n3 = Te[this.specification.type];
              return n3 ? n3(t3, e3, r2) : t3;
            }
          }
          class li {
            constructor(t3, e3) {
              this.specification = t3, this.overrides = e3;
            }
            possiblyEvaluate(t3, e3, r2, n3) {
              return new ai(this, "constant" === t3.expression.kind || "camera" === t3.expression.kind ? { kind: "constant", value: t3.expression.evaluate(e3, null, {}, r2, n3) } : t3.expression, e3);
            }
            interpolate(t3, e3, r2) {
              if ("constant" !== t3.value.kind || "constant" !== e3.value.kind)
                return t3;
              if (void 0 === t3.value.value || void 0 === e3.value.value)
                return new ai(this, { kind: "constant", value: void 0 }, t3.parameters);
              const n3 = Te[this.specification.type];
              if (n3) {
                const i3 = n3(t3.value.value, e3.value.value, r2);
                return new ai(this, { kind: "constant", value: i3 }, t3.parameters);
              }
              return t3;
            }
            evaluate(t3, e3, r2, n3, i3, a3) {
              return "constant" === t3.kind ? t3.value : t3.evaluate(e3, r2, n3, i3, a3);
            }
          }
          class ui extends li {
            possiblyEvaluate(t3, e3, r2, n3) {
              if (void 0 === t3.value)
                return new ai(this, { kind: "constant", value: void 0 }, e3);
              if ("constant" === t3.expression.kind) {
                const i3 = t3.expression.evaluate(e3, null, {}, r2, n3), a3 = "resolvedImage" === t3.property.specification.type && "string" != typeof i3 ? i3.name : i3, s2 = this._calculate(a3, a3, a3, e3);
                return new ai(this, { kind: "constant", value: s2 }, e3);
              }
              if ("camera" === t3.expression.kind) {
                const r3 = this._calculate(t3.expression.evaluate({ zoom: e3.zoom - 1 }), t3.expression.evaluate({ zoom: e3.zoom }), t3.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
                return new ai(this, { kind: "constant", value: r3 }, e3);
              }
              return new ai(this, t3.expression, e3);
            }
            evaluate(t3, e3, r2, n3, i3, a3) {
              if ("source" === t3.kind) {
                const s2 = t3.evaluate(e3, r2, n3, i3, a3);
                return this._calculate(s2, s2, s2, e3);
              }
              return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n3), t3.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n3), t3.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n3), e3) : t3.value;
            }
            _calculate(t3, e3, r2, n3) {
              return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r2, to: e3 };
            }
            interpolate(t3) {
              return t3;
            }
          }
          class ci {
            constructor(t3) {
              this.specification = t3;
            }
            possiblyEvaluate(t3, e3, r2, n3) {
              if (void 0 !== t3.value) {
                if ("constant" === t3.expression.kind) {
                  const i3 = t3.expression.evaluate(e3, null, {}, r2, n3);
                  return this._calculate(i3, i3, i3, e3);
                }
                return this._calculate(t3.expression.evaluate(new Wn(Math.floor(e3.zoom - 1), e3)), t3.expression.evaluate(new Wn(Math.floor(e3.zoom), e3)), t3.expression.evaluate(new Wn(Math.floor(e3.zoom + 1), e3)), e3);
              }
            }
            _calculate(t3, e3, r2, n3) {
              return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r2, to: e3 };
            }
            interpolate(t3) {
              return t3;
            }
          }
          class hi {
            constructor(t3) {
              this.specification = t3;
            }
            possiblyEvaluate(t3, e3, r2, n3) {
              return !!t3.expression.evaluate(e3, null, {}, r2, n3);
            }
            interpolate() {
              return false;
            }
          }
          class pi {
            constructor(t3) {
              this.properties = t3, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e3 in t3) {
                const r2 = t3[e3];
                r2.specification.overridable && this.overridableProperties.push(e3);
                const n3 = this.defaultPropertyValues[e3] = new Qn(r2, void 0), i3 = this.defaultTransitionablePropertyValues[e3] = new ti(r2);
                this.defaultTransitioningPropertyValues[e3] = i3.untransitioned(), this.defaultPossiblyEvaluatedValues[e3] = n3.possiblyEvaluate({});
              }
            }
          }
          In("DataDrivenProperty", li), In("DataConstantProperty", oi), In("CrossFadedDataDrivenProperty", ui), In("CrossFadedProperty", ci), In("ColorRampProperty", hi);
          const fi = "-transition";
          class di extends R {
            constructor(t3, e3) {
              if (super(), this.id = t3.id, this.type = t3.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t3.type && (this.metadata = t3.metadata, this.minzoom = t3.minzoom, this.maxzoom = t3.maxzoom, "background" !== t3.type && (this.source = t3.source, this.sourceLayer = t3["source-layer"], this.filter = t3.filter), e3.layout && (this._unevaluatedLayout = new ii(e3.layout)), e3.paint)) {
                this._transitionablePaint = new ei(e3.paint);
                for (const e4 in t3.paint)
                  this.setPaintProperty(e4, t3.paint[e4], { validate: false });
                for (const e4 in t3.layout)
                  this.setLayoutProperty(e4, t3.layout[e4], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new si(e3.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t3) {
              return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
            }
            setLayoutProperty(t3, e3, r2 = {}) {
              null != e3 && this._validate(_n, `layers.${this.id}.layout.${t3}`, t3, e3, r2) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3);
            }
            getPaintProperty(t3) {
              return t3.endsWith(fi) ? this._transitionablePaint.getTransition(t3.slice(0, -11)) : this._transitionablePaint.getValue(t3);
            }
            setPaintProperty(t3, e3, r2 = {}) {
              if (null != e3 && this._validate(wn, `layers.${this.id}.paint.${t3}`, t3, e3, r2))
                return false;
              if (t3.endsWith(fi))
                return this._transitionablePaint.setTransition(t3.slice(0, -11), e3 || void 0), false;
              {
                const r3 = this._transitionablePaint._values[t3], n3 = "cross-faded-data-driven" === r3.property.specification["property-type"], i3 = r3.value.isDataDriven(), a3 = r3.value;
                this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
                const s2 = this._transitionablePaint._values[t3].value;
                return s2.isDataDriven() || i3 || n3 || this._handleOverridablePaintPropertyUpdate(t3, a3, s2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t3) {
            }
            _handleOverridablePaintPropertyUpdate(t3, e3, r2) {
              return false;
            }
            isHidden(t3) {
              return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t3) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t3, e3) {
              t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e3);
            }
            serialize() {
              const t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), y(t3, (t4, e3) => !(void 0 === t4 || "layout" === e3 && !Object.keys(t4).length || "paint" === e3 && !Object.keys(t4).length));
            }
            _validate(t3, e3, r2, n3, i3 = {}) {
              return (!i3 || false !== i3.validate) && An(this, t3.call(vn, { key: e3, layerType: this.type, objectKey: r2, value: n3, styleSpec: q, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t3 in this.paint._values) {
                const e3 = this.paint.get(t3);
                if (e3 instanceof ai && pr(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                  return true;
              }
              return false;
            }
          }
          const yi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class mi {
            constructor(t3, e3) {
              this._structArray = t3, this._pos1 = e3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class gi {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t3, e3) {
              return t3._trim(), e3 && (t3.isTransferred = true, e3.push(t3.arrayBuffer)), { length: t3.length, arrayBuffer: t3.arrayBuffer };
            }
            static deserialize(t3) {
              const e3 = Object.create(this.prototype);
              return e3.arrayBuffer = t3.arrayBuffer, e3.length = t3.length, e3.capacity = t3.arrayBuffer.byteLength / e3.bytesPerElement, e3._refreshViews(), e3;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t3) {
              this.reserve(t3), this.length = t3;
            }
            reserve(t3) {
              if (t3 > this.capacity) {
                this.capacity = Math.max(t3, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e3 = this.uint8;
                this._refreshViews(), e3 && this.uint8.set(e3);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function xi(t3, e3 = 1) {
            let r2 = 0, n3 = 0;
            return { members: t3.map((t4) => {
              const i3 = yi[t4.type].BYTES_PER_ELEMENT, a3 = r2 = vi(r2, Math.max(e3, i3)), s2 = t4.components || 1;
              return n3 = Math.max(n3, i3), r2 += i3 * s2, { name: t4.name, type: t4.type, components: s2, offset: a3 };
            }), size: vi(r2, Math.max(n3, e3)), alignment: e3 };
          }
          function vi(t3, e3) {
            return Math.ceil(t3 / e3) * e3;
          }
          class bi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }
            emplace(t3, e3, r2) {
              const n3 = 2 * t3;
              return this.int16[n3 + 0] = e3, this.int16[n3 + 1] = r2, t3;
            }
          }
          bi.prototype.bytesPerElement = 4, In("StructArrayLayout2i4", bi);
          class wi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t3, e3, r2);
            }
            emplace(t3, e3, r2, n3) {
              const i3 = 3 * t3;
              return this.int16[i3 + 0] = e3, this.int16[i3 + 1] = r2, this.int16[i3 + 2] = n3, t3;
            }
          }
          wi.prototype.bytesPerElement = 6, In("StructArrayLayout3i6", wi);
          class _i extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3) {
              const i3 = this.length;
              return this.resize(i3 + 1), this.emplace(i3, t3, e3, r2, n3);
            }
            emplace(t3, e3, r2, n3, i3) {
              const a3 = 4 * t3;
              return this.int16[a3 + 0] = e3, this.int16[a3 + 1] = r2, this.int16[a3 + 2] = n3, this.int16[a3 + 3] = i3, t3;
            }
          }
          _i.prototype.bytesPerElement = 8, In("StructArrayLayout4i8", _i);
          class Ai extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t3, e3, r2, n3, i3, a3);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2) {
              const o2 = 6 * t3;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n3, this.int16[o2 + 3] = i3, this.int16[o2 + 4] = a3, this.int16[o2 + 5] = s2, t3;
            }
          }
          Ai.prototype.bytesPerElement = 12, In("StructArrayLayout2i4i12", Ai);
          class ki extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t3, e3, r2, n3, i3, a3);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2) {
              const o2 = 4 * t3, l2 = 8 * t3;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n3, this.uint8[l2 + 5] = i3, this.uint8[l2 + 6] = a3, this.uint8[l2 + 7] = s2, t3;
            }
          }
          ki.prototype.bytesPerElement = 8, In("StructArrayLayout2i4ub8", ki);
          class Si extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }
            emplace(t3, e3, r2) {
              const n3 = 2 * t3;
              return this.float32[n3 + 0] = e3, this.float32[n3 + 1] = r2, t3;
            }
          }
          Si.prototype.bytesPerElement = 8, In("StructArrayLayout2f8", Si);
          class Ii extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2) {
              const c5 = this.length;
              return this.resize(c5 + 1), this.emplace(c5, t3, e3, r2, n3, i3, a3, s2, o2, l2, u2);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5) {
              const h2 = 10 * t3;
              return this.uint16[h2 + 0] = e3, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n3, this.uint16[h2 + 3] = i3, this.uint16[h2 + 4] = a3, this.uint16[h2 + 5] = s2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c5, t3;
            }
          }
          Ii.prototype.bytesPerElement = 20, In("StructArrayLayout10ui20", Ii);
          class zi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2) {
              const p3 = this.length;
              return this.resize(p3 + 1), this.emplace(p3, t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3) {
              const f2 = 12 * t3;
              return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n3, this.int16[f2 + 3] = i3, this.uint16[f2 + 4] = a3, this.uint16[f2 + 5] = s2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c5, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p3, t3;
            }
          }
          zi.prototype.bytesPerElement = 24, In("StructArrayLayout4i4ui4i24", zi);
          class Mi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t3, e3, r2);
            }
            emplace(t3, e3, r2, n3) {
              const i3 = 3 * t3;
              return this.float32[i3 + 0] = e3, this.float32[i3 + 1] = r2, this.float32[i3 + 2] = n3, t3;
            }
          }
          Mi.prototype.bytesPerElement = 12, In("StructArrayLayout3f12", Mi);
          class Pi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t3) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }
            emplace(t3, e3) {
              return this.uint32[1 * t3 + 0] = e3, t3;
            }
          }
          Pi.prototype.bytesPerElement = 4, In("StructArrayLayout1ul4", Pi);
          class Bi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3, s2, o2, l2) {
              const u2 = this.length;
              return this.resize(u2 + 1), this.emplace(u2, t3, e3, r2, n3, i3, a3, s2, o2, l2);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2) {
              const c5 = 10 * t3, h2 = 5 * t3;
              return this.int16[c5 + 0] = e3, this.int16[c5 + 1] = r2, this.int16[c5 + 2] = n3, this.int16[c5 + 3] = i3, this.int16[c5 + 4] = a3, this.int16[c5 + 5] = s2, this.uint32[h2 + 3] = o2, this.uint16[c5 + 8] = l2, this.uint16[c5 + 9] = u2, t3;
            }
          }
          Bi.prototype.bytesPerElement = 20, In("StructArrayLayout6i1ul2ui20", Bi);
          class Ci extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t3, e3, r2, n3, i3, a3);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2) {
              const o2 = 6 * t3;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n3, this.int16[o2 + 3] = i3, this.int16[o2 + 4] = a3, this.int16[o2 + 5] = s2, t3;
            }
          }
          Ci.prototype.bytesPerElement = 12, In("StructArrayLayout2i2i2i12", Ci);
          class Vi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3) {
              const a3 = this.length;
              return this.resize(a3 + 1), this.emplace(a3, t3, e3, r2, n3, i3);
            }
            emplace(t3, e3, r2, n3, i3, a3) {
              const s2 = 4 * t3, o2 = 8 * t3;
              return this.float32[s2 + 0] = e3, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n3, this.int16[o2 + 6] = i3, this.int16[o2 + 7] = a3, t3;
            }
          }
          Vi.prototype.bytesPerElement = 16, In("StructArrayLayout2f1f2i16", Vi);
          class Ei extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3) {
              const i3 = this.length;
              return this.resize(i3 + 1), this.emplace(i3, t3, e3, r2, n3);
            }
            emplace(t3, e3, r2, n3, i3) {
              const a3 = 12 * t3, s2 = 3 * t3;
              return this.uint8[a3 + 0] = e3, this.uint8[a3 + 1] = r2, this.float32[s2 + 1] = n3, this.float32[s2 + 2] = i3, t3;
            }
          }
          Ei.prototype.bytesPerElement = 12, In("StructArrayLayout2ub2f12", Ei);
          class Fi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t3, e3, r2);
            }
            emplace(t3, e3, r2, n3) {
              const i3 = 3 * t3;
              return this.uint16[i3 + 0] = e3, this.uint16[i3 + 1] = r2, this.uint16[i3 + 2] = n3, t3;
            }
          }
          Fi.prototype.bytesPerElement = 6, In("StructArrayLayout3ui6", Fi);
          class Ti extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4) {
              const g3 = this.length;
              return this.resize(g3 + 1), this.emplace(g3, t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4, g3) {
              const x2 = 24 * t3, v2 = 12 * t3, b3 = 48 * t3;
              return this.int16[x2 + 0] = e3, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n3, this.uint16[x2 + 3] = i3, this.uint32[v2 + 2] = a3, this.uint32[v2 + 3] = s2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c5, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p3, this.uint8[b3 + 36] = f2, this.uint8[b3 + 37] = d3, this.uint8[b3 + 38] = y2, this.uint32[v2 + 10] = m4, this.int16[x2 + 22] = g3, t3;
            }
          }
          Ti.prototype.bytesPerElement = 48, In("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ti);
          class Li extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4, g3, x2, v2, b3, w2, _2, A2, k2, S2, I2, z2) {
              const M2 = this.length;
              return this.resize(M2 + 1), this.emplace(M2, t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4, g3, x2, v2, b3, w2, _2, A2, k2, S2, I2, z2);
            }
            emplace(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4, g3, x2, v2, b3, w2, _2, A2, k2, S2, I2, z2, M2) {
              const P2 = 34 * t3, B2 = 17 * t3;
              return this.int16[P2 + 0] = e3, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n3, this.int16[P2 + 3] = i3, this.int16[P2 + 4] = a3, this.int16[P2 + 5] = s2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l2, this.uint16[P2 + 8] = u2, this.uint16[P2 + 9] = c5, this.uint16[P2 + 10] = h2, this.uint16[P2 + 11] = p3, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d3, this.uint16[P2 + 14] = y2, this.uint16[P2 + 15] = m4, this.uint16[P2 + 16] = g3, this.uint16[P2 + 17] = x2, this.uint16[P2 + 18] = v2, this.uint16[P2 + 19] = b3, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _2, this.uint16[P2 + 22] = A2, this.uint32[B2 + 12] = k2, this.float32[B2 + 13] = S2, this.float32[B2 + 14] = I2, this.float32[B2 + 15] = z2, this.float32[B2 + 16] = M2, t3;
            }
          }
          Li.prototype.bytesPerElement = 68, In("StructArrayLayout8i15ui1ul4f68", Li);
          class $i extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }
            emplace(t3, e3) {
              return this.float32[1 * t3 + 0] = e3, t3;
            }
          }
          $i.prototype.bytesPerElement = 4, In("StructArrayLayout1f4", $i);
          class Di extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t3, e3, r2);
            }
            emplace(t3, e3, r2, n3) {
              const i3 = 4 * t3;
              return this.uint32[2 * t3 + 0] = e3, this.uint16[i3 + 2] = r2, this.uint16[i3 + 3] = n3, t3;
            }
          }
          Di.prototype.bytesPerElement = 8, In("StructArrayLayout1ul2ui8", Di);
          class Oi extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }
            emplace(t3, e3, r2) {
              const n3 = 2 * t3;
              return this.uint16[n3 + 0] = e3, this.uint16[n3 + 1] = r2, t3;
            }
          }
          Oi.prototype.bytesPerElement = 4, In("StructArrayLayout2ui4", Oi);
          class Ui extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t3) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }
            emplace(t3, e3) {
              return this.uint16[1 * t3 + 0] = e3, t3;
            }
          }
          Ui.prototype.bytesPerElement = 2, In("StructArrayLayout1ui2", Ui);
          class Ri extends gi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t3, e3, r2, n3) {
              const i3 = this.length;
              return this.resize(i3 + 1), this.emplace(i3, t3, e3, r2, n3);
            }
            emplace(t3, e3, r2, n3, i3) {
              const a3 = 4 * t3;
              return this.float32[a3 + 0] = e3, this.float32[a3 + 1] = r2, this.float32[a3 + 2] = n3, this.float32[a3 + 3] = i3, t3;
            }
          }
          Ri.prototype.bytesPerElement = 16, In("StructArrayLayout4f16", Ri);
          class qi extends mi {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new i2(this.anchorPointX, this.anchorPointY);
            }
          }
          qi.prototype.size = 20;
          class ji extends Bi {
            get(t3) {
              return new qi(this, t3);
            }
          }
          In("CollisionBoxArray", ji);
          class Ni extends mi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t3) {
              this._structArray.uint8[this._pos1 + 37] = t3;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t3) {
              this._structArray.uint8[this._pos1 + 38] = t3;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t3) {
              this._structArray.uint32[this._pos4 + 10] = t3;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          Ni.prototype.size = 48;
          class Zi extends Ti {
            get(t3) {
              return new Ni(this, t3);
            }
          }
          In("PlacedSymbolArray", Zi);
          class Ki extends mi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t3) {
              this._structArray.uint32[this._pos4 + 12] = t3;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 16];
            }
          }
          Ki.prototype.size = 68;
          class Gi extends Li {
            get(t3) {
              return new Ki(this, t3);
            }
          }
          In("SymbolInstanceArray", Gi);
          class Ji extends $i {
            getoffsetX(t3) {
              return this.float32[1 * t3 + 0];
            }
          }
          In("GlyphOffsetArray", Ji);
          class Xi extends wi {
            getx(t3) {
              return this.int16[3 * t3 + 0];
            }
            gety(t3) {
              return this.int16[3 * t3 + 1];
            }
            gettileUnitDistanceFromAnchor(t3) {
              return this.int16[3 * t3 + 2];
            }
          }
          In("SymbolLineVertexArray", Xi);
          class Yi extends mi {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          Yi.prototype.size = 8;
          class Hi extends Di {
            get(t3) {
              return new Yi(this, t3);
            }
          }
          In("FeatureIndexArray", Hi);
          class Wi extends bi {
          }
          class Qi extends bi {
          }
          class ta extends bi {
          }
          class ea extends Ai {
          }
          class ra extends ki {
          }
          class na extends Si {
          }
          class ia extends Ii {
          }
          class aa extends zi {
          }
          class sa extends Mi {
          }
          class oa extends Pi {
          }
          class la extends Ci {
          }
          class ua extends Ei {
          }
          class ca extends Fi {
          }
          class ha extends Oi {
          }
          const pa = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: fa } = pa;
          class da {
            constructor(t3 = []) {
              this.segments = t3;
            }
            prepareSegment(t3, e3, r2, n3) {
              let i3 = this.segments[this.segments.length - 1];
              return t3 > da.MAX_VERTEX_ARRAY_LENGTH && x(`Max vertices per segment is ${da.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t3}`), (!i3 || i3.vertexLength + t3 > da.MAX_VERTEX_ARRAY_LENGTH || i3.sortKey !== n3) && (i3 = { vertexOffset: e3.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i3.sortKey = n3), this.segments.push(i3)), i3;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t3 of this.segments)
                for (const e3 in t3.vaos)
                  t3.vaos[e3].destroy();
            }
            static simpleSegment(t3, e3, r2, n3) {
              return new da([{ vertexOffset: t3, primitiveOffset: e3, vertexLength: r2, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
            }
          }
          function ya(t3, e3) {
            return 256 * (t3 = c4(Math.floor(t3), 0, 255)) + c4(Math.floor(e3), 0, 255);
          }
          da.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, In("SegmentVector", da);
          const ma = xi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var ga = { exports: {} }, xa = { exports: {} };
          xa.exports = function(t3, e3) {
            var r2, n3, i3, a3, s2, o2, l2, u2;
            for (n3 = t3.length - (r2 = 3 & t3.length), i3 = e3, s2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n3; )
              l2 = 255 & t3.charCodeAt(u2) | (255 & t3.charCodeAt(++u2)) << 8 | (255 & t3.charCodeAt(++u2)) << 16 | (255 & t3.charCodeAt(++u2)) << 24, ++u2, i3 = 27492 + (65535 & (a3 = 5 * (65535 & (i3 = (i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i3 >>> 19)) + ((5 * (i3 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a3 >>> 16) & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t3.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t3.charCodeAt(u2 + 1)) << 8;
              case 1:
                i3 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u2))) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i3 ^= t3.length, i3 = 2246822507 * (65535 & (i3 ^= i3 >>> 16)) + ((2246822507 * (i3 >>> 16) & 65535) << 16) & 4294967295, i3 = 3266489909 * (65535 & (i3 ^= i3 >>> 13)) + ((3266489909 * (i3 >>> 16) & 65535) << 16) & 4294967295, (i3 ^= i3 >>> 16) >>> 0;
          };
          var va = xa.exports, ba = { exports: {} };
          ba.exports = function(t3, e3) {
            for (var r2, n3 = t3.length, i3 = e3 ^ n3, a3 = 0; n3 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(a3) | (255 & t3.charCodeAt(++a3)) << 8 | (255 & t3.charCodeAt(++a3)) << 16 | (255 & t3.charCodeAt(++a3)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i3 = 1540483477 * (65535 & i3) + ((1540483477 * (i3 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n3 -= 4, ++a3;
            switch (n3) {
              case 3:
                i3 ^= (255 & t3.charCodeAt(a3 + 2)) << 16;
              case 2:
                i3 ^= (255 & t3.charCodeAt(a3 + 1)) << 8;
              case 1:
                i3 = 1540483477 * (65535 & (i3 ^= 255 & t3.charCodeAt(a3))) + ((1540483477 * (i3 >>> 16) & 65535) << 16);
            }
            return i3 = 1540483477 * (65535 & (i3 ^= i3 >>> 13)) + ((1540483477 * (i3 >>> 16) & 65535) << 16), (i3 ^= i3 >>> 15) >>> 0;
          };
          var wa = va, _a2 = ba.exports;
          ga.exports = wa, ga.exports.murmur3 = wa, ga.exports.murmur2 = _a2;
          var Aa = e2(ga.exports);
          class ka {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t3, e3, r2, n3) {
              this.ids.push(Sa(t3)), this.positions.push(e3, r2, n3);
            }
            getPositions(t3) {
              if (!this.indexed)
                throw new Error("Trying to get index, but feature positions are not indexed");
              const e3 = Sa(t3);
              let r2 = 0, n3 = this.ids.length - 1;
              for (; r2 < n3; ) {
                const t4 = r2 + n3 >> 1;
                this.ids[t4] >= e3 ? n3 = t4 : r2 = t4 + 1;
              }
              const i3 = [];
              for (; this.ids[r2] === e3; )
                i3.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
              return i3;
            }
            static serialize(t3, e3) {
              const r2 = new Float64Array(t3.ids), n3 = new Uint32Array(t3.positions);
              return Ia(r2, n3, 0, r2.length - 1), e3 && e3.push(r2.buffer, n3.buffer), { ids: r2, positions: n3 };
            }
            static deserialize(t3) {
              const e3 = new ka();
              return e3.ids = t3.ids, e3.positions = t3.positions, e3.indexed = true, e3;
            }
          }
          function Sa(t3) {
            const e3 = +t3;
            return !isNaN(e3) && e3 <= Number.MAX_SAFE_INTEGER ? e3 : Aa(String(t3));
          }
          function Ia(t3, e3, r2, n3) {
            for (; r2 < n3; ) {
              const i3 = t3[r2 + n3 >> 1];
              let a3 = r2 - 1, s2 = n3 + 1;
              for (; ; ) {
                do {
                  a3++;
                } while (t3[a3] < i3);
                do {
                  s2--;
                } while (t3[s2] > i3);
                if (a3 >= s2)
                  break;
                za(t3, a3, s2), za(e3, 3 * a3, 3 * s2), za(e3, 3 * a3 + 1, 3 * s2 + 1), za(e3, 3 * a3 + 2, 3 * s2 + 2);
              }
              s2 - r2 < n3 - s2 ? (Ia(t3, e3, r2, s2), r2 = s2 + 1) : (Ia(t3, e3, s2 + 1, n3), n3 = s2);
            }
          }
          function za(t3, e3, r2) {
            const n3 = t3[e3];
            t3[e3] = t3[r2], t3[r2] = n3;
          }
          In("FeaturePositionMap", ka);
          class Ma {
            constructor(t3, e3) {
              this.gl = t3.gl, this.location = e3;
            }
          }
          class Pa extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = 0;
            }
            set(t3) {
              this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
            }
          }
          class Ba extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = [0, 0, 0, 0];
            }
            set(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
            }
          }
          class Ca extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = qt.transparent;
            }
            set(t3) {
              t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
            }
          }
          const Va = new Float32Array(16);
          function Ea(t3) {
            return [ya(255 * t3.r, 255 * t3.g), ya(255 * t3.b, 255 * t3.a)];
          }
          class Fa {
            constructor(t3, e3, r2) {
              this.value = t3, this.uniformNames = e3.map((t4) => `u_${t4}`), this.type = r2;
            }
            setUniform(t3, e3, r2) {
              t3.set(r2.constantOr(this.value));
            }
            getBinding(t3, e3, r2) {
              return "color" === this.type ? new Ca(t3, e3) : new Pa(t3, e3);
            }
          }
          class Ta {
            constructor(t3, e3) {
              this.uniformNames = e3.map((t4) => `u_${t4}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t3, e3) {
              this.pixelRatioFrom = e3.pixelRatio, this.pixelRatioTo = t3.pixelRatio, this.patternFrom = e3.tlbr, this.patternTo = t3.tlbr;
            }
            setUniform(t3, e3, r2, n3) {
              const i3 = "u_pattern_to" === n3 ? this.patternTo : "u_pattern_from" === n3 ? this.patternFrom : "u_pixel_ratio_to" === n3 ? this.pixelRatioTo : "u_pixel_ratio_from" === n3 ? this.pixelRatioFrom : null;
              i3 && t3.set(i3);
            }
            getBinding(t3, e3, r2) {
              return "u_pattern" === r2.substr(0, 9) ? new Ba(t3, e3) : new Pa(t3, e3);
            }
          }
          class La {
            constructor(t3, e3, r2, n3) {
              this.expression = t3, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
            }
            populatePaintArray(t3, e3, r2, n3, i3) {
              const a3 = this.paintVertexArray.length, s2 = this.expression.evaluate(new Wn(0), e3, {}, n3, [], i3);
              this.paintVertexArray.resize(t3), this._setPaintValue(a3, t3, s2);
            }
            updatePaintArray(t3, e3, r2, n3) {
              const i3 = this.expression.evaluate({ zoom: 0 }, r2, n3);
              this._setPaintValue(t3, e3, i3);
            }
            _setPaintValue(t3, e3, r2) {
              if ("color" === this.type) {
                const n3 = Ea(r2);
                for (let r3 = t3; r3 < e3; r3++)
                  this.paintVertexArray.emplace(r3, n3[0], n3[1]);
              } else {
                for (let n3 = t3; n3 < e3; n3++)
                  this.paintVertexArray.emplace(n3, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t3) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class $a {
            constructor(t3, e3, r2, n3, i3, a3) {
              this.expression = t3, this.uniformNames = e3.map((t4) => `u_${t4}_t`), this.type = r2, this.useIntegerZoom = n3, this.zoom = i3, this.maxValue = 0, this.paintVertexAttributes = e3.map((t4) => ({ name: `a_${t4}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a3();
            }
            populatePaintArray(t3, e3, r2, n3, i3) {
              const a3 = this.expression.evaluate(new Wn(this.zoom), e3, {}, n3, [], i3), s2 = this.expression.evaluate(new Wn(this.zoom + 1), e3, {}, n3, [], i3), o2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t3), this._setPaintValue(o2, t3, a3, s2);
            }
            updatePaintArray(t3, e3, r2, n3) {
              const i3 = this.expression.evaluate({ zoom: this.zoom }, r2, n3), a3 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n3);
              this._setPaintValue(t3, e3, i3, a3);
            }
            _setPaintValue(t3, e3, r2, n3) {
              if ("color" === this.type) {
                const i3 = Ea(r2), a3 = Ea(n3);
                for (let r3 = t3; r3 < e3; r3++)
                  this.paintVertexArray.emplace(r3, i3[0], i3[1], a3[0], a3[1]);
              } else {
                for (let i3 = t3; i3 < e3; i3++)
                  this.paintVertexArray.emplace(i3, r2, n3);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n3));
              }
            }
            upload(t3) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t3.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t3, e3) {
              const r2 = this.useIntegerZoom ? Math.floor(e3.zoom) : e3.zoom, n3 = c4(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
              t3.set(n3);
            }
            getBinding(t3, e3, r2) {
              return new Pa(t3, e3);
            }
          }
          class Da {
            constructor(t3, e3, r2, n3, i3, a3) {
              this.expression = t3, this.type = e3, this.useIntegerZoom = r2, this.zoom = n3, this.layerId = a3, this.zoomInPaintVertexArray = new i3(), this.zoomOutPaintVertexArray = new i3();
            }
            populatePaintArray(t3, e3, r2) {
              const n3 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t3), this.zoomOutPaintVertexArray.resize(t3), this._setPaintValues(n3, t3, e3.patterns && e3.patterns[this.layerId], r2);
            }
            updatePaintArray(t3, e3, r2, n3, i3) {
              this._setPaintValues(t3, e3, r2.patterns && r2.patterns[this.layerId], i3);
            }
            _setPaintValues(t3, e3, r2, n3) {
              if (!n3 || !r2)
                return;
              const { min: i3, mid: a3, max: s2 } = r2, o2 = n3[i3], l2 = n3[a3], u2 = n3[s2];
              if (o2 && l2 && u2)
                for (let r3 = t3; r3 < e3; r3++)
                  this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
            }
            upload(t3) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t3.createVertexBuffer(this.zoomInPaintVertexArray, ma.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t3.createVertexBuffer(this.zoomOutPaintVertexArray, ma.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class Oa {
            constructor(t3, e3, r2) {
              this.binders = {}, this._buffers = [];
              const n3 = [];
              for (const i3 in t3.paint._values) {
                if (!r2(i3))
                  continue;
                const a3 = t3.paint.get(i3);
                if (!(a3 instanceof ai && pr(a3.property.specification)))
                  continue;
                const s2 = Ra(i3, t3.type), o2 = a3.value, l2 = a3.property.specification.type, u2 = a3.property.useIntegerZoom, c5 = a3.property.specification["property-type"], h2 = "cross-faded" === c5 || "cross-faded-data-driven" === c5;
                if ("constant" === o2.kind)
                  this.binders[i3] = h2 ? new Ta(o2.value, s2) : new Fa(o2.value, s2, l2), n3.push(`/u_${i3}`);
                else if ("source" === o2.kind || h2) {
                  const r3 = qa(i3, l2, "source");
                  this.binders[i3] = h2 ? new Da(o2, l2, u2, e3, r3, t3.id) : new La(o2, s2, l2, r3), n3.push(`/a_${i3}`);
                } else {
                  const t4 = qa(i3, l2, "composite");
                  this.binders[i3] = new $a(o2, s2, l2, u2, e3, t4), n3.push(`/z_${i3}`);
                }
              }
              this.cacheKey = n3.sort().join("");
            }
            getMaxValue(t3) {
              const e3 = this.binders[t3];
              return e3 instanceof La || e3 instanceof $a ? e3.maxValue : 0;
            }
            populatePaintArrays(t3, e3, r2, n3, i3) {
              for (const a3 in this.binders) {
                const s2 = this.binders[a3];
                (s2 instanceof La || s2 instanceof $a || s2 instanceof Da) && s2.populatePaintArray(t3, e3, r2, n3, i3);
              }
            }
            setConstantPatternPositions(t3, e3) {
              for (const r2 in this.binders) {
                const n3 = this.binders[r2];
                n3 instanceof Ta && n3.setConstantPatternPositions(t3, e3);
              }
            }
            updatePaintArrays(t3, e3, r2, n3, i3) {
              let a3 = false;
              for (const s2 in t3) {
                const o2 = e3.getPositions(s2);
                for (const e4 of o2) {
                  const o3 = r2.feature(e4.index);
                  for (const r3 in this.binders) {
                    const l2 = this.binders[r3];
                    if ((l2 instanceof La || l2 instanceof $a || l2 instanceof Da) && true === l2.expression.isStateDependent) {
                      const u2 = n3.paint.get(r3);
                      l2.expression = u2.value, l2.updatePaintArray(e4.start, e4.end, o3, t3[s2], i3), a3 = true;
                    }
                  }
                }
              }
              return a3;
            }
            defines() {
              const t3 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                (r2 instanceof Fa || r2 instanceof Ta) && t3.push(...r2.uniformNames.map((t4) => `#define HAS_UNIFORM_${t4}`));
              }
              return t3;
            }
            getBinderAttributes() {
              const t3 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (r2 instanceof La || r2 instanceof $a)
                  for (let e4 = 0; e4 < r2.paintVertexAttributes.length; e4++)
                    t3.push(r2.paintVertexAttributes[e4].name);
                else if (r2 instanceof Da)
                  for (let e4 = 0; e4 < ma.members.length; e4++)
                    t3.push(ma.members[e4].name);
              }
              return t3;
            }
            getBinderUniforms() {
              const t3 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (r2 instanceof Fa || r2 instanceof Ta || r2 instanceof $a)
                  for (const e4 of r2.uniformNames)
                    t3.push(e4);
              }
              return t3;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t3, e3) {
              const r2 = [];
              for (const n3 in this.binders) {
                const i3 = this.binders[n3];
                if (i3 instanceof Fa || i3 instanceof Ta || i3 instanceof $a) {
                  for (const a3 of i3.uniformNames)
                    if (e3[a3]) {
                      const s2 = i3.getBinding(t3, e3[a3], a3);
                      r2.push({ name: a3, property: n3, binding: s2 });
                    }
                }
              }
              return r2;
            }
            setUniforms(t3, e3, r2, n3) {
              for (const { name: t4, property: i3, binding: a3 } of e3)
                this.binders[i3].setUniform(a3, n3, r2.get(i3), t4);
            }
            updatePaintBuffers(t3) {
              this._buffers = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (t3 && r2 instanceof Da) {
                  const e4 = 2 === t3.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                  e4 && this._buffers.push(e4);
                } else
                  (r2 instanceof La || r2 instanceof $a) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
              }
            }
            upload(t3) {
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                (r2 instanceof La || r2 instanceof $a || r2 instanceof Da) && r2.upload(t3);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t3 in this.binders) {
                const e3 = this.binders[t3];
                (e3 instanceof La || e3 instanceof $a || e3 instanceof Da) && e3.destroy();
              }
            }
          }
          class Ua {
            constructor(t3, e3, r2 = () => true) {
              this.programConfigurations = {};
              for (const n3 of t3)
                this.programConfigurations[n3.id] = new Oa(n3, e3, r2);
              this.needsUpload = false, this._featureMap = new ka(), this._bufferOffset = 0;
            }
            populatePaintArrays(t3, e3, r2, n3, i3, a3) {
              for (const r3 in this.programConfigurations)
                this.programConfigurations[r3].populatePaintArrays(t3, e3, n3, i3, a3);
              void 0 !== e3.id && this._featureMap.add(e3.id, r2, this._bufferOffset, t3), this._bufferOffset = t3, this.needsUpload = true;
            }
            updatePaintArrays(t3, e3, r2, n3) {
              for (const i3 of r2)
                this.needsUpload = this.programConfigurations[i3.id].updatePaintArrays(t3, this._featureMap, e3, i3, n3) || this.needsUpload;
            }
            get(t3) {
              return this.programConfigurations[t3];
            }
            upload(t3) {
              if (this.needsUpload) {
                for (const e3 in this.programConfigurations)
                  this.programConfigurations[e3].upload(t3);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t3 in this.programConfigurations)
                this.programConfigurations[t3].destroy();
            }
          }
          function Ra(t3, e3) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t3] || [t3.replace(`${e3}-`, "").replace(/-/g, "_")];
          }
          function qa(t3, e3, r2) {
            const n3 = { color: { source: Si, composite: Ri }, number: { source: $i, composite: Si } }, i3 = function(t4) {
              return { "line-pattern": { source: ia, composite: ia }, "fill-pattern": { source: ia, composite: ia }, "fill-extrusion-pattern": { source: ia, composite: ia } }[t4];
            }(t3);
            return i3 && i3[r2] || n3[e3][r2];
          }
          In("ConstantBinder", Fa), In("CrossFadedConstantBinder", Ta), In("SourceExpressionBinder", La), In("CrossFadedCompositeBinder", Da), In("CompositeExpressionBinder", $a), In("ProgramConfiguration", Oa, { omit: ["_buffers"] }), In("ProgramConfigurationSet", Ua);
          const ja = 8192, Na = Math.pow(2, 14) - 1, Za = -Na - 1;
          function Ka(t3) {
            const e3 = ja / t3.extent, r2 = t3.loadGeometry();
            for (let t4 = 0; t4 < r2.length; t4++) {
              const n3 = r2[t4];
              for (let t5 = 0; t5 < n3.length; t5++) {
                const r3 = n3[t5], i3 = Math.round(r3.x * e3), a3 = Math.round(r3.y * e3);
                r3.x = c4(i3, Za, Na), r3.y = c4(a3, Za, Na), (i3 < r3.x || i3 > r3.x + 1 || a3 < r3.y || a3 > r3.y + 1) && x("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r2;
          }
          function Ga(t3, e3) {
            return { type: t3.type, id: t3.id, properties: t3.properties, geometry: e3 ? Ka(t3) : [] };
          }
          function Ja(t3, e3, r2, n3, i3) {
            t3.emplaceBack(2 * e3 + (n3 + 1) / 2, 2 * r2 + (i3 + 1) / 2);
          }
          class Xa {
            constructor(t3) {
              this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new Qi(), this.indexArray = new ca(), this.segments = new da(), this.programConfigurations = new Ua(t3.layers, t3.zoom), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
            }
            populate(t3, e3, r2) {
              const n3 = this.layers[0], i3 = [];
              let a3 = null, s2 = false;
              "circle" === n3.type && (a3 = n3.layout.get("circle-sort-key"), s2 = !a3.isConstant());
              for (const { feature: e4, id: n4, index: o2, sourceLayerIndex: l2 } of t3) {
                const t4 = this.layers[0]._featureFilter.needGeometry, u2 = Ga(e4, t4);
                if (!this.layers[0]._featureFilter.filter(new Wn(this.zoom), u2, r2))
                  continue;
                const c5 = s2 ? a3.evaluate(u2, {}, r2) : void 0, h2 = { id: n4, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t4 ? u2.geometry : Ka(e4), patterns: {}, sortKey: c5 };
                i3.push(h2);
              }
              s2 && i3.sort((t4, e4) => t4.sortKey - e4.sortKey);
              for (const n4 of i3) {
                const { geometry: i4, index: a4, sourceLayerIndex: s3 } = n4, o2 = t3[a4].feature;
                this.addFeature(n4, i4, a4, r2), e3.featureIndex.insert(o2, i4, a4, s3, this.index);
              }
            }
            update(t3, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t3) {
              this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, fa), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t3, e3, r2, n3) {
              for (const r3 of e3)
                for (const e4 of r3) {
                  const r4 = e4.x, n4 = e4.y;
                  if (r4 < 0 || r4 >= ja || n4 < 0 || n4 >= ja)
                    continue;
                  const i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t3.sortKey), a3 = i3.vertexLength;
                  Ja(this.layoutVertexArray, r4, n4, -1, -1), Ja(this.layoutVertexArray, r4, n4, 1, -1), Ja(this.layoutVertexArray, r4, n4, 1, 1), Ja(this.layoutVertexArray, r4, n4, -1, 1), this.indexArray.emplaceBack(a3, a3 + 1, a3 + 2), this.indexArray.emplaceBack(a3, a3 + 3, a3 + 2), i3.vertexLength += 4, i3.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r2, {}, n3);
            }
          }
          function Ya(t3, e3) {
            for (let r2 = 0; r2 < t3.length; r2++)
              if (as(e3, t3[r2]))
                return true;
            for (let r2 = 0; r2 < e3.length; r2++)
              if (as(t3, e3[r2]))
                return true;
            return !!ts(t3, e3);
          }
          function Ha(t3, e3, r2) {
            return !!as(t3, e3) || !!rs(e3, t3, r2);
          }
          function Wa(t3, e3) {
            if (1 === t3.length)
              return is(e3, t3[0]);
            for (let r2 = 0; r2 < e3.length; r2++) {
              const n3 = e3[r2];
              for (let e4 = 0; e4 < n3.length; e4++)
                if (as(t3, n3[e4]))
                  return true;
            }
            for (let r2 = 0; r2 < t3.length; r2++)
              if (is(e3, t3[r2]))
                return true;
            for (let r2 = 0; r2 < e3.length; r2++)
              if (ts(t3, e3[r2]))
                return true;
            return false;
          }
          function Qa(t3, e3, r2) {
            if (t3.length > 1) {
              if (ts(t3, e3))
                return true;
              for (let n3 = 0; n3 < e3.length; n3++)
                if (rs(e3[n3], t3, r2))
                  return true;
            }
            for (let n3 = 0; n3 < t3.length; n3++)
              if (rs(t3[n3], e3, r2))
                return true;
            return false;
          }
          function ts(t3, e3) {
            if (0 === t3.length || 0 === e3.length)
              return false;
            for (let r2 = 0; r2 < t3.length - 1; r2++) {
              const n3 = t3[r2], i3 = t3[r2 + 1];
              for (let t4 = 0; t4 < e3.length - 1; t4++)
                if (es(n3, i3, e3[t4], e3[t4 + 1]))
                  return true;
            }
            return false;
          }
          function es(t3, e3, r2, n3) {
            return v(t3, r2, n3) !== v(e3, r2, n3) && v(t3, e3, r2) !== v(t3, e3, n3);
          }
          function rs(t3, e3, r2) {
            const n3 = r2 * r2;
            if (1 === e3.length)
              return t3.distSqr(e3[0]) < n3;
            for (let r3 = 1; r3 < e3.length; r3++)
              if (ns(t3, e3[r3 - 1], e3[r3]) < n3)
                return true;
            return false;
          }
          function ns(t3, e3, r2) {
            const n3 = e3.distSqr(r2);
            if (0 === n3)
              return t3.distSqr(e3);
            const i3 = ((t3.x - e3.x) * (r2.x - e3.x) + (t3.y - e3.y) * (r2.y - e3.y)) / n3;
            return t3.distSqr(i3 < 0 ? e3 : i3 > 1 ? r2 : r2.sub(e3)._mult(i3)._add(e3));
          }
          function is(t3, e3) {
            let r2, n3, i3, a3 = false;
            for (let s2 = 0; s2 < t3.length; s2++) {
              r2 = t3[s2];
              for (let t4 = 0, s3 = r2.length - 1; t4 < r2.length; s3 = t4++)
                n3 = r2[t4], i3 = r2[s3], n3.y > e3.y != i3.y > e3.y && e3.x < (i3.x - n3.x) * (e3.y - n3.y) / (i3.y - n3.y) + n3.x && (a3 = !a3);
            }
            return a3;
          }
          function as(t3, e3) {
            let r2 = false;
            for (let n3 = 0, i3 = t3.length - 1; n3 < t3.length; i3 = n3++) {
              const a3 = t3[n3], s2 = t3[i3];
              a3.y > e3.y != s2.y > e3.y && e3.x < (s2.x - a3.x) * (e3.y - a3.y) / (s2.y - a3.y) + a3.x && (r2 = !r2);
            }
            return r2;
          }
          function ss(t3, e3, r2) {
            const n3 = r2[0], i3 = r2[2];
            if (t3.x < n3.x && e3.x < n3.x || t3.x > i3.x && e3.x > i3.x || t3.y < n3.y && e3.y < n3.y || t3.y > i3.y && e3.y > i3.y)
              return false;
            const a3 = v(t3, e3, r2[0]);
            return a3 !== v(t3, e3, r2[1]) || a3 !== v(t3, e3, r2[2]) || a3 !== v(t3, e3, r2[3]);
          }
          function os(t3, e3, r2) {
            const n3 = e3.paint.get(t3).value;
            return "constant" === n3.kind ? n3.value : r2.programConfigurations.get(e3.id).getMaxValue(t3);
          }
          function ls(t3) {
            return Math.sqrt(t3[0] * t3[0] + t3[1] * t3[1]);
          }
          function us(t3, e3, r2, n3, a3) {
            if (!e3[0] && !e3[1])
              return t3;
            const s2 = i2.convert(e3)._mult(a3);
            "viewport" === r2 && s2._rotate(-n3);
            const o2 = [];
            for (let e4 = 0; e4 < t3.length; e4++)
              o2.push(t3[e4].sub(s2));
            return o2;
          }
          let cs, hs;
          In("CircleBucket", Xa, { omit: ["layers"] });
          var ps = { get paint() {
            return hs = hs || new pi({ "circle-radius": new li(q.paint_circle["circle-radius"]), "circle-color": new li(q.paint_circle["circle-color"]), "circle-blur": new li(q.paint_circle["circle-blur"]), "circle-opacity": new li(q.paint_circle["circle-opacity"]), "circle-translate": new oi(q.paint_circle["circle-translate"]), "circle-translate-anchor": new oi(q.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new oi(q.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new oi(q.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new li(q.paint_circle["circle-stroke-width"]), "circle-stroke-color": new li(q.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new li(q.paint_circle["circle-stroke-opacity"]) });
          }, get layout() {
            return cs = cs || new pi({ "circle-sort-key": new li(q.layout_circle["circle-sort-key"]) });
          } }, fs = 1e-6, ds = "undefined" != typeof Float32Array ? Float32Array : Array;
          function ys(t3) {
            return t3[0] = 1, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = 1, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 1, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
          }
          function ms(t3, e3, r2) {
            var n3 = e3[0], i3 = e3[1], a3 = e3[2], s2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c5 = e3[7], h2 = e3[8], p3 = e3[9], f2 = e3[10], d3 = e3[11], y2 = e3[12], m4 = e3[13], g3 = e3[14], x2 = e3[15], v2 = r2[0], b3 = r2[1], w2 = r2[2], _2 = r2[3];
            return t3[0] = v2 * n3 + b3 * o2 + w2 * h2 + _2 * y2, t3[1] = v2 * i3 + b3 * l2 + w2 * p3 + _2 * m4, t3[2] = v2 * a3 + b3 * u2 + w2 * f2 + _2 * g3, t3[3] = v2 * s2 + b3 * c5 + w2 * d3 + _2 * x2, t3[4] = (v2 = r2[4]) * n3 + (b3 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t3[5] = v2 * i3 + b3 * l2 + w2 * p3 + _2 * m4, t3[6] = v2 * a3 + b3 * u2 + w2 * f2 + _2 * g3, t3[7] = v2 * s2 + b3 * c5 + w2 * d3 + _2 * x2, t3[8] = (v2 = r2[8]) * n3 + (b3 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t3[9] = v2 * i3 + b3 * l2 + w2 * p3 + _2 * m4, t3[10] = v2 * a3 + b3 * u2 + w2 * f2 + _2 * g3, t3[11] = v2 * s2 + b3 * c5 + w2 * d3 + _2 * x2, t3[12] = (v2 = r2[12]) * n3 + (b3 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t3[13] = v2 * i3 + b3 * l2 + w2 * p3 + _2 * m4, t3[14] = v2 * a3 + b3 * u2 + w2 * f2 + _2 * g3, t3[15] = v2 * s2 + b3 * c5 + w2 * d3 + _2 * x2, t3;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t3 = 0, e3 = arguments.length; e3--; )
              t3 += arguments[e3] * arguments[e3];
            return Math.sqrt(t3);
          });
          var gs, xs = ms;
          function vs(t3, e3, r2) {
            var n3 = e3[0], i3 = e3[1], a3 = e3[2], s2 = e3[3];
            return t3[0] = r2[0] * n3 + r2[4] * i3 + r2[8] * a3 + r2[12] * s2, t3[1] = r2[1] * n3 + r2[5] * i3 + r2[9] * a3 + r2[13] * s2, t3[2] = r2[2] * n3 + r2[6] * i3 + r2[10] * a3 + r2[14] * s2, t3[3] = r2[3] * n3 + r2[7] * i3 + r2[11] * a3 + r2[15] * s2, t3;
          }
          gs = new ds(4), ds != Float32Array && (gs[0] = 0, gs[1] = 0, gs[2] = 0, gs[3] = 0);
          class bs extends di {
            constructor(t3) {
              super(t3, ps);
            }
            createBucket(t3) {
              return new Xa(t3);
            }
            queryRadius(t3) {
              const e3 = t3;
              return os("circle-radius", this, e3) + os("circle-stroke-width", this, e3) + ls(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t3, e3, r2, n3, i3, a3, s2, o2) {
              const l2 = us(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a3.angle, s2), u2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), c5 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c5 ? l2 : function(t4, e4) {
                return t4.map((t5) => ws(t5, e4));
              }(l2, o2), p3 = c5 ? u2 * s2 : u2;
              for (const t4 of n3)
                for (const e4 of t4) {
                  const t5 = c5 ? e4 : ws(e4, o2);
                  let r3 = p3;
                  const n4 = vs([], [e4.x, e4.y, 0, 1], o2);
                  if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n4[3] / a3.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= a3.cameraToCenterDistance / n4[3]), Ha(h2, t5, r3))
                    return true;
                }
              return false;
            }
          }
          function ws(t3, e3) {
            const r2 = vs([], [t3.x, t3.y, 0, 1], e3);
            return new i2(r2[0] / r2[3], r2[1] / r2[3]);
          }
          class _s extends Xa {
          }
          let As;
          In("HeatmapBucket", _s, { omit: ["layers"] });
          var ks = { get paint() {
            return As = As || new pi({ "heatmap-radius": new li(q.paint_heatmap["heatmap-radius"]), "heatmap-weight": new li(q.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new oi(q.paint_heatmap["heatmap-intensity"]), "heatmap-color": new hi(q.paint_heatmap["heatmap-color"]), "heatmap-opacity": new oi(q.paint_heatmap["heatmap-opacity"]) });
          } };
          function Ss(t3, { width: e3, height: r2 }, n3, i3) {
            if (i3) {
              if (i3 instanceof Uint8ClampedArray)
                i3 = new Uint8Array(i3.buffer);
              else if (i3.length !== e3 * r2 * n3)
                throw new RangeError(`mismatched image size. expected: ${i3.length} but got: ${e3 * r2 * n3}`);
            } else
              i3 = new Uint8Array(e3 * r2 * n3);
            return t3.width = e3, t3.height = r2, t3.data = i3, t3;
          }
          function Is(t3, { width: e3, height: r2 }, n3) {
            if (e3 === t3.width && r2 === t3.height)
              return;
            const i3 = Ss({}, { width: e3, height: r2 }, n3);
            zs(t3, i3, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t3.width, e3), height: Math.min(t3.height, r2) }, n3), t3.width = e3, t3.height = r2, t3.data = i3.data;
          }
          function zs(t3, e3, r2, n3, i3, a3) {
            if (0 === i3.width || 0 === i3.height)
              return e3;
            if (i3.width > t3.width || i3.height > t3.height || r2.x > t3.width - i3.width || r2.y > t3.height - i3.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i3.width > e3.width || i3.height > e3.height || n3.x > e3.width - i3.width || n3.y > e3.height - i3.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const s2 = t3.data, o2 = e3.data;
            if (s2 === o2)
              throw new Error("srcData equals dstData, so image is already copied");
            for (let l2 = 0; l2 < i3.height; l2++) {
              const u2 = ((r2.y + l2) * t3.width + r2.x) * a3, c5 = ((n3.y + l2) * e3.width + n3.x) * a3;
              for (let t4 = 0; t4 < i3.width * a3; t4++)
                o2[c5 + t4] = s2[u2 + t4];
            }
            return e3;
          }
          class Ms {
            constructor(t3, e3) {
              Ss(this, t3, 1, e3);
            }
            resize(t3) {
              Is(this, t3, 1);
            }
            clone() {
              return new Ms({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t3, e3, r2, n3, i3) {
              zs(t3, e3, r2, n3, i3, 1);
            }
          }
          class Ps {
            constructor(t3, e3) {
              Ss(this, t3, 4, e3);
            }
            resize(t3) {
              Is(this, t3, 4);
            }
            replace(t3, e3) {
              e3 ? this.data.set(t3) : this.data = t3 instanceof Uint8ClampedArray ? new Uint8Array(t3.buffer) : t3;
            }
            clone() {
              return new Ps({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t3, e3, r2, n3, i3) {
              zs(t3, e3, r2, n3, i3, 4);
            }
          }
          function Bs(t3) {
            const e3 = {}, r2 = t3.resolution || 256, n3 = t3.clips ? t3.clips.length : 1, i3 = t3.image || new Ps({ width: r2, height: n3 });
            if (Math.log(r2) / Math.LN2 % 1 != 0)
              throw new Error(`width is not a power of 2 - ${r2}`);
            const a3 = (r3, n4, a4) => {
              e3[t3.evaluationKey] = a4;
              const s2 = t3.expression.evaluate(e3);
              i3.data[r3 + n4 + 0] = Math.floor(255 * s2.r / s2.a), i3.data[r3 + n4 + 1] = Math.floor(255 * s2.g / s2.a), i3.data[r3 + n4 + 2] = Math.floor(255 * s2.b / s2.a), i3.data[r3 + n4 + 3] = Math.floor(255 * s2.a);
            };
            if (t3.clips)
              for (let e4 = 0, i4 = 0; e4 < n3; ++e4, i4 += 4 * r2)
                for (let n4 = 0, s2 = 0; n4 < r2; n4++, s2 += 4) {
                  const o2 = n4 / (r2 - 1), { start: l2, end: u2 } = t3.clips[e4];
                  a3(i4, s2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t4 = 0, e4 = 0; t4 < r2; t4++, e4 += 4)
                a3(0, e4, t4 / (r2 - 1));
            return i3;
          }
          In("AlphaImage", Ms), In("RGBAImage", Ps);
          class Cs extends di {
            createBucket(t3) {
              return new _s(t3);
            }
            constructor(t3) {
              super(t3, ks), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t3) {
              "heatmap-color" === t3 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Bs({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
          }
          let Vs;
          var Es = { get paint() {
            return Vs = Vs || new pi({ "hillshade-illumination-direction": new oi(q.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new oi(q.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new oi(q.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new oi(q.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new oi(q.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new oi(q.paint_hillshade["hillshade-accent-color"]) });
          } };
          class Fs extends di {
            constructor(t3) {
              super(t3, Es);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
          }
          const Ts = xi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ls } = Ts;
          var $s = { exports: {} };
          function Ds(t3, e3, r2) {
            r2 = r2 || 2;
            var n3, i3, a3, s2, o2, l2, u2, c5 = e3 && e3.length, h2 = c5 ? e3[0] * r2 : t3.length, p3 = Os(t3, 0, h2, r2, true), f2 = [];
            if (!p3 || p3.next === p3.prev)
              return f2;
            if (c5 && (p3 = function(t4, e4, r3, n4) {
              var i4, a4, s3, o3 = [];
              for (i4 = 0, a4 = e4.length; i4 < a4; i4++)
                (s3 = Os(t4, e4[i4] * n4, i4 < a4 - 1 ? e4[i4 + 1] * n4 : t4.length, n4, false)) === s3.next && (s3.steiner = true), o3.push(Ys(s3));
              for (o3.sort(Ks), i4 = 0; i4 < o3.length; i4++)
                r3 = Gs(o3[i4], r3);
              return r3;
            }(t3, e3, p3, r2)), t3.length > 80 * r2) {
              n3 = a3 = t3[0], i3 = s2 = t3[1];
              for (var d3 = r2; d3 < h2; d3 += r2)
                (o2 = t3[d3]) < n3 && (n3 = o2), (l2 = t3[d3 + 1]) < i3 && (i3 = l2), o2 > a3 && (a3 = o2), l2 > s2 && (s2 = l2);
              u2 = 0 !== (u2 = Math.max(a3 - n3, s2 - i3)) ? 32767 / u2 : 0;
            }
            return Rs(p3, f2, r2, n3, i3, u2, 0), f2;
          }
          function Os(t3, e3, r2, n3, i3) {
            var a3, s2;
            if (i3 === uo(t3, e3, r2, n3) > 0)
              for (a3 = e3; a3 < r2; a3 += n3)
                s2 = so(a3, t3[a3], t3[a3 + 1], s2);
            else
              for (a3 = r2 - n3; a3 >= e3; a3 -= n3)
                s2 = so(a3, t3[a3], t3[a3 + 1], s2);
            return s2 && to2(s2, s2.next) && (oo(s2), s2 = s2.next), s2;
          }
          function Us(t3, e3) {
            if (!t3)
              return t3;
            e3 || (e3 = t3);
            var r2, n3 = t3;
            do {
              if (r2 = false, n3.steiner || !to2(n3, n3.next) && 0 !== Qs(n3.prev, n3, n3.next))
                n3 = n3.next;
              else {
                if (oo(n3), (n3 = e3 = n3.prev) === n3.next)
                  break;
                r2 = true;
              }
            } while (r2 || n3 !== e3);
            return e3;
          }
          function Rs(t3, e3, r2, n3, i3, a3, s2) {
            if (t3) {
              !s2 && a3 && function(t4, e4, r3, n4) {
                var i4 = t4;
                do {
                  0 === i4.z && (i4.z = Xs(i4.x, i4.y, e4, r3, n4)), i4.prevZ = i4.prev, i4.nextZ = i4.next, i4 = i4.next;
                } while (i4 !== t4);
                i4.prevZ.nextZ = null, i4.prevZ = null, function(t5) {
                  var e5, r4, n5, i5, a4, s3, o3, l3, u3 = 1;
                  do {
                    for (r4 = t5, t5 = null, a4 = null, s3 = 0; r4; ) {
                      for (s3++, n5 = r4, o3 = 0, e5 = 0; e5 < u3 && (o3++, n5 = n5.nextZ); e5++)
                        ;
                      for (l3 = u3; o3 > 0 || l3 > 0 && n5; )
                        0 !== o3 && (0 === l3 || !n5 || r4.z <= n5.z) ? (i5 = r4, r4 = r4.nextZ, o3--) : (i5 = n5, n5 = n5.nextZ, l3--), a4 ? a4.nextZ = i5 : t5 = i5, i5.prevZ = a4, a4 = i5;
                      r4 = n5;
                    }
                    a4.nextZ = null, u3 *= 2;
                  } while (s3 > 1);
                }(i4);
              }(t3, n3, i3, a3);
              for (var o2, l2, u2 = t3; t3.prev !== t3.next; )
                if (o2 = t3.prev, l2 = t3.next, a3 ? js(t3, n3, i3, a3) : qs(t3))
                  e3.push(o2.i / r2 | 0), e3.push(t3.i / r2 | 0), e3.push(l2.i / r2 | 0), oo(t3), t3 = l2.next, u2 = l2.next;
                else if ((t3 = l2) === u2) {
                  s2 ? 1 === s2 ? Rs(t3 = Ns(Us(t3), e3, r2), e3, r2, n3, i3, a3, 2) : 2 === s2 && Zs(t3, e3, r2, n3, i3, a3) : Rs(Us(t3), e3, r2, n3, i3, a3, 1);
                  break;
                }
            }
          }
          function qs(t3) {
            var e3 = t3.prev, r2 = t3, n3 = t3.next;
            if (Qs(e3, r2, n3) >= 0)
              return false;
            for (var i3 = e3.x, a3 = r2.x, s2 = n3.x, o2 = e3.y, l2 = r2.y, u2 = n3.y, c5 = i3 < a3 ? i3 < s2 ? i3 : s2 : a3 < s2 ? a3 : s2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p3 = i3 > a3 ? i3 > s2 ? i3 : s2 : a3 > s2 ? a3 : s2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d3 = n3.next; d3 !== e3; ) {
              if (d3.x >= c5 && d3.x <= p3 && d3.y >= h2 && d3.y <= f2 && Hs(i3, o2, a3, l2, s2, u2, d3.x, d3.y) && Qs(d3.prev, d3, d3.next) >= 0)
                return false;
              d3 = d3.next;
            }
            return true;
          }
          function js(t3, e3, r2, n3) {
            var i3 = t3.prev, a3 = t3, s2 = t3.next;
            if (Qs(i3, a3, s2) >= 0)
              return false;
            for (var o2 = i3.x, l2 = a3.x, u2 = s2.x, c5 = i3.y, h2 = a3.y, p3 = s2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d3 = c5 < h2 ? c5 < p3 ? c5 : p3 : h2 < p3 ? h2 : p3, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m4 = c5 > h2 ? c5 > p3 ? c5 : p3 : h2 > p3 ? h2 : p3, g3 = Xs(f2, d3, e3, r2, n3), x2 = Xs(y2, m4, e3, r2, n3), v2 = t3.prevZ, b3 = t3.nextZ; v2 && v2.z >= g3 && b3 && b3.z <= x2; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d3 && v2.y <= m4 && v2 !== i3 && v2 !== s2 && Hs(o2, c5, l2, h2, u2, p3, v2.x, v2.y) && Qs(v2.prev, v2, v2.next) >= 0)
                return false;
              if (v2 = v2.prevZ, b3.x >= f2 && b3.x <= y2 && b3.y >= d3 && b3.y <= m4 && b3 !== i3 && b3 !== s2 && Hs(o2, c5, l2, h2, u2, p3, b3.x, b3.y) && Qs(b3.prev, b3, b3.next) >= 0)
                return false;
              b3 = b3.nextZ;
            }
            for (; v2 && v2.z >= g3; ) {
              if (v2.x >= f2 && v2.x <= y2 && v2.y >= d3 && v2.y <= m4 && v2 !== i3 && v2 !== s2 && Hs(o2, c5, l2, h2, u2, p3, v2.x, v2.y) && Qs(v2.prev, v2, v2.next) >= 0)
                return false;
              v2 = v2.prevZ;
            }
            for (; b3 && b3.z <= x2; ) {
              if (b3.x >= f2 && b3.x <= y2 && b3.y >= d3 && b3.y <= m4 && b3 !== i3 && b3 !== s2 && Hs(o2, c5, l2, h2, u2, p3, b3.x, b3.y) && Qs(b3.prev, b3, b3.next) >= 0)
                return false;
              b3 = b3.nextZ;
            }
            return true;
          }
          function Ns(t3, e3, r2) {
            var n3 = t3;
            do {
              var i3 = n3.prev, a3 = n3.next.next;
              !to2(i3, a3) && eo(i3, n3, n3.next, a3) && io(i3, a3) && io(a3, i3) && (e3.push(i3.i / r2 | 0), e3.push(n3.i / r2 | 0), e3.push(a3.i / r2 | 0), oo(n3), oo(n3.next), n3 = t3 = a3), n3 = n3.next;
            } while (n3 !== t3);
            return Us(n3);
          }
          function Zs(t3, e3, r2, n3, i3, a3) {
            var s2 = t3;
            do {
              for (var o2 = s2.next.next; o2 !== s2.prev; ) {
                if (s2.i !== o2.i && Ws(s2, o2)) {
                  var l2 = ao(s2, o2);
                  return s2 = Us(s2, s2.next), l2 = Us(l2, l2.next), Rs(s2, e3, r2, n3, i3, a3, 0), void Rs(l2, e3, r2, n3, i3, a3, 0);
                }
                o2 = o2.next;
              }
              s2 = s2.next;
            } while (s2 !== t3);
          }
          function Ks(t3, e3) {
            return t3.x - e3.x;
          }
          function Gs(t3, e3) {
            var r2 = function(t4, e4) {
              var r3, n4 = e4, i3 = t4.x, a3 = t4.y, s2 = -1 / 0;
              do {
                if (a3 <= n4.y && a3 >= n4.next.y && n4.next.y !== n4.y) {
                  var o2 = n4.x + (a3 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                  if (o2 <= i3 && o2 > s2 && (s2 = o2, r3 = n4.x < n4.next.x ? n4 : n4.next, o2 === i3))
                    return r3;
                }
                n4 = n4.next;
              } while (n4 !== e4);
              if (!r3)
                return null;
              var l2, u2 = r3, c5 = r3.x, h2 = r3.y, p3 = 1 / 0;
              n4 = r3;
              do {
                i3 >= n4.x && n4.x >= c5 && i3 !== n4.x && Hs(a3 < h2 ? i3 : s2, a3, c5, h2, a3 < h2 ? s2 : i3, a3, n4.x, n4.y) && (l2 = Math.abs(a3 - n4.y) / (i3 - n4.x), io(n4, t4) && (l2 < p3 || l2 === p3 && (n4.x > r3.x || n4.x === r3.x && Js(r3, n4))) && (r3 = n4, p3 = l2)), n4 = n4.next;
              } while (n4 !== u2);
              return r3;
            }(t3, e3);
            if (!r2)
              return e3;
            var n3 = ao(r2, t3);
            return Us(n3, n3.next), Us(r2, r2.next);
          }
          function Js(t3, e3) {
            return Qs(t3.prev, t3, e3.prev) < 0 && Qs(e3.next, t3, t3.next) < 0;
          }
          function Xs(t3, e3, r2, n3, i3) {
            return (t3 = 1431655765 & ((t3 = 858993459 & ((t3 = 252645135 & ((t3 = 16711935 & ((t3 = (t3 - r2) * i3 | 0) | t3 << 8)) | t3 << 4)) | t3 << 2)) | t3 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = (e3 - n3) * i3 | 0) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
          }
          function Ys(t3) {
            var e3 = t3, r2 = t3;
            do {
              (e3.x < r2.x || e3.x === r2.x && e3.y < r2.y) && (r2 = e3), e3 = e3.next;
            } while (e3 !== t3);
            return r2;
          }
          function Hs(t3, e3, r2, n3, i3, a3, s2, o2) {
            return (i3 - s2) * (e3 - o2) >= (t3 - s2) * (a3 - o2) && (t3 - s2) * (n3 - o2) >= (r2 - s2) * (e3 - o2) && (r2 - s2) * (a3 - o2) >= (i3 - s2) * (n3 - o2);
          }
          function Ws(t3, e3) {
            return t3.next.i !== e3.i && t3.prev.i !== e3.i && !function(t4, e4) {
              var r2 = t4;
              do {
                if (r2.i !== t4.i && r2.next.i !== t4.i && r2.i !== e4.i && r2.next.i !== e4.i && eo(r2, r2.next, t4, e4))
                  return true;
                r2 = r2.next;
              } while (r2 !== t4);
              return false;
            }(t3, e3) && (io(t3, e3) && io(e3, t3) && function(t4, e4) {
              var r2 = t4, n3 = false, i3 = (t4.x + e4.x) / 2, a3 = (t4.y + e4.y) / 2;
              do {
                r2.y > a3 != r2.next.y > a3 && r2.next.y !== r2.y && i3 < (r2.next.x - r2.x) * (a3 - r2.y) / (r2.next.y - r2.y) + r2.x && (n3 = !n3), r2 = r2.next;
              } while (r2 !== t4);
              return n3;
            }(t3, e3) && (Qs(t3.prev, t3, e3.prev) || Qs(t3, e3.prev, e3)) || to2(t3, e3) && Qs(t3.prev, t3, t3.next) > 0 && Qs(e3.prev, e3, e3.next) > 0);
          }
          function Qs(t3, e3, r2) {
            return (e3.y - t3.y) * (r2.x - e3.x) - (e3.x - t3.x) * (r2.y - e3.y);
          }
          function to2(t3, e3) {
            return t3.x === e3.x && t3.y === e3.y;
          }
          function eo(t3, e3, r2, n3) {
            var i3 = no(Qs(t3, e3, r2)), a3 = no(Qs(t3, e3, n3)), s2 = no(Qs(r2, n3, t3)), o2 = no(Qs(r2, n3, e3));
            return i3 !== a3 && s2 !== o2 || !(0 !== i3 || !ro(t3, r2, e3)) || !(0 !== a3 || !ro(t3, n3, e3)) || !(0 !== s2 || !ro(r2, t3, n3)) || !(0 !== o2 || !ro(r2, e3, n3));
          }
          function ro(t3, e3, r2) {
            return e3.x <= Math.max(t3.x, r2.x) && e3.x >= Math.min(t3.x, r2.x) && e3.y <= Math.max(t3.y, r2.y) && e3.y >= Math.min(t3.y, r2.y);
          }
          function no(t3) {
            return t3 > 0 ? 1 : t3 < 0 ? -1 : 0;
          }
          function io(t3, e3) {
            return Qs(t3.prev, t3, t3.next) < 0 ? Qs(t3, e3, t3.next) >= 0 && Qs(t3, t3.prev, e3) >= 0 : Qs(t3, e3, t3.prev) < 0 || Qs(t3, t3.next, e3) < 0;
          }
          function ao(t3, e3) {
            var r2 = new lo(t3.i, t3.x, t3.y), n3 = new lo(e3.i, e3.x, e3.y), i3 = t3.next, a3 = e3.prev;
            return t3.next = e3, e3.prev = t3, r2.next = i3, i3.prev = r2, n3.next = r2, r2.prev = n3, a3.next = n3, n3.prev = a3, n3;
          }
          function so(t3, e3, r2, n3) {
            var i3 = new lo(t3, e3, r2);
            return n3 ? (i3.next = n3.next, i3.prev = n3, n3.next.prev = i3, n3.next = i3) : (i3.prev = i3, i3.next = i3), i3;
          }
          function oo(t3) {
            t3.next.prev = t3.prev, t3.prev.next = t3.next, t3.prevZ && (t3.prevZ.nextZ = t3.nextZ), t3.nextZ && (t3.nextZ.prevZ = t3.prevZ);
          }
          function lo(t3, e3, r2) {
            this.i = t3, this.x = e3, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function uo(t3, e3, r2, n3) {
            for (var i3 = 0, a3 = e3, s2 = r2 - n3; a3 < r2; a3 += n3)
              i3 += (t3[s2] - t3[a3]) * (t3[a3 + 1] + t3[s2 + 1]), s2 = a3;
            return i3;
          }
          $s.exports = Ds, $s.exports.default = Ds, Ds.deviation = function(t3, e3, r2, n3) {
            var i3 = e3 && e3.length, a3 = Math.abs(uo(t3, 0, i3 ? e3[0] * r2 : t3.length, r2));
            if (i3)
              for (var s2 = 0, o2 = e3.length; s2 < o2; s2++)
                a3 -= Math.abs(uo(t3, e3[s2] * r2, s2 < o2 - 1 ? e3[s2 + 1] * r2 : t3.length, r2));
            var l2 = 0;
            for (s2 = 0; s2 < n3.length; s2 += 3) {
              var u2 = n3[s2] * r2, c5 = n3[s2 + 1] * r2, h2 = n3[s2 + 2] * r2;
              l2 += Math.abs((t3[u2] - t3[h2]) * (t3[c5 + 1] - t3[u2 + 1]) - (t3[u2] - t3[c5]) * (t3[h2 + 1] - t3[u2 + 1]));
            }
            return 0 === a3 && 0 === l2 ? 0 : Math.abs((l2 - a3) / a3);
          }, Ds.flatten = function(t3) {
            for (var e3 = t3[0][0].length, r2 = { vertices: [], holes: [], dimensions: e3 }, n3 = 0, i3 = 0; i3 < t3.length; i3++) {
              for (var a3 = 0; a3 < t3[i3].length; a3++)
                for (var s2 = 0; s2 < e3; s2++)
                  r2.vertices.push(t3[i3][a3][s2]);
              i3 > 0 && r2.holes.push(n3 += t3[i3 - 1].length);
            }
            return r2;
          };
          var co = e2($s.exports);
          function ho(t3, e3, r2, n3, i3) {
            po(t3, e3, r2 || 0, n3 || t3.length - 1, i3 || yo);
          }
          function po(t3, e3, r2, n3, i3) {
            for (; n3 > r2; ) {
              if (n3 - r2 > 600) {
                var a3 = n3 - r2 + 1, s2 = e3 - r2 + 1, o2 = Math.log(a3), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (a3 - l2) / a3) * (s2 - a3 / 2 < 0 ? -1 : 1);
                po(t3, e3, Math.max(r2, Math.floor(e3 - s2 * l2 / a3 + u2)), Math.min(n3, Math.floor(e3 + (a3 - s2) * l2 / a3 + u2)), i3);
              }
              var c5 = t3[e3], h2 = r2, p3 = n3;
              for (fo(t3, r2, e3), i3(t3[n3], c5) > 0 && fo(t3, r2, n3); h2 < p3; ) {
                for (fo(t3, h2, p3), h2++, p3--; i3(t3[h2], c5) < 0; )
                  h2++;
                for (; i3(t3[p3], c5) > 0; )
                  p3--;
              }
              0 === i3(t3[r2], c5) ? fo(t3, r2, p3) : fo(t3, ++p3, n3), p3 <= e3 && (r2 = p3 + 1), e3 <= p3 && (n3 = p3 - 1);
            }
          }
          function fo(t3, e3, r2) {
            var n3 = t3[e3];
            t3[e3] = t3[r2], t3[r2] = n3;
          }
          function yo(t3, e3) {
            return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
          }
          function mo(t3, e3) {
            const r2 = t3.length;
            if (r2 <= 1)
              return [t3];
            const n3 = [];
            let i3, a3;
            for (let e4 = 0; e4 < r2; e4++) {
              const r3 = b2(t3[e4]);
              0 !== r3 && (t3[e4].area = Math.abs(r3), void 0 === a3 && (a3 = r3 < 0), a3 === r3 < 0 ? (i3 && n3.push(i3), i3 = [t3[e4]]) : i3.push(t3[e4]));
            }
            if (i3 && n3.push(i3), e3 > 1)
              for (let t4 = 0; t4 < n3.length; t4++)
                n3[t4].length <= e3 || (ho(n3[t4], e3, 1, n3[t4].length - 1, go), n3[t4] = n3[t4].slice(0, e3));
            return n3;
          }
          function go(t3, e3) {
            return e3.area - t3.area;
          }
          function xo(t3, e3, r2) {
            const n3 = r2.patternDependencies;
            let i3 = false;
            for (const r3 of e3) {
              const e4 = r3.paint.get(`${t3}-pattern`);
              e4.isConstant() || (i3 = true);
              const a3 = e4.constantOr(null);
              a3 && (i3 = true, n3[a3.to] = true, n3[a3.from] = true);
            }
            return i3;
          }
          function vo(t3, e3, r2, n3, i3) {
            const a3 = i3.patternDependencies;
            for (const s2 of e3) {
              const e4 = s2.paint.get(`${t3}-pattern`).value;
              if ("constant" !== e4.kind) {
                let t4 = e4.evaluate({ zoom: n3 - 1 }, r2, {}, i3.availableImages), o2 = e4.evaluate({ zoom: n3 }, r2, {}, i3.availableImages), l2 = e4.evaluate({ zoom: n3 + 1 }, r2, {}, i3.availableImages);
                t4 = t4 && t4.name ? t4.name : t4, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, a3[t4] = true, a3[o2] = true, a3[l2] = true, r2.patterns[s2.id] = { min: t4, mid: o2, max: l2 };
              }
            }
            return r2;
          }
          class bo {
            constructor(t3) {
              this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new ta(), this.indexArray = new ca(), this.indexArray2 = new ha(), this.programConfigurations = new Ua(t3.layers, t3.zoom), this.segments = new da(), this.segments2 = new da(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
            }
            populate(t3, e3, r2) {
              this.hasPattern = xo("fill", this.layers, e3);
              const n3 = this.layers[0].layout.get("fill-sort-key"), i3 = !n3.isConstant(), a3 = [];
              for (const { feature: s2, id: o2, index: l2, sourceLayerIndex: u2 } of t3) {
                const t4 = this.layers[0]._featureFilter.needGeometry, c5 = Ga(s2, t4);
                if (!this.layers[0]._featureFilter.filter(new Wn(this.zoom), c5, r2))
                  continue;
                const h2 = i3 ? n3.evaluate(c5, {}, r2, e3.availableImages) : void 0, p3 = { id: o2, properties: s2.properties, type: s2.type, sourceLayerIndex: u2, index: l2, geometry: t4 ? c5.geometry : Ka(s2), patterns: {}, sortKey: h2 };
                a3.push(p3);
              }
              i3 && a3.sort((t4, e4) => t4.sortKey - e4.sortKey);
              for (const n4 of a3) {
                const { geometry: i4, index: a4, sourceLayerIndex: s2 } = n4;
                if (this.hasPattern) {
                  const t4 = vo("fill", this.layers, n4, this.zoom, e3);
                  this.patternFeatures.push(t4);
                } else
                  this.addFeature(n4, i4, a4, r2, {});
                e3.featureIndex.insert(t3[a4].feature, i4, a4, s2, this.index);
              }
            }
            update(t3, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r2);
            }
            addFeatures(t3, e3, r2) {
              for (const t4 of this.patternFeatures)
                this.addFeature(t4, t4.geometry, t4.index, e3, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t3) {
              this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Ls), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.indexBuffer2 = t3.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t3), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t3, e3, r2, n3, i3) {
              for (const t4 of mo(e3, 500)) {
                let e4 = 0;
                for (const r4 of t4)
                  e4 += r4.length;
                const r3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray), n4 = r3.vertexLength, i4 = [], a3 = [];
                for (const e5 of t4) {
                  if (0 === e5.length)
                    continue;
                  e5 !== t4[0] && a3.push(i4.length / 2);
                  const r4 = this.segments2.prepareSegment(e5.length, this.layoutVertexArray, this.indexArray2), n5 = r4.vertexLength;
                  this.layoutVertexArray.emplaceBack(e5[0].x, e5[0].y), this.indexArray2.emplaceBack(n5 + e5.length - 1, n5), i4.push(e5[0].x), i4.push(e5[0].y);
                  for (let t5 = 1; t5 < e5.length; t5++)
                    this.layoutVertexArray.emplaceBack(e5[t5].x, e5[t5].y), this.indexArray2.emplaceBack(n5 + t5 - 1, n5 + t5), i4.push(e5[t5].x), i4.push(e5[t5].y);
                  r4.vertexLength += e5.length, r4.primitiveLength += e5.length;
                }
                const s2 = co(i4, a3);
                for (let t5 = 0; t5 < s2.length; t5 += 3)
                  this.indexArray.emplaceBack(n4 + s2[t5], n4 + s2[t5 + 1], n4 + s2[t5 + 2]);
                r3.vertexLength += e4, r3.primitiveLength += s2.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r2, i3, n3);
            }
          }
          let wo, _o;
          In("FillBucket", bo, { omit: ["layers", "patternFeatures"] });
          var Ao = { get paint() {
            return _o = _o || new pi({ "fill-antialias": new oi(q.paint_fill["fill-antialias"]), "fill-opacity": new li(q.paint_fill["fill-opacity"]), "fill-color": new li(q.paint_fill["fill-color"]), "fill-outline-color": new li(q.paint_fill["fill-outline-color"]), "fill-translate": new oi(q.paint_fill["fill-translate"]), "fill-translate-anchor": new oi(q.paint_fill["fill-translate-anchor"]), "fill-pattern": new ui(q.paint_fill["fill-pattern"]) });
          }, get layout() {
            return wo = wo || new pi({ "fill-sort-key": new li(q.layout_fill["fill-sort-key"]) });
          } };
          class ko extends di {
            constructor(t3) {
              super(t3, Ao);
            }
            recalculate(t3, e3) {
              super.recalculate(t3, e3);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t3) {
              return new bo(t3);
            }
            queryRadius() {
              return ls(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t3, e3, r2, n3, i3, a3, s2) {
              return Wa(us(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a3.angle, s2), n3);
            }
            isTileClipped() {
              return true;
            }
          }
          const So = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Io = xi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: zo } = So;
          var Mo = {}, Po = r, Bo = Co;
          function Co(t3, e3, r2, n3, i3) {
            this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = n3, this._values = i3, t3.readFields(Vo, this, e3);
          }
          function Vo(t3, e3, r2) {
            1 == t3 ? e3.id = r2.readVarint() : 2 == t3 ? function(t4, e4) {
              for (var r3 = t4.readVarint() + t4.pos; t4.pos < r3; ) {
                var n3 = e4._keys[t4.readVarint()], i3 = e4._values[t4.readVarint()];
                e4.properties[n3] = i3;
              }
            }(r2, e3) : 3 == t3 ? e3.type = r2.readVarint() : 4 == t3 && (e3._geometry = r2.pos);
          }
          function Eo(t3) {
            for (var e3, r2, n3 = 0, i3 = 0, a3 = t3.length, s2 = a3 - 1; i3 < a3; s2 = i3++)
              n3 += ((r2 = t3[s2]).x - (e3 = t3[i3]).x) * (e3.y + r2.y);
            return n3;
          }
          Co.types = ["Unknown", "Point", "LineString", "Polygon"], Co.prototype.loadGeometry = function() {
            var t3 = this._pbf;
            t3.pos = this._geometry;
            for (var e3, r2 = t3.readVarint() + t3.pos, n3 = 1, i3 = 0, a3 = 0, s2 = 0, o2 = []; t3.pos < r2; ) {
              if (i3 <= 0) {
                var l2 = t3.readVarint();
                n3 = 7 & l2, i3 = l2 >> 3;
              }
              if (i3--, 1 === n3 || 2 === n3)
                a3 += t3.readSVarint(), s2 += t3.readSVarint(), 1 === n3 && (e3 && o2.push(e3), e3 = []), e3.push(new Po(a3, s2));
              else {
                if (7 !== n3)
                  throw new Error("unknown command " + n3);
                e3 && e3.push(e3[0].clone());
              }
            }
            return e3 && o2.push(e3), o2;
          }, Co.prototype.bbox = function() {
            var t3 = this._pbf;
            t3.pos = this._geometry;
            for (var e3 = t3.readVarint() + t3.pos, r2 = 1, n3 = 0, i3 = 0, a3 = 0, s2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t3.pos < e3; ) {
              if (n3 <= 0) {
                var c5 = t3.readVarint();
                r2 = 7 & c5, n3 = c5 >> 3;
              }
              if (n3--, 1 === r2 || 2 === r2)
                (i3 += t3.readSVarint()) < s2 && (s2 = i3), i3 > o2 && (o2 = i3), (a3 += t3.readSVarint()) < l2 && (l2 = a3), a3 > u2 && (u2 = a3);
              else if (7 !== r2)
                throw new Error("unknown command " + r2);
            }
            return [s2, l2, o2, u2];
          }, Co.prototype.toGeoJSON = function(t3, e3, r2) {
            var n3, i3, a3 = this.extent * Math.pow(2, r2), s2 = this.extent * t3, o2 = this.extent * e3, l2 = this.loadGeometry(), u2 = Co.types[this.type];
            function c5(t4) {
              for (var e4 = 0; e4 < t4.length; e4++) {
                var r3 = t4[e4];
                t4[e4] = [360 * (r3.x + s2) / a3 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / a3) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h2 = [];
                for (n3 = 0; n3 < l2.length; n3++)
                  h2[n3] = l2[n3][0];
                c5(l2 = h2);
                break;
              case 2:
                for (n3 = 0; n3 < l2.length; n3++)
                  c5(l2[n3]);
                break;
              case 3:
                for (l2 = function(t4) {
                  var e4 = t4.length;
                  if (e4 <= 1)
                    return [t4];
                  for (var r3, n4, i4 = [], a4 = 0; a4 < e4; a4++) {
                    var s3 = Eo(t4[a4]);
                    0 !== s3 && (void 0 === n4 && (n4 = s3 < 0), n4 === s3 < 0 ? (r3 && i4.push(r3), r3 = [t4[a4]]) : r3.push(t4[a4]));
                  }
                  return r3 && i4.push(r3), i4;
                }(l2), n3 = 0; n3 < l2.length; n3++)
                  for (i3 = 0; i3 < l2[n3].length; i3++)
                    c5(l2[n3][i3]);
            }
            1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
            var p3 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
            return "id" in this && (p3.id = this.id), p3;
          };
          var Fo = Bo, To = Lo;
          function Lo(t3, e3) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields($o, this, e3), this.length = this._features.length;
          }
          function $o(t3, e3, r2) {
            15 === t3 ? e3.version = r2.readVarint() : 1 === t3 ? e3.name = r2.readString() : 5 === t3 ? e3.extent = r2.readVarint() : 2 === t3 ? e3._features.push(r2.pos) : 3 === t3 ? e3._keys.push(r2.readString()) : 4 === t3 && e3._values.push(function(t4) {
              for (var e4 = null, r3 = t4.readVarint() + t4.pos; t4.pos < r3; ) {
                var n3 = t4.readVarint() >> 3;
                e4 = 1 === n3 ? t4.readString() : 2 === n3 ? t4.readFloat() : 3 === n3 ? t4.readDouble() : 4 === n3 ? t4.readVarint64() : 5 === n3 ? t4.readVarint() : 6 === n3 ? t4.readSVarint() : 7 === n3 ? t4.readBoolean() : null;
              }
              return e4;
            }(r2));
          }
          Lo.prototype.feature = function(t3) {
            if (t3 < 0 || t3 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t3];
            var e3 = this._pbf.readVarint() + this._pbf.pos;
            return new Fo(this._pbf, e3, this.extent, this._keys, this._values);
          };
          var Do = To;
          function Oo(t3, e3, r2) {
            if (3 === t3) {
              var n3 = new Do(r2, r2.readVarint() + r2.pos);
              n3.length && (e3[n3.name] = n3);
            }
          }
          Mo.VectorTile = function(t3, e3) {
            this.layers = t3.readFields(Oo, {}, e3);
          }, Mo.VectorTileFeature = Bo, Mo.VectorTileLayer = To;
          const Uo = Mo.VectorTileFeature.types, Ro = Math.pow(2, 13);
          function qo(t3, e3, r2, n3, i3, a3, s2, o2) {
            t3.emplaceBack(e3, r2, 2 * Math.floor(n3 * Ro) + s2, i3 * Ro * 2, a3 * Ro * 2, Math.round(o2));
          }
          class jo {
            constructor(t3) {
              this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.layoutVertexArray = new ea(), this.centroidVertexArray = new Wi(), this.indexArray = new ca(), this.programConfigurations = new Ua(t3.layers, t3.zoom), this.segments = new da(), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
            }
            populate(t3, e3, r2) {
              this.features = [], this.hasPattern = xo("fill-extrusion", this.layers, e3);
              for (const { feature: n3, id: i3, index: a3, sourceLayerIndex: s2 } of t3) {
                const t4 = this.layers[0]._featureFilter.needGeometry, o2 = Ga(n3, t4);
                if (!this.layers[0]._featureFilter.filter(new Wn(this.zoom), o2, r2))
                  continue;
                const l2 = { id: i3, sourceLayerIndex: s2, index: a3, geometry: t4 ? o2.geometry : Ka(n3), properties: n3.properties, type: n3.type, patterns: {} };
                this.hasPattern ? this.features.push(vo("fill-extrusion", this.layers, l2, this.zoom, e3)) : this.addFeature(l2, l2.geometry, a3, r2, {}), e3.featureIndex.insert(n3, l2.geometry, a3, s2, this.index, true);
              }
            }
            addFeatures(t3, e3, r2) {
              for (const t4 of this.features) {
                const { geometry: n3 } = t4;
                this.addFeature(t4, n3, t4.index, e3, r2);
              }
            }
            update(t3, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t3) {
              this.uploaded || (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, zo), this.centroidVertexBuffer = t3.createVertexBuffer(this.centroidVertexArray, Io.members, true), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t3, e3, r2, n3, i3) {
              const a3 = { x: 0, y: 0, vertexCount: 0 };
              for (const r3 of mo(e3, 500)) {
                let e4 = 0;
                for (const t4 of r3)
                  e4 += t4.length;
                let n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                for (const t4 of r3) {
                  if (0 === t4.length)
                    continue;
                  if (Zo(t4))
                    continue;
                  let e5 = 0;
                  for (let r4 = 0; r4 < t4.length; r4++) {
                    const i5 = t4[r4];
                    if (r4 >= 1) {
                      const s3 = t4[r4 - 1];
                      if (!No(i5, s3)) {
                        n4.vertexLength + 4 > da.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        const t5 = i5.sub(s3)._perp()._unit(), r5 = s3.dist(i5);
                        e5 + r5 > 32768 && (e5 = 0), qo(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 0, e5), qo(this.layoutVertexArray, i5.x, i5.y, t5.x, t5.y, 0, 1, e5), a3.x += 2 * i5.x, a3.y += 2 * i5.y, a3.vertexCount += 2, e5 += r5, qo(this.layoutVertexArray, s3.x, s3.y, t5.x, t5.y, 0, 0, e5), qo(this.layoutVertexArray, s3.x, s3.y, t5.x, t5.y, 0, 1, e5), a3.x += 2 * s3.x, a3.y += 2 * s3.y, a3.vertexCount += 2;
                        const o3 = n4.vertexLength;
                        this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n4.vertexLength += 4, n4.primitiveLength += 2;
                      }
                    }
                  }
                }
                if (n4.vertexLength + e4 > da.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray)), "Polygon" !== Uo[t3.type])
                  continue;
                const i4 = [], s2 = [], o2 = n4.vertexLength;
                for (const t4 of r3)
                  if (0 !== t4.length) {
                    t4 !== r3[0] && s2.push(i4.length / 2);
                    for (let e5 = 0; e5 < t4.length; e5++) {
                      const r4 = t4[e5];
                      qo(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), a3.x += r4.x, a3.y += r4.y, a3.vertexCount += 1, i4.push(r4.x), i4.push(r4.y);
                    }
                  }
                const l2 = co(i4, s2);
                for (let t4 = 0; t4 < l2.length; t4 += 3)
                  this.indexArray.emplaceBack(o2 + l2[t4], o2 + l2[t4 + 2], o2 + l2[t4 + 1]);
                n4.primitiveLength += l2.length / 3, n4.vertexLength += e4;
              }
              for (let t4 = 0; t4 < a3.vertexCount; t4++)
                this.centroidVertexArray.emplaceBack(Math.floor(a3.x / a3.vertexCount), Math.floor(a3.y / a3.vertexCount));
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r2, i3, n3);
            }
          }
          function No(t3, e3) {
            return t3.x === e3.x && (t3.x < 0 || t3.x > ja) || t3.y === e3.y && (t3.y < 0 || t3.y > ja);
          }
          function Zo(t3) {
            return t3.every((t4) => t4.x < 0) || t3.every((t4) => t4.x > ja) || t3.every((t4) => t4.y < 0) || t3.every((t4) => t4.y > ja);
          }
          let Ko;
          In("FillExtrusionBucket", jo, { omit: ["layers", "features"] });
          var Go = { get paint() {
            return Ko = Ko || new pi({ "fill-extrusion-opacity": new oi(q["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new li(q["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new oi(q["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new oi(q["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ui(q["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new li(q["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new li(q["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new oi(q["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
          } };
          class Jo extends di {
            constructor(t3) {
              super(t3, Go);
            }
            createBucket(t3) {
              return new jo(t3);
            }
            queryRadius() {
              return ls(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature(t3, e3, r2, n3, a3, s2, o2, l2) {
              const u2 = us(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, o2), c5 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), p3 = function(t4, e4, r3, n4) {
                const a4 = [];
                for (const r4 of t4) {
                  const t5 = [r4.x, r4.y, 0, 1];
                  vs(t5, t5, e4), a4.push(new i2(t5[0] / t5[3], t5[1] / t5[3]));
                }
                return a4;
              }(u2, l2), f2 = function(t4, e4, r3, n4) {
                const a4 = [], s3 = [], o3 = n4[8] * e4, l3 = n4[9] * e4, u3 = n4[10] * e4, c6 = n4[11] * e4, h3 = n4[8] * r3, p4 = n4[9] * r3, f3 = n4[10] * r3, d3 = n4[11] * r3;
                for (const e5 of t4) {
                  const t5 = [], r4 = [];
                  for (const a5 of e5) {
                    const e6 = a5.x, s4 = a5.y, y2 = n4[0] * e6 + n4[4] * s4 + n4[12], m4 = n4[1] * e6 + n4[5] * s4 + n4[13], g3 = n4[2] * e6 + n4[6] * s4 + n4[14], x2 = n4[3] * e6 + n4[7] * s4 + n4[15], v2 = g3 + u3, b3 = x2 + c6, w2 = y2 + h3, _2 = m4 + p4, A2 = g3 + f3, k2 = x2 + d3, S2 = new i2((y2 + o3) / b3, (m4 + l3) / b3);
                    S2.z = v2 / b3, t5.push(S2);
                    const I2 = new i2(w2 / k2, _2 / k2);
                    I2.z = A2 / k2, r4.push(I2);
                  }
                  a4.push(t5), s3.push(r4);
                }
                return [a4, s3];
              }(n3, h2, c5, l2);
              return function(t4, e4, r3) {
                let n4 = 1 / 0;
                Wa(r3, e4) && (n4 = Yo(r3, e4[0]));
                for (let i3 = 0; i3 < e4.length; i3++) {
                  const a4 = e4[i3], s3 = t4[i3];
                  for (let t5 = 0; t5 < a4.length - 1; t5++) {
                    const e5 = a4[t5], i4 = [e5, a4[t5 + 1], s3[t5 + 1], s3[t5], e5];
                    Ya(r3, i4) && (n4 = Math.min(n4, Yo(r3, i4)));
                  }
                }
                return n4 !== 1 / 0 && n4;
              }(f2[0], f2[1], p3);
            }
          }
          function Xo(t3, e3) {
            return t3.x * e3.x + t3.y * e3.y;
          }
          function Yo(t3, e3) {
            if (1 === t3.length) {
              let r2 = 0;
              const n3 = e3[r2++];
              let i3;
              for (; !i3 || n3.equals(i3); )
                if (i3 = e3[r2++], !i3)
                  return 1 / 0;
              for (; r2 < e3.length; r2++) {
                const a3 = e3[r2], s2 = t3[0], o2 = i3.sub(n3), l2 = a3.sub(n3), u2 = s2.sub(n3), c5 = Xo(o2, o2), h2 = Xo(o2, l2), p3 = Xo(l2, l2), f2 = Xo(u2, o2), d3 = Xo(u2, l2), y2 = c5 * p3 - h2 * h2, m4 = (p3 * f2 - h2 * d3) / y2, g3 = (c5 * d3 - h2 * f2) / y2, x2 = n3.z * (1 - m4 - g3) + i3.z * m4 + a3.z * g3;
                if (isFinite(x2))
                  return x2;
              }
              return 1 / 0;
            }
            {
              let t4 = 1 / 0;
              for (const r2 of e3)
                t4 = Math.min(t4, r2.z);
              return t4;
            }
          }
          const Ho = xi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Wo } = Ho, Qo = xi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: tl } = Qo, el = Mo.VectorTileFeature.types, rl = Math.cos(Math.PI / 180 * 37.5), nl = Math.pow(2, 14) / 0.5;
          class il {
            constructor(t3) {
              this.zoom = t3.zoom, this.overscaling = t3.overscaling, this.layers = t3.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = t3.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t4) => {
                this.gradients[t4.id] = {};
              }), this.layoutVertexArray = new ra(), this.layoutVertexArray2 = new na(), this.indexArray = new ca(), this.programConfigurations = new Ua(t3.layers, t3.zoom), this.segments = new da(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id);
            }
            populate(t3, e3, r2) {
              this.hasPattern = xo("line", this.layers, e3);
              const n3 = this.layers[0].layout.get("line-sort-key"), i3 = !n3.isConstant(), a3 = [];
              for (const { feature: e4, id: s2, index: o2, sourceLayerIndex: l2 } of t3) {
                const t4 = this.layers[0]._featureFilter.needGeometry, u2 = Ga(e4, t4);
                if (!this.layers[0]._featureFilter.filter(new Wn(this.zoom), u2, r2))
                  continue;
                const c5 = i3 ? n3.evaluate(u2, {}, r2) : void 0, h2 = { id: s2, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t4 ? u2.geometry : Ka(e4), patterns: {}, sortKey: c5 };
                a3.push(h2);
              }
              i3 && a3.sort((t4, e4) => t4.sortKey - e4.sortKey);
              for (const n4 of a3) {
                const { geometry: i4, index: a4, sourceLayerIndex: s2 } = n4;
                if (this.hasPattern) {
                  const t4 = vo("line", this.layers, n4, this.zoom, e3);
                  this.patternFeatures.push(t4);
                } else
                  this.addFeature(n4, i4, a4, r2, {});
                e3.featureIndex.insert(t3[a4].feature, i4, a4, s2, this.index);
              }
            }
            update(t3, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t3, e3, this.stateDependentLayers, r2);
            }
            addFeatures(t3, e3, r2) {
              for (const t4 of this.patternFeatures)
                this.addFeature(t4, t4.geometry, t4.index, e3, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t3) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t3.createVertexBuffer(this.layoutVertexArray2, tl)), this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, Wo), this.indexBuffer = t3.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t3), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t3) {
              if (t3.properties && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t3.properties, "mapbox_clip_end"))
                return { start: +t3.properties.mapbox_clip_start, end: +t3.properties.mapbox_clip_end };
            }
            addFeature(t3, e3, r2, n3, i3) {
              const a3 = this.layers[0].layout, s2 = a3.get("line-join").evaluate(t3, {}), o2 = a3.get("line-cap"), l2 = a3.get("line-miter-limit"), u2 = a3.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t3);
              for (const r3 of e3)
                this.addLine(r3, t3, s2, o2, l2, u2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t3, r2, i3, n3);
            }
            addLine(t3, e3, r2, n3, i3, a3) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e4 = 0; e4 < t3.length - 1; e4++)
                  this.totalDistance += t3[e4].dist(t3[e4 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const s2 = "Polygon" === el[e3.type];
              let o2 = t3.length;
              for (; o2 >= 2 && t3[o2 - 1].equals(t3[o2 - 2]); )
                o2--;
              let l2 = 0;
              for (; l2 < o2 - 1 && t3[l2].equals(t3[l2 + 1]); )
                l2++;
              if (o2 < (s2 ? 3 : 2))
                return;
              "bevel" === r2 && (i3 = 1.05);
              const u2 = this.overscaling <= 16 ? 15 * ja / (512 * this.overscaling) : 0, c5 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
              let h2, p3, f2, d3, y2;
              this.e1 = this.e2 = -1, s2 && (h2 = t3[o2 - 2], y2 = t3[l2].sub(h2)._unit()._perp());
              for (let e4 = l2; e4 < o2; e4++) {
                if (f2 = e4 === o2 - 1 ? s2 ? t3[l2 + 1] : void 0 : t3[e4 + 1], f2 && t3[e4].equals(f2))
                  continue;
                y2 && (d3 = y2), h2 && (p3 = h2), h2 = t3[e4], y2 = f2 ? f2.sub(h2)._unit()._perp() : d3, d3 = d3 || y2;
                let m4 = d3.add(y2);
                0 === m4.x && 0 === m4.y || m4._unit();
                const g3 = d3.x * y2.x + d3.y * y2.y, x2 = m4.x * y2.x + m4.y * y2.y, v2 = 0 !== x2 ? 1 / x2 : 1 / 0, b3 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < rl && p3 && f2, _2 = d3.x * y2.y - d3.y * y2.x > 0;
                if (w2 && e4 > l2) {
                  const t4 = h2.dist(p3);
                  if (t4 > 2 * u2) {
                    const e5 = h2.sub(h2.sub(p3)._mult(u2 / t4)._round());
                    this.updateDistance(p3, e5), this.addCurrentVertex(e5, d3, 0, 0, c5), p3 = e5;
                  }
                }
                const A2 = p3 && f2;
                let k2 = A2 ? r2 : s2 ? "butt" : n3;
                if (A2 && "round" === k2 && (v2 < a3 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), "miter" === k2 && v2 > i3 && (k2 = "bevel"), "bevel" === k2 && (v2 > 2 && (k2 = "flipbevel"), v2 < i3 && (k2 = "miter")), p3 && this.updateDistance(p3, h2), "miter" === k2)
                  m4._mult(v2), this.addCurrentVertex(h2, m4, 0, 0, c5);
                else if ("flipbevel" === k2) {
                  if (v2 > 100)
                    m4 = y2.mult(-1);
                  else {
                    const t4 = v2 * d3.add(y2).mag() / d3.sub(y2).mag();
                    m4._perp()._mult(t4 * (_2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, m4, 0, 0, c5), this.addCurrentVertex(h2, m4.mult(-1), 0, 0, c5);
                } else if ("bevel" === k2 || "fakeround" === k2) {
                  const t4 = -Math.sqrt(v2 * v2 - 1), e5 = _2 ? t4 : 0, r3 = _2 ? 0 : t4;
                  if (p3 && this.addCurrentVertex(h2, d3, e5, r3, c5), "fakeround" === k2) {
                    const t5 = Math.round(180 * b3 / Math.PI / 20);
                    for (let e6 = 1; e6 < t5; e6++) {
                      let r4 = e6 / t5;
                      if (0.5 !== r4) {
                        const t6 = r4 - 0.5;
                        r4 += r4 * t6 * (r4 - 1) * ((1.0904 + g3 * (g3 * (3.55645 - 1.43519 * g3) - 3.2452)) * t6 * t6 + (0.848013 + g3 * (0.215638 * g3 - 1.06021)));
                      }
                      const n4 = y2.sub(d3)._mult(r4)._add(d3)._unit()._mult(_2 ? -1 : 1);
                      this.addHalfVertex(h2, n4.x, n4.y, false, _2, 0, c5);
                    }
                  }
                  f2 && this.addCurrentVertex(h2, y2, -e5, -r3, c5);
                } else if ("butt" === k2)
                  this.addCurrentVertex(h2, m4, 0, 0, c5);
                else if ("square" === k2) {
                  const t4 = p3 ? 1 : -1;
                  this.addCurrentVertex(h2, m4, t4, t4, c5);
                } else
                  "round" === k2 && (p3 && (this.addCurrentVertex(h2, d3, 0, 0, c5), this.addCurrentVertex(h2, d3, 1, 1, c5, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c5, true), this.addCurrentVertex(h2, y2, 0, 0, c5)));
                if (w2 && e4 < o2 - 1) {
                  const t4 = h2.dist(f2);
                  if (t4 > 2 * u2) {
                    const e5 = h2.add(f2.sub(h2)._mult(u2 / t4)._round());
                    this.updateDistance(h2, e5), this.addCurrentVertex(e5, y2, 0, 0, c5), h2 = e5;
                  }
                }
              }
            }
            addCurrentVertex(t3, e3, r2, n3, i3, a3 = false) {
              const s2 = e3.y * n3 - e3.x, o2 = -e3.y - e3.x * n3;
              this.addHalfVertex(t3, e3.x + e3.y * r2, e3.y - e3.x * r2, a3, false, r2, i3), this.addHalfVertex(t3, s2, o2, a3, true, -n3, i3), this.distance > nl / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t3, e3, r2, n3, i3, a3));
            }
            addHalfVertex({ x: t3, y: e3 }, r2, n3, i3, a3, s2, o2) {
              const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (nl - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t3 << 1) + (i3 ? 1 : 0), (e3 << 1) + (a3 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n3) + 128, 1 + (0 === s2 ? 0 : s2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), a3 ? this.e2 = u2 : this.e1 = u2;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t3, e3) {
              this.distance += t3.dist(e3), this.updateScaledDistance();
            }
          }
          let al, sl;
          In("LineBucket", il, { omit: ["layers", "patternFeatures"] });
          var ol = { get paint() {
            return sl = sl || new pi({ "line-opacity": new li(q.paint_line["line-opacity"]), "line-color": new li(q.paint_line["line-color"]), "line-translate": new oi(q.paint_line["line-translate"]), "line-translate-anchor": new oi(q.paint_line["line-translate-anchor"]), "line-width": new li(q.paint_line["line-width"]), "line-gap-width": new li(q.paint_line["line-gap-width"]), "line-offset": new li(q.paint_line["line-offset"]), "line-blur": new li(q.paint_line["line-blur"]), "line-dasharray": new ci(q.paint_line["line-dasharray"]), "line-pattern": new ui(q.paint_line["line-pattern"]), "line-gradient": new hi(q.paint_line["line-gradient"]) });
          }, get layout() {
            return al = al || new pi({ "line-cap": new oi(q.layout_line["line-cap"]), "line-join": new li(q.layout_line["line-join"]), "line-miter-limit": new oi(q.layout_line["line-miter-limit"]), "line-round-limit": new oi(q.layout_line["line-round-limit"]), "line-sort-key": new li(q.layout_line["line-sort-key"]) });
          } };
          class ll extends li {
            possiblyEvaluate(t3, e3) {
              return e3 = new Wn(Math.floor(e3.zoom), { now: e3.now, fadeDuration: e3.fadeDuration, zoomHistory: e3.zoomHistory, transition: e3.transition }), super.possiblyEvaluate(t3, e3);
            }
            evaluate(t3, e3, r2, n3) {
              return e3 = p2({}, e3, { zoom: Math.floor(e3.zoom) }), super.evaluate(t3, e3, r2, n3);
            }
          }
          let ul;
          class cl extends di {
            constructor(t3) {
              super(t3, ol), this.gradientVersion = 0, ul || (ul = new ll(ol.paint.properties["line-width"].specification), ul.useIntegerZoom = true);
            }
            _handleSpecialPaintPropertyUpdate(t3) {
              "line-gradient" === t3 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ve, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t3, e3) {
              super.recalculate(t3, e3), this.paint._values["line-floorwidth"] = ul.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t3);
            }
            createBucket(t3) {
              return new il(t3);
            }
            queryRadius(t3) {
              const e3 = t3, r2 = hl(os("line-width", this, e3), os("line-gap-width", this, e3)), n3 = os("line-offset", this, e3);
              return r2 / 2 + Math.abs(n3) + ls(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t3, e3, r2, n3, a3, s2, o2) {
              const l2 = us(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, o2), u2 = o2 / 2 * hl(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), c5 = this.paint.get("line-offset").evaluate(e3, r2);
              return c5 && (n3 = function(t4, e4) {
                const r3 = [];
                for (let n4 = 0; n4 < t4.length; n4++) {
                  const a4 = t4[n4], s3 = [];
                  for (let t5 = 0; t5 < a4.length; t5++) {
                    const r4 = a4[t5 - 1], n5 = a4[t5], o3 = a4[t5 + 1], l3 = 0 === t5 ? new i2(0, 0) : n5.sub(r4)._unit()._perp(), u3 = t5 === a4.length - 1 ? new i2(0, 0) : o3.sub(n5)._unit()._perp(), c6 = l3._add(u3)._unit(), h2 = c6.x * u3.x + c6.y * u3.y;
                    0 !== h2 && c6._mult(1 / h2), s3.push(c6._mult(e4)._add(n5));
                  }
                  r3.push(s3);
                }
                return r3;
              }(n3, c5 * o2)), function(t4, e4, r3) {
                for (let n4 = 0; n4 < e4.length; n4++) {
                  const i3 = e4[n4];
                  if (t4.length >= 3) {
                    for (let e5 = 0; e5 < i3.length; e5++)
                      if (as(t4, i3[e5]))
                        return true;
                  }
                  if (Qa(t4, i3, r3))
                    return true;
                }
                return false;
              }(l2, n3, u2);
            }
            isTileClipped() {
              return true;
            }
          }
          function hl(t3, e3) {
            return e3 > 0 ? e3 + 2 * t3 : t3;
          }
          const pl = xi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), fl = xi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          xi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const dl = xi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
          xi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const yl = xi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), ml = xi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function gl(t3, e3, r2) {
            return t3.sections.forEach((t4) => {
              t4.text = function(t5, e4, r3) {
                const n3 = e4.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n3 ? t5 = t5.toLocaleUpperCase() : "lowercase" === n3 && (t5 = t5.toLocaleLowerCase()), Hn.applyArabicShaping && (t5 = Hn.applyArabicShaping(t5)), t5;
              }(t4.text, e3, r2);
            }), t3;
          }
          xi([{ name: "triangle", components: 3, type: "Uint16" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), xi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), xi([{ type: "Float32", name: "offsetX" }]), xi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
          const xl = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var vl = 24, bl = Al, wl = function(t3, e3, r2, n3, i3) {
            var a3, s2, o2 = 8 * i3 - n3 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c5 = -7, h2 = r2 ? i3 - 1 : 0, p3 = r2 ? -1 : 1, f2 = t3[e3 + h2];
            for (h2 += p3, a3 = f2 & (1 << -c5) - 1, f2 >>= -c5, c5 += o2; c5 > 0; a3 = 256 * a3 + t3[e3 + h2], h2 += p3, c5 -= 8)
              ;
            for (s2 = a3 & (1 << -c5) - 1, a3 >>= -c5, c5 += n3; c5 > 0; s2 = 256 * s2 + t3[e3 + h2], h2 += p3, c5 -= 8)
              ;
            if (0 === a3)
              a3 = 1 - u2;
            else {
              if (a3 === l2)
                return s2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              s2 += Math.pow(2, n3), a3 -= u2;
            }
            return (f2 ? -1 : 1) * s2 * Math.pow(2, a3 - n3);
          }, _l = function(t3, e3, r2, n3, i3, a3) {
            var s2, o2, l2, u2 = 8 * a3 - i3 - 1, c5 = (1 << u2) - 1, h2 = c5 >> 1, p3 = 23 === i3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : a3 - 1, d3 = n3 ? 1 : -1, y2 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
            for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o2 = isNaN(e3) ? 1 : 0, s2 = c5) : (s2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e3 += s2 + h2 >= 1 ? p3 / l2 : p3 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= c5 ? (o2 = 0, s2 = c5) : s2 + h2 >= 1 ? (o2 = (e3 * l2 - 1) * Math.pow(2, i3), s2 += h2) : (o2 = e3 * Math.pow(2, h2 - 1) * Math.pow(2, i3), s2 = 0)); i3 >= 8; t3[r2 + f2] = 255 & o2, f2 += d3, o2 /= 256, i3 -= 8)
              ;
            for (s2 = s2 << i3 | o2, u2 += i3; u2 > 0; t3[r2 + f2] = 255 & s2, f2 += d3, s2 /= 256, u2 -= 8)
              ;
            t3[r2 + f2 - d3] |= 128 * y2;
          };
          function Al(t3) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          Al.Varint = 0, Al.Fixed64 = 1, Al.Bytes = 2, Al.Fixed32 = 5;
          var kl = 4294967296, Sl = 1 / kl, Il = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
          function zl(t3) {
            return t3.type === Al.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
          }
          function Ml(t3, e3, r2) {
            return r2 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
          }
          function Pl(t3, e3, r2) {
            var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
            r2.realloc(n3);
            for (var i3 = r2.pos - 1; i3 >= t3; i3--)
              r2.buf[i3 + n3] = r2.buf[i3];
          }
          function Bl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeVarint(t3[r2]);
          }
          function Cl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeSVarint(t3[r2]);
          }
          function Vl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeFloat(t3[r2]);
          }
          function El(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeDouble(t3[r2]);
          }
          function Fl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeBoolean(t3[r2]);
          }
          function Tl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeFixed32(t3[r2]);
          }
          function Ll(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeSFixed32(t3[r2]);
          }
          function $l(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeFixed64(t3[r2]);
          }
          function Dl(t3, e3) {
            for (var r2 = 0; r2 < t3.length; r2++)
              e3.writeSFixed64(t3[r2]);
          }
          function Ol(t3, e3) {
            return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
          }
          function Ul(t3, e3, r2) {
            t3[r2] = e3, t3[r2 + 1] = e3 >>> 8, t3[r2 + 2] = e3 >>> 16, t3[r2 + 3] = e3 >>> 24;
          }
          function Rl(t3, e3) {
            return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
          }
          Al.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t3, e3, r2) {
            for (r2 = r2 || this.length; this.pos < r2; ) {
              var n3 = this.readVarint(), i3 = n3 >> 3, a3 = this.pos;
              this.type = 7 & n3, t3(i3, e3, this), this.pos === a3 && this.skip(n3);
            }
            return e3;
          }, readMessage: function(t3, e3) {
            return this.readFields(t3, e3, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t3 = Ol(this.buf, this.pos);
            return this.pos += 4, t3;
          }, readSFixed32: function() {
            var t3 = Rl(this.buf, this.pos);
            return this.pos += 4, t3;
          }, readFixed64: function() {
            var t3 = Ol(this.buf, this.pos) + Ol(this.buf, this.pos + 4) * kl;
            return this.pos += 8, t3;
          }, readSFixed64: function() {
            var t3 = Ol(this.buf, this.pos) + Rl(this.buf, this.pos + 4) * kl;
            return this.pos += 8, t3;
          }, readFloat: function() {
            var t3 = wl(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t3;
          }, readDouble: function() {
            var t3 = wl(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t3;
          }, readVarint: function(t3) {
            var e3, r2, n3 = this.buf;
            return e3 = 127 & (r2 = n3[this.pos++]), r2 < 128 ? e3 : (e3 |= (127 & (r2 = n3[this.pos++])) << 7, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n3[this.pos++])) << 14, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n3[this.pos++])) << 21, r2 < 128 ? e3 : function(t4, e4, r3) {
              var n4, i3, a3 = r3.buf;
              if (n4 = (112 & (i3 = a3[r3.pos++])) >> 4, i3 < 128)
                return Ml(t4, n4, e4);
              if (n4 |= (127 & (i3 = a3[r3.pos++])) << 3, i3 < 128)
                return Ml(t4, n4, e4);
              if (n4 |= (127 & (i3 = a3[r3.pos++])) << 10, i3 < 128)
                return Ml(t4, n4, e4);
              if (n4 |= (127 & (i3 = a3[r3.pos++])) << 17, i3 < 128)
                return Ml(t4, n4, e4);
              if (n4 |= (127 & (i3 = a3[r3.pos++])) << 24, i3 < 128)
                return Ml(t4, n4, e4);
              if (n4 |= (1 & (i3 = a3[r3.pos++])) << 31, i3 < 128)
                return Ml(t4, n4, e4);
              throw new Error("Expected varint not more than 10 bytes");
            }(e3 |= (15 & (r2 = n3[this.pos])) << 28, t3, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t3 = this.readVarint();
            return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t3 = this.readVarint() + this.pos, e3 = this.pos;
            return this.pos = t3, t3 - e3 >= 12 && Il ? function(t4, e4, r2) {
              return Il.decode(t4.subarray(e4, r2));
            }(this.buf, e3, t3) : function(t4, e4, r2) {
              for (var n3 = "", i3 = e4; i3 < r2; ) {
                var a3, s2, o2, l2 = t4[i3], u2 = null, c5 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
                if (i3 + c5 > r2)
                  break;
                1 === c5 ? l2 < 128 && (u2 = l2) : 2 === c5 ? 128 == (192 & (a3 = t4[i3 + 1])) && (u2 = (31 & l2) << 6 | 63 & a3) <= 127 && (u2 = null) : 3 === c5 ? (s2 = t4[i3 + 2], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s2) && ((u2 = (15 & l2) << 12 | (63 & a3) << 6 | 63 & s2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c5 && (s2 = t4[i3 + 2], o2 = t4[i3 + 3], 128 == (192 & (a3 = t4[i3 + 1])) && 128 == (192 & s2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & a3) << 12 | (63 & s2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c5 = 1) : u2 > 65535 && (u2 -= 65536, n3 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n3 += String.fromCharCode(u2), i3 += c5;
              }
              return n3;
            }(this.buf, e3, t3);
          }, readBytes: function() {
            var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
            return this.pos = t3, e3;
          }, readPackedVarint: function(t3, e3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readVarint(e3));
            var r2 = zl(this);
            for (t3 = t3 || []; this.pos < r2; )
              t3.push(this.readVarint(e3));
            return t3;
          }, readPackedSVarint: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readSVarint());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readSVarint());
            return t3;
          }, readPackedBoolean: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readBoolean());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readBoolean());
            return t3;
          }, readPackedFloat: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readFloat());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readFloat());
            return t3;
          }, readPackedDouble: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readDouble());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readDouble());
            return t3;
          }, readPackedFixed32: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readFixed32());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readFixed32());
            return t3;
          }, readPackedSFixed32: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readSFixed32());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readSFixed32());
            return t3;
          }, readPackedFixed64: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readFixed64());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readFixed64());
            return t3;
          }, readPackedSFixed64: function(t3) {
            if (this.type !== Al.Bytes)
              return t3.push(this.readSFixed64());
            var e3 = zl(this);
            for (t3 = t3 || []; this.pos < e3; )
              t3.push(this.readSFixed64());
            return t3;
          }, skip: function(t3) {
            var e3 = 7 & t3;
            if (e3 === Al.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e3 === Al.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e3 === Al.Fixed32)
              this.pos += 4;
            else {
              if (e3 !== Al.Fixed64)
                throw new Error("Unimplemented type: " + e3);
              this.pos += 8;
            }
          }, writeTag: function(t3, e3) {
            this.writeVarint(t3 << 3 | e3);
          }, realloc: function(t3) {
            for (var e3 = this.length || 16; e3 < this.pos + t3; )
              e3 *= 2;
            if (e3 !== this.length) {
              var r2 = new Uint8Array(e3);
              r2.set(this.buf), this.buf = r2, this.length = e3;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t3) {
            this.realloc(4), Ul(this.buf, t3, this.pos), this.pos += 4;
          }, writeSFixed32: function(t3) {
            this.realloc(4), Ul(this.buf, t3, this.pos), this.pos += 4;
          }, writeFixed64: function(t3) {
            this.realloc(8), Ul(this.buf, -1 & t3, this.pos), Ul(this.buf, Math.floor(t3 * Sl), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t3) {
            this.realloc(8), Ul(this.buf, -1 & t3, this.pos), Ul(this.buf, Math.floor(t3 * Sl), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t3) {
            (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
              var r2, n3;
              if (t4 >= 0 ? (r2 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r2 = ~(-t4 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e3.realloc(10), function(t5, e4, r3) {
                r3.buf[r3.pos++] = 127 & t5 | 128, t5 >>>= 7, r3.buf[r3.pos++] = 127 & t5 | 128, t5 >>>= 7, r3.buf[r3.pos++] = 127 & t5 | 128, t5 >>>= 7, r3.buf[r3.pos++] = 127 & t5 | 128, r3.buf[r3.pos] = 127 & (t5 >>>= 7);
              }(r2, 0, e3), function(t5, e4) {
                var r3 = (7 & t5) << 4;
                e4.buf[e4.pos++] |= r3 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
              }(n3, e3);
            }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
          }, writeSVarint: function(t3) {
            this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
          }, writeBoolean: function(t3) {
            this.writeVarint(Boolean(t3));
          }, writeString: function(t3) {
            t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
            var e3 = this.pos;
            this.pos = function(t4, e4, r3) {
              for (var n3, i3, a3 = 0; a3 < e4.length; a3++) {
                if ((n3 = e4.charCodeAt(a3)) > 55295 && n3 < 57344) {
                  if (!i3) {
                    n3 > 56319 || a3 + 1 === e4.length ? (t4[r3++] = 239, t4[r3++] = 191, t4[r3++] = 189) : i3 = n3;
                    continue;
                  }
                  if (n3 < 56320) {
                    t4[r3++] = 239, t4[r3++] = 191, t4[r3++] = 189, i3 = n3;
                    continue;
                  }
                  n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
                } else
                  i3 && (t4[r3++] = 239, t4[r3++] = 191, t4[r3++] = 189, i3 = null);
                n3 < 128 ? t4[r3++] = n3 : (n3 < 2048 ? t4[r3++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r3++] = n3 >> 12 | 224 : (t4[r3++] = n3 >> 18 | 240, t4[r3++] = n3 >> 12 & 63 | 128), t4[r3++] = n3 >> 6 & 63 | 128), t4[r3++] = 63 & n3 | 128);
              }
              return r3;
            }(this.buf, t3, this.pos);
            var r2 = this.pos - e3;
            r2 >= 128 && Pl(e3, r2, this), this.pos = e3 - 1, this.writeVarint(r2), this.pos += r2;
          }, writeFloat: function(t3) {
            this.realloc(4), _l(this.buf, t3, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t3) {
            this.realloc(8), _l(this.buf, t3, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t3) {
            var e3 = t3.length;
            this.writeVarint(e3), this.realloc(e3);
            for (var r2 = 0; r2 < e3; r2++)
              this.buf[this.pos++] = t3[r2];
          }, writeRawMessage: function(t3, e3) {
            this.pos++;
            var r2 = this.pos;
            t3(e3, this);
            var n3 = this.pos - r2;
            n3 >= 128 && Pl(r2, n3, this), this.pos = r2 - 1, this.writeVarint(n3), this.pos += n3;
          }, writeMessage: function(t3, e3, r2) {
            this.writeTag(t3, Al.Bytes), this.writeRawMessage(e3, r2);
          }, writePackedVarint: function(t3, e3) {
            e3.length && this.writeMessage(t3, Bl, e3);
          }, writePackedSVarint: function(t3, e3) {
            e3.length && this.writeMessage(t3, Cl, e3);
          }, writePackedBoolean: function(t3, e3) {
            e3.length && this.writeMessage(t3, Fl, e3);
          }, writePackedFloat: function(t3, e3) {
            e3.length && this.writeMessage(t3, Vl, e3);
          }, writePackedDouble: function(t3, e3) {
            e3.length && this.writeMessage(t3, El, e3);
          }, writePackedFixed32: function(t3, e3) {
            e3.length && this.writeMessage(t3, Tl, e3);
          }, writePackedSFixed32: function(t3, e3) {
            e3.length && this.writeMessage(t3, Ll, e3);
          }, writePackedFixed64: function(t3, e3) {
            e3.length && this.writeMessage(t3, $l, e3);
          }, writePackedSFixed64: function(t3, e3) {
            e3.length && this.writeMessage(t3, Dl, e3);
          }, writeBytesField: function(t3, e3) {
            this.writeTag(t3, Al.Bytes), this.writeBytes(e3);
          }, writeFixed32Field: function(t3, e3) {
            this.writeTag(t3, Al.Fixed32), this.writeFixed32(e3);
          }, writeSFixed32Field: function(t3, e3) {
            this.writeTag(t3, Al.Fixed32), this.writeSFixed32(e3);
          }, writeFixed64Field: function(t3, e3) {
            this.writeTag(t3, Al.Fixed64), this.writeFixed64(e3);
          }, writeSFixed64Field: function(t3, e3) {
            this.writeTag(t3, Al.Fixed64), this.writeSFixed64(e3);
          }, writeVarintField: function(t3, e3) {
            this.writeTag(t3, Al.Varint), this.writeVarint(e3);
          }, writeSVarintField: function(t3, e3) {
            this.writeTag(t3, Al.Varint), this.writeSVarint(e3);
          }, writeStringField: function(t3, e3) {
            this.writeTag(t3, Al.Bytes), this.writeString(e3);
          }, writeFloatField: function(t3, e3) {
            this.writeTag(t3, Al.Fixed32), this.writeFloat(e3);
          }, writeDoubleField: function(t3, e3) {
            this.writeTag(t3, Al.Fixed64), this.writeDouble(e3);
          }, writeBooleanField: function(t3, e3) {
            this.writeVarintField(t3, Boolean(e3));
          } };
          var ql = e2(bl);
          const jl = 3;
          function Nl(t3, e3, r2) {
            1 === t3 && r2.readMessage(Zl, e3);
          }
          function Zl(t3, e3, r2) {
            if (3 === t3) {
              const { id: t4, bitmap: n3, width: i3, height: a3, left: s2, top: o2, advance: l2 } = r2.readMessage(Kl, {});
              e3.push({ id: t4, bitmap: new Ms({ width: i3 + 2 * jl, height: a3 + 2 * jl }, n3), metrics: { width: i3, height: a3, left: s2, top: o2, advance: l2 } });
            }
          }
          function Kl(t3, e3, r2) {
            1 === t3 ? e3.id = r2.readVarint() : 2 === t3 ? e3.bitmap = r2.readBytes() : 3 === t3 ? e3.width = r2.readVarint() : 4 === t3 ? e3.height = r2.readVarint() : 5 === t3 ? e3.left = r2.readSVarint() : 6 === t3 ? e3.top = r2.readSVarint() : 7 === t3 && (e3.advance = r2.readVarint());
          }
          const Gl = jl;
          function Jl(t3) {
            let e3 = 0, r2 = 0;
            for (const n4 of t3)
              e3 += n4.w * n4.h, r2 = Math.max(r2, n4.w);
            t3.sort((t4, e4) => e4.h - t4.h);
            const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e3 / 0.95)), r2), h: 1 / 0 }];
            let i3 = 0, a3 = 0;
            for (const e4 of t3)
              for (let t4 = n3.length - 1; t4 >= 0; t4--) {
                const r3 = n3[t4];
                if (!(e4.w > r3.w || e4.h > r3.h)) {
                  if (e4.x = r3.x, e4.y = r3.y, a3 = Math.max(a3, e4.y + e4.h), i3 = Math.max(i3, e4.x + e4.w), e4.w === r3.w && e4.h === r3.h) {
                    const e5 = n3.pop();
                    t4 < n3.length && (n3[t4] = e5);
                  } else
                    e4.h === r3.h ? (r3.x += e4.w, r3.w -= e4.w) : e4.w === r3.w ? (r3.y += e4.h, r3.h -= e4.h) : (n3.push({ x: r3.x + e4.w, y: r3.y, w: r3.w - e4.w, h: e4.h }), r3.y += e4.h, r3.h -= e4.h);
                  break;
                }
              }
            return { w: i3, h: a3, fill: e3 / (i3 * a3) || 0 };
          }
          const Xl = 1;
          class Yl {
            constructor(t3, { pixelRatio: e3, version: r2, stretchX: n3, stretchY: i3, content: a3 }) {
              this.paddedRect = t3, this.pixelRatio = e3, this.stretchX = n3, this.stretchY = i3, this.content = a3, this.version = r2;
            }
            get tl() {
              return [this.paddedRect.x + Xl, this.paddedRect.y + Xl];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - Xl, this.paddedRect.y + this.paddedRect.h - Xl];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * Xl) / this.pixelRatio, (this.paddedRect.h - 2 * Xl) / this.pixelRatio];
            }
          }
          class Hl {
            constructor(t3, e3) {
              const r2 = {}, n3 = {};
              this.haveRenderCallbacks = [];
              const i3 = [];
              this.addImages(t3, r2, i3), this.addImages(e3, n3, i3);
              const { w: a3, h: s2 } = Jl(i3), o2 = new Ps({ width: a3 || 1, height: s2 || 1 });
              for (const e4 in t3) {
                const n4 = t3[e4], i4 = r2[e4].paddedRect;
                Ps.copy(n4.data, o2, { x: 0, y: 0 }, { x: i4.x + Xl, y: i4.y + Xl }, n4.data);
              }
              for (const t4 in e3) {
                const r3 = e3[t4], i4 = n3[t4].paddedRect, a4 = i4.x + Xl, s3 = i4.y + Xl, l2 = r3.data.width, u2 = r3.data.height;
                Ps.copy(r3.data, o2, { x: 0, y: 0 }, { x: a4, y: s3 }, r3.data), Ps.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: a4, y: s3 - 1 }, { width: l2, height: 1 }), Ps.copy(r3.data, o2, { x: 0, y: 0 }, { x: a4, y: s3 + u2 }, { width: l2, height: 1 }), Ps.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: a4 - 1, y: s3 }, { width: 1, height: u2 }), Ps.copy(r3.data, o2, { x: 0, y: 0 }, { x: a4 + l2, y: s3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r2, this.patternPositions = n3;
            }
            addImages(t3, e3, r2) {
              for (const n3 in t3) {
                const i3 = t3[n3], a3 = { x: 0, y: 0, w: i3.data.width + 2 * Xl, h: i3.data.height + 2 * Xl };
                r2.push(a3), e3[n3] = new Yl(a3, i3), i3.hasRenderCallback && this.haveRenderCallbacks.push(n3);
              }
            }
            patchUpdatedImages(t3, e3) {
              t3.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r2 in t3.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r2], t3.getImage(r2), e3), this.patchUpdatedImage(this.patternPositions[r2], t3.getImage(r2), e3);
            }
            patchUpdatedImage(t3, e3, r2) {
              if (!t3 || !e3)
                return;
              if (t3.version === e3.version)
                return;
              t3.version = e3.version;
              const [n3, i3] = t3.tl;
              r2.update(e3.data, void 0, { x: n3, y: i3 });
            }
          }
          var Wl;
          In("ImagePosition", Yl), In("ImageAtlas", Hl), t2.WritingMode = void 0, (Wl = t2.WritingMode || (t2.WritingMode = {}))[Wl.none = 0] = "none", Wl[Wl.horizontal = 1] = "horizontal", Wl[Wl.vertical = 2] = "vertical", Wl[Wl.horizontalOnly = 3] = "horizontalOnly";
          const Ql = -17;
          class tu {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t3, e3) {
              const r2 = new tu();
              return r2.scale = t3 || 1, r2.fontStack = e3, r2;
            }
            static forImage(t3) {
              const e3 = new tu();
              return e3.imageName = t3, e3;
            }
          }
          class eu {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t3, e3) {
              const r2 = new eu();
              for (let n3 = 0; n3 < t3.sections.length; n3++) {
                const i3 = t3.sections[n3];
                i3.image ? r2.addImageSection(i3) : r2.addTextSection(i3, e3);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t3) {
              return this.sections[this.sectionIndex[t3]];
            }
            getSectionIndex(t3) {
              return this.sectionIndex[t3];
            }
            getCharCode(t3) {
              return this.text.charCodeAt(t3);
            }
            verticalizePunctuation() {
              this.text = function(t3) {
                let e3 = "";
                for (let r2 = 0; r2 < t3.length; r2++) {
                  const n3 = t3.charCodeAt(r2 + 1) || null, i3 = t3.charCodeAt(r2 - 1) || null;
                  e3 += n3 && Ln(n3) && !xl[t3[r2 + 1]] || i3 && Ln(i3) && !xl[t3[r2 - 1]] || !xl[t3[r2]] ? t3[r2] : xl[t3[r2]];
                }
                return e3;
              }(this.text);
            }
            trim() {
              let t3 = 0;
              for (let e4 = 0; e4 < this.text.length && nu[this.text.charCodeAt(e4)]; e4++)
                t3++;
              let e3 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t3 && nu[this.text.charCodeAt(r2)]; r2--)
                e3--;
              this.text = this.text.substring(t3, e3), this.sectionIndex = this.sectionIndex.slice(t3, e3);
            }
            substring(t3, e3) {
              const r2 = new eu();
              return r2.text = this.text.substring(t3, e3), r2.sectionIndex = this.sectionIndex.slice(t3, e3), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t3, e3) => Math.max(t3, this.sections[e3].scale), 0);
            }
            addTextSection(t3, e3) {
              this.text += t3.text, this.sections.push(tu.forText(t3.scale, t3.fontStack || e3));
              const r2 = this.sections.length - 1;
              for (let e4 = 0; e4 < t3.text.length; ++e4)
                this.sectionIndex.push(r2);
            }
            addImageSection(t3) {
              const e3 = t3.image ? t3.image.name : "";
              if (0 === e3.length)
                return void x("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(tu.forImage(e3)), this.sectionIndex.push(this.sections.length - 1)) : x("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function ru(e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2, m4) {
            const g3 = eu.fromFeature(e3, a3);
            let x2;
            p3 === t2.WritingMode.vertical && g3.verticalizePunctuation();
            const { processBidirectionalText: v2, processStyledBidirectionalText: b3 } = Hn;
            if (v2 && 1 === g3.sections.length) {
              x2 = [];
              const t3 = v2(g3.toString(), cu(g3, c5, s2, r2, i3, d3, y2));
              for (const e4 of t3) {
                const t4 = new eu();
                t4.text = e4, t4.sections = g3.sections;
                for (let r3 = 0; r3 < e4.length; r3++)
                  t4.sectionIndex.push(0);
                x2.push(t4);
              }
            } else if (b3) {
              x2 = [];
              const t3 = b3(g3.text, g3.sectionIndex, cu(g3, c5, s2, r2, i3, d3, y2));
              for (const e4 of t3) {
                const t4 = new eu();
                t4.text = e4[0], t4.sectionIndex = e4[1], t4.sections = g3.sections, x2.push(t4);
              }
            } else
              x2 = function(t3, e4) {
                const r3 = [], n4 = t3.text;
                let i4 = 0;
                for (const n5 of e4)
                  r3.push(t3.substring(i4, n5)), i4 = n5;
                return i4 < n4.length && r3.push(t3.substring(i4, n4.length)), r3;
              }(g3, cu(g3, c5, s2, r2, i3, d3, y2));
            const w2 = [], _2 = { positionedLines: w2, text: g3.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p3, iconsInText: false, verticalizable: false };
            return function(e4, r3, n4, i4, a4, s3, o3, l3, u3, c6, h3, p4) {
              let f3 = 0, d4 = Ql, y3 = 0, m5 = 0;
              const g4 = "right" === l3 ? 1 : "left" === l3 ? 0 : 0.5;
              let x3 = 0;
              for (const o4 of a4) {
                o4.trim();
                const a5 = o4.getMaxScale(), l4 = (a5 - 1) * vl, b5 = { positionedGlyphs: [], lineOffset: 0 };
                e4.positionedLines[x3] = b5;
                const w4 = b5.positionedGlyphs;
                let _4 = 0;
                if (!o4.length()) {
                  d4 += s3, ++x3;
                  continue;
                }
                for (let s4 = 0; s4 < o4.length(); s4++) {
                  const y4 = o4.getSection(s4), m6 = o4.getSectionIndex(s4), g5 = o4.getCharCode(s4);
                  let x4 = 0, b6 = null, A3 = null, k2 = null, S2 = vl;
                  const I2 = !(u3 === t2.WritingMode.horizontal || !h3 && !Tn(g5) || h3 && (nu[g5] || (v3 = g5, Cn.Arabic(v3) || Cn["Arabic Supplement"](v3) || Cn["Arabic Extended-A"](v3) || Cn["Arabic Presentation Forms-A"](v3) || Cn["Arabic Presentation Forms-B"](v3))));
                  if (y4.imageName) {
                    const t3 = i4[y4.imageName];
                    if (!t3)
                      continue;
                    k2 = y4.imageName, e4.iconsInText = e4.iconsInText || true, A3 = t3.paddedRect;
                    const r4 = t3.displaySize;
                    y4.scale = y4.scale * vl / p4, b6 = { width: r4[0], height: r4[1], left: Xl, top: -Gl, advance: I2 ? r4[1] : r4[0] }, x4 = l4 + (vl - r4[1] * y4.scale), S2 = b6.advance;
                    const n5 = I2 ? r4[0] * y4.scale - vl * a5 : r4[1] * y4.scale - vl * a5;
                    n5 > 0 && n5 > _4 && (_4 = n5);
                  } else {
                    const t3 = n4[y4.fontStack], e5 = t3 && t3[g5];
                    if (e5 && e5.rect)
                      A3 = e5.rect, b6 = e5.metrics;
                    else {
                      const t4 = r3[y4.fontStack], e6 = t4 && t4[g5];
                      if (!e6)
                        continue;
                      b6 = e6.metrics;
                    }
                    x4 = (a5 - y4.scale) * vl;
                  }
                  I2 ? (e4.verticalizable = true, w4.push({ glyph: g5, imageName: k2, x: f3, y: d4 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m6, metrics: b6, rect: A3 }), f3 += S2 * y4.scale + c6) : (w4.push({ glyph: g5, imageName: k2, x: f3, y: d4 + x4, vertical: I2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m6, metrics: b6, rect: A3 }), f3 += b6.advance * y4.scale + c6);
                }
                0 !== w4.length && (y3 = Math.max(f3 - c6, y3), pu(w4, 0, w4.length - 1, g4, _4)), f3 = 0;
                const A2 = s3 * a5 + _4;
                b5.lineOffset = Math.max(_4, l4), d4 += A2, m5 = Math.max(A2, m5), ++x3;
              }
              var v3;
              const b4 = d4 - Ql, { horizontalAlign: w3, verticalAlign: _3 } = hu(o3);
              (function(t3, e5, r4, n5, i5, a5, s4, o4, l4) {
                const u4 = (e5 - r4) * i5;
                let c7 = 0;
                c7 = a5 !== s4 ? -o4 * n5 - Ql : (-n5 * l4 + 0.5) * s4;
                for (const e6 of t3)
                  for (const t4 of e6.positionedGlyphs)
                    t4.x += u4, t4.y += c7;
              })(e4.positionedLines, g4, w3, _3, y3, m5, s3, b4, a4.length), e4.top += -_3 * b4, e4.bottom = e4.top + b4, e4.left += -w3 * y3, e4.right = e4.left + y3;
            }(_2, r2, n3, i3, x2, o2, l2, u2, p3, c5, f2, m4), !function(t3) {
              for (const e4 of t3)
                if (0 !== e4.positionedGlyphs.length)
                  return false;
              return true;
            }(w2) && _2;
          }
          const nu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, iu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function au(t3, e3, r2, n3, i3, a3) {
            if (e3.imageName) {
              const t4 = n3[e3.imageName];
              return t4 ? t4.displaySize[0] * e3.scale * vl / a3 + i3 : 0;
            }
            {
              const n4 = r2[e3.fontStack], a4 = n4 && n4[t3];
              return a4 ? a4.metrics.advance * e3.scale + i3 : 0;
            }
          }
          function su(t3, e3, r2, n3) {
            const i3 = Math.pow(t3 - e3, 2);
            return n3 ? t3 < e3 ? i3 / 2 : 2 * i3 : i3 + Math.abs(r2) * r2;
          }
          function ou(t3, e3, r2) {
            let n3 = 0;
            return 10 === t3 && (n3 -= 1e4), r2 && (n3 += 150), 40 !== t3 && 65288 !== t3 || (n3 += 50), 41 !== e3 && 65289 !== e3 || (n3 += 50), n3;
          }
          function lu(t3, e3, r2, n3, i3, a3) {
            let s2 = null, o2 = su(e3, r2, i3, a3);
            for (const t4 of n3) {
              const n4 = su(e3 - t4.x, r2, i3, a3) + t4.badness;
              n4 <= o2 && (s2 = t4, o2 = n4);
            }
            return { index: t3, x: e3, priorBreak: s2, badness: o2 };
          }
          function uu(t3) {
            return t3 ? uu(t3.priorBreak).concat(t3.index) : [];
          }
          function cu(t3, e3, r2, n3, i3, a3, s2) {
            if ("point" !== a3)
              return [];
            if (!t3)
              return [];
            const o2 = [], l2 = function(t4, e4, r3, n4, i4, a4) {
              let s3 = 0;
              for (let r4 = 0; r4 < t4.length(); r4++) {
                const o3 = t4.getSection(r4);
                s3 += au(t4.getCharCode(r4), o3, n4, i4, e4, a4);
              }
              return s3 / Math.max(1, Math.ceil(s3 / r3));
            }(t3, e3, r2, n3, i3, s2), u2 = t3.text.indexOf("\u200B") >= 0;
            let c5 = 0;
            for (let r3 = 0; r3 < t3.length(); r3++) {
              const a4 = t3.getSection(r3), p3 = t3.getCharCode(r3);
              if (nu[p3] || (c5 += au(p3, a4, n3, i3, e3, s2)), r3 < t3.length() - 1) {
                const e4 = !((h2 = p3) < 11904 || !(Cn["Bopomofo Extended"](h2) || Cn.Bopomofo(h2) || Cn["CJK Compatibility Forms"](h2) || Cn["CJK Compatibility Ideographs"](h2) || Cn["CJK Compatibility"](h2) || Cn["CJK Radicals Supplement"](h2) || Cn["CJK Strokes"](h2) || Cn["CJK Symbols and Punctuation"](h2) || Cn["CJK Unified Ideographs Extension A"](h2) || Cn["CJK Unified Ideographs"](h2) || Cn["Enclosed CJK Letters and Months"](h2) || Cn["Halfwidth and Fullwidth Forms"](h2) || Cn.Hiragana(h2) || Cn["Ideographic Description Characters"](h2) || Cn["Kangxi Radicals"](h2) || Cn["Katakana Phonetic Extensions"](h2) || Cn.Katakana(h2) || Cn["Vertical Forms"](h2) || Cn["Yi Radicals"](h2) || Cn["Yi Syllables"](h2)));
                (iu[p3] || e4 || a4.imageName) && o2.push(lu(r3 + 1, c5, l2, o2, ou(p3, t3.getCharCode(r3 + 1), e4 && u2), false));
              }
            }
            var h2;
            return uu(lu(t3.length(), c5, l2, o2, 0, true));
          }
          function hu(t3) {
            let e3 = 0.5, r2 = 0.5;
            switch (t3) {
              case "right":
              case "top-right":
              case "bottom-right":
                e3 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e3 = 0;
            }
            switch (t3) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e3, verticalAlign: r2 };
          }
          function pu(t3, e3, r2, n3, i3) {
            if (!n3 && !i3)
              return;
            const a3 = t3[r2], s2 = (t3[r2].x + a3.metrics.advance * a3.scale) * n3;
            for (let n4 = e3; n4 <= r2; n4++)
              t3[n4].x -= s2, t3[n4].y += i3;
          }
          function fu(t3, e3, r2) {
            const { horizontalAlign: n3, verticalAlign: i3 } = hu(r2), a3 = e3[0] - t3.displaySize[0] * n3, s2 = e3[1] - t3.displaySize[1] * i3;
            return { image: t3, top: s2, bottom: s2 + t3.displaySize[1], left: a3, right: a3 + t3.displaySize[0] };
          }
          function du(t3, e3, r2, n3, i3, a3) {
            const s2 = t3.image;
            let o2;
            if (s2.content) {
              const t4 = s2.content, e4 = s2.pixelRatio || 1;
              o2 = [t4[0] / e4, t4[1] / e4, s2.displaySize[0] - t4[2] / e4, s2.displaySize[1] - t4[3] / e4];
            }
            const l2 = e3.left * a3, u2 = e3.right * a3;
            let c5, h2, p3, f2;
            "width" === r2 || "both" === r2 ? (f2 = i3[0] + l2 - n3[3], h2 = i3[0] + u2 + n3[1]) : (f2 = i3[0] + (l2 + u2 - s2.displaySize[0]) / 2, h2 = f2 + s2.displaySize[0]);
            const d3 = e3.top * a3, y2 = e3.bottom * a3;
            return "height" === r2 || "both" === r2 ? (c5 = i3[1] + d3 - n3[0], p3 = i3[1] + y2 + n3[2]) : (c5 = i3[1] + (d3 + y2 - s2.displaySize[1]) / 2, p3 = c5 + s2.displaySize[1]), { image: s2, top: c5, right: h2, bottom: p3, left: f2, collisionPadding: o2 };
          }
          const yu = 255, mu = 128, gu = yu * mu;
          function xu(t3, e3) {
            const { expression: r2 } = e3;
            if ("constant" === r2.kind)
              return { kind: "constant", layoutSize: r2.evaluate(new Wn(t3 + 1)) };
            if ("source" === r2.kind)
              return { kind: "source" };
            {
              const { zoomStops: e4, interpolationType: n3 } = r2;
              let i3 = 0;
              for (; i3 < e4.length && e4[i3] <= t3; )
                i3++;
              i3 = Math.max(0, i3 - 1);
              let a3 = i3;
              for (; a3 < e4.length && e4[a3] < t3 + 1; )
                a3++;
              a3 = Math.min(e4.length - 1, a3);
              const s2 = e4[i3], o2 = e4[a3];
              return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: o2, interpolationType: n3 } : { kind: "camera", minZoom: s2, maxZoom: o2, minSize: r2.evaluate(new Wn(s2)), maxSize: r2.evaluate(new Wn(o2)), interpolationType: n3 };
            }
          }
          function vu(t3, e3, r2) {
            let n3 = "never";
            const i3 = t3.get(e3);
            return i3 ? n3 = i3 : t3.get(r2) && (n3 = "always"), n3;
          }
          const bu = Mo.VectorTileFeature.types, wu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function _u(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3) {
            const f2 = o2 ? Math.min(gu, Math.round(o2[0])) : 0, d3 = o2 ? Math.min(gu, Math.round(o2[1])) : 0;
            t3.emplaceBack(e3, r2, Math.round(32 * n3), Math.round(32 * i3), a3, s2, (f2 << 1) + (l2 ? 1 : 0), d3, 16 * u2, 16 * c5, 256 * h2, 256 * p3);
          }
          function Au(t3, e3, r2) {
            t3.emplaceBack(e3.x, e3.y, r2), t3.emplaceBack(e3.x, e3.y, r2), t3.emplaceBack(e3.x, e3.y, r2), t3.emplaceBack(e3.x, e3.y, r2);
          }
          function ku(t3) {
            for (const e3 of t3.sections)
              if (On(e3.text))
                return true;
            return false;
          }
          class Su {
            constructor(t3) {
              this.layoutVertexArray = new aa(), this.indexArray = new ca(), this.programConfigurations = t3, this.segments = new da(), this.dynamicLayoutVertexArray = new sa(), this.opacityVertexArray = new oa(), this.hasVisibleVertices = false, this.placedSymbolArray = new Zi();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t3, e3, r2, n3) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, pl.members), this.indexBuffer = t3.createIndexBuffer(this.indexArray, e3), this.dynamicLayoutVertexBuffer = t3.createVertexBuffer(this.dynamicLayoutVertexArray, fl.members, true), this.opacityVertexBuffer = t3.createVertexBuffer(this.opacityVertexArray, wu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n3) && this.programConfigurations.upload(t3));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          In("SymbolBuffers", Su);
          class Iu {
            constructor(t3, e3, r2) {
              this.layoutVertexArray = new t3(), this.layoutAttributes = e3, this.indexArray = new r2(), this.segments = new da(), this.collisionVertexArray = new ua();
            }
            upload(t3) {
              this.layoutVertexBuffer = t3.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t3.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t3.createVertexBuffer(this.collisionVertexArray, dl.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          In("CollisionBuffers", Iu);
          class zu {
            constructor(e3) {
              this.collisionBoxArray = e3.collisionBoxArray, this.zoom = e3.zoom, this.overscaling = e3.overscaling, this.layers = e3.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = e3.index, this.pixelRatio = e3.pixelRatio, this.sourceLayerIndex = e3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ys([]), this.placementViewportMatrix = ys([]);
              const r2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = xu(this.zoom, r2["text-size"]), this.iconSizeData = xu(this.zoom, r2["icon-size"]);
              const n3 = this.layers[0].layout, i3 = n3.get("symbol-sort-key"), a3 = n3.get("symbol-z-order");
              this.canOverlap = "never" !== vu(n3, "text-overlap", "text-allow-overlap") || "never" !== vu(n3, "icon-overlap", "icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a3 && !i3.isConstant(), this.sortFeaturesByY = ("viewport-y" === a3 || "auto" === a3 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n3.get("symbol-placement") && (this.writingModes = n3.get("text-writing-mode").map((e4) => t2.WritingMode[e4])), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = e3.sourceID;
            }
            createArrays() {
              this.text = new Su(new Ua(this.layers, this.zoom, (t3) => /^text/.test(t3))), this.icon = new Su(new Ua(this.layers, this.zoom, (t3) => /^icon/.test(t3))), this.glyphOffsetArray = new Ji(), this.lineVertexArray = new Xi(), this.symbolInstances = new Gi();
            }
            calculateGlyphDependencies(t3, e3, r2, n3, i3) {
              for (let a3 = 0; a3 < t3.length; a3++)
                if (e3[t3.charCodeAt(a3)] = true, (r2 || n3) && i3) {
                  const r3 = xl[t3.charAt(a3)];
                  r3 && (e3[r3.charCodeAt(0)] = true);
                }
            }
            populate(e3, r2, n3) {
              const i3 = this.layers[0], a3 = i3.layout, s2 = a3.get("text-font"), o2 = a3.get("text-field"), l2 = a3.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Zt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== s2.value.kind || s2.value.value.length > 0), c5 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = a3.get("symbol-sort-key");
              if (this.features = [], !u2 && !c5)
                return;
              const p3 = r2.iconDependencies, f2 = r2.glyphDependencies, d3 = r2.availableImages, y2 = new Wn(this.zoom);
              for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m4 } of e3) {
                const e4 = i3._featureFilter.needGeometry, g3 = Ga(r3, e4);
                if (!i3._featureFilter.filter(y2, g3, n3))
                  continue;
                let x2, v2;
                if (e4 || (g3.geometry = Ka(r3)), u2) {
                  const t3 = i3.getValueAndResolveTokens("text-field", g3, n3, d3), e5 = Zt.factory(t3);
                  ku(e5) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Xn() || this.hasRTLText && Hn.isParsed()) && (x2 = gl(e5, i3, g3));
                }
                if (c5) {
                  const t3 = i3.getValueAndResolveTokens("icon-image", g3, n3, d3);
                  v2 = t3 instanceof Gt ? t3 : Gt.fromString(t3);
                }
                if (!x2 && !v2)
                  continue;
                const b3 = this.sortFeaturesByKey ? h2.evaluate(g3, {}, n3) : void 0;
                if (this.features.push({ id: o3, text: x2, icon: v2, index: l3, sourceLayerIndex: m4, geometry: g3.geometry, properties: r3.properties, type: bu[r3.type], sortKey: b3 }), v2 && (p3[v2.name] = true), x2) {
                  const e5 = s2.evaluate(g3, {}, n3).join(","), r4 = "viewport" !== a3.get("text-rotation-alignment") && "point" !== a3.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t2.WritingMode.vertical) >= 0;
                  for (const t3 of x2.sections)
                    if (t3.image)
                      p3[t3.image.name] = true;
                    else {
                      const n4 = Vn(x2.toString()), i4 = t3.fontStack || e5, a4 = f2[i4] = f2[i4] || {};
                      this.calculateGlyphDependencies(t3.text, a4, r4, this.allowVerticalPlacement, n4);
                    }
                }
              }
              "line" === a3.get("symbol-placement") && (this.features = function(t3) {
                const e4 = {}, r3 = {}, n4 = [];
                let i4 = 0;
                function a4(e5) {
                  n4.push(t3[e5]), i4++;
                }
                function s3(t4, e5, i5) {
                  const a5 = r3[t4];
                  return delete r3[t4], r3[e5] = a5, n4[a5].geometry[0].pop(), n4[a5].geometry[0] = n4[a5].geometry[0].concat(i5[0]), a5;
                }
                function o3(t4, r4, i5) {
                  const a5 = e4[r4];
                  return delete e4[r4], e4[t4] = a5, n4[a5].geometry[0].shift(), n4[a5].geometry[0] = i5[0].concat(n4[a5].geometry[0]), a5;
                }
                function l3(t4, e5, r4) {
                  const n5 = r4 ? e5[0][e5[0].length - 1] : e5[0][0];
                  return `${t4}:${n5.x}:${n5.y}`;
                }
                for (let u3 = 0; u3 < t3.length; u3++) {
                  const c6 = t3[u3], h3 = c6.geometry, p4 = c6.text ? c6.text.toString() : null;
                  if (!p4) {
                    a4(u3);
                    continue;
                  }
                  const f3 = l3(p4, h3), d4 = l3(p4, h3, true);
                  if (f3 in r3 && d4 in e4 && r3[f3] !== e4[d4]) {
                    const t4 = o3(f3, d4, h3), i5 = s3(f3, d4, n4[t4].geometry);
                    delete e4[f3], delete r3[d4], r3[l3(p4, n4[i5].geometry, true)] = i5, n4[t4].geometry = null;
                  } else
                    f3 in r3 ? s3(f3, d4, h3) : d4 in e4 ? o3(f3, d4, h3) : (a4(u3), e4[f3] = i4 - 1, r3[d4] = i4 - 1);
                }
                return n4.filter((t4) => t4.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t3, e4) => t3.sortKey - e4.sortKey);
            }
            update(t3, e3, r2) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t3, e3, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t3, e3, this.layers, r2));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t3) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t3), this.iconCollisionBox.upload(t3)), this.text.upload(t3, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t3, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t3, e3) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t3.segment) {
                let r3 = t3.dist(e3[t3.segment + 1]), n3 = t3.dist(e3[t3.segment]);
                const i3 = {};
                for (let n4 = t3.segment + 1; n4 < e3.length; n4++)
                  i3[n4] = { x: e3[n4].x, y: e3[n4].y, tileUnitDistanceFromAnchor: r3 }, n4 < e3.length - 1 && (r3 += e3[n4 + 1].dist(e3[n4]));
                for (let r4 = t3.segment || 0; r4 >= 0; r4--)
                  i3[r4] = { x: e3[r4].x, y: e3[r4].y, tileUnitDistanceFromAnchor: n3 }, r4 > 0 && (n3 += e3[r4 - 1].dist(e3[r4]));
                for (let t4 = 0; t4 < e3.length; t4++) {
                  const e4 = i3[t4];
                  this.lineVertexArray.emplaceBack(e4.x, e4.y, e4.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2, p3) {
              const f2 = e3.indexArray, d3 = e3.layoutVertexArray, y2 = e3.segments.prepareSegment(4 * r2.length, d3, f2, this.canOverlap ? s2.sortKey : void 0), m4 = this.glyphOffsetArray.length, g3 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t2.WritingMode.vertical ? Math.PI / 2 : 0, v2 = s2.text && s2.text.sections;
              for (let t3 = 0; t3 < r2.length; t3++) {
                const { tl: i4, tr: a4, bl: o3, br: u3, tex: c6, pixelOffsetTL: h3, pixelOffsetBR: m5, minFontScaleX: g4, minFontScaleY: b3, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t3], k2 = y2.vertexLength, S2 = w2[1];
                _u(d3, l2.x, l2.y, i4.x, S2 + i4.y, c6.x, c6.y, n3, _2, h3.x, h3.y, g4, b3), _u(d3, l2.x, l2.y, a4.x, S2 + a4.y, c6.x + c6.w, c6.y, n3, _2, m5.x, h3.y, g4, b3), _u(d3, l2.x, l2.y, o3.x, S2 + o3.y, c6.x, c6.y + c6.h, n3, _2, h3.x, m5.y, g4, b3), _u(d3, l2.x, l2.y, u3.x, S2 + u3.y, c6.x + c6.w, c6.y + c6.h, n3, _2, m5.x, m5.y, g4, b3), Au(e3.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(k2, k2 + 1, k2 + 2), f2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t3 !== r2.length - 1 && A2 === r2[t3 + 1].sectionIndex || e3.programConfigurations.populatePaintArrays(d3.length, s2, s2.index, {}, p3, v2 && v2[A2]);
              }
              e3.placedSymbolArray.emplaceBack(l2.x, l2.y, m4, this.glyphOffsetArray.length - m4, g3, u2, c5, l2.segment, n3 ? n3[0] : 0, n3 ? n3[1] : 0, i3[0], i3[1], o2, 0, false, 0, h2);
            }
            _addCollisionDebugVertex(t3, e3, r2, n3, i3, a3) {
              return e3.emplaceBack(0, 0), t3.emplaceBack(r2.x, r2.y, n3, i3, Math.round(a3.x), Math.round(a3.y));
            }
            addCollisionDebugVertices(t3, e3, r2, n3, a3, s2, o2) {
              const l2 = a3.segments.prepareSegment(4, a3.layoutVertexArray, a3.indexArray), u2 = l2.vertexLength, c5 = a3.layoutVertexArray, h2 = a3.collisionVertexArray, p3 = o2.anchorX, f2 = o2.anchorY;
              this._addCollisionDebugVertex(c5, h2, s2, p3, f2, new i2(t3, e3)), this._addCollisionDebugVertex(c5, h2, s2, p3, f2, new i2(r2, e3)), this._addCollisionDebugVertex(c5, h2, s2, p3, f2, new i2(r2, n3)), this._addCollisionDebugVertex(c5, h2, s2, p3, f2, new i2(t3, n3)), l2.vertexLength += 4;
              const d3 = a3.indexArray;
              d3.emplaceBack(u2, u2 + 1), d3.emplaceBack(u2 + 1, u2 + 2), d3.emplaceBack(u2 + 2, u2 + 3), d3.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t3, e3, r2, n3) {
              for (let i3 = t3; i3 < e3; i3++) {
                const t4 = this.collisionBoxArray.get(i3);
                this.addCollisionDebugVertices(t4.x1, t4.y1, t4.x2, t4.y2, n3 ? this.textCollisionBox : this.iconCollisionBox, t4.anchorPoint, r2);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Iu(la, yl.members, ha), this.iconCollisionBox = new Iu(la, yl.members, ha);
              for (let t3 = 0; t3 < this.symbolInstances.length; t3++) {
                const e3 = this.symbolInstances.get(t3);
                this.addDebugCollisionBoxes(e3.textBoxStartIndex, e3.textBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.verticalTextBoxStartIndex, e3.verticalTextBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.iconBoxStartIndex, e3.iconBoxEndIndex, e3, false), this.addDebugCollisionBoxes(e3.verticalIconBoxStartIndex, e3.verticalIconBoxEndIndex, e3, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t3, e3, r2, n3, i3, a3, s2, o2, l2) {
              const u2 = {};
              for (let n4 = e3; n4 < r2; n4++) {
                const e4 = t3.get(n4);
                u2.textBox = { x1: e4.x1, y1: e4.y1, x2: e4.x2, y2: e4.y2, anchorPointX: e4.anchorPointX, anchorPointY: e4.anchorPointY }, u2.textFeatureIndex = e4.featureIndex;
                break;
              }
              for (let e4 = n3; e4 < i3; e4++) {
                const r3 = t3.get(e4);
                u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e4 = a3; e4 < s2; e4++) {
                const r3 = t3.get(e4);
                u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e4 = o2; e4 < l2; e4++) {
                const r3 = t3.get(e4);
                u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
                break;
              }
              return u2;
            }
            deserializeCollisionBoxes(t3) {
              this.collisionArrays = [];
              for (let e3 = 0; e3 < this.symbolInstances.length; e3++) {
                const r2 = this.symbolInstances.get(e3);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t3, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t3, e3) {
              const r2 = t3.placedSymbolArray.get(e3), n3 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e4 = r2.vertexStartIndex; e4 < n3; e4 += 4)
                t3.indexArray.emplaceBack(e4, e4 + 1, e4 + 2), t3.indexArray.emplaceBack(e4 + 1, e4 + 2, e4 + 3);
            }
            getSortedSymbolIndexes(t3) {
              if (this.sortedAngle === t3 && void 0 !== this.symbolInstanceIndexes)
                return this.symbolInstanceIndexes;
              const e3 = Math.sin(t3), r2 = Math.cos(t3), n3 = [], i3 = [], a3 = [];
              for (let t4 = 0; t4 < this.symbolInstances.length; ++t4) {
                a3.push(t4);
                const s2 = this.symbolInstances.get(t4);
                n3.push(0 | Math.round(e3 * s2.anchorX + r2 * s2.anchorY)), i3.push(s2.featureIndex);
              }
              return a3.sort((t4, e4) => n3[t4] - n3[e4] || i3[e4] - i3[t4]), a3;
            }
            addToSortKeyRanges(t3, e3) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e3 ? r2.symbolInstanceEnd = t3 + 1 : this.sortKeyRanges.push({ sortKey: e3, symbolInstanceStart: t3, symbolInstanceEnd: t3 + 1 });
            }
            sortFeatures(t3) {
              if (this.sortFeaturesByY && this.sortedAngle !== t3 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t3), this.sortedAngle = t3, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t4 of this.symbolInstanceIndexes) {
                  const e3 = this.symbolInstances.get(t4);
                  this.featureSortOrder.push(e3.featureIndex), [e3.rightJustifiedTextSymbolIndex, e3.centerJustifiedTextSymbolIndex, e3.leftJustifiedTextSymbolIndex].forEach((t5, e4, r2) => {
                    t5 >= 0 && r2.indexOf(t5) === e4 && this.addIndicesForPlacedSymbol(this.text, t5);
                  }), e3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e3.verticalPlacedTextSymbolIndex), e3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.placedIconSymbolIndex), e3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Mu, Pu;
          In("SymbolBucket", zu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), zu.MAX_GLYPHS = 65535, zu.addDynamicAttributes = Au;
          var Bu = { get paint() {
            return Pu = Pu || new pi({ "icon-opacity": new li(q.paint_symbol["icon-opacity"]), "icon-color": new li(q.paint_symbol["icon-color"]), "icon-halo-color": new li(q.paint_symbol["icon-halo-color"]), "icon-halo-width": new li(q.paint_symbol["icon-halo-width"]), "icon-halo-blur": new li(q.paint_symbol["icon-halo-blur"]), "icon-translate": new oi(q.paint_symbol["icon-translate"]), "icon-translate-anchor": new oi(q.paint_symbol["icon-translate-anchor"]), "text-opacity": new li(q.paint_symbol["text-opacity"]), "text-color": new li(q.paint_symbol["text-color"], { runtimeType: lt, getOverride: (t3) => t3.textColor, hasOverride: (t3) => !!t3.textColor }), "text-halo-color": new li(q.paint_symbol["text-halo-color"]), "text-halo-width": new li(q.paint_symbol["text-halo-width"]), "text-halo-blur": new li(q.paint_symbol["text-halo-blur"]), "text-translate": new oi(q.paint_symbol["text-translate"]), "text-translate-anchor": new oi(q.paint_symbol["text-translate-anchor"]) });
          }, get layout() {
            return Mu = Mu || new pi({ "symbol-placement": new oi(q.layout_symbol["symbol-placement"]), "symbol-spacing": new oi(q.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new oi(q.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new li(q.layout_symbol["symbol-sort-key"]), "symbol-z-order": new oi(q.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new oi(q.layout_symbol["icon-allow-overlap"]), "icon-overlap": new oi(q.layout_symbol["icon-overlap"]), "icon-ignore-placement": new oi(q.layout_symbol["icon-ignore-placement"]), "icon-optional": new oi(q.layout_symbol["icon-optional"]), "icon-rotation-alignment": new oi(q.layout_symbol["icon-rotation-alignment"]), "icon-size": new li(q.layout_symbol["icon-size"]), "icon-text-fit": new oi(q.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new oi(q.layout_symbol["icon-text-fit-padding"]), "icon-image": new li(q.layout_symbol["icon-image"]), "icon-rotate": new li(q.layout_symbol["icon-rotate"]), "icon-padding": new li(q.layout_symbol["icon-padding"]), "icon-keep-upright": new oi(q.layout_symbol["icon-keep-upright"]), "icon-offset": new li(q.layout_symbol["icon-offset"]), "icon-anchor": new li(q.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new oi(q.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new oi(q.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new oi(q.layout_symbol["text-rotation-alignment"]), "text-field": new li(q.layout_symbol["text-field"]), "text-font": new li(q.layout_symbol["text-font"]), "text-size": new li(q.layout_symbol["text-size"]), "text-max-width": new li(q.layout_symbol["text-max-width"]), "text-line-height": new oi(q.layout_symbol["text-line-height"]), "text-letter-spacing": new li(q.layout_symbol["text-letter-spacing"]), "text-justify": new li(q.layout_symbol["text-justify"]), "text-radial-offset": new li(q.layout_symbol["text-radial-offset"]), "text-variable-anchor": new oi(q.layout_symbol["text-variable-anchor"]), "text-anchor": new li(q.layout_symbol["text-anchor"]), "text-max-angle": new oi(q.layout_symbol["text-max-angle"]), "text-writing-mode": new oi(q.layout_symbol["text-writing-mode"]), "text-rotate": new li(q.layout_symbol["text-rotate"]), "text-padding": new oi(q.layout_symbol["text-padding"]), "text-keep-upright": new oi(q.layout_symbol["text-keep-upright"]), "text-transform": new li(q.layout_symbol["text-transform"]), "text-offset": new li(q.layout_symbol["text-offset"]), "text-allow-overlap": new oi(q.layout_symbol["text-allow-overlap"]), "text-overlap": new oi(q.layout_symbol["text-overlap"]), "text-ignore-placement": new oi(q.layout_symbol["text-ignore-placement"]), "text-optional": new oi(q.layout_symbol["text-optional"]) });
          } };
          class Cu {
            constructor(t3) {
              if (void 0 === t3.property.overrides)
                throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
              this.type = t3.property.overrides ? t3.property.overrides.runtimeType : it, this.defaultValue = t3;
            }
            evaluate(t3) {
              if (t3.formattedSection) {
                const e3 = this.defaultValue.property.overrides;
                if (e3 && e3.hasOverride(t3.formattedSection))
                  return e3.getOverride(t3.formattedSection);
              }
              return t3.feature && t3.featureState ? this.defaultValue.evaluate(t3.feature, t3.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t3) {
              this.defaultValue.isConstant() || t3(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          In("FormatSectionOverride", Cu, { omit: ["defaultValue"] });
          class Vu extends di {
            constructor(t3) {
              super(t3, Bu);
            }
            recalculate(t3, e3) {
              if (super.recalculate(t3, e3), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                const t4 = this.layout.get("text-writing-mode");
                if (t4) {
                  const e4 = [];
                  for (const r2 of t4)
                    e4.indexOf(r2) < 0 && e4.push(r2);
                  this.layout._values["text-writing-mode"] = e4;
                } else
                  this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t3, e3, r2, n3) {
              const i3 = this.layout.get(t3).evaluate(e3, {}, r2, n3), a3 = this._unevaluatedLayout._values[t3];
              return a3.isDataDriven() || Sr(a3.value) || !i3 ? i3 : function(t4, e4) {
                return e4.replace(/{([^{}]+)}/g, (e5, r3) => r3 in t4 ? String(t4[r3]) : "");
              }(e3.properties, i3);
            }
            createBucket(t3) {
              return new zu(t3);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
              for (const t3 of Bu.paint.overridableProperties) {
                if (!Vu.hasPaintOverride(this.layout, t3))
                  continue;
                const e3 = this.paint.get(t3), r2 = new Cu(e3), n3 = new kr(r2, e3.property.specification);
                let i3 = null;
                i3 = "constant" === e3.value.kind || "source" === e3.value.kind ? new zr("source", n3) : new Mr("composite", n3, e3.value.zoomStops), this.paint._values[t3] = new ai(e3.property, i3, e3.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t3, e3, r2) {
              return !(!this.layout || e3.isDataDriven() || r2.isDataDriven()) && Vu.hasPaintOverride(this.layout, t3);
            }
            static hasPaintOverride(t3, e3) {
              const r2 = t3.get("text-field"), n3 = Bu.paint.properties[e3];
              let i3 = false;
              const a3 = (t4) => {
                for (const e4 of t4)
                  if (n3.overrides && n3.overrides.hasOverride(e4))
                    return void (i3 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Zt)
                a3(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t4 = (e5) => {
                  i3 || (e5 instanceof Wt && Yt(e5.value) === pt ? a3(e5.value.sections) : e5 instanceof rr ? a3(e5.sections) : e5.eachChild(t4));
                }, e4 = r2.value;
                e4._styleExpression && t4(e4._styleExpression.expression);
              }
              return i3;
            }
          }
          let Eu;
          var Fu = { get paint() {
            return Eu = Eu || new pi({ "background-color": new oi(q.paint_background["background-color"]), "background-pattern": new ci(q.paint_background["background-pattern"]), "background-opacity": new oi(q.paint_background["background-opacity"]) });
          } };
          class Tu extends di {
            constructor(t3) {
              super(t3, Fu);
            }
          }
          let Lu;
          var $u = { get paint() {
            return Lu = Lu || new pi({ "raster-opacity": new oi(q.paint_raster["raster-opacity"]), "raster-hue-rotate": new oi(q.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new oi(q.paint_raster["raster-brightness-min"]), "raster-brightness-max": new oi(q.paint_raster["raster-brightness-max"]), "raster-saturation": new oi(q.paint_raster["raster-saturation"]), "raster-contrast": new oi(q.paint_raster["raster-contrast"]), "raster-resampling": new oi(q.paint_raster["raster-resampling"]), "raster-fade-duration": new oi(q.paint_raster["raster-fade-duration"]) });
          } };
          class Du extends di {
            constructor(t3) {
              super(t3, $u);
            }
          }
          class Ou extends di {
            constructor(t3) {
              super(t3, {}), this.onAdd = (t4) => {
                this.implementation.onAdd && this.implementation.onAdd(t4, t4.painter.context.gl);
              }, this.onRemove = (t4) => {
                this.implementation.onRemove && this.implementation.onRemove(t4, t4.painter.context.gl);
              }, this.implementation = t3;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
              throw new Error("Custom layers cannot be serialized");
            }
          }
          class Uu {
            constructor(t3) {
              this._callback = t3, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              delete this._channel, this._callback = () => {
              };
            }
          }
          const Ru = 63710088e-1;
          class qu {
            constructor(t3, e3) {
              if (isNaN(t3) || isNaN(e3))
                throw new Error(`Invalid LngLat object: (${t3}, ${e3})`);
              if (this.lng = +t3, this.lat = +e3, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new qu(h(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t3) {
              const e3 = Math.PI / 180, r2 = this.lat * e3, n3 = t3.lat * e3, i3 = Math.sin(r2) * Math.sin(n3) + Math.cos(r2) * Math.cos(n3) * Math.cos((t3.lng - this.lng) * e3);
              return Ru * Math.acos(Math.min(i3, 1));
            }
            static convert(t3) {
              if (t3 instanceof qu)
                return t3;
              if (Array.isArray(t3) && (2 === t3.length || 3 === t3.length))
                return new qu(Number(t3[0]), Number(t3[1]));
              if (!Array.isArray(t3) && "object" == typeof t3 && null !== t3)
                return new qu(Number("lng" in t3 ? t3.lng : t3.lon), Number(t3.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          const ju = 2 * Math.PI * Ru;
          function Nu(t3) {
            return ju * Math.cos(t3 * Math.PI / 180);
          }
          function Zu(t3) {
            return (180 + t3) / 360;
          }
          function Ku(t3) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t3 * Math.PI / 360))) / 360;
          }
          function Gu(t3, e3) {
            return t3 / Nu(e3);
          }
          function Ju(t3) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t3) * Math.PI / 180)) - 90;
          }
          class Xu {
            constructor(t3, e3, r2 = 0) {
              this.x = +t3, this.y = +e3, this.z = +r2;
            }
            static fromLngLat(t3, e3 = 0) {
              const r2 = qu.convert(t3);
              return new Xu(Zu(r2.lng), Ku(r2.lat), Gu(e3, r2.lat));
            }
            toLngLat() {
              return new qu(360 * this.x - 180, Ju(this.y));
            }
            toAltitude() {
              return this.z * Nu(Ju(this.y));
            }
            meterInMercatorCoordinateUnits() {
              return 1 / ju * (t3 = Ju(this.y), 1 / Math.cos(t3 * Math.PI / 180));
              var t3;
            }
          }
          function Yu(t3, e3, r2) {
            var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t3 * n3 - 2 * Math.PI * 6378137 / 2, e3 * n3 - 2 * Math.PI * 6378137 / 2];
          }
          class Hu {
            constructor(t3, e3, r2) {
              if (t3 < 0 || t3 > 25 || r2 < 0 || r2 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3))
                throw new Error(`x=${e3}, y=${r2}, z=${t3} outside of bounds. 0<=x<${Math.pow(2, t3)}, 0<=y<${Math.pow(2, t3)} 0<=z<=25 `);
              this.z = t3, this.x = e3, this.y = r2, this.key = tc(0, t3, t3, e3, r2);
            }
            equals(t3) {
              return this.z === t3.z && this.x === t3.x && this.y === t3.y;
            }
            url(t3, e3, r2) {
              const n3 = (a3 = this.y, s2 = this.z, o2 = Yu(256 * (i3 = this.x), 256 * (a3 = Math.pow(2, s2) - a3 - 1), s2), l2 = Yu(256 * (i3 + 1), 256 * (a3 + 1), s2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
              var i3, a3, s2, o2, l2;
              const u2 = function(t4, e4, r3) {
                let n4, i4 = "";
                for (let a4 = t4; a4 > 0; a4--)
                  n4 = 1 << a4 - 1, i4 += (e4 & n4 ? 1 : 0) + (r3 & n4 ? 2 : 0);
                return i4;
              }(this.z, this.x, this.y);
              return t3[(this.x + this.y) % t3.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e3 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n3);
            }
            isChildOf(t3) {
              const e3 = this.z - t3.z;
              return e3 > 0 && t3.x === this.x >> e3 && t3.y === this.y >> e3;
            }
            getTilePoint(t3) {
              const e3 = Math.pow(2, this.z);
              return new i2((t3.x * e3 - this.x) * ja, (t3.y * e3 - this.y) * ja);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class Wu {
            constructor(t3, e3) {
              this.wrap = t3, this.canonical = e3, this.key = tc(t3, e3.z, e3.z, e3.x, e3.y);
            }
          }
          class Qu {
            constructor(t3, e3, r2, n3, i3) {
              if (t3 < r2)
                throw new Error(`overscaledZ should be >= z; overscaledZ = ${t3}; z = ${r2}`);
              this.overscaledZ = t3, this.wrap = e3, this.canonical = new Hu(r2, +n3, +i3), this.key = tc(e3, t3, r2, n3, i3);
            }
            clone() {
              return new Qu(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t3) {
              return this.overscaledZ === t3.overscaledZ && this.wrap === t3.wrap && this.canonical.equals(t3.canonical);
            }
            scaledTo(t3) {
              if (t3 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
              const e3 = this.canonical.z - t3;
              return t3 > this.canonical.z ? new Qu(t3, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Qu(t3, this.wrap, t3, this.canonical.x >> e3, this.canonical.y >> e3);
            }
            calculateScaledKey(t3, e3) {
              if (t3 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t3}; overscaledZ = ${this.overscaledZ}`);
              const r2 = this.canonical.z - t3;
              return t3 > this.canonical.z ? tc(this.wrap * +e3, t3, this.canonical.z, this.canonical.x, this.canonical.y) : tc(this.wrap * +e3, t3, t3, this.canonical.x >> r2, this.canonical.y >> r2);
            }
            isChildOf(t3) {
              if (t3.wrap !== this.wrap)
                return false;
              const e3 = this.canonical.z - t3.canonical.z;
              return 0 === t3.overscaledZ || t3.overscaledZ < this.overscaledZ && t3.canonical.x === this.canonical.x >> e3 && t3.canonical.y === this.canonical.y >> e3;
            }
            children(t3) {
              if (this.overscaledZ >= t3)
                return [new Qu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e3 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
              return [new Qu(e3, this.wrap, e3, r2, n3), new Qu(e3, this.wrap, e3, r2 + 1, n3), new Qu(e3, this.wrap, e3, r2, n3 + 1), new Qu(e3, this.wrap, e3, r2 + 1, n3 + 1)];
            }
            isLessThan(t3) {
              return this.wrap < t3.wrap || !(this.wrap > t3.wrap) && (this.overscaledZ < t3.overscaledZ || !(this.overscaledZ > t3.overscaledZ) && (this.canonical.x < t3.canonical.x || !(this.canonical.x > t3.canonical.x) && this.canonical.y < t3.canonical.y));
            }
            wrapped() {
              return new Qu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t3) {
              return new Qu(this.overscaledZ, t3, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new Wu(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t3) {
              return this.canonical.getTilePoint(new Xu(t3.x - this.wrap, t3.y));
            }
          }
          function tc(t3, e3, r2, n3, i3) {
            (t3 *= 2) < 0 && (t3 = -1 * t3 - 1);
            const a3 = 1 << r2;
            return (a3 * a3 * t3 + a3 * i3 + n3).toString(36) + r2.toString(36) + e3.toString(36);
          }
          In("CanonicalTileID", Hu), In("OverscaledTileID", Qu, { omit: ["posMatrix"] });
          class ec {
            constructor(t3, e3, r2) {
              if (this.uid = t3, e3.height !== e3.width)
                throw new RangeError("DEM tiles must be square");
              if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
                return void x(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e3.height;
              const n3 = this.dim = e3.height - 2;
              this.data = new Uint32Array(e3.data.buffer), this.encoding = r2 || "mapbox";
              for (let t4 = 0; t4 < n3; t4++)
                this.data[this._idx(-1, t4)] = this.data[this._idx(0, t4)], this.data[this._idx(n3, t4)] = this.data[this._idx(n3 - 1, t4)], this.data[this._idx(t4, -1)] = this.data[this._idx(t4, 0)], this.data[this._idx(t4, n3)] = this.data[this._idx(t4, n3 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n3, -1)] = this.data[this._idx(n3 - 1, 0)], this.data[this._idx(-1, n3)] = this.data[this._idx(0, n3 - 1)], this.data[this._idx(n3, n3)] = this.data[this._idx(n3 - 1, n3 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t4 = 0; t4 < n3; t4++)
                for (let e4 = 0; e4 < n3; e4++) {
                  const r3 = this.get(t4, e4);
                  r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
                }
            }
            get(t3, e3) {
              const r2 = new Uint8Array(this.data.buffer), n3 = 4 * this._idx(t3, e3);
              return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n3], r2[n3 + 1], r2[n3 + 2]);
            }
            getUnpackVector() {
              return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
            }
            _idx(t3, e3) {
              if (t3 < -1 || t3 >= this.dim + 1 || e3 < -1 || e3 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e3 + 1) * this.stride + (t3 + 1);
            }
            _unpackMapbox(t3, e3, r2) {
              return (256 * t3 * 256 + 256 * e3 + r2) / 10 - 1e4;
            }
            _unpackTerrarium(t3, e3, r2) {
              return 256 * t3 + e3 + r2 / 256 - 32768;
            }
            getPixels() {
              return new Ps({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t3, e3, r2) {
              if (this.dim !== t3.dim)
                throw new Error("dem dimension mismatch");
              let n3 = e3 * this.dim, i3 = e3 * this.dim + this.dim, a3 = r2 * this.dim, s2 = r2 * this.dim + this.dim;
              switch (e3) {
                case -1:
                  n3 = i3 - 1;
                  break;
                case 1:
                  i3 = n3 + 1;
              }
              switch (r2) {
                case -1:
                  a3 = s2 - 1;
                  break;
                case 1:
                  s2 = a3 + 1;
              }
              const o2 = -e3 * this.dim, l2 = -r2 * this.dim;
              for (let e4 = a3; e4 < s2; e4++)
                for (let r3 = n3; r3 < i3; r3++)
                  this.data[this._idx(r3, e4)] = t3.data[this._idx(r3 + o2, e4 + l2)];
            }
          }
          In("DEMData", ec);
          class rc {
            constructor(t3) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e3 = 0; e3 < t3.length; e3++) {
                const r2 = t3[e3];
                this._stringToNumber[r2] = e3, this._numberToString[e3] = r2;
              }
            }
            encode(t3) {
              return this._stringToNumber[t3];
            }
            decode(t3) {
              if (t3 >= this._numberToString.length)
                throw new Error(`Out of bounds. Index requested n=${t3} can't be >= this._numberToString.length ${this._numberToString.length}`);
              return this._numberToString[t3];
            }
          }
          class nc {
            constructor(t3, e3, r2, n3, i3) {
              this.type = "Feature", this._vectorTileFeature = t3, t3._z = e3, t3._x = r2, t3._y = n3, this.properties = t3.properties, this.id = i3;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t3) {
              this._geometry = t3;
            }
            toJSON() {
              const t3 = { geometry: this.geometry };
              for (const e3 in this)
                "_geometry" !== e3 && "_vectorTileFeature" !== e3 && (t3[e3] = this[e3]);
              return t3;
            }
          }
          class ic {
            constructor(t3, e3) {
              this.tileID = t3, this.x = t3.canonical.x, this.y = t3.canonical.y, this.z = t3.canonical.z, this.grid = new kn(ja, 16, 0), this.grid3D = new kn(ja, 16, 0), this.featureIndexArray = new Hi(), this.promoteId = e3;
            }
            insert(t3, e3, r2, n3, i3, a3) {
              const s2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n3, i3);
              const o2 = a3 ? this.grid3D : this.grid;
              for (let t4 = 0; t4 < e3.length; t4++) {
                const r3 = e3[t4], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t5 = 0; t5 < r3.length; t5++) {
                  const e4 = r3[t5];
                  n4[0] = Math.min(n4[0], e4.x), n4[1] = Math.min(n4[1], e4.y), n4[2] = Math.max(n4[2], e4.x), n4[3] = Math.max(n4[3], e4.y);
                }
                n4[0] < ja && n4[1] < ja && n4[2] >= 0 && n4[3] >= 0 && o2.insert(s2, n4[0], n4[1], n4[2], n4[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new Mo.VectorTile(new ql(this.rawTileData)).layers, this.sourceLayerCoder = new rc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t3, e3, r2, n3) {
              this.loadVTLayers();
              const a3 = t3.params || {}, s2 = ja / t3.tileSize / t3.scale, o2 = Fr(a3.filter), l2 = t3.queryGeometry, u2 = t3.queryPadding * s2, c5 = sc(l2), h2 = this.grid.query(c5.minX - u2, c5.minY - u2, c5.maxX + u2, c5.maxY + u2), p3 = sc(t3.cameraQueryGeometry), f2 = this.grid3D.query(p3.minX - u2, p3.minY - u2, p3.maxX + u2, p3.maxY + u2, (e4, r3, n4, a4) => function(t4, e5, r4, n5, a5) {
                for (const i3 of t4)
                  if (e5 <= i3.x && r4 <= i3.y && n5 >= i3.x && a5 >= i3.y)
                    return true;
                const s3 = [new i2(e5, r4), new i2(e5, a5), new i2(n5, a5), new i2(n5, r4)];
                if (t4.length > 2) {
                  for (const e6 of s3)
                    if (as(t4, e6))
                      return true;
                }
                for (let e6 = 0; e6 < t4.length - 1; e6++)
                  if (ss(t4[e6], t4[e6 + 1], s3))
                    return true;
                return false;
              }(t3.cameraQueryGeometry, e4 - u2, r3 - u2, n4 + u2, a4 + u2));
              for (const t4 of f2)
                h2.push(t4);
              h2.sort(oc);
              const d3 = {};
              let y2;
              for (let i3 = 0; i3 < h2.length; i3++) {
                const u3 = h2[i3];
                if (u3 === y2)
                  continue;
                y2 = u3;
                const c6 = this.featureIndexArray.get(u3);
                let p4 = null;
                this.loadMatchingFeature(d3, c6.bucketIndex, c6.sourceLayerIndex, c6.featureIndex, o2, a3.layers, a3.availableImages, e3, r2, n3, (e4, r3, n4) => (p4 || (p4 = Ka(e4)), r3.queryIntersectsFeature(l2, e4, n4, p4, this.z, t3.transform, s2, t3.pixelPosMatrix)));
              }
              return d3;
            }
            loadMatchingFeature(t3, e3, r2, n3, i3, a3, s2, o2, l2, u2, c5) {
              const h2 = this.bucketLayerIDs[e3];
              if (a3 && !function(t4, e4) {
                for (let r3 = 0; r3 < t4.length; r3++)
                  if (e4.indexOf(t4[r3]) >= 0)
                    return true;
                return false;
              }(a3, h2))
                return;
              const f2 = this.sourceLayerCoder.decode(r2), d3 = this.vtLayers[f2].feature(n3);
              if (i3.needGeometry) {
                const t4 = Ga(d3, true);
                if (!i3.filter(new Wn(this.tileID.overscaledZ), t4, this.tileID.canonical))
                  return;
              } else if (!i3.filter(new Wn(this.tileID.overscaledZ), d3))
                return;
              const y2 = this.getId(d3, f2);
              for (let e4 = 0; e4 < h2.length; e4++) {
                const r3 = h2[e4];
                if (a3 && a3.indexOf(r3) < 0)
                  continue;
                const i4 = o2[r3];
                if (!i4)
                  continue;
                let f3 = {};
                y2 && u2 && (f3 = u2.getState(i4.sourceLayer || "_geojsonTileLayer", y2));
                const m4 = p2({}, l2[r3]);
                m4.paint = ac(m4.paint, i4.paint, d3, f3, s2), m4.layout = ac(m4.layout, i4.layout, d3, f3, s2);
                const g3 = !c5 || c5(d3, i4, f3);
                if (!g3)
                  continue;
                const x2 = new nc(d3, this.z, this.x, this.y, y2);
                x2.layer = m4;
                let v2 = t3[r3];
                void 0 === v2 && (v2 = t3[r3] = []), v2.push({ featureIndex: n3, feature: x2, intersectionZ: g3 });
              }
            }
            lookupSymbolFeatures(t3, e3, r2, n3, i3, a3, s2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = Fr(i3);
              for (const i4 of t3)
                this.loadMatchingFeature(l2, r2, n3, i4, u2, a3, s2, o2, e3);
              return l2;
            }
            hasLayer(t3) {
              for (const e3 of this.bucketLayerIDs)
                for (const r2 of e3)
                  if (t3 === r2)
                    return true;
              return false;
            }
            getId(t3, e3) {
              let r2 = t3.id;
              return this.promoteId && (r2 = t3.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e3]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
            }
          }
          function ac(t3, e3, r2, n3, i3) {
            return d2(t3, (t4, a3) => {
              const s2 = e3 instanceof si ? e3.get(a3) : null;
              return s2 && s2.evaluate ? s2.evaluate(r2, n3, i3) : s2;
            });
          }
          function sc(t3) {
            let e3 = 1 / 0, r2 = 1 / 0, n3 = -1 / 0, i3 = -1 / 0;
            for (const a3 of t3)
              e3 = Math.min(e3, a3.x), r2 = Math.min(r2, a3.y), n3 = Math.max(n3, a3.x), i3 = Math.max(i3, a3.y);
            return { minX: e3, minY: r2, maxX: n3, maxY: i3 };
          }
          function oc(t3, e3) {
            return e3 - t3;
          }
          function lc(t3, e3, r2, n3, a3) {
            const s2 = [];
            for (let o2 = 0; o2 < t3.length; o2++) {
              const l2 = t3[o2];
              let u2;
              for (let t4 = 0; t4 < l2.length - 1; t4++) {
                let o3 = l2[t4], c5 = l2[t4 + 1];
                o3.x < e3 && c5.x < e3 || (o3.x < e3 ? o3 = new i2(e3, o3.y + (e3 - o3.x) / (c5.x - o3.x) * (c5.y - o3.y))._round() : c5.x < e3 && (c5 = new i2(e3, o3.y + (e3 - o3.x) / (c5.x - o3.x) * (c5.y - o3.y))._round()), o3.y < r2 && c5.y < r2 || (o3.y < r2 ? o3 = new i2(o3.x + (r2 - o3.y) / (c5.y - o3.y) * (c5.x - o3.x), r2)._round() : c5.y < r2 && (c5 = new i2(o3.x + (r2 - o3.y) / (c5.y - o3.y) * (c5.x - o3.x), r2)._round()), o3.x >= n3 && c5.x >= n3 || (o3.x >= n3 ? o3 = new i2(n3, o3.y + (n3 - o3.x) / (c5.x - o3.x) * (c5.y - o3.y))._round() : c5.x >= n3 && (c5 = new i2(n3, o3.y + (n3 - o3.x) / (c5.x - o3.x) * (c5.y - o3.y))._round()), o3.y >= a3 && c5.y >= a3 || (o3.y >= a3 ? o3 = new i2(o3.x + (a3 - o3.y) / (c5.y - o3.y) * (c5.x - o3.x), a3)._round() : c5.y >= a3 && (c5 = new i2(o3.x + (a3 - o3.y) / (c5.y - o3.y) * (c5.x - o3.x), a3)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], s2.push(u2)), u2.push(c5)))));
              }
            }
            return s2;
          }
          In("FeatureIndex", ic, { omit: ["rawTileData", "sourceLayerCoder"] });
          class uc extends i2 {
            constructor(t3, e3, r2, n3) {
              super(t3, e3), this.angle = r2, void 0 !== n3 && (this.segment = n3);
            }
            clone() {
              return new uc(this.x, this.y, this.angle, this.segment);
            }
          }
          function cc(t3, e3, r2, n3, i3) {
            if (void 0 === e3.segment || 0 === r2)
              return true;
            let a3 = e3, s2 = e3.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (s2--, s2 < 0)
                return false;
              o2 -= t3[s2].dist(a3), a3 = t3[s2];
            }
            o2 += t3[s2].dist(t3[s2 + 1]), s2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e4 = t3[s2], r3 = t3[s2 + 1];
              if (!r3)
                return false;
              let a4 = t3[s2 - 1].angleTo(e4) - e4.angleTo(r3);
              for (a4 = Math.abs((a4 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: a4 }), u2 += a4; o2 - l2[0].distance > n3; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i3)
                return false;
              s2++, o2 += e4.dist(r3);
            }
            return true;
          }
          function hc(t3) {
            let e3 = 0;
            for (let r2 = 0; r2 < t3.length - 1; r2++)
              e3 += t3[r2].dist(t3[r2 + 1]);
            return e3;
          }
          function pc(t3, e3, r2) {
            return t3 ? 0.6 * e3 * r2 : 0;
          }
          function fc(t3, e3) {
            return Math.max(t3 ? t3.right - t3.left : 0, e3 ? e3.right - e3.left : 0);
          }
          function dc(t3, e3, r2, n3, i3, a3) {
            const s2 = pc(r2, i3, a3), o2 = fc(r2, n3) * a3;
            let l2 = 0;
            const u2 = hc(t3) / 2;
            for (let r3 = 0; r3 < t3.length - 1; r3++) {
              const n4 = t3[r3], i4 = t3[r3 + 1], a4 = n4.dist(i4);
              if (l2 + a4 > u2) {
                const c5 = (u2 - l2) / a4, h2 = Te.number(n4.x, i4.x, c5), p3 = Te.number(n4.y, i4.y, c5), f2 = new uc(h2, p3, i4.angleTo(n4), r3);
                return f2._round(), !s2 || cc(t3, f2, o2, s2, e3) ? f2 : void 0;
              }
              l2 += a4;
            }
          }
          function yc(t3, e3, r2, n3, i3, a3, s2, o2, l2) {
            const u2 = pc(n3, a3, s2), c5 = fc(n3, i3), h2 = c5 * s2, p3 = 0 === t3[0].x || t3[0].x === l2 || 0 === t3[0].y || t3[0].y === l2;
            return e3 - h2 < e3 / 4 && (e3 = h2 + e3 / 4), mc(t3, p3 ? e3 / 2 * o2 % e3 : (c5 / 2 + 2 * a3) * s2 * o2 % e3, e3, u2, r2, h2, p3, false, l2);
          }
          function mc(t3, e3, r2, n3, i3, a3, s2, o2, l2) {
            const u2 = a3 / 2, c5 = hc(t3);
            let h2 = 0, p3 = e3 - r2, f2 = [];
            for (let e4 = 0; e4 < t3.length - 1; e4++) {
              const s3 = t3[e4], o3 = t3[e4 + 1], d3 = s3.dist(o3), y2 = o3.angleTo(s3);
              for (; p3 + r2 < h2 + d3; ) {
                p3 += r2;
                const m4 = (p3 - h2) / d3, g3 = Te.number(s3.x, o3.x, m4), x2 = Te.number(s3.y, o3.y, m4);
                if (g3 >= 0 && g3 < l2 && x2 >= 0 && x2 < l2 && p3 - u2 >= 0 && p3 + u2 <= c5) {
                  const r3 = new uc(g3, x2, y2, e4);
                  r3._round(), n3 && !cc(t3, r3, a3, n3, i3) || f2.push(r3);
                }
              }
              h2 += d3;
            }
            return o2 || f2.length || s2 || (f2 = mc(t3, h2 / 2, r2, n3, i3, a3, s2, true, l2)), f2;
          }
          In("Anchor", uc);
          const gc2 = Xl;
          function xc(t3, e3, r2, n3) {
            const a3 = [], s2 = t3.image, o2 = s2.pixelRatio, l2 = s2.paddedRect.w - 2 * gc2, u2 = s2.paddedRect.h - 2 * gc2, c5 = t3.right - t3.left, h2 = t3.bottom - t3.top, p3 = s2.stretchX || [[0, l2]], f2 = s2.stretchY || [[0, u2]], d3 = (t4, e4) => t4 + e4[1] - e4[0], y2 = p3.reduce(d3, 0), m4 = f2.reduce(d3, 0), g3 = l2 - y2, x2 = u2 - m4;
            let v2 = 0, b3 = y2, w2 = 0, _2 = m4, A2 = 0, k2 = g3, S2 = 0, I2 = x2;
            if (s2.content && n3) {
              const t4 = s2.content;
              v2 = vc(p3, 0, t4[0]), w2 = vc(f2, 0, t4[1]), b3 = vc(p3, t4[0], t4[2]), _2 = vc(f2, t4[1], t4[3]), A2 = t4[0] - v2, S2 = t4[1] - w2, k2 = t4[2] - t4[0] - b3, I2 = t4[3] - t4[1] - _2;
            }
            const z2 = (n4, a4, l3, u3) => {
              const p4 = wc(n4.stretch - v2, b3, c5, t3.left), f3 = _c(n4.fixed - A2, k2, n4.stretch, y2), d4 = wc(a4.stretch - w2, _2, h2, t3.top), g4 = _c(a4.fixed - S2, I2, a4.stretch, m4), x3 = wc(l3.stretch - v2, b3, c5, t3.left), z3 = _c(l3.fixed - A2, k2, l3.stretch, y2), M2 = wc(u3.stretch - w2, _2, h2, t3.top), P2 = _c(u3.fixed - S2, I2, u3.stretch, m4), B2 = new i2(p4, d4), C3 = new i2(x3, d4), V2 = new i2(x3, M2), E2 = new i2(p4, M2), F2 = new i2(f3 / o2, g4 / o2), T2 = new i2(z3 / o2, P2 / o2), L2 = e3 * Math.PI / 180;
              if (L2) {
                const t4 = Math.sin(L2), e4 = Math.cos(L2), r3 = [e4, -t4, t4, e4];
                B2._matMult(r3), C3._matMult(r3), E2._matMult(r3), V2._matMult(r3);
              }
              const $12 = n4.stretch + n4.fixed, D2 = a4.stretch + a4.fixed;
              return { tl: B2, tr: C3, bl: E2, br: V2, tex: { x: s2.paddedRect.x + gc2 + $12, y: s2.paddedRect.y + gc2 + D2, w: l3.stretch + l3.fixed - $12, h: u3.stretch + u3.fixed - D2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: k2 / o2 / c5, minFontScaleY: I2 / o2 / h2, isSDF: r2 };
            };
            if (n3 && (s2.stretchX || s2.stretchY)) {
              const t4 = bc(p3, g3, y2), e4 = bc(f2, x2, m4);
              for (let r3 = 0; r3 < t4.length - 1; r3++) {
                const n4 = t4[r3], i3 = t4[r3 + 1];
                for (let t5 = 0; t5 < e4.length - 1; t5++)
                  a3.push(z2(n4, e4[t5], i3, e4[t5 + 1]));
              }
            } else
              a3.push(z2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
            return a3;
          }
          function vc(t3, e3, r2) {
            let n3 = 0;
            for (const i3 of t3)
              n3 += Math.max(e3, Math.min(r2, i3[1])) - Math.max(e3, Math.min(r2, i3[0]));
            return n3;
          }
          function bc(t3, e3, r2) {
            const n3 = [{ fixed: -gc2, stretch: 0 }];
            for (const [e4, r3] of t3) {
              const t4 = n3[n3.length - 1];
              n3.push({ fixed: e4 - t4.stretch, stretch: t4.stretch }), n3.push({ fixed: e4 - t4.stretch, stretch: t4.stretch + (r3 - e4) });
            }
            return n3.push({ fixed: e3 + gc2, stretch: r2 }), n3;
          }
          function wc(t3, e3, r2, n3) {
            return t3 / e3 * r2 + n3;
          }
          function _c(t3, e3, r2, n3) {
            return t3 - e3 * r2 / n3;
          }
          class Ac {
            constructor(t3, e3, r2, n3, a3, s2, o2, l2, u2, c5) {
              if (this.boxStartIndex = t3.length, u2) {
                let t4 = s2.top, e4 = s2.bottom;
                const r3 = s2.collisionPadding;
                r3 && (t4 -= r3[1], e4 += r3[3]);
                let n4 = e4 - t4;
                n4 > 0 && (n4 = Math.max(10, n4), this.circleDiameter = n4);
              } else {
                let u3 = s2.top * o2 - l2[0], h2 = s2.bottom * o2 + l2[2], p3 = s2.left * o2 - l2[3], f2 = s2.right * o2 + l2[1];
                const d3 = s2.collisionPadding;
                if (d3 && (p3 -= d3[0] * o2, u3 -= d3[1] * o2, f2 += d3[2] * o2, h2 += d3[3] * o2), c5) {
                  const t4 = new i2(p3, u3), e4 = new i2(f2, u3), r3 = new i2(p3, h2), n4 = new i2(f2, h2), a4 = c5 * Math.PI / 180;
                  t4._rotate(a4), e4._rotate(a4), r3._rotate(a4), n4._rotate(a4), p3 = Math.min(t4.x, e4.x, r3.x, n4.x), f2 = Math.max(t4.x, e4.x, r3.x, n4.x), u3 = Math.min(t4.y, e4.y, r3.y, n4.y), h2 = Math.max(t4.y, e4.y, r3.y, n4.y);
                }
                t3.emplaceBack(e3.x, e3.y, p3, u3, f2, h2, r2, n3, a3);
              }
              this.boxEndIndex = t3.length;
            }
          }
          class kc {
            constructor(t3 = [], e3 = Sc) {
              if (this.data = t3, this.length = this.data.length, this.compare = e3, this.length > 0)
                for (let t4 = (this.length >> 1) - 1; t4 >= 0; t4--)
                  this._down(t4);
            }
            push(t3) {
              this.data.push(t3), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (0 === this.length)
                return;
              const t3 = this.data[0], e3 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t3;
            }
            peek() {
              return this.data[0];
            }
            _up(t3) {
              const { data: e3, compare: r2 } = this, n3 = e3[t3];
              for (; t3 > 0; ) {
                const i3 = t3 - 1 >> 1, a3 = e3[i3];
                if (r2(n3, a3) >= 0)
                  break;
                e3[t3] = a3, t3 = i3;
              }
              e3[t3] = n3;
            }
            _down(t3) {
              const { data: e3, compare: r2 } = this, n3 = this.length >> 1, i3 = e3[t3];
              for (; t3 < n3; ) {
                let n4 = 1 + (t3 << 1), a3 = e3[n4];
                const s2 = n4 + 1;
                if (s2 < this.length && r2(e3[s2], a3) < 0 && (n4 = s2, a3 = e3[s2]), r2(a3, i3) >= 0)
                  break;
                e3[t3] = a3, t3 = n4;
              }
              e3[t3] = i3;
            }
          }
          function Sc(t3, e3) {
            return t3 < e3 ? -1 : t3 > e3 ? 1 : 0;
          }
          function Ic(t3, e3 = 1, r2 = false) {
            let n3 = 1 / 0, a3 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
            const l2 = t3[0];
            for (let t4 = 0; t4 < l2.length; t4++) {
              const e4 = l2[t4];
              (!t4 || e4.x < n3) && (n3 = e4.x), (!t4 || e4.y < a3) && (a3 = e4.y), (!t4 || e4.x > s2) && (s2 = e4.x), (!t4 || e4.y > o2) && (o2 = e4.y);
            }
            const u2 = Math.min(s2 - n3, o2 - a3);
            let c5 = u2 / 2;
            const h2 = new kc([], zc);
            if (0 === u2)
              return new i2(n3, a3);
            for (let e4 = n3; e4 < s2; e4 += u2)
              for (let r3 = a3; r3 < o2; r3 += u2)
                h2.push(new Mc(e4 + c5, r3 + c5, c5, t3));
            let p3 = function(t4) {
              let e4 = 0, r3 = 0, n4 = 0;
              const i3 = t4[0];
              for (let t5 = 0, a4 = i3.length, s3 = a4 - 1; t5 < a4; s3 = t5++) {
                const a5 = i3[t5], o3 = i3[s3], l3 = a5.x * o3.y - o3.x * a5.y;
                r3 += (a5.x + o3.x) * l3, n4 += (a5.y + o3.y) * l3, e4 += 3 * l3;
              }
              return new Mc(r3 / e4, n4 / e4, 0, t4);
            }(t3), f2 = h2.length;
            for (; h2.length; ) {
              const n4 = h2.pop();
              (n4.d > p3.d || !p3.d) && (p3 = n4, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f2)), n4.max - p3.d <= e3 || (c5 = n4.h / 2, h2.push(new Mc(n4.p.x - c5, n4.p.y - c5, c5, t3)), h2.push(new Mc(n4.p.x + c5, n4.p.y - c5, c5, t3)), h2.push(new Mc(n4.p.x - c5, n4.p.y + c5, c5, t3)), h2.push(new Mc(n4.p.x + c5, n4.p.y + c5, c5, t3)), f2 += 4);
            }
            return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p3.d}`)), p3.p;
          }
          function zc(t3, e3) {
            return e3.max - t3.max;
          }
          function Mc(t3, e3, r2, n3) {
            this.p = new i2(t3, e3), this.h = r2, this.d = function(t4, e4) {
              let r3 = false, n4 = 1 / 0;
              for (let i3 = 0; i3 < e4.length; i3++) {
                const a3 = e4[i3];
                for (let e5 = 0, i4 = a3.length, s2 = i4 - 1; e5 < i4; s2 = e5++) {
                  const i5 = a3[e5], o2 = a3[s2];
                  i5.y > t4.y != o2.y > t4.y && t4.x < (o2.x - i5.x) * (t4.y - i5.y) / (o2.y - i5.y) + i5.x && (r3 = !r3), n4 = Math.min(n4, ns(t4, i5, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
          const Pc = Number.POSITIVE_INFINITY;
          function Bc(t3, e3) {
            return e3[1] !== Pc ? function(t4, e4, r2) {
              let n3 = 0, i3 = 0;
              switch (e4 = Math.abs(e4), r2 = Math.abs(r2), t4) {
                case "top-right":
                case "top-left":
                case "top":
                  i3 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i3 = 7 - r2;
              }
              switch (t4) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n3 = -e4;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n3 = e4;
              }
              return [n3, i3];
            }(t3, e3[0], e3[1]) : function(t4, e4) {
              let r2 = 0, n3 = 0;
              e4 < 0 && (e4 = 0);
              const i3 = e4 / Math.sqrt(2);
              switch (t4) {
                case "top-right":
                case "top-left":
                  n3 = i3 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n3 = 7 - i3;
                  break;
                case "bottom":
                  n3 = 7 - e4;
                  break;
                case "top":
                  n3 = e4 - 7;
              }
              switch (t4) {
                case "top-right":
                case "bottom-right":
                  r2 = -i3;
                  break;
                case "top-left":
                case "bottom-left":
                  r2 = i3;
                  break;
                case "left":
                  r2 = e4;
                  break;
                case "right":
                  r2 = -e4;
              }
              return [r2, n3];
            }(t3, e3[0]);
          }
          function Cc(t3) {
            switch (t3) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Vc(e3, r2, n3, i3, a3, s2, o2, l2, u2, c5, h2) {
            let p3 = s2.textMaxSize.evaluate(r2, {});
            void 0 === p3 && (p3 = o2);
            const f2 = e3.layers[0].layout, d3 = f2.get("icon-offset").evaluate(r2, {}, h2), y2 = Fc(n3.horizontal), m4 = o2 / 24, g3 = e3.tilePixelRatio * m4, v2 = e3.tilePixelRatio * p3 / 24, b3 = e3.tilePixelRatio * l2, w2 = e3.tilePixelRatio * f2.get("symbol-spacing"), _2 = f2.get("text-padding") * e3.tilePixelRatio, A2 = function(t3, e4, r3, n4 = 1) {
              const i4 = t3.get("icon-padding").evaluate(e4, {}, r3), a4 = i4 && i4.values;
              return [a4[0] * n4, a4[1] * n4, a4[2] * n4, a4[3] * n4];
            }(f2, r2, h2, e3.tilePixelRatio), k2 = f2.get("text-max-angle") / 180 * Math.PI, S2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), z2 = f2.get("symbol-placement"), M2 = w2 / 2, P2 = f2.get("icon-text-fit");
            let B2;
            i3 && "none" !== P2 && (e3.allowVerticalPlacement && n3.vertical && (B2 = du(i3, n3.vertical, P2, f2.get("icon-text-fit-padding"), d3, m4)), y2 && (i3 = du(i3, y2, P2, f2.get("icon-text-fit-padding"), d3, m4)));
            const C3 = (l3, p4) => {
              p4.x < 0 || p4.x >= ja || p4.y < 0 || p4.y >= ja || function(e4, r3, n4, i4, a4, s3, o3, l4, u3, c6, h3, p5, f3, d4, y3, m5, g4, v3, b4, w3, _3, A3, k3, S3, I3) {
                const z3 = e4.addToLineVertexArray(r3, n4);
                let M3, P4, B3, C4, V2 = 0, E2 = 0, F2 = 0, T2 = 0, L2 = -1, $12 = -1;
                const D2 = {};
                let O2 = Aa(""), U2 = 0, R2 = 0;
                if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [U2, R2] = l4.layout.get("text-offset").evaluate(_3, {}, S3).map((t3) => t3 * vl) : (U2 = l4.layout.get("text-radial-offset").evaluate(_3, {}, S3) * vl, R2 = Pc), e4.allowVerticalPlacement && i4.vertical) {
                  const t3 = l4.layout.get("text-rotate").evaluate(_3, {}, S3) + 90;
                  B3 = new Ac(u3, r3, c6, h3, p5, i4.vertical, f3, d4, y3, t3), o3 && (C4 = new Ac(u3, r3, c6, h3, p5, o3, g4, v3, y3, t3));
                }
                if (a4) {
                  const n5 = l4.layout.get("icon-rotate").evaluate(_3, {}), i5 = "none" !== l4.layout.get("icon-text-fit"), s4 = xc(a4, n5, k3, i5), f4 = o3 ? xc(o3, n5, k3, i5) : void 0;
                  P4 = new Ac(u3, r3, c6, h3, p5, a4, g4, v3, false, n5), V2 = 4 * s4.length;
                  const d5 = e4.iconSizeData;
                  let y4 = null;
                  "source" === d5.kind ? (y4 = [mu * l4.layout.get("icon-size").evaluate(_3, {})], y4[0] > gu && x(`${e4.layerIds[0]}: Value for "icon-size" is >= ${yu}. Reduce your "icon-size".`)) : "composite" === d5.kind && (y4 = [mu * A3.compositeIconSizes[0].evaluate(_3, {}, S3), mu * A3.compositeIconSizes[1].evaluate(_3, {}, S3)], (y4[0] > gu || y4[1] > gu) && x(`${e4.layerIds[0]}: Value for "icon-size" is >= ${yu}. Reduce your "icon-size".`)), e4.addSymbols(e4.icon, s4, y4, w3, b4, _3, t2.WritingMode.none, r3, z3.lineStartIndex, z3.lineLength, -1, S3), L2 = e4.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e4.addSymbols(e4.icon, f4, y4, w3, b4, _3, t2.WritingMode.vertical, r3, z3.lineStartIndex, z3.lineLength, -1, S3), $12 = e4.icon.placedSymbolArray.length - 1);
                }
                const q2 = Object.keys(i4.horizontal);
                for (const n5 of q2) {
                  const a5 = i4.horizontal[n5];
                  if (!M3) {
                    O2 = Aa(a5.text);
                    const t3 = l4.layout.get("text-rotate").evaluate(_3, {}, S3);
                    M3 = new Ac(u3, r3, c6, h3, p5, a5, f3, d4, y3, t3);
                  }
                  const o4 = 1 === a5.positionedLines.length;
                  if (F2 += Ec(e4, r3, a5, s3, l4, y3, _3, m5, z3, i4.vertical ? t2.WritingMode.horizontal : t2.WritingMode.horizontalOnly, o4 ? q2 : [n5], D2, L2, A3, S3), o4)
                    break;
                }
                i4.vertical && (T2 += Ec(e4, r3, i4.vertical, s3, l4, y3, _3, m5, z3, t2.WritingMode.vertical, ["vertical"], D2, $12, A3, S3));
                const j2 = M3 ? M3.boxStartIndex : e4.collisionBoxArray.length, N2 = M3 ? M3.boxEndIndex : e4.collisionBoxArray.length, Z2 = B3 ? B3.boxStartIndex : e4.collisionBoxArray.length, K2 = B3 ? B3.boxEndIndex : e4.collisionBoxArray.length, G2 = P4 ? P4.boxStartIndex : e4.collisionBoxArray.length, J2 = P4 ? P4.boxEndIndex : e4.collisionBoxArray.length, X2 = C4 ? C4.boxStartIndex : e4.collisionBoxArray.length, Y2 = C4 ? C4.boxEndIndex : e4.collisionBoxArray.length;
                let H2 = -1;
                const W2 = (t3, e5) => t3 && t3.circleDiameter ? Math.max(t3.circleDiameter, e5) : e5;
                H2 = W2(M3, H2), H2 = W2(B3, H2), H2 = W2(P4, H2), H2 = W2(C4, H2);
                const Q2 = H2 > -1 ? 1 : 0;
                Q2 && (H2 *= I3 / vl), e4.glyphOffsetArray.length >= zu.MAX_GLYPHS && x("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== _3.sortKey && e4.addToSortKeyRanges(e4.symbolInstances.length, _3.sortKey), e4.symbolInstances.emplaceBack(r3.x, r3.y, D2.right >= 0 ? D2.right : -1, D2.center >= 0 ? D2.center : -1, D2.left >= 0 ? D2.left : -1, D2.vertical || -1, L2, $12, O2, j2, N2, Z2, K2, G2, J2, X2, Y2, c6, F2, T2, V2, E2, Q2, 0, f3, U2, R2, H2);
              }(e3, p4, l3, n3, i3, a3, B2, e3.layers[0], e3.collisionBoxArray, r2.index, r2.sourceLayerIndex, e3.index, g3, [_2, _2, _2, _2], S2, u2, b3, A2, I2, d3, r2, s2, c5, h2, o2);
            };
            if ("line" === z2)
              for (const t3 of lc(r2.geometry, 0, 0, ja, ja)) {
                const r3 = yc(t3, w2, k2, n3.vertical || y2, i3, 24, v2, e3.overscaling, ja);
                for (const n4 of r3)
                  y2 && Tc(e3, y2.text, M2, n4) || C3(t3, n4);
              }
            else if ("line-center" === z2) {
              for (const t3 of r2.geometry)
                if (t3.length > 1) {
                  const e4 = dc(t3, k2, n3.vertical || y2, i3, 24, v2);
                  e4 && C3(t3, e4);
                }
            } else if ("Polygon" === r2.type)
              for (const t3 of mo(r2.geometry, 0)) {
                const e4 = Ic(t3, 16);
                C3(t3[0], new uc(e4.x, e4.y, 0));
              }
            else if ("LineString" === r2.type)
              for (const t3 of r2.geometry)
                C3(t3, new uc(t3[0].x, t3[0].y, 0));
            else if ("Point" === r2.type)
              for (const t3 of r2.geometry)
                for (const e4 of t3)
                  C3([e4], new uc(e4.x, e4.y, 0));
          }
          function Ec(t3, e3, r2, n3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2) {
            const m4 = function(t4, e4, r3, n4, a4, s3, o3, l3) {
              const u3 = n4.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c6 = [];
              for (const t5 of e4.positionedLines)
                for (const n5 of t5.positionedGlyphs) {
                  if (!n5.rect)
                    continue;
                  const s4 = n5.rect || {};
                  let h3 = Gl + 1, p4 = true, f3 = 1, d4 = 0;
                  const y3 = (a4 || l3) && n5.vertical, m5 = n5.metrics.advance * n5.scale / 2;
                  if (l3 && e4.verticalizable && (d4 = t5.lineOffset / 2 - (n5.imageName ? -(vl - n5.metrics.width * n5.scale) / 2 : (n5.scale - 1) * vl)), n5.imageName) {
                    const t6 = o3[n5.imageName];
                    p4 = t6.sdf, f3 = t6.pixelRatio, h3 = Xl / f3;
                  }
                  const g4 = a4 ? [n5.x + m5, n5.y] : [0, 0];
                  let x2 = a4 ? [0, 0] : [n5.x + m5 + r3[0], n5.y + r3[1] - d4], v3 = [0, 0];
                  y3 && (v3 = x2, x2 = [0, 0]);
                  const b3 = (n5.metrics.left - h3) * n5.scale - m5 + x2[0], w2 = (-n5.metrics.top - h3) * n5.scale + x2[1], _2 = b3 + s4.w * n5.scale / f3, A2 = w2 + s4.h * n5.scale / f3, k2 = new i2(b3, w2), S2 = new i2(_2, w2), I2 = new i2(b3, A2), z2 = new i2(_2, A2);
                  if (y3) {
                    const t6 = new i2(-m5, m5 - Ql), e5 = -Math.PI / 2, r4 = vl / 2 - m5, a5 = new i2(5 - Ql - r4, -(n5.imageName ? r4 : 0)), s5 = new i2(...v3);
                    k2._rotateAround(e5, t6)._add(a5)._add(s5), S2._rotateAround(e5, t6)._add(a5)._add(s5), I2._rotateAround(e5, t6)._add(a5)._add(s5), z2._rotateAround(e5, t6)._add(a5)._add(s5);
                  }
                  if (u3) {
                    const t6 = Math.sin(u3), e5 = Math.cos(u3), r4 = [e5, -t6, t6, e5];
                    k2._matMult(r4), S2._matMult(r4), I2._matMult(r4), z2._matMult(r4);
                  }
                  const M2 = new i2(0, 0), P2 = new i2(0, 0);
                  c6.push({ tl: k2, tr: S2, bl: I2, br: z2, tex: s4, writingMode: e4.writingMode, glyphOffset: g4, sectionIndex: n5.sectionIndex, isSDF: p4, pixelOffsetTL: M2, pixelOffsetBR: P2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              return c6;
            }(0, r2, l2, a3, s2, o2, n3, t3.allowVerticalPlacement), g3 = t3.textSizeData;
            let v2 = null;
            "source" === g3.kind ? (v2 = [mu * a3.layout.get("text-size").evaluate(o2, {})], v2[0] > gu && x(`${t3.layerIds[0]}: Value for "text-size" is >= ${yu}. Reduce your "text-size".`)) : "composite" === g3.kind && (v2 = [mu * d3.compositeTextSizes[0].evaluate(o2, {}, y2), mu * d3.compositeTextSizes[1].evaluate(o2, {}, y2)], (v2[0] > gu || v2[1] > gu) && x(`${t3.layerIds[0]}: Value for "text-size" is >= ${yu}. Reduce your "text-size".`)), t3.addSymbols(t3.text, m4, v2, l2, s2, o2, c5, e3, u2.lineStartIndex, u2.lineLength, f2, y2);
            for (const e4 of h2)
              p3[e4] = t3.text.placedSymbolArray.length - 1;
            return 4 * m4.length;
          }
          function Fc(t3) {
            for (const e3 in t3)
              return t3[e3];
            return null;
          }
          function Tc(t3, e3, r2, n3) {
            const i3 = t3.compareText;
            if (e3 in i3) {
              const t4 = i3[e3];
              for (let e4 = t4.length - 1; e4 >= 0; e4--)
                if (n3.dist(t4[e4]) < r2)
                  return true;
            } else
              i3[e3] = [];
            return i3[e3].push(n3), false;
          }
          const Lc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class $c {
            static from(t3) {
              if (!(t3 instanceof ArrayBuffer))
                throw new Error("Data must be an instance of ArrayBuffer.");
              const [e3, r2] = new Uint8Array(t3, 0, 2);
              if (219 !== e3)
                throw new Error("Data does not appear to be in a KDBush format.");
              const n3 = r2 >> 4;
              if (1 !== n3)
                throw new Error(`Got v${n3} data when expected v1.`);
              const i3 = Lc[15 & r2];
              if (!i3)
                throw new Error("Unrecognized array type.");
              const [a3] = new Uint16Array(t3, 2, 1), [s2] = new Uint32Array(t3, 4, 1);
              return new $c(s2, a3, i3, t3);
            }
            constructor(t3, e3 = 64, r2 = Float64Array, n3) {
              if (isNaN(t3) || t3 < 0)
                throw new Error(`Unpexpected numItems value: ${t3}.`);
              this.numItems = +t3, this.nodeSize = Math.min(Math.max(+e3, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t3 < 65536 ? Uint16Array : Uint32Array;
              const i3 = Lc.indexOf(this.ArrayType), a3 = 2 * t3 * this.ArrayType.BYTES_PER_ELEMENT, s2 = t3 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - s2 % 8) % 8;
              if (i3 < 0)
                throw new Error(`Unexpected typed array class: ${r2}.`);
              n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s2 + o2, 2 * t3), this._pos = 2 * t3, this._finished = true) : (this.data = new ArrayBuffer(8 + a3 + s2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t3), this.coords = new this.ArrayType(this.data, 8 + s2 + o2, 2 * t3), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i3]), new Uint16Array(this.data, 2, 1)[0] = e3, new Uint32Array(this.data, 4, 1)[0] = t3);
            }
            add(t3, e3) {
              const r2 = this._pos >> 1;
              return this.ids[r2] = r2, this.coords[this._pos++] = t3, this.coords[this._pos++] = e3, r2;
            }
            finish() {
              const t3 = this._pos >> 1;
              if (t3 !== this.numItems)
                throw new Error(`Added ${t3} items when expected ${this.numItems}.`);
              return Dc(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t3, e3, r2, n3) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i3, coords: a3, nodeSize: s2 } = this, o2 = [0, i3.length - 1, 0], l2 = [];
              for (; o2.length; ) {
                const u2 = o2.pop() || 0, c5 = o2.pop() || 0, h2 = o2.pop() || 0;
                if (c5 - h2 <= s2) {
                  for (let s3 = h2; s3 <= c5; s3++) {
                    const o3 = a3[2 * s3], u3 = a3[2 * s3 + 1];
                    o3 >= t3 && o3 <= r2 && u3 >= e3 && u3 <= n3 && l2.push(i3[s3]);
                  }
                  continue;
                }
                const p3 = h2 + c5 >> 1, f2 = a3[2 * p3], d3 = a3[2 * p3 + 1];
                f2 >= t3 && f2 <= r2 && d3 >= e3 && d3 <= n3 && l2.push(i3[p3]), (0 === u2 ? t3 <= f2 : e3 <= d3) && (o2.push(h2), o2.push(p3 - 1), o2.push(1 - u2)), (0 === u2 ? r2 >= f2 : n3 >= d3) && (o2.push(p3 + 1), o2.push(c5), o2.push(1 - u2));
              }
              return l2;
            }
            within(t3, e3, r2) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n3, coords: i3, nodeSize: a3 } = this, s2 = [0, n3.length - 1, 0], o2 = [], l2 = r2 * r2;
              for (; s2.length; ) {
                const u2 = s2.pop() || 0, c5 = s2.pop() || 0, h2 = s2.pop() || 0;
                if (c5 - h2 <= a3) {
                  for (let r3 = h2; r3 <= c5; r3++)
                    qc(i3[2 * r3], i3[2 * r3 + 1], t3, e3) <= l2 && o2.push(n3[r3]);
                  continue;
                }
                const p3 = h2 + c5 >> 1, f2 = i3[2 * p3], d3 = i3[2 * p3 + 1];
                qc(f2, d3, t3, e3) <= l2 && o2.push(n3[p3]), (0 === u2 ? t3 - r2 <= f2 : e3 - r2 <= d3) && (s2.push(h2), s2.push(p3 - 1), s2.push(1 - u2)), (0 === u2 ? t3 + r2 >= f2 : e3 + r2 >= d3) && (s2.push(p3 + 1), s2.push(c5), s2.push(1 - u2));
              }
              return o2;
            }
          }
          function Dc(t3, e3, r2, n3, i3, a3) {
            if (i3 - n3 <= r2)
              return;
            const s2 = n3 + i3 >> 1;
            Oc(t3, e3, s2, n3, i3, a3), Dc(t3, e3, r2, n3, s2 - 1, 1 - a3), Dc(t3, e3, r2, s2 + 1, i3, 1 - a3);
          }
          function Oc(t3, e3, r2, n3, i3, a3) {
            for (; i3 > n3; ) {
              if (i3 - n3 > 600) {
                const s3 = i3 - n3 + 1, o3 = r2 - n3 + 1, l3 = Math.log(s3), u2 = 0.5 * Math.exp(2 * l3 / 3), c5 = 0.5 * Math.sqrt(l3 * u2 * (s3 - u2) / s3) * (o3 - s3 / 2 < 0 ? -1 : 1);
                Oc(t3, e3, r2, Math.max(n3, Math.floor(r2 - o3 * u2 / s3 + c5)), Math.min(i3, Math.floor(r2 + (s3 - o3) * u2 / s3 + c5)), a3);
              }
              const s2 = e3[2 * r2 + a3];
              let o2 = n3, l2 = i3;
              for (Uc(t3, e3, n3, r2), e3[2 * i3 + a3] > s2 && Uc(t3, e3, n3, i3); o2 < l2; ) {
                for (Uc(t3, e3, o2, l2), o2++, l2--; e3[2 * o2 + a3] < s2; )
                  o2++;
                for (; e3[2 * l2 + a3] > s2; )
                  l2--;
              }
              e3[2 * n3 + a3] === s2 ? Uc(t3, e3, n3, l2) : (l2++, Uc(t3, e3, l2, i3)), l2 <= r2 && (n3 = l2 + 1), r2 <= l2 && (i3 = l2 - 1);
            }
          }
          function Uc(t3, e3, r2, n3) {
            Rc(t3, r2, n3), Rc(e3, 2 * r2, 2 * n3), Rc(e3, 2 * r2 + 1, 2 * n3 + 1);
          }
          function Rc(t3, e3, r2) {
            const n3 = t3[e3];
            t3[e3] = t3[r2], t3[r2] = n3;
          }
          function qc(t3, e3, r2, n3) {
            const i3 = t3 - r2, a3 = e3 - n3;
            return i3 * i3 + a3 * a3;
          }
          var jc;
          t2.PerformanceMarkers = void 0, (jc = t2.PerformanceMarkers || (t2.PerformanceMarkers = {})).create = "create", jc.load = "load", jc.fullLoad = "fullLoad";
          let Nc = null, Zc = [];
          const Kc = 1e3 / 60, Gc = "loadTime", Jc = "fullLoadTime", Xc = { mark(t3) {
            performance.mark(t3);
          }, frame(t3) {
            const e3 = t3;
            null != Nc && Zc.push(e3 - Nc), Nc = e3;
          }, clearMetrics() {
            Nc = null, Zc = [], performance.clearMeasures(Gc), performance.clearMeasures(Jc);
            for (const e3 in t2.PerformanceMarkers)
              performance.clearMarks(t2.PerformanceMarkers[e3]);
          }, getPerformanceMetrics() {
            performance.measure(Gc, t2.PerformanceMarkers.create, t2.PerformanceMarkers.load), performance.measure(Jc, t2.PerformanceMarkers.create, t2.PerformanceMarkers.fullLoad);
            const e3 = performance.getEntriesByName(Gc)[0].duration, r2 = performance.getEntriesByName(Jc)[0].duration, n3 = Zc.length, i3 = 1 / (Zc.reduce((t3, e4) => t3 + e4, 0) / n3 / 1e3), a3 = Zc.filter((t3) => t3 > Kc).reduce((t3, e4) => t3 + (e4 - Kc) / Kc, 0);
            return { loadTime: e3, fullLoadTime: r2, fps: i3, percentDroppedFrames: a3 / (n3 + a3) * 100, totalFrames: n3 };
          } };
          t2.AJAXError = B, t2.ARRAY_TYPE = ds, t2.Actor = class {
            constructor(t3, e3, r2) {
              this.receive = (t4) => {
                const e4 = t4.data, r3 = e4.id;
                if (r3 && (!e4.targetMapId || this.mapId === e4.targetMapId))
                  if ("<cancel>" === e4.type) {
                    delete this.tasks[r3];
                    const t5 = this.cancelCallbacks[r3];
                    delete this.cancelCallbacks[r3], t5 && t5();
                  } else
                    w() || e4.mustQueue ? (this.tasks[r3] = e4, this.taskQueue.push(r3), this.invoker.trigger()) : this.processTask(r3, e4);
              }, this.process = () => {
                if (!this.taskQueue.length)
                  return;
                const t4 = this.taskQueue.shift(), e4 = this.tasks[t4];
                delete this.tasks[t4], this.taskQueue.length && this.invoker.trigger(), e4 && this.processTask(t4, e4);
              }, this.target = t3, this.parent = e3, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Uu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = w() ? t3 : window;
            }
            send(t3, e3, r2, n3, i3 = false) {
              const a3 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (this.callbacks[a3] = r2);
              const s2 = A(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: a3, type: t3, hasCallback: !!r2, targetMapId: n3, mustQueue: i3, sourceMapId: this.mapId, data: Mn(e3, s2) }, s2), { cancel: () => {
                r2 && delete this.callbacks[a3], this.target.postMessage({ id: a3, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
              } };
            }
            processTask(t3, e3) {
              if ("<response>" === e3.type) {
                const r2 = this.callbacks[t3];
                delete this.callbacks[t3], r2 && (e3.error ? r2(Pn(e3.error)) : r2(null, Pn(e3.data)));
              } else {
                let r2 = false;
                const n3 = A(this.globalScope) ? void 0 : [], i3 = e3.hasCallback ? (e4, i4) => {
                  r2 = true, delete this.cancelCallbacks[t3], this.target.postMessage({ id: t3, type: "<response>", sourceMapId: this.mapId, error: e4 ? Mn(e4) : null, data: Mn(i4, n3) }, n3);
                } : (t4) => {
                  r2 = true;
                };
                let a3 = null;
                const s2 = Pn(e3.data);
                if (this.parent[e3.type])
                  a3 = this.parent[e3.type](e3.sourceMapId, s2, i3);
                else if (this.parent.getWorkerSource) {
                  const t4 = e3.type.split(".");
                  a3 = this.parent.getWorkerSource(e3.sourceMapId, t4[0], s2.source)[t4[1]](s2, i3);
                } else
                  i3(new Error(`Could not find function ${e3.type}`));
                !r2 && a3 && a3.cancel && (this.cancelCallbacks[t3] = a3.cancel);
              }
            }
            remove() {
              this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t2.AlphaImage = Ms, t2.CanonicalTileID = Hu, t2.CollisionBoxArray = ji, t2.CollisionCircleLayoutArray = class extends Vi {
          }, t2.Color = qt, t2.DEMData = ec, t2.DataConstantProperty = oi, t2.DictionaryCoder = rc, t2.EXTENT = ja, t2.ErrorEvent = U, t2.EvaluationParameters = Wn, t2.Event = O, t2.Evented = R, t2.FeatureIndex = ic, t2.FillBucket = bo, t2.FillExtrusionBucket = jo, t2.GeoJSONFeature = nc, t2.ImageAtlas = Hl, t2.ImagePosition = Yl, t2.KDBush = $c, t2.LineBucket = il, t2.LineStripIndexArray = class extends Ui {
          }, t2.LngLat = qu, t2.MercatorCoordinate = Xu, t2.ONE_EM = vl, t2.OverscaledTileID = Qu, t2.PerformanceUtils = Xc, t2.Point = i2, t2.Pos3dArray = class extends wi {
          }, t2.PosArray = Wi, t2.Properties = pi, t2.Protobuf = ql, t2.QuadTriangleArray = class extends Fi {
          }, t2.RGBAImage = Ps, t2.RasterBoundsArray = class extends _i {
          }, t2.RequestPerformance = class {
            constructor(t3) {
              this._marks = { start: [t3.url, "start"].join("#"), end: [t3.url, "end"].join("#"), measure: t3.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t3 = performance.getEntriesByName(this._marks.measure);
              return 0 === t3.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t3 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t3;
            }
          }, t2.SegmentVector = da, t2.SymbolBucket = zu, t2.Transitionable = ei, t2.TriangleIndexArray = ca, t2.Uniform1f = Pa, t2.Uniform1i = class extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = 0;
            }
            set(t3) {
              this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
            }
          }, t2.Uniform2f = class extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = [0, 0];
            }
            set(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
            }
          }, t2.Uniform3f = class extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = [0, 0, 0];
            }
            set(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
            }
          }, t2.Uniform4f = Ba, t2.UniformColor = Ca, t2.UniformMatrix4f = class extends Ma {
            constructor(t3, e3) {
              super(t3, e3), this.current = Va;
            }
            set(t3) {
              if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
                return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
              for (let e3 = 1; e3 < 16; e3++)
                if (t3[e3] !== this.current[e3]) {
                  this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
                  break;
                }
            }
          }, t2.UnwrappedTileID = Wu, t2.ValidationError = tt, t2.ZoomHistory = Bn, t2.addDynamicAttributes = Au, t2.arrayBufferToImage = function(t3, e3) {
            const r2 = new Image();
            r2.onload = () => {
              e3(null, r2), URL.revokeObjectURL(r2.src), r2.onload = null, window.requestAnimationFrame(() => {
                r2.src = S;
              });
            }, r2.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const n3 = new Blob([new Uint8Array(t3)], { type: "image/png" });
            r2.src = t3.byteLength ? URL.createObjectURL(n3) : S;
          }, t2.arrayBufferToImageBitmap = function(t3, e3) {
            const r2 = new Blob([new Uint8Array(t3)], { type: "image/png" });
            createImageBitmap(r2).then((t4) => {
              e3(null, t4);
            }).catch((t4) => {
              e3(new Error(`Could not load image because of ${t4.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }, t2.asyncAll = function(t3, e3, r2) {
            if (!t3.length)
              return r2(null, []);
            let n3 = t3.length;
            const i3 = new Array(t3.length);
            let a3 = null;
            t3.forEach((t4, s2) => {
              e3(t4, (t5, e4) => {
                t5 && (a3 = t5), i3[s2] = e4, 0 == --n3 && r2(a3, i3);
              });
            });
          }, t2.bezier = l, t2.browser = M, t2.clamp = c4, t2.clipLine = lc, t2.clone = function(t3) {
            var e3 = new ds(16);
            return e3[0] = t3[0], e3[1] = t3[1], e3[2] = t3[2], e3[3] = t3[3], e3[4] = t3[4], e3[5] = t3[5], e3[6] = t3[6], e3[7] = t3[7], e3[8] = t3[8], e3[9] = t3[9], e3[10] = t3[10], e3[11] = t3[11], e3[12] = t3[12], e3[13] = t3[13], e3[14] = t3[14], e3[15] = t3[15], e3;
          }, t2.clone$1 = m3, t2.collisionCircleLayout = ml, t2.config = P, t2.copy = function(t3, e3) {
            return t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[4] = e3[4], t3[5] = e3[5], t3[6] = e3[6], t3[7] = e3[7], t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
          }, t2.create = function() {
            var t3 = new ds(16);
            return ds != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0), t3[0] = 1, t3[5] = 1, t3[10] = 1, t3[15] = 1, t3;
          }, t2.createExpression = Ir, t2.createFilter = Fr, t2.createLayout = xi, t2.createStyleLayer = function(t3) {
            if ("custom" === t3.type)
              return new Ou(t3);
            switch (t3.type) {
              case "background":
                return new Tu(t3);
              case "circle":
                return new bs(t3);
              case "fill":
                return new ko(t3);
              case "fill-extrusion":
                return new Jo(t3);
              case "heatmap":
                return new Cs(t3);
              case "hillshade":
                return new Fs(t3);
              case "line":
                return new cl(t3);
              case "raster":
                return new Du(t3);
              case "symbol":
                return new Vu(t3);
            }
          }, t2.deepEqual = function t3(e3, r2) {
            if (Array.isArray(e3)) {
              if (!Array.isArray(r2) || e3.length !== r2.length)
                return false;
              for (let n3 = 0; n3 < e3.length; n3++)
                if (!t3(e3[n3], r2[n3]))
                  return false;
              return true;
            }
            if ("object" == typeof e3 && null !== e3 && null !== r2) {
              if ("object" != typeof r2)
                return false;
              if (Object.keys(e3).length !== Object.keys(r2).length)
                return false;
              for (const n3 in e3)
                if (!t3(e3[n3], r2[n3]))
                  return false;
              return true;
            }
            return e3 === r2;
          }, t2.defaultEasing = u, t2.derefLayers = function(t3) {
            t3 = t3.slice();
            const e3 = /* @__PURE__ */ Object.create(null);
            for (let r2 = 0; r2 < t3.length; r2++)
              e3[t3[r2].id] = t3[r2];
            for (let r2 = 0; r2 < t3.length; r2++)
              "ref" in t3[r2] && (t3[r2] = N(t3[r2], e3[t3[r2].ref]));
            return t3;
          }, t2.diffStyles = function(t3, e3) {
            if (!t3)
              return [{ command: K.setStyle, args: [e3] }];
            let r2 = [];
            try {
              if (!Z(t3.version, e3.version))
                return [{ command: K.setStyle, args: [e3] }];
              Z(t3.center, e3.center) || r2.push({ command: K.setCenter, args: [e3.center] }), Z(t3.zoom, e3.zoom) || r2.push({ command: K.setZoom, args: [e3.zoom] }), Z(t3.bearing, e3.bearing) || r2.push({ command: K.setBearing, args: [e3.bearing] }), Z(t3.pitch, e3.pitch) || r2.push({ command: K.setPitch, args: [e3.pitch] }), Z(t3.sprite, e3.sprite) || r2.push({ command: K.setSprite, args: [e3.sprite] }), Z(t3.glyphs, e3.glyphs) || r2.push({ command: K.setGlyphs, args: [e3.glyphs] }), Z(t3.transition, e3.transition) || r2.push({ command: K.setTransition, args: [e3.transition] }), Z(t3.light, e3.light) || r2.push({ command: K.setLight, args: [e3.light] });
              const n3 = {}, i3 = [];
              !function(t4, e4, r3, n4) {
                let i4;
                for (i4 in e4 = e4 || {}, t4 = t4 || {})
                  Object.prototype.hasOwnProperty.call(t4, i4) && (Object.prototype.hasOwnProperty.call(e4, i4) || J(i4, r3, n4));
                for (i4 in e4)
                  Object.prototype.hasOwnProperty.call(e4, i4) && (Object.prototype.hasOwnProperty.call(t4, i4) ? Z(t4[i4], e4[i4]) || ("geojson" === t4[i4].type && "geojson" === e4[i4].type && Y(t4, e4, i4) ? r3.push({ command: K.setGeoJSONSourceData, args: [i4, e4[i4].data] }) : X(i4, e4, r3, n4)) : G(i4, e4, r3));
              }(t3.sources, e3.sources, i3, n3);
              const a3 = [];
              t3.layers && t3.layers.forEach((t4) => {
                n3[t4.source] ? r2.push({ command: K.removeLayer, args: [t4.id] }) : a3.push(t4);
              }), r2 = r2.concat(i3), function(t4, e4, r3) {
                e4 = e4 || [];
                const n4 = (t4 = t4 || []).map(W), i4 = e4.map(W), a4 = t4.reduce(Q, {}), s2 = e4.reduce(Q, {}), o2 = n4.slice(), l2 = /* @__PURE__ */ Object.create(null);
                let u2, c5, h2, p3, f2, d3, y2;
                for (u2 = 0, c5 = 0; u2 < n4.length; u2++)
                  h2 = n4[u2], Object.prototype.hasOwnProperty.call(s2, h2) ? c5++ : (r3.push({ command: K.removeLayer, args: [h2] }), o2.splice(o2.indexOf(h2, c5), 1));
                for (u2 = 0, c5 = 0; u2 < i4.length; u2++)
                  h2 = i4[i4.length - 1 - u2], o2[o2.length - 1 - u2] !== h2 && (Object.prototype.hasOwnProperty.call(a4, h2) ? (r3.push({ command: K.removeLayer, args: [h2] }), o2.splice(o2.lastIndexOf(h2, o2.length - c5), 1)) : c5++, d3 = o2[o2.length - u2], r3.push({ command: K.addLayer, args: [s2[h2], d3] }), o2.splice(o2.length - u2, 0, h2), l2[h2] = true);
                for (u2 = 0; u2 < i4.length; u2++)
                  if (h2 = i4[u2], p3 = a4[h2], f2 = s2[h2], !l2[h2] && !Z(p3, f2))
                    if (Z(p3.source, f2.source) && Z(p3["source-layer"], f2["source-layer"]) && Z(p3.type, f2.type)) {
                      for (y2 in H(p3.layout, f2.layout, r3, h2, null, K.setLayoutProperty), H(p3.paint, f2.paint, r3, h2, null, K.setPaintProperty), Z(p3.filter, f2.filter) || r3.push({ command: K.setFilter, args: [h2, f2.filter] }), Z(p3.minzoom, f2.minzoom) && Z(p3.maxzoom, f2.maxzoom) || r3.push({ command: K.setLayerZoomRange, args: [h2, f2.minzoom, f2.maxzoom] }), p3)
                        Object.prototype.hasOwnProperty.call(p3, y2) && "layout" !== y2 && "paint" !== y2 && "filter" !== y2 && "metadata" !== y2 && "minzoom" !== y2 && "maxzoom" !== y2 && (0 === y2.indexOf("paint.") ? H(p3[y2], f2[y2], r3, h2, y2.slice(6), K.setPaintProperty) : Z(p3[y2], f2[y2]) || r3.push({ command: K.setLayerProperty, args: [h2, y2, f2[y2]] }));
                      for (y2 in f2)
                        Object.prototype.hasOwnProperty.call(f2, y2) && !Object.prototype.hasOwnProperty.call(p3, y2) && "layout" !== y2 && "paint" !== y2 && "filter" !== y2 && "metadata" !== y2 && "minzoom" !== y2 && "maxzoom" !== y2 && (0 === y2.indexOf("paint.") ? H(p3[y2], f2[y2], r3, h2, y2.slice(6), K.setPaintProperty) : Z(p3[y2], f2[y2]) || r3.push({ command: K.setLayerProperty, args: [h2, y2, f2[y2]] }));
                    } else
                      r3.push({ command: K.removeLayer, args: [h2] }), d3 = o2[o2.lastIndexOf(h2) + 1], r3.push({ command: K.addLayer, args: [f2, d3] });
              }(a3, e3.layers, r2);
            } catch (t4) {
              console.warn("Unable to compute style diff:", t4), r2 = [{ command: K.setStyle, args: [e3] }];
            }
            return r2;
          }, t2.dot = function(t3, e3) {
            return t3[0] * e3[0] + t3[1] * e3[1] + t3[2] * e3[2] + t3[3] * e3[3];
          }, t2.earthRadius = Ru, t2.emitValidationErrors = An, t2.emptyStyle = function() {
            const t3 = {}, e3 = q.$version;
            for (const r2 in q.$root) {
              const n3 = q.$root[r2];
              if (n3.required) {
                let i3 = null;
                i3 = "version" === r2 ? e3 : "array" === n3.type ? [] : {}, null != i3 && (t3[r2] = i3);
              }
            }
            return t3;
          }, t2.equals = function(t3, e3) {
            var r2 = t3[0], n3 = t3[1], i3 = t3[2], a3 = t3[3], s2 = t3[4], o2 = t3[5], l2 = t3[6], u2 = t3[7], c5 = t3[8], h2 = t3[9], p3 = t3[10], f2 = t3[11], d3 = t3[12], y2 = t3[13], m4 = t3[14], g3 = t3[15], x2 = e3[0], v2 = e3[1], b3 = e3[2], w2 = e3[3], _2 = e3[4], A2 = e3[5], k2 = e3[6], S2 = e3[7], I2 = e3[8], z2 = e3[9], M2 = e3[10], P2 = e3[11], B2 = e3[12], C3 = e3[13], V2 = e3[14], E2 = e3[15];
            return Math.abs(r2 - x2) <= fs * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n3 - v2) <= fs * Math.max(1, Math.abs(n3), Math.abs(v2)) && Math.abs(i3 - b3) <= fs * Math.max(1, Math.abs(i3), Math.abs(b3)) && Math.abs(a3 - w2) <= fs * Math.max(1, Math.abs(a3), Math.abs(w2)) && Math.abs(s2 - _2) <= fs * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(o2 - A2) <= fs * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - k2) <= fs * Math.max(1, Math.abs(l2), Math.abs(k2)) && Math.abs(u2 - S2) <= fs * Math.max(1, Math.abs(u2), Math.abs(S2)) && Math.abs(c5 - I2) <= fs * Math.max(1, Math.abs(c5), Math.abs(I2)) && Math.abs(h2 - z2) <= fs * Math.max(1, Math.abs(h2), Math.abs(z2)) && Math.abs(p3 - M2) <= fs * Math.max(1, Math.abs(p3), Math.abs(M2)) && Math.abs(f2 - P2) <= fs * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(d3 - B2) <= fs * Math.max(1, Math.abs(d3), Math.abs(B2)) && Math.abs(y2 - C3) <= fs * Math.max(1, Math.abs(y2), Math.abs(C3)) && Math.abs(m4 - V2) <= fs * Math.max(1, Math.abs(m4), Math.abs(V2)) && Math.abs(g3 - E2) <= fs * Math.max(1, Math.abs(g3), Math.abs(E2));
          }, t2.evaluateSizeForFeature = function(t3, { uSize: e3, uSizeT: r2 }, { lowerSize: n3, upperSize: i3 }) {
            return "source" === t3.kind ? n3 / mu : "composite" === t3.kind ? Te.number(n3 / mu, i3 / mu, r2) : e3;
          }, t2.evaluateSizeForZoom = function(t3, e3) {
            let r2 = 0, n3 = 0;
            if ("constant" === t3.kind)
              n3 = t3.layoutSize;
            else if ("source" !== t3.kind) {
              const { interpolationType: i3, minZoom: a3, maxZoom: s2 } = t3, o2 = i3 ? c4(Le.interpolationFactor(i3, e3, a3, s2), 0, 1) : 0;
              "camera" === t3.kind ? n3 = Te.number(t3.minSize, t3.maxSize, o2) : r2 = o2;
            }
            return { uSizeT: r2, uSize: n3 };
          }, t2.evaluateVariableOffset = Bc, t2.evented = Jn, t2.extend = p2, t2.filterObject = y, t2.findLineIntersection = function(t3, e3, r2, n3) {
            const a3 = e3.y - t3.y, s2 = e3.x - t3.x, o2 = n3.y - r2.y, l2 = n3.x - r2.x, u2 = o2 * s2 - l2 * a3;
            if (0 === u2)
              return null;
            const c5 = (l2 * (t3.y - r2.y) - o2 * (t3.x - r2.x)) / u2;
            return new i2(t3.x + c5 * s2, t3.y + c5 * a3);
          }, t2.fromScaling = function(t3, e3) {
            return t3[0] = e3[0], t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = e3[1], t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = e3[2], t3[11] = 0, t3[12] = 0, t3[13] = 0, t3[14] = 0, t3[15] = 1, t3;
          }, t2.getAnchorAlignment = hu, t2.getAnchorJustification = Cc, t2.getArrayBuffer = T, t2.getDefaultExportFromCjs = e2, t2.getJSON = function(t3, e3) {
            return F(p2(t3, { type: "json" }), e3);
          }, t2.getOverlapMode = vu, t2.getProtocolAction = V, t2.getRTLTextPluginStatus = Xn, t2.getReferrer = C2, t2.getVideo = function(t3, e3) {
            const r2 = window.document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              e3(null, r2);
            };
            for (let e4 = 0; e4 < t3.length; e4++) {
              const n3 = window.document.createElement("source");
              L(t3[e4]) || (r2.crossOrigin = "Anonymous"), n3.src = t3[e4], r2.appendChild(n3);
            }
            return { cancel: () => {
            } };
          }, t2.groupByLayout = function(t3, e3) {
            const r2 = {};
            for (let n4 = 0; n4 < t3.length; n4++) {
              const i3 = e3 && e3[t3[n4].id] || jr(t3[n4]);
              e3 && (e3[t3[n4].id] = i3);
              let a3 = r2[i3];
              a3 || (a3 = r2[i3] = []), a3.push(t3[n4]);
            }
            const n3 = [];
            for (const t4 in r2)
              n3.push(r2[t4]);
            return n3;
          }, t2.identity = ys, t2.interpolate = Te, t2.invert = function(t3, e3) {
            var r2 = e3[0], n3 = e3[1], i3 = e3[2], a3 = e3[3], s2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c5 = e3[8], h2 = e3[9], p3 = e3[10], f2 = e3[11], d3 = e3[12], y2 = e3[13], m4 = e3[14], g3 = e3[15], x2 = r2 * o2 - n3 * s2, v2 = r2 * l2 - i3 * s2, b3 = r2 * u2 - a3 * s2, w2 = n3 * l2 - i3 * o2, _2 = n3 * u2 - a3 * o2, A2 = i3 * u2 - a3 * l2, k2 = c5 * y2 - h2 * d3, S2 = c5 * m4 - p3 * d3, I2 = c5 * g3 - f2 * d3, z2 = h2 * m4 - p3 * y2, M2 = h2 * g3 - f2 * y2, P2 = p3 * g3 - f2 * m4, B2 = x2 * P2 - v2 * M2 + b3 * z2 + w2 * I2 - _2 * S2 + A2 * k2;
            return B2 ? (t3[0] = (o2 * P2 - l2 * M2 + u2 * z2) * (B2 = 1 / B2), t3[1] = (i3 * M2 - n3 * P2 - a3 * z2) * B2, t3[2] = (y2 * A2 - m4 * _2 + g3 * w2) * B2, t3[3] = (p3 * _2 - h2 * A2 - f2 * w2) * B2, t3[4] = (l2 * I2 - s2 * P2 - u2 * S2) * B2, t3[5] = (r2 * P2 - i3 * I2 + a3 * S2) * B2, t3[6] = (m4 * b3 - d3 * A2 - g3 * v2) * B2, t3[7] = (c5 * A2 - p3 * b3 + f2 * v2) * B2, t3[8] = (s2 * M2 - o2 * I2 + u2 * k2) * B2, t3[9] = (n3 * I2 - r2 * M2 - a3 * k2) * B2, t3[10] = (d3 * _2 - y2 * b3 + g3 * x2) * B2, t3[11] = (h2 * b3 - c5 * _2 - f2 * x2) * B2, t3[12] = (o2 * S2 - s2 * z2 - l2 * k2) * B2, t3[13] = (r2 * z2 - n3 * S2 + i3 * k2) * B2, t3[14] = (y2 * v2 - d3 * w2 - m4 * x2) * B2, t3[15] = (c5 * w2 - h2 * v2 + p3 * x2) * B2, t3) : null;
          }, t2.isImageBitmap = k, t2.isSafari = A, t2.isWorker = w, t2.keysDifference = function(t3, e3) {
            const r2 = [];
            for (const n3 in t3)
              n3 in e3 || r2.push(n3);
            return r2;
          }, t2.lazyLoadRTLTextPlugin = function() {
            Hn.isLoading() || Hn.isLoaded() || "deferred" !== Xn() || Yn();
          }, t2.makeRequest = F, t2.mapObject = d2, t2.mercatorXfromLng = Zu, t2.mercatorYfromLat = Ku, t2.mercatorZfromAltitude = Gu, t2.mul = xs, t2.mul$1 = function(t3, e3, r2) {
            return t3[0] = e3[0] * r2[0], t3[1] = e3[1] * r2[1], t3[2] = e3[2] * r2[2], t3[3] = e3[3] * r2[3], t3;
          }, t2.multiply = ms, t2.nextPowerOfTwo = function(t3) {
            return t3 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t3) / Math.LN2));
          }, t2.operations = K, t2.ortho = function(t3, e3, r2, n3, i3, a3, s2) {
            var o2 = 1 / (e3 - r2), l2 = 1 / (n3 - i3), u2 = 1 / (a3 - s2);
            return t3[0] = -2 * o2, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = -2 * l2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[10] = 2 * u2, t3[11] = 0, t3[12] = (e3 + r2) * o2, t3[13] = (i3 + n3) * l2, t3[14] = (s2 + a3) * u2, t3[15] = 1, t3;
          }, t2.parseCacheControl = function(t3) {
            const e3 = {};
            if (t3.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t4, r2, n3, i3) => {
              const a3 = n3 || i3;
              return e3[r2] = !a3 || a3.toLowerCase(), "";
            }), e3["max-age"]) {
              const t4 = parseInt(e3["max-age"], 10);
              isNaN(t4) ? delete e3["max-age"] : e3["max-age"] = t4;
            }
            return e3;
          }, t2.parseGlyphPbf = function(t3) {
            return new ql(t3).readFields(Nl, []);
          }, t2.pbf = bl, t2.performSymbolLayout = function(e3) {
            e3.bucket.createArrays(), e3.bucket.tilePixelRatio = ja / (512 * e3.bucket.overscaling), e3.bucket.compareText = {}, e3.bucket.iconsNeedLinear = false;
            const r2 = e3.bucket.layers[0].layout, n3 = e3.bucket.layers[0]._unevaluatedLayout._values, i3 = { layoutIconSize: n3["icon-size"].possiblyEvaluate(new Wn(e3.bucket.zoom + 1), e3.canonical), layoutTextSize: n3["text-size"].possiblyEvaluate(new Wn(e3.bucket.zoom + 1), e3.canonical), textMaxSize: n3["text-size"].possiblyEvaluate(new Wn(18)) };
            if ("composite" === e3.bucket.textSizeData.kind) {
              const { minZoom: t3, maxZoom: r3 } = e3.bucket.textSizeData;
              i3.compositeTextSizes = [n3["text-size"].possiblyEvaluate(new Wn(t3), e3.canonical), n3["text-size"].possiblyEvaluate(new Wn(r3), e3.canonical)];
            }
            if ("composite" === e3.bucket.iconSizeData.kind) {
              const { minZoom: t3, maxZoom: r3 } = e3.bucket.iconSizeData;
              i3.compositeIconSizes = [n3["icon-size"].possiblyEvaluate(new Wn(t3), e3.canonical), n3["icon-size"].possiblyEvaluate(new Wn(r3), e3.canonical)];
            }
            const a3 = r2.get("text-line-height") * vl, s2 = "viewport" !== r2.get("text-rotation-alignment") && "point" !== r2.get("symbol-placement"), o2 = r2.get("text-keep-upright"), l2 = r2.get("text-size");
            for (const n4 of e3.bucket.features) {
              const u2 = r2.get("text-font").evaluate(n4, {}, e3.canonical).join(","), c5 = l2.evaluate(n4, {}, e3.canonical), h2 = i3.layoutTextSize.evaluate(n4, {}, e3.canonical), p3 = i3.layoutIconSize.evaluate(n4, {}, e3.canonical), f2 = { horizontal: {}, vertical: void 0 }, d3 = n4.text;
              let y2, m4 = [0, 0];
              if (d3) {
                const i4 = d3.toString(), l3 = r2.get("text-letter-spacing").evaluate(n4, {}, e3.canonical) * vl, p4 = En(i4) ? l3 : 0, y3 = r2.get("text-anchor").evaluate(n4, {}, e3.canonical), g4 = r2.get("text-variable-anchor");
                if (!g4) {
                  const t3 = r2.get("text-radial-offset").evaluate(n4, {}, e3.canonical);
                  m4 = t3 ? Bc(y3, [t3 * vl, Pc]) : r2.get("text-offset").evaluate(n4, {}, e3.canonical).map((t4) => t4 * vl);
                }
                let x2 = s2 ? "center" : r2.get("text-justify").evaluate(n4, {}, e3.canonical);
                const v3 = r2.get("symbol-placement"), b3 = "point" === v3 ? r2.get("text-max-width").evaluate(n4, {}, e3.canonical) * vl : 0, w2 = () => {
                  e3.bucket.allowVerticalPlacement && Vn(i4) && (f2.vertical = ru(d3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b3, a3, y3, "left", p4, m4, t2.WritingMode.vertical, true, v3, h2, c5));
                };
                if (!s2 && g4) {
                  const r3 = "auto" === x2 ? g4.map((t3) => Cc(t3)) : [x2];
                  let n5 = false;
                  for (let i5 = 0; i5 < r3.length; i5++) {
                    const s3 = r3[i5];
                    if (!f2.horizontal[s3])
                      if (n5)
                        f2.horizontal[s3] = f2.horizontal[0];
                      else {
                        const r4 = ru(d3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b3, a3, "center", s3, p4, m4, t2.WritingMode.horizontal, false, v3, h2, c5);
                        r4 && (f2.horizontal[s3] = r4, n5 = 1 === r4.positionedLines.length);
                      }
                  }
                  w2();
                } else {
                  "auto" === x2 && (x2 = Cc(y3));
                  const r3 = ru(d3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b3, a3, y3, x2, p4, m4, t2.WritingMode.horizontal, false, v3, h2, c5);
                  r3 && (f2.horizontal[x2] = r3), w2(), Vn(i4) && s2 && o2 && (f2.vertical = ru(d3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b3, a3, y3, x2, p4, m4, t2.WritingMode.vertical, false, v3, h2, c5));
                }
              }
              let g3 = false;
              if (n4.icon && n4.icon.name) {
                const t3 = e3.imageMap[n4.icon.name];
                t3 && (y2 = fu(e3.imagePositions[n4.icon.name], r2.get("icon-offset").evaluate(n4, {}, e3.canonical), r2.get("icon-anchor").evaluate(n4, {}, e3.canonical)), g3 = !!t3.sdf, void 0 === e3.bucket.sdfIcons ? e3.bucket.sdfIcons = g3 : e3.bucket.sdfIcons !== g3 && x("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t3.pixelRatio !== e3.bucket.pixelRatio || 0 !== r2.get("icon-rotate").constantOr(1)) && (e3.bucket.iconsNeedLinear = true));
              }
              const v2 = Fc(f2.horizontal) || f2.vertical;
              e3.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || y2) && Vc(e3.bucket, n4, f2, y2, e3.imageMap, i3, h2, p3, m4, g3, e3.canonical);
            }
            e3.showCollisionBoxes && e3.bucket.generateCollisionDebugBuffers();
          }, t2.perspective = function(t3, e3, r2, n3, i3) {
            var a3, s2 = 1 / Math.tan(e3 / 2);
            return t3[0] = s2 / r2, t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[4] = 0, t3[5] = s2, t3[6] = 0, t3[7] = 0, t3[8] = 0, t3[9] = 0, t3[11] = -1, t3[12] = 0, t3[13] = 0, t3[15] = 0, null != i3 && i3 !== 1 / 0 ? (t3[10] = (i3 + n3) * (a3 = 1 / (n3 - i3)), t3[14] = 2 * i3 * n3 * a3) : (t3[10] = -1, t3[14] = -2 * n3), t3;
          }, t2.pick = function(t3, e3) {
            const r2 = {};
            for (let n3 = 0; n3 < e3.length; n3++) {
              const i3 = e3[n3];
              i3 in t3 && (r2[i3] = t3[i3]);
            }
            return r2;
          }, t2.plugin = Hn, t2.pointGeometry = r, t2.polygonIntersectsPolygon = Ya, t2.potpack = Jl, t2.register = In, t2.registerForPluginStateChange = function(t3) {
            return t3({ pluginStatus: Nn, pluginURL: Zn }), Jn.on("pluginStateChange", t3), t3;
          }, t2.renderColorRamp = Bs, t2.rotateX = function(t3, e3, r2) {
            var n3 = Math.sin(r2), i3 = Math.cos(r2), a3 = e3[4], s2 = e3[5], o2 = e3[6], l2 = e3[7], u2 = e3[8], c5 = e3[9], h2 = e3[10], p3 = e3[11];
            return e3 !== t3 && (t3[0] = e3[0], t3[1] = e3[1], t3[2] = e3[2], t3[3] = e3[3], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[4] = a3 * i3 + u2 * n3, t3[5] = s2 * i3 + c5 * n3, t3[6] = o2 * i3 + h2 * n3, t3[7] = l2 * i3 + p3 * n3, t3[8] = u2 * i3 - a3 * n3, t3[9] = c5 * i3 - s2 * n3, t3[10] = h2 * i3 - o2 * n3, t3[11] = p3 * i3 - l2 * n3, t3;
          }, t2.rotateZ = function(t3, e3, r2) {
            var n3 = Math.sin(r2), i3 = Math.cos(r2), a3 = e3[0], s2 = e3[1], o2 = e3[2], l2 = e3[3], u2 = e3[4], c5 = e3[5], h2 = e3[6], p3 = e3[7];
            return e3 !== t3 && (t3[8] = e3[8], t3[9] = e3[9], t3[10] = e3[10], t3[11] = e3[11], t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15]), t3[0] = a3 * i3 + u2 * n3, t3[1] = s2 * i3 + c5 * n3, t3[2] = o2 * i3 + h2 * n3, t3[3] = l2 * i3 + p3 * n3, t3[4] = u2 * i3 - a3 * n3, t3[5] = c5 * i3 - s2 * n3, t3[6] = h2 * i3 - o2 * n3, t3[7] = p3 * i3 - l2 * n3, t3;
          }, t2.sameOrigin = L, t2.scale = function(t3, e3, r2) {
            var n3 = r2[0], i3 = r2[1], a3 = r2[2];
            return t3[0] = e3[0] * n3, t3[1] = e3[1] * n3, t3[2] = e3[2] * n3, t3[3] = e3[3] * n3, t3[4] = e3[4] * i3, t3[5] = e3[5] * i3, t3[6] = e3[6] * i3, t3[7] = e3[7] * i3, t3[8] = e3[8] * a3, t3[9] = e3[9] * a3, t3[10] = e3[10] * a3, t3[11] = e3[11] * a3, t3[12] = e3[12], t3[13] = e3[13], t3[14] = e3[14], t3[15] = e3[15], t3;
          }, t2.setRTLTextPlugin = function(t3, e3, r2 = false) {
            if (Nn === Un || Nn === Rn || Nn === qn)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Zn = M.resolveURL(t3), Nn = Un, jn = e3, Gn(), r2 || Yn();
          }, t2.sphericalToCartesian = function([t3, e3, r2]) {
            return e3 += 90, e3 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t3 * Math.cos(e3) * Math.sin(r2), y: t3 * Math.sin(e3) * Math.sin(r2), z: t3 * Math.cos(r2) };
          }, t2.toEvaluationFeature = Ga, t2.transformMat4 = vs, t2.translate = function(t3, e3, r2) {
            var n3, i3, a3, s2, o2, l2, u2, c5, h2, p3, f2, d3, y2 = r2[0], m4 = r2[1], g3 = r2[2];
            return e3 === t3 ? (t3[12] = e3[0] * y2 + e3[4] * m4 + e3[8] * g3 + e3[12], t3[13] = e3[1] * y2 + e3[5] * m4 + e3[9] * g3 + e3[13], t3[14] = e3[2] * y2 + e3[6] * m4 + e3[10] * g3 + e3[14], t3[15] = e3[3] * y2 + e3[7] * m4 + e3[11] * g3 + e3[15]) : (i3 = e3[1], a3 = e3[2], s2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c5 = e3[7], h2 = e3[8], p3 = e3[9], f2 = e3[10], d3 = e3[11], t3[0] = n3 = e3[0], t3[1] = i3, t3[2] = a3, t3[3] = s2, t3[4] = o2, t3[5] = l2, t3[6] = u2, t3[7] = c5, t3[8] = h2, t3[9] = p3, t3[10] = f2, t3[11] = d3, t3[12] = n3 * y2 + o2 * m4 + h2 * g3 + e3[12], t3[13] = i3 * y2 + l2 * m4 + p3 * g3 + e3[13], t3[14] = a3 * y2 + u2 * m4 + f2 * g3 + e3[14], t3[15] = s2 * y2 + c5 * m4 + d3 * g3 + e3[15]), t3;
          }, t2.triggerPluginCompletionEvent = Kn, t2.unicodeBlockLookup = Cn, t2.uniqueId = function() {
            return f++;
          }, t2.v8Spec = q, t2.validateCustomStyleLayer = function(t3) {
            const e3 = [], r2 = t3.id;
            return void 0 === r2 && e3.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t3.render && e3.push({ message: `layers.${r2}: missing required method "render"` }), t3.renderingMode && "2d" !== t3.renderingMode && "3d" !== t3.renderingMode && e3.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e3;
          }, t2.validateLight = bn, t2.validateStyle = vn, t2.vectorTile = Mo, t2.warnOnce = x, t2.wrap = h;
        });
        define2(["./shared"], function(e2) {
          "use strict";
          class t2 {
            constructor(e3) {
              this.keyCache = {}, e3 && this.replace(e3);
            }
            replace(e3) {
              this._layerConfigs = {}, this._layers = {}, this.update(e3, []);
            }
            update(t3, o2) {
              for (const o3 of t3) {
                this._layerConfigs[o3.id] = o3;
                const t4 = this._layers[o3.id] = e2.createStyleLayer(o3);
                t4._featureFilter = e2.createFilter(t4.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
              }
              for (const e3 of o2)
                delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
              this.familiesBySource = {};
              const i3 = e2.groupByLayout(Object.values(this._layerConfigs), this.keyCache);
              for (const e3 of i3) {
                const t4 = e3.map((e4) => this._layers[e4.id]), o3 = t4[0];
                if ("none" === o3.visibility)
                  continue;
                const i4 = o3.source || "";
                let r2 = this.familiesBySource[i4];
                r2 || (r2 = this.familiesBySource[i4] = {});
                const s2 = o3.sourceLayer || "_geojsonTileLayer";
                let n3 = r2[s2];
                n3 || (n3 = r2[s2] = []), n3.push(t4);
              }
            }
          }
          class o {
            constructor(t3) {
              const o2 = {}, i3 = [];
              for (const e3 in t3) {
                const r3 = t3[e3], s3 = o2[e3] = {};
                for (const e4 in r3) {
                  const t4 = r3[+e4];
                  if (!t4 || 0 === t4.bitmap.width || 0 === t4.bitmap.height)
                    continue;
                  const o3 = { x: 0, y: 0, w: t4.bitmap.width + 2, h: t4.bitmap.height + 2 };
                  i3.push(o3), s3[e4] = { rect: o3, metrics: t4.metrics };
                }
              }
              const { w: r2, h: s2 } = e2.potpack(i3), n3 = new e2.AlphaImage({ width: r2 || 1, height: s2 || 1 });
              for (const i4 in t3) {
                const r3 = t3[i4];
                for (const t4 in r3) {
                  const s3 = r3[+t4];
                  if (!s3 || 0 === s3.bitmap.width || 0 === s3.bitmap.height)
                    continue;
                  const a3 = o2[i4][t4].rect;
                  e2.AlphaImage.copy(s3.bitmap, n3, { x: 0, y: 0 }, { x: a3.x + 1, y: a3.y + 1 }, s3.bitmap);
                }
              }
              this.image = n3, this.positions = o2;
            }
          }
          e2.register("GlyphAtlas", o);
          class i2 {
            constructor(t3) {
              this.tileID = new e2.OverscaledTileID(t3.tileID.overscaledZ, t3.tileID.wrap, t3.tileID.canonical.z, t3.tileID.canonical.x, t3.tileID.canonical.y), this.uid = t3.uid, this.zoom = t3.zoom, this.pixelRatio = t3.pixelRatio, this.tileSize = t3.tileSize, this.source = t3.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t3.showCollisionBoxes, this.collectResourceTiming = !!t3.collectResourceTiming, this.returnDependencies = !!t3.returnDependencies, this.promoteId = t3.promoteId;
            }
            parse(t3, i3, s2, n3, a3) {
              this.status = "parsing", this.data = t3, this.collisionBoxArray = new e2.CollisionBoxArray();
              const l2 = new e2.DictionaryCoder(Object.keys(t3.layers).sort()), c5 = new e2.FeatureIndex(this.tileID, this.promoteId);
              c5.bucketLayerIDs = [];
              const u2 = {}, h2 = { featureIndex: c5, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s2 }, d3 = i3.familiesBySource[this.source];
              for (const o2 in d3) {
                const i4 = t3.layers[o2];
                if (!i4)
                  continue;
                1 === i4.version && e2.warnOnce(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n4 = l2.encode(o2), a4 = [];
                for (let e3 = 0; e3 < i4.length; e3++) {
                  const t4 = i4.feature(e3), r2 = c5.getId(t4, o2);
                  a4.push({ feature: t4, id: r2, index: e3, sourceLayerIndex: n4 });
                }
                for (const t4 of d3[o2]) {
                  const o3 = t4[0];
                  o3.source !== this.source && e2.warnOnce(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || "none" !== o3.visibility && (r(t4, this.zoom, s2), (u2[o3.id] = o3.createBucket({ index: c5.bucketLayerIDs.length, layers: t4, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n4, sourceID: this.source })).populate(a4, h2, this.tileID.canonical), c5.bucketLayerIDs.push(t4.map((e3) => e3.id)));
                }
              }
              let p3, f2, g3, m4;
              const y2 = e2.mapObject(h2.glyphDependencies, (e3) => Object.keys(e3).map(Number));
              Object.keys(y2).length ? n3.send("getGlyphs", { uid: this.uid, stacks: y2, source: this.source, tileID: this.tileID, type: "glyphs" }, (e3, t4) => {
                p3 || (p3 = e3, f2 = t4, w2.call(this));
              }) : f2 = {};
              const v2 = Object.keys(h2.iconDependencies);
              v2.length ? n3.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "icons" }, (e3, t4) => {
                p3 || (p3 = e3, g3 = t4, w2.call(this));
              }) : g3 = {};
              const x2 = Object.keys(h2.patternDependencies);
              function w2() {
                if (p3)
                  return a3(p3);
                if (f2 && g3 && m4) {
                  const t4 = new o(f2), i4 = new e2.ImageAtlas(g3, m4);
                  for (const o2 in u2) {
                    const n4 = u2[o2];
                    n4 instanceof e2.SymbolBucket ? (r(n4.layers, this.zoom, s2), e2.performSymbolLayout({ bucket: n4, glyphMap: f2, glyphPositions: t4.positions, imageMap: g3, imagePositions: i4.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n4.hasPattern && (n4 instanceof e2.LineBucket || n4 instanceof e2.FillBucket || n4 instanceof e2.FillExtrusionBucket) && (r(n4.layers, this.zoom, s2), n4.addFeatures(h2, this.tileID.canonical, i4.patternPositions));
                  }
                  this.status = "done", a3(null, { buckets: Object.values(u2).filter((e3) => !e3.isEmpty()), featureIndex: c5, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t4.image, imageAtlas: i4, glyphMap: this.returnDependencies ? f2 : null, iconMap: this.returnDependencies ? g3 : null, glyphPositions: this.returnDependencies ? t4.positions : null });
                }
              }
              x2.length ? n3.send("getImages", { icons: x2, source: this.source, tileID: this.tileID, type: "patterns" }, (e3, t4) => {
                p3 || (p3 = e3, m4 = t4, w2.call(this));
              }) : m4 = {}, w2.call(this);
            }
          }
          function r(t3, o2, i3) {
            const r2 = new e2.EvaluationParameters(o2);
            for (const e3 of t3)
              e3.recalculate(r2, i3);
          }
          function s(t3, o2) {
            const i3 = e2.getArrayBuffer(t3.request, (t4, i4, r2, s2) => {
              t4 ? o2(t4) : i4 && o2(null, { vectorTile: new e2.vectorTile.VectorTile(new e2.Protobuf(i4)), rawData: i4, cacheControl: r2, expires: s2 });
            });
            return () => {
              i3.cancel(), o2();
            };
          }
          class n2 {
            constructor(e3, t3, o2, i3) {
              this.actor = e3, this.layerIndex = t3, this.availableImages = o2, this.loadVectorData = i3 || s, this.loading = {}, this.loaded = {};
            }
            loadTile(t3, o2) {
              const r2 = t3.uid;
              this.loading || (this.loading = {});
              const s2 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e2.RequestPerformance(t3.request), n3 = this.loading[r2] = new i2(t3);
              n3.abort = this.loadVectorData(t3, (t4, i3) => {
                if (delete this.loading[r2], t4 || !i3)
                  return n3.status = "done", this.loaded[r2] = n3, o2(t4);
                const a3 = i3.rawData, l2 = {};
                i3.expires && (l2.expires = i3.expires), i3.cacheControl && (l2.cacheControl = i3.cacheControl);
                const c5 = {};
                if (s2) {
                  const e3 = s2.finish();
                  e3 && (c5.resourceTiming = JSON.parse(JSON.stringify(e3)));
                }
                n3.vectorTile = i3.vectorTile, n3.parse(i3.vectorTile, this.layerIndex, this.availableImages, this.actor, (t5, i4) => {
                  if (t5 || !i4)
                    return o2(t5);
                  o2(null, e2.extend({ rawTileData: a3.slice(0) }, i4, l2, c5));
                }), this.loaded = this.loaded || {}, this.loaded[r2] = n3;
              });
            }
            reloadTile(e3, t3) {
              const o2 = this.loaded, i3 = e3.uid, r2 = this;
              if (o2 && o2[i3]) {
                const s2 = o2[i3];
                s2.showCollisionBoxes = e3.showCollisionBoxes;
                const n3 = (e4, o3) => {
                  const i4 = s2.reloadCallback;
                  i4 && (delete s2.reloadCallback, s2.parse(s2.vectorTile, r2.layerIndex, this.availableImages, r2.actor, i4)), t3(e4, o3);
                };
                "parsing" === s2.status ? s2.reloadCallback = n3 : "done" === s2.status && (s2.vectorTile ? s2.parse(s2.vectorTile, this.layerIndex, this.availableImages, this.actor, n3) : n3());
              }
            }
            abortTile(e3, t3) {
              const o2 = this.loading, i3 = e3.uid;
              o2 && o2[i3] && o2[i3].abort && (o2[i3].abort(), delete o2[i3]), t3();
            }
            removeTile(e3, t3) {
              const o2 = this.loaded, i3 = e3.uid;
              o2 && o2[i3] && delete o2[i3], t3();
            }
          }
          class a2 {
            constructor() {
              this.loaded = {};
            }
            loadTile(t3, o2) {
              const { uid: i3, encoding: r2, rawImageData: s2 } = t3, n3 = e2.isImageBitmap(s2) ? this.getImageData(s2) : s2, a3 = new e2.DEMData(i3, n3, r2);
              this.loaded = this.loaded || {}, this.loaded[i3] = a3, o2(null, a3);
            }
            getImageData(t3) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t3.width, t3.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = t3.width, this.offscreenCanvas.height = t3.height, this.offscreenCanvasContext.drawImage(t3, 0, 0, t3.width, t3.height);
              const o2 = this.offscreenCanvasContext.getImageData(-1, -1, t3.width + 2, t3.height + 2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e2.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
            }
            removeTile(e3) {
              const t3 = this.loaded, o2 = e3.uid;
              t3 && t3[o2] && delete t3[o2];
            }
          }
          function l(e3, t3) {
            if (0 !== e3.length) {
              c4(e3[0], t3);
              for (var o2 = 1; o2 < e3.length; o2++)
                c4(e3[o2], !t3);
            }
          }
          function c4(e3, t3) {
            for (var o2 = 0, i3 = 0, r2 = 0, s2 = e3.length, n3 = s2 - 1; r2 < s2; n3 = r2++) {
              var a3 = (e3[r2][0] - e3[n3][0]) * (e3[n3][1] + e3[r2][1]), l2 = o2 + a3;
              i3 += Math.abs(o2) >= Math.abs(a3) ? o2 - l2 + a3 : a3 - l2 + o2, o2 = l2;
            }
            o2 + i3 >= 0 != !!t3 && e3.reverse();
          }
          var u = e2.getDefaultExportFromCjs(function e3(t3, o2) {
            var i3, r2 = t3 && t3.type;
            if ("FeatureCollection" === r2)
              for (i3 = 0; i3 < t3.features.length; i3++)
                e3(t3.features[i3], o2);
            else if ("GeometryCollection" === r2)
              for (i3 = 0; i3 < t3.geometries.length; i3++)
                e3(t3.geometries[i3], o2);
            else if ("Feature" === r2)
              e3(t3.geometry, o2);
            else if ("Polygon" === r2)
              l(t3.coordinates, o2);
            else if ("MultiPolygon" === r2)
              for (i3 = 0; i3 < t3.coordinates.length; i3++)
                l(t3.coordinates[i3], o2);
            return t3;
          });
          const h = e2.vectorTile.VectorTileFeature.prototype.toGeoJSON;
          var d2 = { exports: {} }, p2 = e2.pointGeometry, f = e2.vectorTile.VectorTileFeature, g2 = m3;
          function m3(e3, t3) {
            this.options = t3 || {}, this.features = e3, this.length = e3.length;
          }
          function y(e3, t3) {
            this.id = "number" == typeof e3.id ? e3.id : void 0, this.type = e3.type, this.rawGeometry = 1 === e3.type ? [e3.geometry] : e3.geometry, this.properties = e3.tags, this.extent = t3 || 4096;
          }
          m3.prototype.feature = function(e3) {
            return new y(this.features[e3], this.options.extent);
          }, y.prototype.loadGeometry = function() {
            var e3 = this.rawGeometry;
            this.geometry = [];
            for (var t3 = 0; t3 < e3.length; t3++) {
              for (var o2 = e3[t3], i3 = [], r2 = 0; r2 < o2.length; r2++)
                i3.push(new p2(o2[r2][0], o2[r2][1]));
              this.geometry.push(i3);
            }
            return this.geometry;
          }, y.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e3 = this.geometry, t3 = 1 / 0, o2 = -1 / 0, i3 = 1 / 0, r2 = -1 / 0, s2 = 0; s2 < e3.length; s2++)
              for (var n3 = e3[s2], a3 = 0; a3 < n3.length; a3++) {
                var l2 = n3[a3];
                t3 = Math.min(t3, l2.x), o2 = Math.max(o2, l2.x), i3 = Math.min(i3, l2.y), r2 = Math.max(r2, l2.y);
              }
            return [t3, i3, o2, r2];
          }, y.prototype.toGeoJSON = f.prototype.toGeoJSON;
          var v = e2.pbf, x = g2;
          function w(e3) {
            var t3 = new v();
            return function(e4, t4) {
              for (var o2 in e4.layers)
                t4.writeMessage(3, S, e4.layers[o2]);
            }(e3, t3), t3.finish();
          }
          function S(e3, t3) {
            var o2;
            t3.writeVarintField(15, e3.version || 1), t3.writeStringField(1, e3.name || ""), t3.writeVarintField(5, e3.extent || 4096);
            var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (o2 = 0; o2 < e3.length; o2++)
              i3.feature = e3.feature(o2), t3.writeMessage(2, b2, i3);
            var r2 = i3.keys;
            for (o2 = 0; o2 < r2.length; o2++)
              t3.writeStringField(3, r2[o2]);
            var s2 = i3.values;
            for (o2 = 0; o2 < s2.length; o2++)
              t3.writeMessage(4, T, s2[o2]);
          }
          function b2(e3, t3) {
            var o2 = e3.feature;
            void 0 !== o2.id && t3.writeVarintField(1, o2.id), t3.writeMessage(2, I, e3), t3.writeVarintField(3, o2.type), t3.writeMessage(4, k, o2);
          }
          function I(e3, t3) {
            var o2 = e3.feature, i3 = e3.keys, r2 = e3.values, s2 = e3.keycache, n3 = e3.valuecache;
            for (var a3 in o2.properties) {
              var l2 = o2.properties[a3], c5 = s2[a3];
              if (null !== l2) {
                void 0 === c5 && (i3.push(a3), s2[a3] = c5 = i3.length - 1), t3.writeVarint(c5);
                var u2 = typeof l2;
                "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l2 = JSON.stringify(l2));
                var h2 = u2 + ":" + l2, d3 = n3[h2];
                void 0 === d3 && (r2.push(l2), n3[h2] = d3 = r2.length - 1), t3.writeVarint(d3);
              }
            }
          }
          function M(e3, t3) {
            return (t3 << 3) + (7 & e3);
          }
          function P(e3) {
            return e3 << 1 ^ e3 >> 31;
          }
          function k(e3, t3) {
            for (var o2 = e3.loadGeometry(), i3 = e3.type, r2 = 0, s2 = 0, n3 = o2.length, a3 = 0; a3 < n3; a3++) {
              var l2 = o2[a3], c5 = 1;
              1 === i3 && (c5 = l2.length), t3.writeVarint(M(1, c5));
              for (var u2 = 3 === i3 ? l2.length - 1 : l2.length, h2 = 0; h2 < u2; h2++) {
                1 === h2 && 1 !== i3 && t3.writeVarint(M(2, u2 - 1));
                var d3 = l2[h2].x - r2, p3 = l2[h2].y - s2;
                t3.writeVarint(P(d3)), t3.writeVarint(P(p3)), r2 += d3, s2 += p3;
              }
              3 === i3 && t3.writeVarint(M(7, 1));
            }
          }
          function T(e3, t3) {
            var o2 = typeof e3;
            "string" === o2 ? t3.writeStringField(1, e3) : "boolean" === o2 ? t3.writeBooleanField(7, e3) : "number" === o2 && (e3 % 1 != 0 ? t3.writeDoubleField(3, e3) : e3 < 0 ? t3.writeSVarintField(6, e3) : t3.writeVarintField(5, e3));
          }
          d2.exports = w, d2.exports.fromVectorTileJs = w, d2.exports.fromGeojsonVt = function(e3, t3) {
            t3 = t3 || {};
            var o2 = {};
            for (var i3 in e3)
              o2[i3] = new x(e3[i3].features, t3), o2[i3].name = i3, o2[i3].version = t3.version, o2[i3].extent = t3.extent;
            return w({ layers: o2 });
          }, d2.exports.GeoJSONWrapper = x;
          var C2 = e2.getDefaultExportFromCjs(d2.exports);
          const _ = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e3) => e3 }, D = Math.fround || (O = new Float32Array(1), (e3) => (O[0] = +e3, O[0]));
          var O;
          const L = 3, F = 5, E = 6;
          class z {
            constructor(e3) {
              this.options = Object.assign(Object.create(_), e3), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e3) {
              const { log: t3, minZoom: o2, maxZoom: i3 } = this.options;
              t3 && console.time("total time");
              const r2 = `prepare ${e3.length} points`;
              t3 && console.time(r2), this.points = e3;
              const s2 = [];
              for (let t4 = 0; t4 < e3.length; t4++) {
                const o3 = e3[t4];
                if (!o3.geometry)
                  continue;
                const [i4, r3] = o3.geometry.coordinates, n4 = D(B(i4)), a3 = D(Z(r3));
                s2.push(n4, a3, 1 / 0, t4, -1, 1), this.options.reduce && s2.push(0);
              }
              let n3 = this.trees[i3 + 1] = this._createTree(s2);
              t3 && console.timeEnd(r2);
              for (let e4 = i3; e4 >= o2; e4--) {
                const o3 = +Date.now();
                n3 = this.trees[e4] = this._createTree(this._cluster(n3, e4)), t3 && console.log("z%d: %d clusters in %dms", e4, n3.numItems, +Date.now() - o3);
              }
              return t3 && console.timeEnd("total time"), this;
            }
            getClusters(e3, t3) {
              let o2 = ((e3[0] + 180) % 360 + 360) % 360 - 180;
              const i3 = Math.max(-90, Math.min(90, e3[1]));
              let r2 = 180 === e3[2] ? 180 : ((e3[2] + 180) % 360 + 360) % 360 - 180;
              const s2 = Math.max(-90, Math.min(90, e3[3]));
              if (e3[2] - e3[0] >= 360)
                o2 = -180, r2 = 180;
              else if (o2 > r2) {
                const e4 = this.getClusters([o2, i3, 180, s2], t3), n4 = this.getClusters([-180, i3, r2, s2], t3);
                return e4.concat(n4);
              }
              const n3 = this.trees[this._limitZoom(t3)], a3 = n3.range(B(o2), Z(s2), B(r2), Z(i3)), l2 = n3.data, c5 = [];
              for (const e4 of a3) {
                const t4 = this.stride * e4;
                c5.push(l2[t4 + F] > 1 ? j(l2, t4, this.clusterProps) : this.points[l2[t4 + L]]);
              }
              return c5;
            }
            getChildren(e3) {
              const t3 = this._getOriginId(e3), o2 = this._getOriginZoom(e3), i3 = "No cluster with the specified id.", r2 = this.trees[o2];
              if (!r2)
                throw new Error(i3);
              const s2 = r2.data;
              if (t3 * this.stride >= s2.length)
                throw new Error(i3);
              const n3 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a3 = r2.within(s2[t3 * this.stride], s2[t3 * this.stride + 1], n3), l2 = [];
              for (const t4 of a3) {
                const o3 = t4 * this.stride;
                s2[o3 + 4] === e3 && l2.push(s2[o3 + F] > 1 ? j(s2, o3, this.clusterProps) : this.points[s2[o3 + L]]);
              }
              if (0 === l2.length)
                throw new Error(i3);
              return l2;
            }
            getLeaves(e3, t3, o2) {
              const i3 = [];
              return this._appendLeaves(i3, e3, t3 = t3 || 10, o2 = o2 || 0, 0), i3;
            }
            getTile(e3, t3, o2) {
              const i3 = this.trees[this._limitZoom(e3)], r2 = Math.pow(2, e3), { extent: s2, radius: n3 } = this.options, a3 = n3 / s2, l2 = (o2 - a3) / r2, c5 = (o2 + 1 + a3) / r2, u2 = { features: [] };
              return this._addTileFeatures(i3.range((t3 - a3) / r2, l2, (t3 + 1 + a3) / r2, c5), i3.data, t3, o2, r2, u2), 0 === t3 && this._addTileFeatures(i3.range(1 - a3 / r2, l2, 1, c5), i3.data, r2, o2, r2, u2), t3 === r2 - 1 && this._addTileFeatures(i3.range(0, l2, a3 / r2, c5), i3.data, -1, o2, r2, u2), u2.features.length ? u2 : null;
            }
            getClusterExpansionZoom(e3) {
              let t3 = this._getOriginZoom(e3) - 1;
              for (; t3 <= this.options.maxZoom; ) {
                const o2 = this.getChildren(e3);
                if (t3++, 1 !== o2.length)
                  break;
                e3 = o2[0].properties.cluster_id;
              }
              return t3;
            }
            _appendLeaves(e3, t3, o2, i3, r2) {
              const s2 = this.getChildren(t3);
              for (const t4 of s2) {
                const s3 = t4.properties;
                if (s3 && s3.cluster ? r2 + s3.point_count <= i3 ? r2 += s3.point_count : r2 = this._appendLeaves(e3, s3.cluster_id, o2, i3, r2) : r2 < i3 ? r2++ : e3.push(t4), e3.length === o2)
                  break;
              }
              return r2;
            }
            _createTree(t3) {
              const o2 = new e2.KDBush(t3.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e3 = 0; e3 < t3.length; e3 += this.stride)
                o2.add(t3[e3], t3[e3 + 1]);
              return o2.finish(), o2.data = t3, o2;
            }
            _addTileFeatures(e3, t3, o2, i3, r2, s2) {
              for (const n3 of e3) {
                const e4 = n3 * this.stride, a3 = t3[e4 + F] > 1;
                let l2, c5, u2;
                if (a3)
                  l2 = N(t3, e4, this.clusterProps), c5 = t3[e4], u2 = t3[e4 + 1];
                else {
                  const o3 = this.points[t3[e4 + L]];
                  l2 = o3.properties;
                  const [i4, r3] = o3.geometry.coordinates;
                  c5 = B(i4), u2 = Z(r3);
                }
                const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c5 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i3))]], tags: l2 };
                let d3;
                d3 = a3 || this.options.generateId ? t3[e4 + L] : this.points[t3[e4 + L]].id, void 0 !== d3 && (h2.id = d3), s2.features.push(h2);
              }
            }
            _limitZoom(e3) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e3), this.options.maxZoom + 1));
            }
            _cluster(e3, t3) {
              const { radius: o2, extent: i3, reduce: r2, minPoints: s2 } = this.options, n3 = o2 / (i3 * Math.pow(2, t3)), a3 = e3.data, l2 = [], c5 = this.stride;
              for (let o3 = 0; o3 < a3.length; o3 += c5) {
                if (a3[o3 + 2] <= t3)
                  continue;
                a3[o3 + 2] = t3;
                const i4 = a3[o3], u2 = a3[o3 + 1], h2 = e3.within(a3[o3], a3[o3 + 1], n3), d3 = a3[o3 + F];
                let p3 = d3;
                for (const e4 of h2) {
                  const o4 = e4 * c5;
                  a3[o4 + 2] > t3 && (p3 += a3[o4 + F]);
                }
                if (p3 > d3 && p3 >= s2) {
                  let e4, s3 = i4 * d3, n4 = u2 * d3, f2 = -1;
                  const g3 = ((o3 / c5 | 0) << 5) + (t3 + 1) + this.points.length;
                  for (const i5 of h2) {
                    const l3 = i5 * c5;
                    if (a3[l3 + 2] <= t3)
                      continue;
                    a3[l3 + 2] = t3;
                    const u3 = a3[l3 + F];
                    s3 += a3[l3] * u3, n4 += a3[l3 + 1] * u3, a3[l3 + 4] = g3, r2 && (e4 || (e4 = this._map(a3, o3, true), f2 = this.clusterProps.length, this.clusterProps.push(e4)), r2(e4, this._map(a3, l3)));
                  }
                  a3[o3 + 4] = g3, l2.push(s3 / p3, n4 / p3, 1 / 0, g3, -1, p3), r2 && l2.push(f2);
                } else {
                  for (let e4 = 0; e4 < c5; e4++)
                    l2.push(a3[o3 + e4]);
                  if (p3 > 1)
                    for (const e4 of h2) {
                      const o4 = e4 * c5;
                      if (!(a3[o4 + 2] <= t3)) {
                        a3[o4 + 2] = t3;
                        for (let e5 = 0; e5 < c5; e5++)
                          l2.push(a3[o4 + e5]);
                      }
                    }
                }
              }
              return l2;
            }
            _getOriginId(e3) {
              return e3 - this.points.length >> 5;
            }
            _getOriginZoom(e3) {
              return (e3 - this.points.length) % 32;
            }
            _map(e3, t3, o2) {
              if (e3[t3 + F] > 1) {
                const i4 = this.clusterProps[e3[t3 + E]];
                return o2 ? Object.assign({}, i4) : i4;
              }
              const i3 = this.points[e3[t3 + L]].properties, r2 = this.options.map(i3);
              return o2 && r2 === i3 ? Object.assign({}, r2) : r2;
            }
          }
          function j(e3, t3, o2) {
            return { type: "Feature", id: e3[t3 + L], properties: N(e3, t3, o2), geometry: { type: "Point", coordinates: [(i3 = e3[t3], 360 * (i3 - 0.5)), A(e3[t3 + 1])] } };
            var i3;
          }
          function N(e3, t3, o2) {
            const i3 = e3[t3 + F], r2 = i3 >= 1e4 ? `${Math.round(i3 / 1e3)}k` : i3 >= 1e3 ? Math.round(i3 / 100) / 10 + "k" : i3, s2 = e3[t3 + E], n3 = -1 === s2 ? {} : Object.assign({}, o2[s2]);
            return Object.assign(n3, { cluster: true, cluster_id: e3[t3 + L], point_count: i3, point_count_abbreviated: r2 });
          }
          function B(e3) {
            return e3 / 360 + 0.5;
          }
          function Z(e3) {
            const t3 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function A(e3) {
            const t3 = (180 - 360 * e3) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t3)) / Math.PI - 90;
          }
          function G(e3, t3, o2, i3) {
            for (var r2, s2 = i3, n3 = o2 - t3 >> 1, a3 = o2 - t3, l2 = e3[t3], c5 = e3[t3 + 1], u2 = e3[o2], h2 = e3[o2 + 1], d3 = t3 + 3; d3 < o2; d3 += 3) {
              var p3 = J(e3[d3], e3[d3 + 1], l2, c5, u2, h2);
              if (p3 > s2)
                r2 = d3, s2 = p3;
              else if (p3 === s2) {
                var f2 = Math.abs(d3 - n3);
                f2 < a3 && (r2 = d3, a3 = f2);
              }
            }
            s2 > i3 && (r2 - t3 > 3 && G(e3, t3, r2, i3), e3[r2 + 2] = s2, o2 - r2 > 3 && G(e3, r2, o2, i3));
          }
          function J(e3, t3, o2, i3, r2, s2) {
            var n3 = r2 - o2, a3 = s2 - i3;
            if (0 !== n3 || 0 !== a3) {
              var l2 = ((e3 - o2) * n3 + (t3 - i3) * a3) / (n3 * n3 + a3 * a3);
              l2 > 1 ? (o2 = r2, i3 = s2) : l2 > 0 && (o2 += n3 * l2, i3 += a3 * l2);
            }
            return (n3 = e3 - o2) * n3 + (a3 = t3 - i3) * a3;
          }
          function Y(e3, t3, o2, i3) {
            var r2 = { id: void 0 === e3 ? null : e3, type: t3, geometry: o2, tags: i3, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e4) {
              var t4 = e4.geometry, o3 = e4.type;
              if ("Point" === o3 || "MultiPoint" === o3 || "LineString" === o3)
                R(e4, t4);
              else if ("Polygon" === o3 || "MultiLineString" === o3)
                for (var i4 = 0; i4 < t4.length; i4++)
                  R(e4, t4[i4]);
              else if ("MultiPolygon" === o3)
                for (i4 = 0; i4 < t4.length; i4++)
                  for (var r3 = 0; r3 < t4[i4].length; r3++)
                    R(e4, t4[i4][r3]);
            }(r2), r2;
          }
          function R(e3, t3) {
            for (var o2 = 0; o2 < t3.length; o2 += 3)
              e3.minX = Math.min(e3.minX, t3[o2]), e3.minY = Math.min(e3.minY, t3[o2 + 1]), e3.maxX = Math.max(e3.maxX, t3[o2]), e3.maxY = Math.max(e3.maxY, t3[o2 + 1]);
          }
          function V(e3, t3, o2, i3) {
            if (t3.geometry) {
              var r2 = t3.geometry.coordinates, s2 = t3.geometry.type, n3 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2), a3 = [], l2 = t3.id;
              if (o2.promoteId ? l2 = t3.properties[o2.promoteId] : o2.generateId && (l2 = i3 || 0), "Point" === s2)
                X(r2, a3);
              else if ("MultiPoint" === s2)
                for (var c5 = 0; c5 < r2.length; c5++)
                  X(r2[c5], a3);
              else if ("LineString" === s2)
                W(r2, a3, n3, false);
              else if ("MultiLineString" === s2) {
                if (o2.lineMetrics) {
                  for (c5 = 0; c5 < r2.length; c5++)
                    W(r2[c5], a3 = [], n3, false), e3.push(Y(l2, "LineString", a3, t3.properties));
                  return;
                }
                q(r2, a3, n3, false);
              } else if ("Polygon" === s2)
                q(r2, a3, n3, true);
              else {
                if ("MultiPolygon" !== s2) {
                  if ("GeometryCollection" === s2) {
                    for (c5 = 0; c5 < t3.geometry.geometries.length; c5++)
                      V(e3, { id: l2, geometry: t3.geometry.geometries[c5], properties: t3.properties }, o2, i3);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (c5 = 0; c5 < r2.length; c5++) {
                  var u2 = [];
                  q(r2[c5], u2, n3, true), a3.push(u2);
                }
              }
              e3.push(Y(l2, s2, a3, t3.properties));
            }
          }
          function X(e3, t3) {
            t3.push($11(e3[0])), t3.push(U(e3[1])), t3.push(0);
          }
          function W(e3, t3, o2, i3) {
            for (var r2, s2, n3 = 0, a3 = 0; a3 < e3.length; a3++) {
              var l2 = $11(e3[a3][0]), c5 = U(e3[a3][1]);
              t3.push(l2), t3.push(c5), t3.push(0), a3 > 0 && (n3 += i3 ? (r2 * c5 - l2 * s2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c5 - s2, 2))), r2 = l2, s2 = c5;
            }
            var u2 = t3.length - 3;
            t3[2] = 1, G(t3, 0, u2, o2), t3[u2 + 2] = 1, t3.size = Math.abs(n3), t3.start = 0, t3.end = t3.size;
          }
          function q(e3, t3, o2, i3) {
            for (var r2 = 0; r2 < e3.length; r2++) {
              var s2 = [];
              W(e3[r2], s2, o2, i3), t3.push(s2);
            }
          }
          function $11(e3) {
            return e3 / 360 + 0.5;
          }
          function U(e3) {
            var t3 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t3) / (1 - t3)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function K(e3, t3, o2, i3, r2, s2, n3, a3) {
            if (i3 /= t3, s2 >= (o2 /= t3) && n3 < i3)
              return e3;
            if (n3 < o2 || s2 >= i3)
              return null;
            for (var l2 = [], c5 = 0; c5 < e3.length; c5++) {
              var u2 = e3[c5], h2 = u2.geometry, d3 = u2.type, p3 = 0 === r2 ? u2.minX : u2.minY, f2 = 0 === r2 ? u2.maxX : u2.maxY;
              if (p3 >= o2 && f2 < i3)
                l2.push(u2);
              else if (!(f2 < o2 || p3 >= i3)) {
                var g3 = [];
                if ("Point" === d3 || "MultiPoint" === d3)
                  H(h2, g3, o2, i3, r2);
                else if ("LineString" === d3)
                  Q(h2, g3, o2, i3, r2, false, a3.lineMetrics);
                else if ("MultiLineString" === d3)
                  te(h2, g3, o2, i3, r2, false);
                else if ("Polygon" === d3)
                  te(h2, g3, o2, i3, r2, true);
                else if ("MultiPolygon" === d3)
                  for (var m4 = 0; m4 < h2.length; m4++) {
                    var y2 = [];
                    te(h2[m4], y2, o2, i3, r2, true), y2.length && g3.push(y2);
                  }
                if (g3.length) {
                  if (a3.lineMetrics && "LineString" === d3) {
                    for (m4 = 0; m4 < g3.length; m4++)
                      l2.push(Y(u2.id, d3, g3[m4], u2.tags));
                    continue;
                  }
                  "LineString" !== d3 && "MultiLineString" !== d3 || (1 === g3.length ? (d3 = "LineString", g3 = g3[0]) : d3 = "MultiLineString"), "Point" !== d3 && "MultiPoint" !== d3 || (d3 = 3 === g3.length ? "Point" : "MultiPoint"), l2.push(Y(u2.id, d3, g3, u2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function H(e3, t3, o2, i3, r2) {
            for (var s2 = 0; s2 < e3.length; s2 += 3) {
              var n3 = e3[s2 + r2];
              n3 >= o2 && n3 <= i3 && (t3.push(e3[s2]), t3.push(e3[s2 + 1]), t3.push(e3[s2 + 2]));
            }
          }
          function Q(e3, t3, o2, i3, r2, s2, n3) {
            for (var a3, l2, c5 = ee(e3), u2 = 0 === r2 ? ie3 : re, h2 = e3.start, d3 = 0; d3 < e3.length - 3; d3 += 3) {
              var p3 = e3[d3], f2 = e3[d3 + 1], g3 = e3[d3 + 2], m4 = e3[d3 + 3], y2 = e3[d3 + 4], v2 = 0 === r2 ? p3 : f2, x2 = 0 === r2 ? m4 : y2, w2 = false;
              n3 && (a3 = Math.sqrt(Math.pow(p3 - m4, 2) + Math.pow(f2 - y2, 2))), v2 < o2 ? x2 > o2 && (l2 = u2(c5, p3, f2, m4, y2, o2), n3 && (c5.start = h2 + a3 * l2)) : v2 > i3 ? x2 < i3 && (l2 = u2(c5, p3, f2, m4, y2, i3), n3 && (c5.start = h2 + a3 * l2)) : oe(c5, p3, f2, g3), x2 < o2 && v2 >= o2 && (l2 = u2(c5, p3, f2, m4, y2, o2), w2 = true), x2 > i3 && v2 <= i3 && (l2 = u2(c5, p3, f2, m4, y2, i3), w2 = true), !s2 && w2 && (n3 && (c5.end = h2 + a3 * l2), t3.push(c5), c5 = ee(e3)), n3 && (h2 += a3);
            }
            var S2 = e3.length - 3;
            p3 = e3[S2], f2 = e3[S2 + 1], g3 = e3[S2 + 2], (v2 = 0 === r2 ? p3 : f2) >= o2 && v2 <= i3 && oe(c5, p3, f2, g3), S2 = c5.length - 3, s2 && S2 >= 3 && (c5[S2] !== c5[0] || c5[S2 + 1] !== c5[1]) && oe(c5, c5[0], c5[1], c5[2]), c5.length && t3.push(c5);
          }
          function ee(e3) {
            var t3 = [];
            return t3.size = e3.size, t3.start = e3.start, t3.end = e3.end, t3;
          }
          function te(e3, t3, o2, i3, r2, s2) {
            for (var n3 = 0; n3 < e3.length; n3++)
              Q(e3[n3], t3, o2, i3, r2, s2, false);
          }
          function oe(e3, t3, o2, i3) {
            e3.push(t3), e3.push(o2), e3.push(i3);
          }
          function ie3(e3, t3, o2, i3, r2, s2) {
            var n3 = (s2 - t3) / (i3 - t3);
            return e3.push(s2), e3.push(o2 + (r2 - o2) * n3), e3.push(1), n3;
          }
          function re(e3, t3, o2, i3, r2, s2) {
            var n3 = (s2 - o2) / (r2 - o2);
            return e3.push(t3 + (i3 - t3) * n3), e3.push(s2), e3.push(1), n3;
          }
          function se(e3, t3) {
            for (var o2 = [], i3 = 0; i3 < e3.length; i3++) {
              var r2, s2 = e3[i3], n3 = s2.type;
              if ("Point" === n3 || "MultiPoint" === n3 || "LineString" === n3)
                r2 = ne(s2.geometry, t3);
              else if ("MultiLineString" === n3 || "Polygon" === n3) {
                r2 = [];
                for (var a3 = 0; a3 < s2.geometry.length; a3++)
                  r2.push(ne(s2.geometry[a3], t3));
              } else if ("MultiPolygon" === n3)
                for (r2 = [], a3 = 0; a3 < s2.geometry.length; a3++) {
                  for (var l2 = [], c5 = 0; c5 < s2.geometry[a3].length; c5++)
                    l2.push(ne(s2.geometry[a3][c5], t3));
                  r2.push(l2);
                }
              o2.push(Y(s2.id, n3, r2, s2.tags));
            }
            return o2;
          }
          function ne(e3, t3) {
            var o2 = [];
            o2.size = e3.size, void 0 !== e3.start && (o2.start = e3.start, o2.end = e3.end);
            for (var i3 = 0; i3 < e3.length; i3 += 3)
              o2.push(e3[i3] + t3, e3[i3 + 1], e3[i3 + 2]);
            return o2;
          }
          function ae(e3, t3) {
            if (e3.transformed)
              return e3;
            var o2, i3, r2, s2 = 1 << e3.z, n3 = e3.x, a3 = e3.y;
            for (o2 = 0; o2 < e3.features.length; o2++) {
              var l2 = e3.features[o2], c5 = l2.geometry, u2 = l2.type;
              if (l2.geometry = [], 1 === u2)
                for (i3 = 0; i3 < c5.length; i3 += 2)
                  l2.geometry.push(le(c5[i3], c5[i3 + 1], t3, s2, n3, a3));
              else
                for (i3 = 0; i3 < c5.length; i3++) {
                  var h2 = [];
                  for (r2 = 0; r2 < c5[i3].length; r2 += 2)
                    h2.push(le(c5[i3][r2], c5[i3][r2 + 1], t3, s2, n3, a3));
                  l2.geometry.push(h2);
                }
            }
            return e3.transformed = true, e3;
          }
          function le(e3, t3, o2, i3, r2, s2) {
            return [Math.round(o2 * (e3 * i3 - r2)), Math.round(o2 * (t3 * i3 - s2))];
          }
          function ce(e3, t3, o2, i3, r2) {
            for (var s2 = t3 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t3) * r2.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: o2, y: i3, z: t3, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a3 = 0; a3 < e3.length; a3++) {
              n3.numFeatures++, ue(n3, e3[a3], s2, r2);
              var l2 = e3[a3].minX, c5 = e3[a3].minY, u2 = e3[a3].maxX, h2 = e3[a3].maxY;
              l2 < n3.minX && (n3.minX = l2), c5 < n3.minY && (n3.minY = c5), u2 > n3.maxX && (n3.maxX = u2), h2 > n3.maxY && (n3.maxY = h2);
            }
            return n3;
          }
          function ue(e3, t3, o2, i3) {
            var r2 = t3.geometry, s2 = t3.type, n3 = [];
            if ("Point" === s2 || "MultiPoint" === s2)
              for (var a3 = 0; a3 < r2.length; a3 += 3)
                n3.push(r2[a3]), n3.push(r2[a3 + 1]), e3.numPoints++, e3.numSimplified++;
            else if ("LineString" === s2)
              he(n3, r2, e3, o2, false, false);
            else if ("MultiLineString" === s2 || "Polygon" === s2)
              for (a3 = 0; a3 < r2.length; a3++)
                he(n3, r2[a3], e3, o2, "Polygon" === s2, 0 === a3);
            else if ("MultiPolygon" === s2)
              for (var l2 = 0; l2 < r2.length; l2++) {
                var c5 = r2[l2];
                for (a3 = 0; a3 < c5.length; a3++)
                  he(n3, c5[a3], e3, o2, true, 0 === a3);
              }
            if (n3.length) {
              var u2 = t3.tags || null;
              if ("LineString" === s2 && i3.lineMetrics) {
                for (var h2 in u2 = {}, t3.tags)
                  u2[h2] = t3.tags[h2];
                u2.mapbox_clip_start = r2.start / r2.size, u2.mapbox_clip_end = r2.end / r2.size;
              }
              var d3 = { geometry: n3, type: "Polygon" === s2 || "MultiPolygon" === s2 ? 3 : "LineString" === s2 || "MultiLineString" === s2 ? 2 : 1, tags: u2 };
              null !== t3.id && (d3.id = t3.id), e3.features.push(d3);
            }
          }
          function he(e3, t3, o2, i3, r2, s2) {
            var n3 = i3 * i3;
            if (i3 > 0 && t3.size < (r2 ? n3 : i3))
              o2.numPoints += t3.length / 3;
            else {
              for (var a3 = [], l2 = 0; l2 < t3.length; l2 += 3)
                (0 === i3 || t3[l2 + 2] > n3) && (o2.numSimplified++, a3.push(t3[l2]), a3.push(t3[l2 + 1])), o2.numPoints++;
              r2 && function(e4, t4) {
                for (var o3 = 0, i4 = 0, r3 = e4.length, s3 = r3 - 2; i4 < r3; s3 = i4, i4 += 2)
                  o3 += (e4[i4] - e4[s3]) * (e4[i4 + 1] + e4[s3 + 1]);
                if (o3 > 0 === t4)
                  for (i4 = 0, r3 = e4.length; i4 < r3 / 2; i4 += 2) {
                    var n4 = e4[i4], a4 = e4[i4 + 1];
                    e4[i4] = e4[r3 - 2 - i4], e4[i4 + 1] = e4[r3 - 1 - i4], e4[r3 - 2 - i4] = n4, e4[r3 - 1 - i4] = a4;
                  }
              }(a3, s2), e3.push(a3);
            }
          }
          function de(e3, t3) {
            var o2 = (t3 = this.options = function(e4, t4) {
              for (var o3 in t4)
                e4[o3] = t4[o3];
              return e4;
            }(Object.create(this.options), t3)).debug;
            if (o2 && console.time("preprocess data"), t3.maxZoom < 0 || t3.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t3.promoteId && t3.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var i3 = function(e4, t4) {
              var o3 = [];
              if ("FeatureCollection" === e4.type)
                for (var i4 = 0; i4 < e4.features.length; i4++)
                  V(o3, e4.features[i4], t4, i4);
              else
                V(o3, "Feature" === e4.type ? e4 : { geometry: e4 }, t4);
              return o3;
            }(e3, t3);
            this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t3.indexMaxZoom, t3.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i3 = function(e4, t4) {
              var o3 = t4.buffer / t4.extent, i4 = e4, r2 = K(e4, 1, -1 - o3, o3, 0, -1, 2, t4), s2 = K(e4, 1, 1 - o3, 2 + o3, 0, -1, 2, t4);
              return (r2 || s2) && (i4 = K(e4, 1, -o3, 1 + o3, 0, -1, 2, t4) || [], r2 && (i4 = se(r2, 1).concat(i4)), s2 && (i4 = i4.concat(se(s2, -1)))), i4;
            }(i3, t3), i3.length && this.splitTile(i3, 0, 0, 0), o2 && (i3.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function pe(e3, t3, o2) {
            return 32 * ((1 << e3) * o2 + t3) + e3;
          }
          function fe(e3, t3) {
            return t3 ? e3.properties[t3] : e3.id;
          }
          function ge(e3, t3) {
            if (null == e3)
              return true;
            if ("Feature" === e3.type)
              return null != fe(e3, t3);
            if ("FeatureCollection" === e3.type) {
              const o2 = /* @__PURE__ */ new Set();
              for (const i3 of e3.features) {
                const e4 = fe(i3, t3);
                if (null == e4)
                  return false;
                if (o2.has(e4))
                  return false;
                o2.add(e4);
              }
              return true;
            }
            return false;
          }
          function me(e3, t3) {
            const o2 = /* @__PURE__ */ new Map();
            if (null == e3)
              ;
            else if ("Feature" === e3.type)
              o2.set(fe(e3, t3), e3);
            else
              for (const i3 of e3.features)
                o2.set(fe(i3, t3), i3);
            return o2;
          }
          function ye(t3, o2) {
            const i3 = t3.tileID.canonical;
            if (!this._geoJSONIndex)
              return o2(null, null);
            const r2 = this._geoJSONIndex.getTile(i3.z, i3.x, i3.y);
            if (!r2)
              return o2(null, null);
            const s2 = new class {
              constructor(t4) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e2.EXTENT, this.length = t4.length, this._features = t4;
              }
              feature(t4) {
                return new class {
                  constructor(t5) {
                    this._feature = t5, this.extent = e2.EXTENT, this.type = t5.type, this.properties = t5.tags, "id" in t5 && !isNaN(t5.id) && (this.id = parseInt(t5.id, 10));
                  }
                  loadGeometry() {
                    if (1 === this._feature.type) {
                      const t5 = [];
                      for (const o3 of this._feature.geometry)
                        t5.push([new e2.Point(o3[0], o3[1])]);
                      return t5;
                    }
                    {
                      const t5 = [];
                      for (const o3 of this._feature.geometry) {
                        const i4 = [];
                        for (const t6 of o3)
                          i4.push(new e2.Point(t6[0], t6[1]));
                        t5.push(i4);
                      }
                      return t5;
                    }
                  }
                  toGeoJSON(e3, t5, o3) {
                    return h.call(this, e3, t5, o3);
                  }
                }(this._features[t4]);
              }
            }(r2.features);
            let n3 = C2(s2);
            0 === n3.byteOffset && n3.byteLength === n3.buffer.byteLength || (n3 = new Uint8Array(n3)), o2(null, { vectorTile: s2, rawData: n3.buffer });
          }
          de.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, de.prototype.splitTile = function(e3, t3, o2, i3, r2, s2, n3) {
            for (var a3 = [e3, t3, o2, i3], l2 = this.options, c5 = l2.debug; a3.length; ) {
              i3 = a3.pop(), o2 = a3.pop(), t3 = a3.pop(), e3 = a3.pop();
              var u2 = 1 << t3, h2 = pe(t3, o2, i3), d3 = this.tiles[h2];
              if (!d3 && (c5 > 1 && console.time("creation"), d3 = this.tiles[h2] = ce(e3, t3, o2, i3, l2), this.tileCoords.push({ z: t3, x: o2, y: i3 }), c5)) {
                c5 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t3, o2, i3, d3.numFeatures, d3.numPoints, d3.numSimplified), console.timeEnd("creation"));
                var p3 = "z" + t3;
                this.stats[p3] = (this.stats[p3] || 0) + 1, this.total++;
              }
              if (d3.source = e3, r2) {
                if (t3 === l2.maxZoom || t3 === r2)
                  continue;
                var f2 = 1 << r2 - t3;
                if (o2 !== Math.floor(s2 / f2) || i3 !== Math.floor(n3 / f2))
                  continue;
              } else if (t3 === l2.indexMaxZoom || d3.numPoints <= l2.indexMaxPoints)
                continue;
              if (d3.source = null, 0 !== e3.length) {
                c5 > 1 && console.time("clipping");
                var g3, m4, y2, v2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, b3 = 0.5 - S2, I2 = 0.5 + S2, M2 = 1 + S2;
                g3 = m4 = y2 = v2 = null, x2 = K(e3, u2, o2 - S2, o2 + I2, 0, d3.minX, d3.maxX, l2), w2 = K(e3, u2, o2 + b3, o2 + M2, 0, d3.minX, d3.maxX, l2), e3 = null, x2 && (g3 = K(x2, u2, i3 - S2, i3 + I2, 1, d3.minY, d3.maxY, l2), m4 = K(x2, u2, i3 + b3, i3 + M2, 1, d3.minY, d3.maxY, l2), x2 = null), w2 && (y2 = K(w2, u2, i3 - S2, i3 + I2, 1, d3.minY, d3.maxY, l2), v2 = K(w2, u2, i3 + b3, i3 + M2, 1, d3.minY, d3.maxY, l2), w2 = null), c5 > 1 && console.timeEnd("clipping"), a3.push(g3 || [], t3 + 1, 2 * o2, 2 * i3), a3.push(m4 || [], t3 + 1, 2 * o2, 2 * i3 + 1), a3.push(y2 || [], t3 + 1, 2 * o2 + 1, 2 * i3), a3.push(v2 || [], t3 + 1, 2 * o2 + 1, 2 * i3 + 1);
              }
            }
          }, de.prototype.getTile = function(e3, t3, o2) {
            var i3 = this.options, r2 = i3.extent, s2 = i3.debug;
            if (e3 < 0 || e3 > 24)
              return null;
            var n3 = 1 << e3, a3 = pe(e3, t3 = (t3 % n3 + n3) % n3, o2);
            if (this.tiles[a3])
              return ae(this.tiles[a3], r2);
            s2 > 1 && console.log("drilling down to z%d-%d-%d", e3, t3, o2);
            for (var l2, c5 = e3, u2 = t3, h2 = o2; !l2 && c5 > 0; )
              c5--, u2 = Math.floor(u2 / 2), h2 = Math.floor(h2 / 2), l2 = this.tiles[pe(c5, u2, h2)];
            return l2 && l2.source ? (s2 > 1 && console.log("found parent tile z%d-%d-%d", c5, u2, h2), s2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c5, u2, h2, e3, t3, o2), s2 > 1 && console.timeEnd("drilling down"), this.tiles[a3] ? ae(this.tiles[a3], r2) : null) : null;
          };
          class ve extends n2 {
            constructor(t3, o2, i3, r2) {
              super(t3, o2, i3, ye), this._dataUpdateable = /* @__PURE__ */ new Map(), this.loadGeoJSON = (t4, o3) => {
                const { promoteId: i4 } = t4;
                if (t4.request)
                  return e2.getJSON(t4.request, (e3, t5, r3, s2) => {
                    this._dataUpdateable = ge(t5, i4) ? me(t5, i4) : void 0, o3(e3, t5, r3, s2);
                  });
                if ("string" == typeof t4.data)
                  try {
                    const e3 = JSON.parse(t4.data);
                    this._dataUpdateable = ge(e3, i4) ? me(e3, i4) : void 0, o3(null, e3);
                  } catch (e3) {
                    o3(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
                  }
                else
                  t4.dataDiff ? this._dataUpdateable ? (function(e3, t5, o4) {
                    var i5, r3, s2, n3;
                    if (t5.removeAll && e3.clear(), t5.remove)
                      for (const o5 of t5.remove)
                        e3.delete(o5);
                    if (t5.add)
                      for (const i6 of t5.add) {
                        const t6 = fe(i6, o4);
                        null != t6 && e3.set(t6, i6);
                      }
                    if (t5.update)
                      for (const o5 of t5.update) {
                        let t6 = e3.get(o5.id);
                        if (null == t6)
                          continue;
                        const a3 = !o5.removeAllProperties && ((null === (i5 = o5.removeProperties) || void 0 === i5 ? void 0 : i5.length) > 0 || (null === (r3 = o5.addOrUpdateProperties) || void 0 === r3 ? void 0 : r3.length) > 0);
                        if ((o5.newGeometry || o5.removeAllProperties || a3) && (t6 = { ...t6 }, e3.set(o5.id, t6), a3 && (t6.properties = { ...t6.properties })), o5.newGeometry && (t6.geometry = o5.newGeometry), o5.removeAllProperties)
                          t6.properties = {};
                        else if ((null === (s2 = o5.removeProperties) || void 0 === s2 ? void 0 : s2.length) > 0)
                          for (const e4 of o5.removeProperties)
                            Object.prototype.hasOwnProperty.call(t6.properties, e4) && delete t6.properties[e4];
                        if ((null === (n3 = o5.addOrUpdateProperties) || void 0 === n3 ? void 0 : n3.length) > 0)
                          for (const { key: e4, value: i6 } of o5.addOrUpdateProperties)
                            t6.properties[e4] = i6;
                      }
                  }(this._dataUpdateable, t4.dataDiff, i4), o3(null, { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) })) : o3(new Error(`Cannot update existing geojson data in ${t4.source}`)) : o3(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
                return { cancel: () => {
                } };
              }, r2 && (this.loadGeoJSON = r2);
            }
            loadData(t3, o2) {
              var i3;
              null === (i3 = this._pendingRequest) || void 0 === i3 || i3.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
              const r2 = !!(t3 && t3.request && t3.request.collectResourceTiming) && new e2.RequestPerformance(t3.request);
              this._pendingCallback = o2, this._pendingRequest = this.loadGeoJSON(t3, (i4, s2) => {
                if (delete this._pendingCallback, delete this._pendingRequest, i4 || !s2)
                  return o2(i4);
                if ("object" != typeof s2)
                  return o2(new Error(`Input data given to '${t3.source}' is not a valid GeoJSON object.`));
                {
                  u(s2, true);
                  try {
                    if (t3.filter) {
                      const o3 = e2.createExpression(t3.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === o3.result)
                        throw new Error(o3.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
                      const i5 = s2.features.filter((e3) => o3.value.evaluate({ zoom: 0 }, e3));
                      s2 = { type: "FeatureCollection", features: i5 };
                    }
                    this._geoJSONIndex = t3.cluster ? new z(function({ superclusterOptions: t4, clusterProperties: o3 }) {
                      if (!o3 || !t4)
                        return t4;
                      const i5 = {}, r3 = {}, s3 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a3 = Object.keys(o3);
                      for (const t5 of a3) {
                        const [s4, n5] = o3[t5], a4 = e2.createExpression(n5), l2 = e2.createExpression("string" == typeof s4 ? [s4, ["accumulated"], ["get", t5]] : s4);
                        i5[t5] = a4.value, r3[t5] = l2.value;
                      }
                      return t4.map = (e3) => {
                        n4.properties = e3;
                        const t5 = {};
                        for (const e4 of a3)
                          t5[e4] = i5[e4].evaluate(s3, n4);
                        return t5;
                      }, t4.reduce = (e3, t5) => {
                        n4.properties = t5;
                        for (const t6 of a3)
                          s3.accumulated = e3[t6], e3[t6] = r3[t6].evaluate(s3, n4);
                      }, t4;
                    }(t3)).load(s2.features) : function(e3, t4) {
                      return new de(e3, t4);
                    }(s2, t3.geojsonVtOptions);
                  } catch (i5) {
                    return o2(i5);
                  }
                  this.loaded = {};
                  const n3 = {};
                  if (r2) {
                    const e3 = r2.finish();
                    e3 && (n3.resourceTiming = {}, n3.resourceTiming[t3.source] = JSON.parse(JSON.stringify(e3)));
                  }
                  o2(null, n3);
                }
              });
            }
            reloadTile(e3, t3) {
              const o2 = this.loaded;
              return o2 && o2[e3.uid] ? super.reloadTile(e3, t3) : this.loadTile(e3, t3);
            }
            removeSource(e3, t3) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
            }
            getClusterExpansionZoom(e3, t3) {
              try {
                t3(null, this._geoJSONIndex.getClusterExpansionZoom(e3.clusterId));
              } catch (e4) {
                t3(e4);
              }
            }
            getClusterChildren(e3, t3) {
              try {
                t3(null, this._geoJSONIndex.getChildren(e3.clusterId));
              } catch (e4) {
                t3(e4);
              }
            }
            getClusterLeaves(e3, t3) {
              try {
                t3(null, this._geoJSONIndex.getLeaves(e3.clusterId, e3.limit, e3.offset));
              } catch (e4) {
                t3(e4);
              }
            }
          }
          class xe {
            constructor(t3) {
              this.self = t3, this.actor = new e2.Actor(t3, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: n2, geojson: ve }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e3, t4) => {
                if (this.workerSourceTypes[e3])
                  throw new Error(`Worker source with name "${e3}" already registered.`);
                this.workerSourceTypes[e3] = t4;
              }, this.self.registerRTLTextPlugin = (t4) => {
                if (e2.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e2.plugin.applyArabicShaping = t4.applyArabicShaping, e2.plugin.processBidirectionalText = t4.processBidirectionalText, e2.plugin.processStyledBidirectionalText = t4.processStyledBidirectionalText;
              };
            }
            setReferrer(e3, t3) {
              this.referrer = t3;
            }
            setImages(e3, t3, o2) {
              this.availableImages[e3] = t3;
              for (const o3 in this.workerSources[e3]) {
                const i3 = this.workerSources[e3][o3];
                for (const e4 in i3)
                  i3[e4].availableImages = t3;
              }
              o2();
            }
            setLayers(e3, t3, o2) {
              this.getLayerIndex(e3).replace(t3), o2();
            }
            updateLayers(e3, t3, o2) {
              this.getLayerIndex(e3).update(t3.layers, t3.removedIds), o2();
            }
            loadTile(e3, t3, o2) {
              this.getWorkerSource(e3, t3.type, t3.source).loadTile(t3, o2);
            }
            loadDEMTile(e3, t3, o2) {
              this.getDEMWorkerSource(e3, t3.source).loadTile(t3, o2);
            }
            reloadTile(e3, t3, o2) {
              this.getWorkerSource(e3, t3.type, t3.source).reloadTile(t3, o2);
            }
            abortTile(e3, t3, o2) {
              this.getWorkerSource(e3, t3.type, t3.source).abortTile(t3, o2);
            }
            removeTile(e3, t3, o2) {
              this.getWorkerSource(e3, t3.type, t3.source).removeTile(t3, o2);
            }
            removeDEMTile(e3, t3) {
              this.getDEMWorkerSource(e3, t3.source).removeTile(t3);
            }
            removeSource(e3, t3, o2) {
              if (!this.workerSources[e3] || !this.workerSources[e3][t3.type] || !this.workerSources[e3][t3.type][t3.source])
                return;
              const i3 = this.workerSources[e3][t3.type][t3.source];
              delete this.workerSources[e3][t3.type][t3.source], void 0 !== i3.removeSource ? i3.removeSource(t3, o2) : o2();
            }
            loadWorkerSource(e3, t3, o2) {
              try {
                this.self.importScripts(t3.url), o2();
              } catch (e4) {
                o2(e4.toString());
              }
            }
            syncRTLPluginState(t3, o2, i3) {
              try {
                e2.plugin.setState(o2);
                const t4 = e2.plugin.getPluginURL();
                if (e2.plugin.isLoaded() && !e2.plugin.isParsed() && null != t4) {
                  this.self.importScripts(t4);
                  const o3 = e2.plugin.isParsed();
                  i3(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t4}`), o3);
                }
              } catch (e3) {
                i3(e3.toString());
              }
            }
            getAvailableImages(e3) {
              let t3 = this.availableImages[e3];
              return t3 || (t3 = []), t3;
            }
            getLayerIndex(e3) {
              let o2 = this.layerIndexes[e3];
              return o2 || (o2 = this.layerIndexes[e3] = new t2()), o2;
            }
            getWorkerSource(e3, t3, o2) {
              if (this.workerSources[e3] || (this.workerSources[e3] = {}), this.workerSources[e3][t3] || (this.workerSources[e3][t3] = {}), !this.workerSources[e3][t3][o2]) {
                const i3 = { send: (t4, o3, i4) => {
                  this.actor.send(t4, o3, i4, e3);
                } };
                this.workerSources[e3][t3][o2] = new this.workerSourceTypes[t3](i3, this.getLayerIndex(e3), this.getAvailableImages(e3));
              }
              return this.workerSources[e3][t3][o2];
            }
            getDEMWorkerSource(e3, t3) {
              return this.demWorkerSources[e3] || (this.demWorkerSources[e3] = {}), this.demWorkerSources[e3][t3] || (this.demWorkerSources[e3][t3] = new a2()), this.demWorkerSources[e3][t3];
            }
          }
          return e2.isWorker() && (self.worker = new xe(self)), xe;
        });
        define2(["./shared"], function(t2) {
          "use strict";
          var e2 = "3.2.0";
          class i2 {
            static testProp(t3) {
              if (!i2.docStyle)
                return t3[0];
              for (let e3 = 0; e3 < t3.length; e3++)
                if (t3[e3] in i2.docStyle)
                  return t3[e3];
              return t3[0];
            }
            static create(t3, e3, i3) {
              const s2 = window.document.createElement(t3);
              return void 0 !== e3 && (s2.className = e3), i3 && i3.appendChild(s2), s2;
            }
            static createNS(t3, e3) {
              return window.document.createElementNS(t3, e3);
            }
            static disableDrag() {
              i2.docStyle && i2.selectProp && (i2.userSelect = i2.docStyle[i2.selectProp], i2.docStyle[i2.selectProp] = "none");
            }
            static enableDrag() {
              i2.docStyle && i2.selectProp && (i2.docStyle[i2.selectProp] = i2.userSelect);
            }
            static setTransform(t3, e3) {
              t3.style[i2.transformProp] = e3;
            }
            static addEventListener(t3, e3, i3, s2 = {}) {
              t3.addEventListener(e3, i3, "passive" in s2 ? s2 : s2.capture);
            }
            static removeEventListener(t3, e3, i3, s2 = {}) {
              t3.removeEventListener(e3, i3, "passive" in s2 ? s2 : s2.capture);
            }
            static suppressClickInternal(t3) {
              t3.preventDefault(), t3.stopPropagation(), window.removeEventListener("click", i2.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", i2.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", i2.suppressClickInternal, true);
              }, 0);
            }
            static mousePos(e3, i3) {
              const s2 = e3.getBoundingClientRect();
              return new t2.Point(i3.clientX - s2.left - e3.clientLeft, i3.clientY - s2.top - e3.clientTop);
            }
            static touchPos(e3, i3) {
              const s2 = e3.getBoundingClientRect(), a3 = [];
              for (let o2 = 0; o2 < i3.length; o2++)
                a3.push(new t2.Point(i3[o2].clientX - s2.left - e3.clientLeft, i3[o2].clientY - s2.top - e3.clientTop));
              return a3;
            }
            static mouseButton(t3) {
              return t3.button;
            }
            static remove(t3) {
              t3.parentNode && t3.parentNode.removeChild(t3);
            }
          }
          i2.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, i2.selectProp = i2.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), i2.transformProp = i2.testProp(["transform", "WebkitTransform"]);
          const s = { supported: false, testSupport: function(t3) {
            !r && o && (n2 ? l(t3) : a2 = t3);
          } };
          let a2, o, r = false, n2 = false;
          function l(t3) {
            const e3 = t3.createTexture();
            t3.bindTexture(t3.TEXTURE_2D, e3);
            try {
              if (t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o), t3.isContextLost())
                return;
              s.supported = true;
            } catch (t4) {
            }
            t3.deleteTexture(e3), r = true;
          }
          var c4, h;
          "undefined" != typeof document && (o = document.createElement("img"), o.onload = function() {
            a2 && l(a2), a2 = null, n2 = true;
          }, o.onerror = function() {
            r = true, a2 = null;
          }, o.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e3) {
            let i3, a3, o2, r2;
            e3.resetRequestQueue = () => {
              i3 = [], a3 = 0, o2 = 0, r2 = {};
            }, e3.addThrottleControl = (t3) => {
              const e4 = o2++;
              return r2[e4] = t3, e4;
            }, e3.removeThrottleControl = (t3) => {
              delete r2[t3], c5();
            }, e3.getImage = (t3, e4, o3 = true) => {
              s.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*");
              const r3 = { requestParameters: t3, supportImageRefresh: o3, callback: e4, cancelled: false, completed: false, cancel: () => {
                r3.completed || r3.cancelled || (r3.cancelled = true, r3.innerRequest && (r3.innerRequest.cancel(), a3--), c5());
              } };
              return i3.push(r3), c5(), r3;
            };
            const n3 = (e4) => {
              const { requestParameters: i4, supportImageRefresh: s2, callback: a4 } = e4;
              return t2.extend(i4, { type: "image" }), (false !== s2 || t2.isWorker() || t2.getProtocolAction(i4.url) || i4.headers && !Object.keys(i4.headers).reduce((t3, e5) => t3 && "accept" === e5, true) ? t2.makeRequest : h2)(i4, (t3, i5, s3, o3) => {
                l2(e4, a4, t3, i5, s3, o3);
              });
            }, l2 = (e4, i4, s2, o3, r3, n4) => {
              s2 ? i4(s2) : o3 instanceof HTMLImageElement || o3 instanceof ImageBitmap ? i4(null, o3) : o3 && ((e5, i5) => {
                "function" == typeof createImageBitmap ? t2.arrayBufferToImageBitmap(e5, i5) : t2.arrayBufferToImage(e5, i5);
              })(o3, (t3, e5) => {
                null != t3 ? i4(t3) : null != e5 && i4(null, e5, { cacheControl: r3, expires: n4 });
              }), e4.cancelled || (e4.completed = true, a3--, c5());
            }, c5 = () => {
              const e4 = (() => {
                const t3 = Object.keys(r2);
                let e5 = false;
                if (t3.length > 0) {
                  for (const i4 of t3)
                    if (e5 = r2[i4](), e5)
                      break;
                }
                return e5;
              })() ? t2.config.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t2.config.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let t3 = a3; t3 < e4 && i3.length > 0; t3++) {
                const e5 = i3.shift();
                if (e5.cancelled) {
                  t3--;
                  continue;
                }
                const s2 = n3(e5);
                a3++, e5.innerRequest = s2;
              }
            }, h2 = (e4, i4) => {
              const s2 = new Image(), a4 = e4.url;
              let o3 = false;
              const r3 = e4.credentials;
              return r3 && "include" === r3 ? s2.crossOrigin = "use-credentials" : (r3 && "same-origin" === r3 || !t2.sameOrigin(a4)) && (s2.crossOrigin = "anonymous"), s2.fetchPriority = "high", s2.onload = () => {
                i4(null, s2), s2.onerror = s2.onload = null;
              }, s2.onerror = () => {
                o3 || i4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), s2.onerror = s2.onload = null;
              }, s2.src = a4, { cancel: () => {
                o3 = true, s2.src = "";
              } };
            };
          }(c4 || (c4 = {})), c4.resetRequestQueue(), function(t3) {
            t3.Glyphs = "Glyphs", t3.Image = "Image", t3.Source = "Source", t3.SpriteImage = "SpriteImage", t3.SpriteJSON = "SpriteJSON", t3.Style = "Style", t3.Tile = "Tile", t3.Unknown = "Unknown";
          }(h || (h = {}));
          class u {
            constructor(t3) {
              this._transformRequestFn = t3;
            }
            transformRequest(t3, e3) {
              return this._transformRequestFn && this._transformRequestFn(t3, e3) || { url: t3 };
            }
            normalizeSpriteURL(t3, e3, i3) {
              const s2 = function(t4) {
                const e4 = t4.match(d2);
                if (!e4)
                  throw new Error(`Unable to parse URL "${t4}"`);
                return { protocol: e4[1], authority: e4[2], path: e4[3] || "/", params: e4[4] ? e4[4].split("&") : [] };
              }(t3);
              return s2.path += `${e3}${i3}`, function(t4) {
                const e4 = t4.params.length ? `?${t4.params.join("&")}` : "";
                return `${t4.protocol}://${t4.authority}${t4.path}${e4}`;
              }(s2);
            }
            setTransformRequest(t3) {
              this._transformRequestFn = t3;
            }
          }
          const d2 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function _(e3) {
            var i3 = new t2.ARRAY_TYPE(3);
            return i3[0] = e3[0], i3[1] = e3[1], i3[2] = e3[2], i3;
          }
          var m3, p2 = function(t3, e3, i3) {
            return t3[0] = e3[0] - i3[0], t3[1] = e3[1] - i3[1], t3[2] = e3[2] - i3[2], t3;
          };
          m3 = new t2.ARRAY_TYPE(3), t2.ARRAY_TYPE != Float32Array && (m3[0] = 0, m3[1] = 0, m3[2] = 0);
          var f = function(t3) {
            var e3 = t3[0], i3 = t3[1];
            return e3 * e3 + i3 * i3;
          };
          function g2(t3) {
            const e3 = [];
            if ("string" == typeof t3)
              e3.push({ id: "default", url: t3 });
            else if (t3 && t3.length > 0) {
              const i3 = [];
              for (const { id: s2, url: a3 } of t3) {
                const t4 = `${s2}${a3}`;
                -1 === i3.indexOf(t4) && (i3.push(t4), e3.push({ id: s2, url: a3 }));
              }
            }
            return e3;
          }
          function v(e3, i3, s2, a3, o2) {
            if (a3)
              return void e3(a3);
            if (o2 !== Object.values(i3).length || o2 !== Object.values(s2).length)
              return;
            const r2 = {};
            for (const e4 in i3) {
              r2[e4] = {};
              const a4 = t2.browser.getImageCanvasContext(s2[e4]), o3 = i3[e4];
              for (const t3 in o3) {
                const { width: i4, height: s3, x: n3, y: l2, sdf: c5, pixelRatio: h2, stretchX: u2, stretchY: d3, content: _2 } = o3[t3];
                r2[e4][t3] = { data: null, pixelRatio: h2, sdf: c5, stretchX: u2, stretchY: d3, content: _2, spriteData: { width: i4, height: s3, x: n3, y: l2, context: a4 } };
              }
            }
            e3(null, r2);
          }
          !function() {
            var e3 = new t2.ARRAY_TYPE(2);
            t2.ARRAY_TYPE != Float32Array && (e3[0] = 0, e3[1] = 0);
          }();
          class x {
            constructor(t3, e3, i3, s2) {
              this.context = t3, this.format = i3, this.texture = t3.gl.createTexture(), this.update(e3, s2);
            }
            update(e3, i3, s2) {
              const { width: a3, height: o2 } = e3, r2 = !(this.size && this.size[0] === a3 && this.size[1] === o2 || s2), { context: n3 } = this, { gl: l2 } = n3;
              if (this.useMipmap = Boolean(i3 && i3.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n3.pixelStoreUnpackFlipY.set(false), n3.pixelStoreUnpack.set(1), n3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i3 || false !== i3.premultiply)), r2)
                this.size = [a3, o2], e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t2.isImageBitmap(e3) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e3) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a3, o2, 0, this.format, l2.UNSIGNED_BYTE, e3.data);
              else {
                const { x: i4, y: r3 } = s2 || { x: 0, y: 0 };
                e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t2.isImageBitmap(e3) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i4, r3, l2.RGBA, l2.UNSIGNED_BYTE, e3) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i4, r3, a3, o2, l2.RGBA, l2.UNSIGNED_BYTE, e3.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
            }
            bind(t3, e3, i3) {
              const { context: s2 } = this, { gl: a3 } = s2;
              a3.bindTexture(a3.TEXTURE_2D, this.texture), i3 !== a3.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i3 = a3.LINEAR), t3 !== this.filter && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MAG_FILTER, t3), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_MIN_FILTER, i3 || t3), this.filter = t3), e3 !== this.wrap && (a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_S, e3), a3.texParameteri(a3.TEXTURE_2D, a3.TEXTURE_WRAP_T, e3), this.wrap = e3);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t3 } = this.context;
              t3.deleteTexture(this.texture), this.texture = null;
            }
          }
          function y(t3) {
            const { userImage: e3 } = t3;
            return !!(e3 && e3.render && e3.render()) && (t3.data.replace(new Uint8Array(e3.data.buffer)), true);
          }
          class b2 extends t2.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t2.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(t3) {
              if (this.loaded !== t3 && (this.loaded = t3, t3)) {
                for (const { ids: t4, callback: e3 } of this.requestors)
                  this._notify(t4, e3);
                this.requestors = [];
              }
            }
            getImage(e3) {
              const i3 = this.images[e3];
              if (i3 && !i3.data && i3.spriteData) {
                const e4 = i3.spriteData;
                i3.data = new t2.RGBAImage({ width: e4.width, height: e4.height }, e4.context.getImageData(e4.x, e4.y, e4.width, e4.height).data), i3.spriteData = null;
              }
              return i3;
            }
            addImage(t3, e3) {
              if (this.images[t3])
                throw new Error(`Image id ${t3} already exist, use updateImage instead`);
              this._validate(t3, e3) && (this.images[t3] = e3);
            }
            _validate(e3, i3) {
              let s2 = true;
              const a3 = i3.data || i3.spriteData;
              return this._validateStretch(i3.stretchX, a3 && a3.width) || (this.fire(new t2.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchX" value`))), s2 = false), this._validateStretch(i3.stretchY, a3 && a3.height) || (this.fire(new t2.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchY" value`))), s2 = false), this._validateContent(i3.content, i3) || (this.fire(new t2.ErrorEvent(new Error(`Image "${e3}" has invalid "content" value`))), s2 = false), s2;
            }
            _validateStretch(t3, e3) {
              if (!t3)
                return true;
              let i3 = 0;
              for (const s2 of t3) {
                if (s2[0] < i3 || s2[1] < s2[0] || e3 < s2[1])
                  return false;
                i3 = s2[1];
              }
              return true;
            }
            _validateContent(t3, e3) {
              if (!t3)
                return true;
              if (4 !== t3.length)
                return false;
              const i3 = e3.spriteData, s2 = i3 && i3.width || e3.data.width, a3 = i3 && i3.height || e3.data.height;
              return !(t3[0] < 0 || s2 < t3[0] || t3[1] < 0 || a3 < t3[1] || t3[2] < 0 || s2 < t3[2] || t3[3] < 0 || a3 < t3[3] || t3[2] < t3[0] || t3[3] < t3[1]);
            }
            updateImage(t3, e3, i3 = true) {
              const s2 = this.getImage(t3);
              if (i3 && (s2.data.width !== e3.data.width || s2.data.height !== e3.data.height))
                throw new Error(`size mismatch between old image (${s2.data.width}x${s2.data.height}) and new image (${e3.data.width}x${e3.data.height}).`);
              e3.version = s2.version + 1, this.images[t3] = e3, this.updatedImages[t3] = true;
            }
            removeImage(t3) {
              const e3 = this.images[t3];
              delete this.images[t3], delete this.patterns[t3], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(t3, e3) {
              let i3 = true;
              if (!this.isLoaded())
                for (const e4 of t3)
                  this.images[e4] || (i3 = false);
              this.isLoaded() || i3 ? this._notify(t3, e3) : this.requestors.push({ ids: t3, callback: e3 });
            }
            _notify(e3, i3) {
              const s2 = {};
              for (const i4 of e3) {
                let e4 = this.getImage(i4);
                e4 || (this.fire(new t2.Event("styleimagemissing", { id: i4 })), e4 = this.getImage(i4)), e4 ? s2[i4] = { data: e4.data.clone(), pixelRatio: e4.pixelRatio, sdf: e4.sdf, version: e4.version, stretchX: e4.stretchX, stretchY: e4.stretchY, content: e4.content, hasRenderCallback: Boolean(e4.userImage && e4.userImage.render) } : t2.warnOnce(`Image "${i4}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i3(null, s2);
            }
            getPixelSize() {
              const { width: t3, height: e3 } = this.atlasImage;
              return { width: t3, height: e3 };
            }
            getPattern(e3) {
              const i3 = this.patterns[e3], s2 = this.getImage(e3);
              if (!s2)
                return null;
              if (i3 && i3.position.version === s2.version)
                return i3.position;
              if (i3)
                i3.position.version = s2.version;
              else {
                const i4 = { w: s2.data.width + 2, h: s2.data.height + 2, x: 0, y: 0 }, a3 = new t2.ImagePosition(i4, s2);
                this.patterns[e3] = { bin: i4, position: a3 };
              }
              return this._updatePatternAtlas(), this.patterns[e3].position;
            }
            bind(t3) {
              const e3 = t3.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new x(t3, this.atlasImage, e3.RGBA), this.atlasTexture.bind(e3.LINEAR, e3.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e3 = [];
              for (const t3 in this.patterns)
                e3.push(this.patterns[t3].bin);
              const { w: i3, h: s2 } = t2.potpack(e3), a3 = this.atlasImage;
              a3.resize({ width: i3 || 1, height: s2 || 1 });
              for (const e4 in this.patterns) {
                const { bin: i4 } = this.patterns[e4], s3 = i4.x + 1, o2 = i4.y + 1, r2 = this.getImage(e4).data, n3 = r2.width, l2 = r2.height;
                t2.RGBAImage.copy(r2, a3, { x: 0, y: 0 }, { x: s3, y: o2 }, { width: n3, height: l2 }), t2.RGBAImage.copy(r2, a3, { x: 0, y: l2 - 1 }, { x: s3, y: o2 - 1 }, { width: n3, height: 1 }), t2.RGBAImage.copy(r2, a3, { x: 0, y: 0 }, { x: s3, y: o2 + l2 }, { width: n3, height: 1 }), t2.RGBAImage.copy(r2, a3, { x: n3 - 1, y: 0 }, { x: s3 - 1, y: o2 }, { width: 1, height: l2 }), t2.RGBAImage.copy(r2, a3, { x: 0, y: 0 }, { x: s3 + n3, y: o2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e3) {
              for (const i3 of e3) {
                if (this.callbackDispatchedThisFrame[i3])
                  continue;
                this.callbackDispatchedThisFrame[i3] = true;
                const e4 = this.getImage(i3);
                e4 || t2.warnOnce(`Image with ID: "${i3}" was not found`), y(e4) && this.updateImage(i3, e4);
              }
            }
          }
          const w = 1e20;
          function T(t3, e3, i3, s2, a3, o2, r2, n3, l2) {
            for (let c5 = e3; c5 < e3 + s2; c5++)
              E(t3, i3 * o2 + c5, o2, a3, r2, n3, l2);
            for (let c5 = i3; c5 < i3 + a3; c5++)
              E(t3, c5 * o2 + e3, 1, s2, r2, n3, l2);
          }
          function E(t3, e3, i3, s2, a3, o2, r2) {
            o2[0] = 0, r2[0] = -w, r2[1] = w, a3[0] = t3[e3];
            for (let n3 = 1, l2 = 0, c5 = 0; n3 < s2; n3++) {
              a3[n3] = t3[e3 + n3 * i3];
              const s3 = n3 * n3;
              do {
                const t4 = o2[l2];
                c5 = (a3[n3] - a3[t4] + s3 - t4 * t4) / (n3 - t4) / 2;
              } while (c5 <= r2[l2] && --l2 > -1);
              l2++, o2[l2] = n3, r2[l2] = c5, r2[l2 + 1] = w;
            }
            for (let n3 = 0, l2 = 0; n3 < s2; n3++) {
              for (; r2[l2 + 1] < n3; )
                l2++;
              const s3 = o2[l2], c5 = n3 - s3;
              t3[e3 + n3 * i3] = a3[s3] + c5 * c5;
            }
          }
          class I {
            constructor(t3, e3) {
              this.requestManager = t3, this.localIdeographFontFamily = e3, this.entries = {};
            }
            setURL(t3) {
              this.url = t3;
            }
            getGlyphs(e3, i3) {
              const s2 = [];
              for (const t3 in e3)
                for (const i4 of e3[t3])
                  s2.push({ stack: t3, id: i4 });
              t2.asyncAll(s2, ({ stack: t3, id: e4 }, i4) => {
                let s3 = this.entries[t3];
                s3 || (s3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {} });
                let a3 = s3.glyphs[e4];
                if (void 0 !== a3)
                  return void i4(null, { stack: t3, id: e4, glyph: a3 });
                if (a3 = this._tinySDF(s3, t3, e4), a3)
                  return s3.glyphs[e4] = a3, void i4(null, { stack: t3, id: e4, glyph: a3 });
                const o2 = Math.floor(e4 / 256);
                if (256 * o2 > 65535)
                  return void i4(new Error("glyphs > 65535 not supported"));
                if (s3.ranges[o2])
                  return void i4(null, { stack: t3, id: e4, glyph: a3 });
                if (!this.url)
                  return void i4(new Error("glyphsUrl is not set"));
                let r2 = s3.requests[o2];
                r2 || (r2 = s3.requests[o2] = [], I.loadGlyphRange(t3, o2, this.url, this.requestManager, (t4, e5) => {
                  if (e5) {
                    for (const t5 in e5)
                      this._doesCharSupportLocalGlyph(+t5) || (s3.glyphs[+t5] = e5[+t5]);
                    s3.ranges[o2] = true;
                  }
                  for (const i5 of r2)
                    i5(t4, e5);
                  delete s3.requests[o2];
                })), r2.push((s4, a4) => {
                  s4 ? i4(s4) : a4 && i4(null, { stack: t3, id: e4, glyph: a4[e4] || null });
                });
              }, (t3, e4) => {
                if (t3)
                  i3(t3);
                else if (e4) {
                  const t4 = {};
                  for (const { stack: i4, id: s3, glyph: a3 } of e4)
                    (t4[i4] || (t4[i4] = {}))[s3] = a3 && { id: a3.id, bitmap: a3.bitmap.clone(), metrics: a3.metrics };
                  i3(null, t4);
                }
              });
            }
            _doesCharSupportLocalGlyph(e3) {
              return !!this.localIdeographFontFamily && (t2.unicodeBlockLookup["CJK Unified Ideographs"](e3) || t2.unicodeBlockLookup["Hangul Syllables"](e3) || t2.unicodeBlockLookup.Hiragana(e3) || t2.unicodeBlockLookup.Katakana(e3));
            }
            _tinySDF(e3, i3, s2) {
              const a3 = this.localIdeographFontFamily;
              if (!a3)
                return;
              if (!this._doesCharSupportLocalGlyph(s2))
                return;
              let o2 = e3.tinySDF;
              if (!o2) {
                let t3 = "400";
                /bold/i.test(i3) ? t3 = "900" : /medium/i.test(i3) ? t3 = "500" : /light/i.test(i3) && (t3 = "200"), o2 = e3.tinySDF = new I.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a3, fontWeight: t3 });
              }
              const r2 = o2.draw(String.fromCharCode(s2));
              return { id: s2, bitmap: new t2.AlphaImage({ width: r2.width || 30, height: r2.height || 30 }, r2.data), metrics: { width: r2.glyphWidth || 24, height: r2.glyphHeight || 24, left: r2.glyphLeft || 0, top: r2.glyphTop - 27 || -8, advance: r2.glyphAdvance || 24 } };
            }
          }
          I.loadGlyphRange = function(e3, i3, s2, a3, o2) {
            const r2 = 256 * i3, n3 = r2 + 255, l2 = a3.transformRequest(s2.replace("{fontstack}", e3).replace("{range}", `${r2}-${n3}`), h.Glyphs);
            t2.getArrayBuffer(l2, (e4, i4) => {
              if (e4)
                o2(e4);
              else if (i4) {
                const e5 = {};
                for (const s3 of t2.parseGlyphPbf(i4))
                  e5[s3.id] = s3;
                o2(null, e5);
              }
            });
          }, I.TinySDF = class {
            constructor({ fontSize: t3 = 24, buffer: e3 = 3, radius: i3 = 8, cutoff: s2 = 0.25, fontFamily: a3 = "sans-serif", fontWeight: o2 = "normal", fontStyle: r2 = "normal" } = {}) {
              this.buffer = e3, this.cutoff = s2, this.radius = i3;
              const n3 = this.size = t3 + 4 * e3, l2 = this._createCanvas(n3), c5 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              c5.font = `${r2} ${o2} ${t3}px ${a3}`, c5.textBaseline = "alphabetic", c5.textAlign = "left", c5.fillStyle = "black", this.gridOuter = new Float64Array(n3 * n3), this.gridInner = new Float64Array(n3 * n3), this.f = new Float64Array(n3), this.z = new Float64Array(n3 + 1), this.v = new Uint16Array(n3);
            }
            _createCanvas(t3) {
              const e3 = document.createElement("canvas");
              return e3.width = e3.height = t3, e3;
            }
            draw(t3) {
              const { width: e3, actualBoundingBoxAscent: i3, actualBoundingBoxDescent: s2, actualBoundingBoxLeft: a3, actualBoundingBoxRight: o2 } = this.ctx.measureText(t3), r2 = Math.ceil(i3), n3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - a3))), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(s2)), c5 = n3 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, u2 = Math.max(c5 * h2, 0), d3 = new Uint8ClampedArray(u2), _2 = { data: d3, width: c5, height: h2, glyphWidth: n3, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e3 };
              if (0 === n3 || 0 === l2)
                return _2;
              const { ctx: m4, buffer: p3, gridInner: f2, gridOuter: g3 } = this;
              m4.clearRect(p3, p3, n3, l2), m4.fillText(t3, p3, p3 + r2);
              const v2 = m4.getImageData(p3, p3, n3, l2);
              g3.fill(w, 0, u2), f2.fill(0, 0, u2);
              for (let t4 = 0; t4 < l2; t4++)
                for (let e4 = 0; e4 < n3; e4++) {
                  const i4 = v2.data[4 * (t4 * n3 + e4) + 3] / 255;
                  if (0 === i4)
                    continue;
                  const s3 = (t4 + p3) * c5 + e4 + p3;
                  if (1 === i4)
                    g3[s3] = 0, f2[s3] = w;
                  else {
                    const t5 = 0.5 - i4;
                    g3[s3] = t5 > 0 ? t5 * t5 : 0, f2[s3] = t5 < 0 ? t5 * t5 : 0;
                  }
                }
              T(g3, 0, 0, c5, h2, c5, this.f, this.v, this.z), T(f2, p3, p3, n3, l2, c5, this.f, this.v, this.z);
              for (let t4 = 0; t4 < u2; t4++) {
                const e4 = Math.sqrt(g3[t4]) - Math.sqrt(f2[t4]);
                d3[t4] = Math.round(255 - 255 * (e4 / this.radius + this.cutoff));
              }
              return _2;
            }
          };
          class S {
            constructor() {
              this.specification = t2.v8Spec.light.position;
            }
            possiblyEvaluate(e3, i3) {
              return t2.sphericalToCartesian(e3.expression.evaluate(i3));
            }
            interpolate(e3, i3, s2) {
              return { x: t2.interpolate.number(e3.x, i3.x, s2), y: t2.interpolate.number(e3.y, i3.y, s2), z: t2.interpolate.number(e3.z, i3.z, s2) };
            }
          }
          let C2, P;
          class D extends t2.Evented {
            constructor(e3) {
              super(), C2 = C2 || new t2.Properties({ anchor: new t2.DataConstantProperty(t2.v8Spec.light.anchor), position: new S(), color: new t2.DataConstantProperty(t2.v8Spec.light.color), intensity: new t2.DataConstantProperty(t2.v8Spec.light.intensity) }), this._transitionable = new t2.Transitionable(C2), this.setLight(e3), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e3, i3 = {}) {
              if (!this._validate(t2.validateLight, e3, i3))
                for (const t3 in e3) {
                  const i4 = e3[t3];
                  t3.endsWith("-transition") ? this._transitionable.setTransition(t3.slice(0, -11), i4) : this._transitionable.setValue(t3, i4);
                }
            }
            updateTransitions(t3) {
              this._transitioning = this._transitionable.transitioned(t3, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t3) {
              this.properties = this._transitioning.possiblyEvaluate(t3);
            }
            _validate(e3, i3, s2) {
              return (!s2 || false !== s2.validate) && t2.emitValidationErrors(this, e3.call(t2.validateStyle, t2.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t2.v8Spec })));
            }
          }
          class z {
            constructor(t3, e3) {
              this.width = t3, this.height = e3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(t3, e3) {
              const i3 = t3.join(",") + String(e3);
              return this.dashEntry[i3] || (this.dashEntry[i3] = this.addDash(t3, e3)), this.dashEntry[i3];
            }
            getDashRanges(t3, e3, i3) {
              const s2 = [];
              let a3 = t3.length % 2 == 1 ? -t3[t3.length - 1] * i3 : 0, o2 = t3[0] * i3, r2 = true;
              s2.push({ left: a3, right: o2, isDash: r2, zeroLength: 0 === t3[0] });
              let n3 = t3[0];
              for (let e4 = 1; e4 < t3.length; e4++) {
                r2 = !r2;
                const l2 = t3[e4];
                a3 = n3 * i3, n3 += l2, o2 = n3 * i3, s2.push({ left: a3, right: o2, isDash: r2, zeroLength: 0 === l2 });
              }
              return s2;
            }
            addRoundDash(t3, e3, i3) {
              const s2 = e3 / 2;
              for (let e4 = -i3; e4 <= i3; e4++) {
                const a3 = this.width * (this.nextRow + i3 + e4);
                let o2 = 0, r2 = t3[o2];
                for (let n3 = 0; n3 < this.width; n3++) {
                  n3 / r2.right > 1 && (r2 = t3[++o2]);
                  const l2 = Math.abs(n3 - r2.left), c5 = Math.abs(n3 - r2.right), h2 = Math.min(l2, c5);
                  let u2;
                  const d3 = e4 / i3 * (s2 + 1);
                  if (r2.isDash) {
                    const t4 = s2 - Math.abs(d3);
                    u2 = Math.sqrt(h2 * h2 + t4 * t4);
                  } else
                    u2 = s2 - Math.sqrt(h2 * h2 + d3 * d3);
                  this.data[a3 + n3] = Math.max(0, Math.min(255, u2 + 128));
                }
              }
            }
            addRegularDash(t3) {
              for (let e4 = t3.length - 1; e4 >= 0; --e4) {
                const i4 = t3[e4], s3 = t3[e4 + 1];
                i4.zeroLength ? t3.splice(e4, 1) : s3 && s3.isDash === i4.isDash && (s3.left = i4.left, t3.splice(e4, 1));
              }
              const e3 = t3[0], i3 = t3[t3.length - 1];
              e3.isDash === i3.isDash && (e3.left = i3.left - this.width, i3.right = e3.right + this.width);
              const s2 = this.width * this.nextRow;
              let a3 = 0, o2 = t3[a3];
              for (let e4 = 0; e4 < this.width; e4++) {
                e4 / o2.right > 1 && (o2 = t3[++a3]);
                const i4 = Math.abs(e4 - o2.left), r2 = Math.abs(e4 - o2.right), n3 = Math.min(i4, r2);
                this.data[s2 + e4] = Math.max(0, Math.min(255, (o2.isDash ? n3 : -n3) + 128));
              }
            }
            addDash(e3, i3) {
              const s2 = i3 ? 7 : 0, a3 = 2 * s2 + 1;
              if (this.nextRow + a3 > this.height)
                return t2.warnOnce("LineAtlas out of space"), null;
              let o2 = 0;
              for (let t3 = 0; t3 < e3.length; t3++)
                o2 += e3[t3];
              if (0 !== o2) {
                const t3 = this.width / o2, a4 = this.getDashRanges(e3, this.width, t3);
                i3 ? this.addRoundDash(a4, t3, s2) : this.addRegularDash(a4);
              }
              const r2 = { y: (this.nextRow + s2 + 0.5) / this.height, height: 2 * s2 / this.height, width: o2 };
              return this.nextRow += a3, this.dirty = true, r2;
            }
            bind(t3) {
              const e3 = t3.gl;
              this.texture ? (e3.bindTexture(e3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e3.texSubImage2D(e3.TEXTURE_2D, 0, 0, 0, this.width, this.height, e3.ALPHA, e3.UNSIGNED_BYTE, this.data))) : (this.texture = e3.createTexture(), e3.bindTexture(e3.TEXTURE_2D, this.texture), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_S, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_T, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MIN_FILTER, e3.LINEAR), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MAG_FILTER, e3.LINEAR), e3.texImage2D(e3.TEXTURE_2D, 0, e3.ALPHA, this.width, this.height, 0, e3.ALPHA, e3.UNSIGNED_BYTE, this.data));
            }
          }
          class M {
            constructor(t3, e3, i3) {
              this.workerPool = t3, this.actors = [], this.currentActor = 0, this.id = i3;
              const s2 = this.workerPool.acquire(i3);
              for (let t4 = 0; t4 < s2.length; t4++) {
                const a3 = new M.Actor(s2[t4], e3, i3);
                a3.name = `Worker ${t4}`, this.actors.push(a3);
              }
              if (!this.actors.length)
                throw new Error("No actors found");
            }
            broadcast(e3, i3, s2) {
              t2.asyncAll(this.actors, (t3, s3) => {
                t3.send(e3, i3, s3);
              }, s2 = s2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove(t3 = true) {
              this.actors.forEach((t4) => {
                t4.remove();
              }), this.actors = [], t3 && this.workerPool.release(this.id);
            }
          }
          function A(e3, i3, s2) {
            const a3 = function(i4, a4) {
              if (i4)
                return s2(i4);
              if (a4) {
                const i5 = t2.pick(t2.extend(a4, e3), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                a4.vector_layers && (i5.vectorLayers = a4.vector_layers, i5.vectorLayerIds = i5.vectorLayers.map((t3) => t3.id)), s2(null, i5);
              }
            };
            return e3.url ? t2.getJSON(i3.transformRequest(e3.url, h.Source), a3) : t2.browser.frame(() => a3(null, e3));
          }
          M.Actor = t2.Actor;
          class L {
            constructor(t3, e3) {
              t3 && (e3 ? this.setSouthWest(t3).setNorthEast(e3) : Array.isArray(t3) && (4 === t3.length ? this.setSouthWest([t3[0], t3[1]]).setNorthEast([t3[2], t3[3]]) : this.setSouthWest(t3[0]).setNorthEast(t3[1])));
            }
            setNorthEast(e3) {
              return this._ne = e3 instanceof t2.LngLat ? new t2.LngLat(e3.lng, e3.lat) : t2.LngLat.convert(e3), this;
            }
            setSouthWest(e3) {
              return this._sw = e3 instanceof t2.LngLat ? new t2.LngLat(e3.lng, e3.lat) : t2.LngLat.convert(e3), this;
            }
            extend(e3) {
              const i3 = this._sw, s2 = this._ne;
              let a3, o2;
              if (e3 instanceof t2.LngLat)
                a3 = e3, o2 = e3;
              else {
                if (!(e3 instanceof L))
                  return Array.isArray(e3) ? 4 === e3.length || e3.every(Array.isArray) ? this.extend(L.convert(e3)) : this.extend(t2.LngLat.convert(e3)) : e3 && ("lng" in e3 || "lon" in e3) && "lat" in e3 ? this.extend(t2.LngLat.convert(e3)) : this;
                if (a3 = e3._sw, o2 = e3._ne, !a3 || !o2)
                  return this;
              }
              return i3 || s2 ? (i3.lng = Math.min(a3.lng, i3.lng), i3.lat = Math.min(a3.lat, i3.lat), s2.lng = Math.max(o2.lng, s2.lng), s2.lat = Math.max(o2.lat, s2.lat)) : (this._sw = new t2.LngLat(a3.lng, a3.lat), this._ne = new t2.LngLat(o2.lng, o2.lat)), this;
            }
            getCenter() {
              return new t2.LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new t2.LngLat(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new t2.LngLat(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(e3) {
              const { lng: i3, lat: s2 } = t2.LngLat.convert(e3);
              let a3 = this._sw.lng <= i3 && i3 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (a3 = this._sw.lng >= i3 && i3 >= this._ne.lng), this._sw.lat <= s2 && s2 <= this._ne.lat && a3;
            }
            static convert(t3) {
              return t3 instanceof L ? t3 : t3 ? new L(t3) : t3;
            }
            static fromLngLat(e3, i3 = 0) {
              const s2 = 360 * i3 / 40075017, a3 = s2 / Math.cos(Math.PI / 180 * e3.lat);
              return new L(new t2.LngLat(e3.lng - a3, e3.lat - s2), new t2.LngLat(e3.lng + a3, e3.lat + s2));
            }
          }
          class R {
            constructor(t3, e3, i3) {
              this.bounds = L.convert(this.validateBounds(t3)), this.minzoom = e3 || 0, this.maxzoom = i3 || 24;
            }
            validateBounds(t3) {
              return Array.isArray(t3) && 4 === t3.length ? [Math.max(-180, t3[0]), Math.max(-90, t3[1]), Math.min(180, t3[2]), Math.min(90, t3[3])] : [-180, -90, 180, 90];
            }
            contains(e3) {
              const i3 = Math.pow(2, e3.z), s2 = Math.floor(t2.mercatorXfromLng(this.bounds.getWest()) * i3), a3 = Math.floor(t2.mercatorYfromLat(this.bounds.getNorth()) * i3), o2 = Math.ceil(t2.mercatorXfromLng(this.bounds.getEast()) * i3), r2 = Math.ceil(t2.mercatorYfromLat(this.bounds.getSouth()) * i3);
              return e3.x >= s2 && e3.x < o2 && e3.y >= a3 && e3.y < r2;
            }
          }
          class k extends t2.Evented {
            constructor(e3, i3, s2, a3) {
              if (super(), this.load = () => {
                this._loaded = false, this.fire(new t2.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = A(this._options, this.map._requestManager, (e4, i4) => {
                  this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e4 ? this.fire(new t2.ErrorEvent(e4)) : i4 && (t2.extend(this, i4), i4.bounds && (this.tileBounds = new R(i4.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "content" })));
                });
              }, this.serialize = () => t2.extend({}, this._options), this.id = e3, this.dispatcher = s2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t2.extend(this, t2.pick(i3, ["url", "scheme", "tileSize", "promoteId"])), this._options = t2.extend({ type: "vector" }, i3), this._collectResourceTiming = i3.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(a3);
            }
            loaded() {
              return this._loaded;
            }
            hasTile(t3) {
              return !this.tileBounds || this.tileBounds.contains(t3.canonical);
            }
            onAdd(t3) {
              this.map = t3, this.load();
            }
            setSourceProperty(t3) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t3(), this.load();
            }
            setTiles(t3) {
              return this.setSourceProperty(() => {
                this._options.tiles = t3;
              }), this;
            }
            setUrl(t3) {
              return this.setSourceProperty(() => {
                this.url = t3, this._options.url = t3;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            loadTile(t3, e3) {
              const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s2 = { request: this.map._requestManager.transformRequest(i3, h.Tile), uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, tileSize: this.tileSize * t3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              function a3(i4, s3) {
                return delete t3.request, t3.aborted ? e3(null) : i4 && 404 !== i4.status ? e3(i4) : (s3 && s3.resourceTiming && (t3.resourceTiming = s3.resourceTiming), this.map._refreshExpiredTiles && s3 && t3.setExpiryData(s3), t3.loadVectorData(s3, this.map.painter), e3(null), void (t3.reloadCallback && (this.loadTile(t3, t3.reloadCallback), t3.reloadCallback = null)));
              }
              s2.request.collectResourceTiming = this._collectResourceTiming, t3.actor && "expired" !== t3.state ? "loading" === t3.state ? t3.reloadCallback = e3 : t3.request = t3.actor.send("reloadTile", s2, a3.bind(this)) : (t3.actor = this.dispatcher.getActor(), t3.request = t3.actor.send("loadTile", s2, a3.bind(this)));
            }
            abortTile(t3) {
              t3.request && (t3.request.cancel(), delete t3.request), t3.actor && t3.actor.send("abortTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
            }
            unloadTile(t3) {
              t3.unloadVectorData(), t3.actor && t3.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id }, void 0);
            }
            hasTransition() {
              return false;
            }
          }
          class B extends t2.Evented {
            constructor(e3, i3, s2, a3) {
              super(), this.id = e3, this.dispatcher = s2, this.setEventedParent(a3), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t2.extend({ type: "raster" }, i3), t2.extend(this, t2.pick(i3, ["url", "scheme", "tileSize"]));
            }
            load() {
              this._loaded = false, this.fire(new t2.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = A(this._options, this.map._requestManager, (e3, i3) => {
                this._tileJSONRequest = null, this._loaded = true, e3 ? this.fire(new t2.ErrorEvent(e3)) : i3 && (t2.extend(this, i3), i3.bounds && (this.tileBounds = new R(i3.bounds, this.minzoom, this.maxzoom)), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t3) {
              this.map = t3, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t2.extend({}, this._options);
            }
            hasTile(t3) {
              return !this.tileBounds || this.tileBounds.contains(t3.canonical);
            }
            loadTile(t3, e3) {
              const i3 = t3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t3.request = c4.getImage(this.map._requestManager.transformRequest(i3, h.Tile), (i4, s2, a3) => {
                if (delete t3.request, t3.aborted)
                  t3.state = "unloaded", e3(null);
                else if (i4)
                  t3.state = "errored", e3(i4);
                else if (s2) {
                  this.map._refreshExpiredTiles && a3 && t3.setExpiryData(a3);
                  const i5 = this.map.painter.context, o2 = i5.gl;
                  t3.texture = this.map.painter.getTileTexture(s2.width), t3.texture ? t3.texture.update(s2, { useMipmap: true }) : (t3.texture = new x(i5, s2, o2.RGBA, { useMipmap: true }), t3.texture.bind(o2.LINEAR, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), i5.extTextureFilterAnisotropic && o2.texParameterf(o2.TEXTURE_2D, i5.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i5.extTextureFilterAnisotropicMax)), t3.state = "loaded", e3(null);
                }
              }, this.map._refreshExpiredTiles);
            }
            abortTile(t3, e3) {
              t3.request && (t3.request.cancel(), delete t3.request), e3();
            }
            unloadTile(t3, e3) {
              t3.texture && this.map.painter.saveTileTexture(t3.texture), e3();
            }
            hasTransition() {
              return false;
            }
          }
          class F extends B {
            constructor(e3, i3, s2, a3) {
              super(e3, i3, s2, a3), this.type = "raster-dem", this.maxzoom = 22, this._options = t2.extend({ type: "raster-dem" }, i3), this.encoding = i3.encoding || "mapbox";
            }
            serialize() {
              return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
            }
            loadTile(e3, i3) {
              const s2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              function a3(t3, s3) {
                t3 && (e3.state = "errored", i3(t3)), s3 && (e3.dem = s3, e3.needsHillshadePrepare = true, e3.needsTerrainPrepare = true, e3.state = "loaded", i3(null));
              }
              e3.request = c4.getImage(this.map._requestManager.transformRequest(s2, h.Tile), function(s3, o2) {
                if (delete e3.request, e3.aborted)
                  e3.state = "unloaded", i3(null);
                else if (s3)
                  e3.state = "errored", i3(s3);
                else if (o2) {
                  this.map._refreshExpiredTiles && e3.setExpiryData(o2), delete o2.cacheControl, delete o2.expires;
                  const i4 = t2.isImageBitmap(o2) && (null == P && (P = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), P) ? o2 : t2.browser.getImageData(o2, 1), s4 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: i4, encoding: this.encoding };
                  e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", s4, a3.bind(this)));
                }
              }.bind(this), this.map._refreshExpiredTiles), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
            }
            _getNeighboringTiles(e3) {
              const i3 = e3.canonical, s2 = Math.pow(2, i3.z), a3 = (i3.x - 1 + s2) % s2, o2 = 0 === i3.x ? e3.wrap - 1 : e3.wrap, r2 = (i3.x + 1 + s2) % s2, n3 = i3.x + 1 === s2 ? e3.wrap + 1 : e3.wrap, l2 = {};
              return l2[new t2.OverscaledTileID(e3.overscaledZ, o2, i3.z, a3, i3.y).key] = { backfilled: false }, l2[new t2.OverscaledTileID(e3.overscaledZ, n3, i3.z, r2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new t2.OverscaledTileID(e3.overscaledZ, o2, i3.z, a3, i3.y - 1).key] = { backfilled: false }, l2[new t2.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new t2.OverscaledTileID(e3.overscaledZ, n3, i3.z, r2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < s2 && (l2[new t2.OverscaledTileID(e3.overscaledZ, o2, i3.z, a3, i3.y + 1).key] = { backfilled: false }, l2[new t2.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new t2.OverscaledTileID(e3.overscaledZ, n3, i3.z, r2, i3.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(t3) {
              t3.demTexture && this.map.painter.saveTileTexture(t3.demTexture), t3.fbo && (t3.fbo.destroy(), delete t3.fbo), t3.dem && delete t3.dem, delete t3.neighboringTiles, t3.state = "unloaded", t3.actor && t3.actor.send("removeDEMTile", { uid: t3.uid, source: this.id });
            }
          }
          class U extends t2.Evented {
            constructor(e3, i3, s2, a3) {
              super(), this.load = () => {
                this._updateWorkerData();
              }, this.serialize = () => t2.extend({}, this._options, { type: this.type, data: this._data }), this.id = e3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s2.getActor(), this.setEventedParent(a3), this._data = i3.data, this._options = t2.extend({}, i3), this._collectResourceTiming = i3.collectResourceTiming, void 0 !== i3.maxzoom && (this.maxzoom = i3.maxzoom), i3.type && (this.type = i3.type), i3.attribution && (this.attribution = i3.attribution), this.promoteId = i3.promoteId;
              const o2 = t2.EXTENT / this.tileSize;
              this.workerOptions = t2.extend({ source: this.id, cluster: i3.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i3.buffer ? i3.buffer : 128) * o2, tolerance: (void 0 !== i3.tolerance ? i3.tolerance : 0.375) * o2, extent: t2.EXTENT, maxZoom: this.maxzoom, lineMetrics: i3.lineMetrics || false, generateId: i3.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i3.clusterMaxZoom ? i3.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i3.clusterMinPoints || 2), extent: t2.EXTENT, radius: (i3.clusterRadius || 50) * o2, log: false, generateId: i3.generateId || false }, clusterProperties: i3.clusterProperties, filter: i3.filter }, i3.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
            }
            onAdd(t3) {
              this.map = t3, this.load();
            }
            setData(t3) {
              return this._data = t3, this._updateWorkerData(), this;
            }
            updateData(t3) {
              return this._updateWorkerData(t3), this;
            }
            setClusterOptions(t3) {
              return this.workerOptions.cluster = t3.cluster, t3 && (void 0 !== t3.clusterRadius && (this.workerOptions.superclusterOptions.radius = t3.clusterRadius), void 0 !== t3.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t3.clusterMaxZoom)), this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(t3, e3) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t3, source: this.id }, e3), this;
            }
            getClusterChildren(t3, e3) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t3, source: this.id }, e3), this;
            }
            getClusterLeaves(t3, e3, i3, s2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t3, limit: e3, offset: i3 }, s2), this;
            }
            _updateWorkerData(e3) {
              const i3 = t2.extend({}, this.workerOptions);
              e3 ? i3.dataDiff = e3 : "string" == typeof this._data ? (i3.request = this.map._requestManager.transformRequest(t2.browser.resolveURL(this._data), h.Source), i3.request.collectResourceTiming = this._collectResourceTiming) : i3.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t2.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i3, (e4, i4) => {
                if (this._pendingLoads--, this._removed || i4 && i4.abandoned)
                  return void this.fire(new t2.Event("dataabort", { dataType: "source" }));
                let s2 = null;
                if (i4 && i4.resourceTiming && i4.resourceTiming[this.id] && (s2 = i4.resourceTiming[this.id].slice(0)), e4)
                  return void this.fire(new t2.ErrorEvent(e4));
                const a3 = { dataType: "source" };
                this._collectResourceTiming && s2 && s2.length > 0 && t2.extend(a3, { resourceTiming: s2 }), this.fire(new t2.Event("data", { ...a3, sourceDataType: "metadata" })), this.fire(new t2.Event("data", { ...a3, sourceDataType: "content" }));
              });
            }
            loaded() {
              return 0 === this._pendingLoads;
            }
            loadTile(t3, e3) {
              const i3 = t3.actor ? "reloadTile" : "loadTile";
              t3.actor = this.actor;
              const s2 = { type: this.type, uid: t3.uid, tileID: t3.tileID, zoom: t3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t3.request = this.actor.send(i3, s2, (s3, a3) => (delete t3.request, t3.unloadVectorData(), t3.aborted ? e3(null) : s3 ? e3(s3) : (t3.loadVectorData(a3, this.map.painter, "reloadTile" === i3), e3(null))));
            }
            abortTile(t3) {
              t3.request && (t3.request.cancel(), delete t3.request), t3.aborted = true;
            }
            unloadTile(t3) {
              t3.unloadVectorData(), this.actor.send("removeTile", { uid: t3.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
            }
            hasTransition() {
              return false;
            }
          }
          var O = t2.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class N extends t2.Evented {
            constructor(e3, i3, s2, a3) {
              super(), this.load = (e4, i4) => {
                this._loaded = false, this.fire(new t2.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = c4.getImage(this.map._requestManager.transformRequest(this.url, h.Image), (s3, a4) => {
                  this._request = null, this._loaded = true, s3 ? this.fire(new t2.ErrorEvent(s3)) : a4 && (this.image = a4, e4 && (this.coordinates = e4), i4 && i4(), this._finishLoading());
                });
              }, this.prepare = () => {
                if (0 === Object.keys(this.tiles).length || !this.image)
                  return;
                const e4 = this.map.painter.context, i4 = e4.gl;
                this.boundsBuffer || (this.boundsBuffer = e4.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new x(e4, this.image, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
                let s3 = false;
                for (const t3 in this.tiles) {
                  const e5 = this.tiles[t3];
                  "loaded" !== e5.state && (e5.state = "loaded", e5.texture = this.texture, s3 = true);
                }
                s3 && this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), this.id = e3, this.dispatcher = s2, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a3), this.options = i3;
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t3) {
              return t3.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = t3.url, this.load(t3.coordinates, () => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t3) {
              this.map = t3, this.load();
            }
            onRemove() {
              this._request && (this._request.cancel(), this._request = null);
            }
            setCoordinates(e3) {
              this.coordinates = e3;
              const i3 = e3.map(t2.MercatorCoordinate.fromLngLat);
              this.tileID = function(e4) {
                let i4 = 1 / 0, s3 = 1 / 0, a3 = -1 / 0, o2 = -1 / 0;
                for (const t3 of e4)
                  i4 = Math.min(i4, t3.x), s3 = Math.min(s3, t3.y), a3 = Math.max(a3, t3.x), o2 = Math.max(o2, t3.y);
                const r2 = Math.max(a3 - i4, o2 - s3), n3 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n3);
                return new t2.CanonicalTileID(n3, Math.floor((i4 + a3) / 2 * l2), Math.floor((s3 + o2) / 2 * l2));
              }(i3), this.minzoom = this.maxzoom = this.tileID.z;
              const s2 = i3.map((t3) => this.tileID.getTilePoint(t3)._round());
              return this._boundsArray = new t2.RasterBoundsArray(), this._boundsArray.emplaceBack(s2[0].x, s2[0].y, 0, 0), this._boundsArray.emplaceBack(s2[1].x, s2[1].y, t2.EXTENT, 0), this._boundsArray.emplaceBack(s2[3].x, s2[3].y, 0, t2.EXTENT), this._boundsArray.emplaceBack(s2[2].x, s2[2].y, t2.EXTENT, t2.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            loadTile(t3, e3) {
              this.tileID && this.tileID.equals(t3.tileID.canonical) ? (this.tiles[String(t3.tileID.wrap)] = t3, t3.buckets = {}, e3(null)) : (t3.state = "errored", e3(null));
            }
            hasTransition() {
              return false;
            }
          }
          class G extends N {
            constructor(e3, i3, s2, a3) {
              super(e3, i3, s2, a3), this.load = () => {
                this._loaded = false;
                const e4 = this.options;
                this.urls = [];
                for (const t3 of e4.urls)
                  this.urls.push(this.map._requestManager.transformRequest(t3, h.Source).url);
                t2.getVideo(this.urls, (e5, i4) => {
                  this._loaded = true, e5 ? this.fire(new t2.ErrorEvent(e5)) : i4 && (this.video = i4, this.video.loop = true, this.video.addEventListener("playing", () => {
                    this.map.triggerRepaint();
                  }), this.map && this.video.play(), this._finishLoading());
                });
              }, this.prepare = () => {
                if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                  return;
                const e4 = this.map.painter.context, i4 = e4.gl;
                this.boundsBuffer || (this.boundsBuffer = e4.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE), i4.texSubImage2D(i4.TEXTURE_2D, 0, 0, 0, i4.RGBA, i4.UNSIGNED_BYTE, this.video)) : (this.texture = new x(e4, this.video, i4.RGBA), this.texture.bind(i4.LINEAR, i4.CLAMP_TO_EDGE));
                let s3 = false;
                for (const t3 in this.tiles) {
                  const e5 = this.tiles[t3];
                  "loaded" !== e5.state && (e5.state = "loaded", e5.texture = this.texture, s3 = true);
                }
                s3 && this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), this.roundZoom = true, this.type = "video", this.options = i3;
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e3) {
              if (this.video) {
                const i3 = this.video.seekable;
                e3 < i3.start(0) || e3 > i3.end(0) ? this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i3.start(0)} and ${i3.end(0)}-second mark.`))) : this.video.currentTime = e3;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(t3) {
              this.map || (this.map = t3, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class Z extends N {
            constructor(e3, i3, s2, a3) {
              super(e3, i3, s2, a3), this.load = () => {
                this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t2.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                  this._playing = true, this.map.triggerRepaint();
                }, this.pause = function() {
                  this._playing && (this.prepare(), this._playing = false);
                }, this._finishLoading());
              }, this.prepare = () => {
                let e4 = false;
                if (this.canvas.width !== this.width && (this.width = this.canvas.width, e4 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e4 = true), this._hasInvalidDimensions())
                  return;
                if (0 === Object.keys(this.tiles).length)
                  return;
                const i4 = this.map.painter.context, s3 = i4.gl;
                this.boundsBuffer || (this.boundsBuffer = i4.createVertexBuffer(this._boundsArray, O.members)), this.boundsSegments || (this.boundsSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e4 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new x(i4, this.canvas, s3.RGBA, { premultiply: true });
                let a4 = false;
                for (const t3 in this.tiles) {
                  const e5 = this.tiles[t3];
                  "loaded" !== e5.state && (e5.state = "loaded", e5.texture = this.texture, a4 = true);
                }
                a4 && this.fire(new t2.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "canvas", coordinates: this.coordinates }), i3.coordinates ? Array.isArray(i3.coordinates) && 4 === i3.coordinates.length && !i3.coordinates.some((t3) => !Array.isArray(t3) || 2 !== t3.length || t3.some((t4) => "number" != typeof t4)) || this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${e3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${e3}`, null, 'missing required property "coordinates"'))), i3.animate && "boolean" != typeof i3.animate && this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${e3}`, null, 'optional "animate" property must be a boolean value'))), i3.canvas ? "string" == typeof i3.canvas || i3.canvas instanceof HTMLCanvasElement || this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${e3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t2.ErrorEvent(new t2.ValidationError(`sources.${e3}`, null, 'missing required property "canvas"'))), this.options = i3, this.animate = void 0 === i3.animate || i3.animate;
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(t3) {
              this.map = t3, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const t3 of [this.canvas.width, this.canvas.height])
                if (isNaN(t3) || t3 <= 0)
                  return true;
              return false;
            }
          }
          const V = {}, q = (t3) => {
            switch (t3) {
              case "geojson":
                return U;
              case "image":
                return N;
              case "raster":
                return B;
              case "raster-dem":
                return F;
              case "vector":
                return k;
              case "video":
                return G;
              case "canvas":
                return Z;
            }
            return V[t3];
          };
          function j(e3, i3) {
            const s2 = t2.create();
            return t2.translate(s2, s2, [1, 1, 0]), t2.scale(s2, s2, [0.5 * e3.width, 0.5 * e3.height, 1]), t2.multiply(s2, s2, e3.calculatePosMatrix(i3.toUnwrapped()));
          }
          function $11(t3, e3, i3, s2, a3, o2) {
            const r2 = function(t4, e4, i4) {
              if (t4)
                for (const s3 of t4) {
                  const t5 = e4[s3];
                  if (t5 && t5.source === i4 && "fill-extrusion" === t5.type)
                    return true;
                }
              else
                for (const t5 in e4) {
                  const s3 = e4[t5];
                  if (s3.source === i4 && "fill-extrusion" === s3.type)
                    return true;
                }
              return false;
            }(a3 && a3.layers, e3, t3.id), n3 = o2.maxPitchScaleFactor(), l2 = t3.tilesIn(s2, n3, r2);
            l2.sort(X);
            const c5 = [];
            for (const s3 of l2)
              c5.push({ wrappedTileID: s3.tileID.wrapped().key, queryResults: s3.tile.queryRenderedFeatures(e3, i3, t3._state, s3.queryGeometry, s3.cameraQueryGeometry, s3.scale, a3, o2, n3, j(t3.transform, s3.tileID)) });
            const h2 = function(t4) {
              const e4 = {}, i4 = {};
              for (const s3 of t4) {
                const t5 = s3.queryResults, a4 = s3.wrappedTileID, o3 = i4[a4] = i4[a4] || {};
                for (const i5 in t5) {
                  const s4 = t5[i5], a5 = o3[i5] = o3[i5] || {}, r3 = e4[i5] = e4[i5] || [];
                  for (const t6 of s4)
                    a5[t6.featureIndex] || (a5[t6.featureIndex] = true, r3.push(t6));
                }
              }
              return e4;
            }(c5);
            for (const e4 in h2)
              h2[e4].forEach((e5) => {
                const i4 = e5.feature, s3 = t3.getFeatureState(i4.layer["source-layer"], i4.id);
                i4.source = i4.layer.source, i4.layer["source-layer"] && (i4.sourceLayer = i4.layer["source-layer"]), i4.state = s3;
              });
            return h2;
          }
          function X(t3, e3) {
            const i3 = t3.tileID, s2 = e3.tileID;
            return i3.overscaledZ - s2.overscaledZ || i3.canonical.y - s2.canonical.y || i3.wrap - s2.wrap || i3.canonical.x - s2.canonical.x;
          }
          class W {
            constructor(e3, i3) {
              this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e3, this.uid = t2.uniqueId(), this.uses = 0, this.tileSize = i3, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(t3) {
              const e3 = t3 + this.timeAdded;
              e3 < this.fadeEndTime || (this.fadeEndTime = e3);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(t3) {
              this.demTexture && t3.saveTileTexture(this.demTexture), this.demTexture = null;
            }
            loadVectorData(e3, i3, s2) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e3) {
                e3.featureIndex && (this.latestFeatureIndex = e3.featureIndex, e3.rawTileData ? (this.latestRawTileData = e3.rawTileData, this.latestFeatureIndex.rawTileData = e3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e3.collisionBoxArray, this.buckets = function(t3, e4) {
                  const i4 = {};
                  if (!e4)
                    return i4;
                  for (const s3 of t3) {
                    const t4 = s3.layerIds.map((t5) => e4.getLayer(t5)).filter(Boolean);
                    if (0 !== t4.length) {
                      s3.layers = t4, s3.stateDependentLayerIds && (s3.stateDependentLayers = s3.stateDependentLayerIds.map((e5) => t4.filter((t5) => t5.id === e5)[0]));
                      for (const e5 of t4)
                        i4[e5.id] = s3;
                    }
                  }
                  return i4;
                }(e3.buckets, i3.style), this.hasSymbolBuckets = false;
                for (const e4 in this.buckets) {
                  const i4 = this.buckets[e4];
                  if (i4 instanceof t2.SymbolBucket) {
                    if (this.hasSymbolBuckets = true, !s2)
                      break;
                    i4.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const e4 in this.buckets) {
                    const i4 = this.buckets[e4];
                    if (i4 instanceof t2.SymbolBucket && i4.hasRTLText) {
                      this.hasRTLText = true, t2.lazyLoadRTLTextPlugin();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t3 in this.buckets) {
                  const e4 = this.buckets[t3];
                  this.queryPadding = Math.max(this.queryPadding, i3.style.getLayer(t3).queryRadius(e4));
                }
                e3.imageAtlas && (this.imageAtlas = e3.imageAtlas), e3.glyphAtlasImage && (this.glyphAtlasImage = e3.glyphAtlasImage);
              } else
                this.collisionBoxArray = new t2.CollisionBoxArray();
            }
            unloadVectorData() {
              for (const t3 in this.buckets)
                this.buckets[t3].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t3) {
              return this.buckets[t3.id];
            }
            upload(t3) {
              for (const e4 in this.buckets) {
                const i3 = this.buckets[e4];
                i3.uploadPending() && i3.upload(t3);
              }
              const e3 = t3.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new x(t3, this.imageAtlas.image, e3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new x(t3, this.glyphAtlasImage, e3.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(t3) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t3, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s2, cameraQueryGeometry: a3, scale: o2, tileSize: this.tileSize, pixelPosMatrix: c5, transform: n3, params: r2, queryPadding: this.queryPadding * l2 }, t3, e3, i3) : {};
            }
            querySourceFeatures(e3, i3) {
              const s2 = this.latestFeatureIndex;
              if (!s2 || !s2.rawTileData)
                return;
              const a3 = s2.loadVTLayers(), o2 = i3 && i3.sourceLayer ? i3.sourceLayer : "", r2 = a3._geojsonTileLayer || a3[o2];
              if (!r2)
                return;
              const n3 = t2.createFilter(i3 && i3.filter), { z: l2, x: c5, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c5, y: h2 };
              for (let i4 = 0; i4 < r2.length; i4++) {
                const a4 = r2.feature(i4);
                if (n3.needGeometry) {
                  const e4 = t2.toEvaluationFeature(a4, true);
                  if (!n3.filter(new t2.EvaluationParameters(this.tileID.overscaledZ), e4, this.tileID.canonical))
                    continue;
                } else if (!n3.filter(new t2.EvaluationParameters(this.tileID.overscaledZ), a4))
                  continue;
                const d3 = s2.getId(a4, o2), _2 = new t2.GeoJSONFeature(a4, l2, c5, h2, d3);
                _2.tile = u2, e3.push(_2);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e3) {
              const i3 = this.expirationTime;
              if (e3.cacheControl) {
                const i4 = t2.parseCacheControl(e3.cacheControl);
                i4["max-age"] && (this.expirationTime = Date.now() + 1e3 * i4["max-age"]);
              } else
                e3.expires && (this.expirationTime = new Date(e3.expires).getTime());
              if (this.expirationTime) {
                const t3 = Date.now();
                let e4 = false;
                if (this.expirationTime > t3)
                  e4 = false;
                else if (i3)
                  if (this.expirationTime < i3)
                    e4 = true;
                  else {
                    const s2 = this.expirationTime - i3;
                    s2 ? this.expirationTime = t3 + Math.max(s2, 3e4) : e4 = true;
                  }
                else
                  e4 = true;
                e4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t3, e3) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t3).length)
                return;
              const i3 = this.latestFeatureIndex.loadVTLayers();
              for (const s2 in this.buckets) {
                if (!e3.style.hasLayer(s2))
                  continue;
                const a3 = this.buckets[s2], o2 = a3.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i3[o2], n3 = t3[o2];
                if (!r2 || !n3 || 0 === Object.keys(n3).length)
                  continue;
                a3.update(n3, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l2 = e3 && e3.style && e3.style.getLayer(s2);
                l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a3)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t2.browser.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e3) {
              this.symbolFadeHoldUntil = t2.browser.now() + e3;
            }
            setDependencies(t3, e3) {
              const i3 = {};
              for (const t4 of e3)
                i3[t4] = true;
              this.dependencies[t3] = i3;
            }
            hasDependency(t3, e3) {
              for (const i3 of t3) {
                const t4 = this.dependencies[i3];
                if (t4) {
                  for (const i4 of e3)
                    if (t4[i4])
                      return true;
                }
              }
              return false;
            }
          }
          class H {
            constructor(t3, e3) {
              this.max = t3, this.onRemove = e3, this.reset();
            }
            reset() {
              for (const t3 in this.data)
                for (const e3 of this.data[t3])
                  e3.timeout && clearTimeout(e3.timeout), this.onRemove(e3.value);
              return this.data = {}, this.order = [], this;
            }
            add(t3, e3, i3) {
              const s2 = t3.wrapped().key;
              void 0 === this.data[s2] && (this.data[s2] = []);
              const a3 = { value: e3, timeout: void 0 };
              if (void 0 !== i3 && (a3.timeout = setTimeout(() => {
                this.remove(t3, a3);
              }, i3)), this.data[s2].push(a3), this.order.push(s2), this.order.length > this.max) {
                const t4 = this._getAndRemoveByKey(this.order[0]);
                t4 && this.onRemove(t4);
              }
              return this;
            }
            has(t3) {
              return t3.wrapped().key in this.data;
            }
            getAndRemove(t3) {
              return this.has(t3) ? this._getAndRemoveByKey(t3.wrapped().key) : null;
            }
            _getAndRemoveByKey(t3) {
              const e3 = this.data[t3].shift();
              return e3.timeout && clearTimeout(e3.timeout), 0 === this.data[t3].length && delete this.data[t3], this.order.splice(this.order.indexOf(t3), 1), e3.value;
            }
            getByKey(t3) {
              const e3 = this.data[t3];
              return e3 ? e3[0].value : null;
            }
            get(t3) {
              return this.has(t3) ? this.data[t3.wrapped().key][0].value : null;
            }
            remove(t3, e3) {
              if (!this.has(t3))
                return this;
              const i3 = t3.wrapped().key, s2 = void 0 === e3 ? 0 : this.data[i3].indexOf(e3), a3 = this.data[i3][s2];
              return this.data[i3].splice(s2, 1), a3.timeout && clearTimeout(a3.timeout), 0 === this.data[i3].length && delete this.data[i3], this.onRemove(a3.value), this.order.splice(this.order.indexOf(i3), 1), this;
            }
            setMaxSize(t3) {
              for (this.max = t3; this.order.length > this.max; ) {
                const t4 = this._getAndRemoveByKey(this.order[0]);
                t4 && this.onRemove(t4);
              }
              return this;
            }
            filter(t3) {
              const e3 = [];
              for (const i3 in this.data)
                for (const s2 of this.data[i3])
                  t3(s2.value) || e3.push(s2);
              for (const t4 of e3)
                this.remove(t4.value.tileID, t4);
            }
          }
          class K {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e3, i3, s2) {
              const a3 = String(i3);
              if (this.stateChanges[e3] = this.stateChanges[e3] || {}, this.stateChanges[e3][a3] = this.stateChanges[e3][a3] || {}, t2.extend(this.stateChanges[e3][a3], s2), null === this.deletedStates[e3]) {
                this.deletedStates[e3] = {};
                for (const t3 in this.state[e3])
                  t3 !== a3 && (this.deletedStates[e3][t3] = null);
              } else if (this.deletedStates[e3] && null === this.deletedStates[e3][a3]) {
                this.deletedStates[e3][a3] = {};
                for (const t3 in this.state[e3][a3])
                  s2[t3] || (this.deletedStates[e3][a3][t3] = null);
              } else
                for (const t3 in s2)
                  this.deletedStates[e3] && this.deletedStates[e3][a3] && null === this.deletedStates[e3][a3][t3] && delete this.deletedStates[e3][a3][t3];
            }
            removeFeatureState(t3, e3, i3) {
              if (null === this.deletedStates[t3])
                return;
              const s2 = String(e3);
              if (this.deletedStates[t3] = this.deletedStates[t3] || {}, i3 && void 0 !== e3)
                null !== this.deletedStates[t3][s2] && (this.deletedStates[t3][s2] = this.deletedStates[t3][s2] || {}, this.deletedStates[t3][s2][i3] = null);
              else if (void 0 !== e3)
                if (this.stateChanges[t3] && this.stateChanges[t3][s2])
                  for (i3 in this.deletedStates[t3][s2] = {}, this.stateChanges[t3][s2])
                    this.deletedStates[t3][s2][i3] = null;
                else
                  this.deletedStates[t3][s2] = null;
              else
                this.deletedStates[t3] = null;
            }
            getState(e3, i3) {
              const s2 = String(i3), a3 = t2.extend({}, (this.state[e3] || {})[s2], (this.stateChanges[e3] || {})[s2]);
              if (null === this.deletedStates[e3])
                return {};
              if (this.deletedStates[e3]) {
                const t3 = this.deletedStates[e3][i3];
                if (null === t3)
                  return {};
                for (const e4 in t3)
                  delete a3[e4];
              }
              return a3;
            }
            initializeTileState(t3, e3) {
              t3.setFeatureState(this.state, e3);
            }
            coalesceChanges(e3, i3) {
              const s2 = {};
              for (const e4 in this.stateChanges) {
                this.state[e4] = this.state[e4] || {};
                const i4 = {};
                for (const s3 in this.stateChanges[e4])
                  this.state[e4][s3] || (this.state[e4][s3] = {}), t2.extend(this.state[e4][s3], this.stateChanges[e4][s3]), i4[s3] = this.state[e4][s3];
                s2[e4] = i4;
              }
              for (const e4 in this.deletedStates) {
                this.state[e4] = this.state[e4] || {};
                const i4 = {};
                if (null === this.deletedStates[e4])
                  for (const t3 in this.state[e4])
                    i4[t3] = {}, this.state[e4][t3] = {};
                else
                  for (const t3 in this.deletedStates[e4]) {
                    if (null === this.deletedStates[e4][t3])
                      this.state[e4][t3] = {};
                    else
                      for (const i5 of Object.keys(this.deletedStates[e4][t3]))
                        delete this.state[e4][t3][i5];
                    i4[t3] = this.state[e4][t3];
                  }
                s2[e4] = s2[e4] || {}, t2.extend(s2[e4], i4);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s2).length)
                for (const t3 in e3)
                  e3[t3].setFeatureState(s2, i3);
            }
          }
          class Y extends t2.Evented {
            constructor(t3, e3, i3) {
              super(), this.id = t3, this.dispatcher = i3, this.on("data", (t4) => {
                "source" === t4.dataType && "metadata" === t4.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t4.dataType && "content" === t4.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
              }), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = ((t4, e4, i4, s2) => {
                const a3 = new (q(e4.type))(t4, e4, i4, s2);
                if (a3.id !== t4)
                  throw new Error(`Expected Source id to be ${t4} instead of ${a3.id}`);
                return a3;
              })(t3, e3, i3, this), this._tiles = {}, this._cache = new H(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new K(), this._didEmitContent = false, this._updated = false;
            }
            onAdd(t3) {
              this.map = t3, this._maxTileCacheSize = t3 ? t3._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t3 ? t3._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t3);
            }
            onRemove(t3) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t3);
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
                return true;
              if (!this._updated)
                return false;
              for (const t3 in this._tiles) {
                const e3 = this._tiles[t3];
                if ("loaded" !== e3.state && "errored" !== e3.state)
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t3 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t3 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(t3, e3) {
              return this._source.loadTile(t3, e3);
            }
            _unloadTile(t3) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t3, () => {
                });
            }
            _abortTile(e3) {
              this._source.abortTile && this._source.abortTile(e3, () => {
              }), this._source.fire(new t2.Event("dataabort", { tile: e3, coord: e3.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t3) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e3 in this._tiles) {
                const i3 = this._tiles[e3];
                i3.upload(t3), i3.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((t3) => t3.tileID).sort(J).map((t3) => t3.key);
            }
            getRenderableIds(e3) {
              const i3 = [];
              for (const t3 in this._tiles)
                this._isIdRenderable(t3, e3) && i3.push(this._tiles[t3]);
              return e3 ? i3.sort((e4, i4) => {
                const s2 = e4.tileID, a3 = i4.tileID, o2 = new t2.Point(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle), r2 = new t2.Point(a3.canonical.x, a3.canonical.y)._rotate(this.transform.angle);
                return s2.overscaledZ - a3.overscaledZ || r2.y - o2.y || r2.x - o2.x;
              }).map((t3) => t3.tileID.key) : i3.map((t3) => t3.tileID).sort(J).map((t3) => t3.key);
            }
            hasRenderableParent(t3) {
              const e3 = this.findLoadedParent(t3, 0);
              return !!e3 && this._isIdRenderable(e3.tileID.key);
            }
            _isIdRenderable(t3, e3) {
              return this._tiles[t3] && this._tiles[t3].hasData() && !this._coveredTiles[t3] && (e3 || !this._tiles[t3].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t3 in this._tiles)
                  "errored" !== this._tiles[t3].state && this._reloadTile(t3, "reloading");
              }
            }
            _reloadTile(t3, e3) {
              const i3 = this._tiles[t3];
              i3 && ("loading" !== i3.state && (i3.state = e3), this._loadTile(i3, this._tileLoaded.bind(this, i3, t3, e3)));
            }
            _tileLoaded(e3, i3, s2, a3) {
              if (a3)
                return e3.state = "errored", void (404 !== a3.status ? this._source.fire(new t2.ErrorEvent(a3, { tile: e3 })) : this.update(this.transform, this.terrain));
              e3.timeAdded = t2.browser.now(), "expired" === s2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), e3.aborted || this._source.fire(new t2.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
            }
            _backfillDEM(t3) {
              const e3 = this.getRenderableIds();
              for (let s2 = 0; s2 < e3.length; s2++) {
                const a3 = e3[s2];
                if (t3.neighboringTiles && t3.neighboringTiles[a3]) {
                  const e4 = this.getTileByID(a3);
                  i3(t3, e4), i3(e4, t3);
                }
              }
              function i3(t4, e4) {
                t4.needsHillshadePrepare = true, t4.needsTerrainPrepare = true;
                let i4 = e4.tileID.canonical.x - t4.tileID.canonical.x;
                const s2 = e4.tileID.canonical.y - t4.tileID.canonical.y, a3 = Math.pow(2, t4.tileID.canonical.z), o2 = e4.tileID.key;
                0 === i4 && 0 === s2 || Math.abs(s2) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + a3) ? i4 += a3 : 1 === Math.abs(i4 - a3) && (i4 -= a3)), e4.dem && t4.dem && (t4.dem.backfillBorder(e4.dem, i4, s2), t4.neighboringTiles && t4.neighboringTiles[o2] && (t4.neighboringTiles[o2].backfilled = true)));
              }
            }
            getTile(t3) {
              return this.getTileByID(t3.key);
            }
            getTileByID(t3) {
              return this._tiles[t3];
            }
            _retainLoadedChildren(t3, e3, i3, s2) {
              for (const a3 in this._tiles) {
                let o2 = this._tiles[a3];
                if (s2[a3] || !o2.hasData() || o2.tileID.overscaledZ <= e3 || o2.tileID.overscaledZ > i3)
                  continue;
                let r2 = o2.tileID;
                for (; o2 && o2.tileID.overscaledZ > e3 + 1; ) {
                  const t4 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
                  o2 = this._tiles[t4.key], o2 && o2.hasData() && (r2 = t4);
                }
                let n3 = r2;
                for (; n3.overscaledZ > e3; )
                  if (n3 = n3.scaledTo(n3.overscaledZ - 1), t3[n3.key]) {
                    s2[r2.key] = r2;
                    break;
                  }
              }
            }
            findLoadedParent(t3, e3) {
              if (t3.key in this._loadedParentTiles) {
                const i3 = this._loadedParentTiles[t3.key];
                return i3 && i3.tileID.overscaledZ >= e3 ? i3 : null;
              }
              for (let i3 = t3.overscaledZ - 1; i3 >= e3; i3--) {
                const e4 = t3.scaledTo(i3), s2 = this._getLoadedTile(e4);
                if (s2)
                  return s2;
              }
            }
            _getLoadedTile(t3) {
              const e3 = this._tiles[t3.key];
              return e3 && e3.hasData() ? e3 : this._cache.getByKey(t3.wrapped().key);
            }
            updateCacheSize(e3) {
              const i3 = Math.ceil(e3.width / this._source.tileSize) + 1, s2 = Math.ceil(e3.height / this._source.tileSize) + 1, a3 = Math.floor(i3 * s2 * (null === this._maxTileCacheZoomLevels ? t2.config.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a3) : a3;
              this._cache.setMaxSize(o2);
            }
            handleWrapJump(t3) {
              const e3 = Math.round((t3 - (void 0 === this._prevLng ? t3 : this._prevLng)) / 360);
              if (this._prevLng = t3, e3) {
                const t4 = {};
                for (const i3 in this._tiles) {
                  const s2 = this._tiles[i3];
                  s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e3), t4[s2.tileID.key] = s2;
                }
                this._tiles = t4;
                for (const t5 in this._timers)
                  clearTimeout(this._timers[t5]), delete this._timers[t5];
                for (const t5 in this._tiles)
                  this._setTileReloadTimer(t5, this._tiles[t5]);
              }
            }
            update(e3, i3) {
              if (this.transform = e3, this.terrain = i3, !this._sourceLoaded || this._paused)
                return;
              let s2;
              this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map((e4) => new t2.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y)) : (s2 = e3.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i3 }), this._source.hasTile && (s2 = s2.filter((t3) => this._source.hasTile(t3)))) : s2 = [];
              const a3 = e3.coveringZoomLevel(this._source), o2 = Math.max(a3 - Y.maxOverzooming, this._source.minzoom), r2 = Math.max(a3 + Y.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const t3 = {};
                for (const e4 of s2)
                  if (e4.canonical.z > this._source.minzoom) {
                    const i4 = e4.scaledTo(e4.canonical.z - 1);
                    t3[i4.key] = i4;
                    const s3 = e4.scaledTo(Math.max(this._source.minzoom, Math.min(e4.canonical.z, 5)));
                    t3[s3.key] = s3;
                  }
                s2 = s2.concat(Object.values(t3));
              }
              const n3 = 0 === s2.length && !this._updated && this._didEmitContent;
              this._updated = true, n3 && this.fire(new t2.Event("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
              const l2 = this._updateRetainedTiles(s2, a3);
              if (Q(this._source.type)) {
                const e4 = {}, n4 = {}, c6 = Object.keys(l2), h2 = t2.browser.now();
                for (const t3 of c6) {
                  const i4 = l2[t3], s3 = this._tiles[t3];
                  if (!s3 || 0 !== s3.fadeEndTime && s3.fadeEndTime <= h2)
                    continue;
                  const a4 = this.findLoadedParent(i4, o2);
                  a4 && (this._addTile(a4.tileID), e4[a4.tileID.key] = a4.tileID), n4[t3] = i4;
                }
                this._retainLoadedChildren(n4, a3, r2, l2);
                for (const t3 in e4)
                  l2[t3] || (this._coveredTiles[t3] = true, l2[t3] = e4[t3]);
                if (i3) {
                  const t3 = {}, e5 = {};
                  for (const i4 of s2)
                    this._tiles[i4.key].hasData() ? t3[i4.key] = i4 : e5[i4.key] = i4;
                  for (const i4 in e5) {
                    const s3 = e5[i4].children(this._source.maxzoom);
                    this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (t3[s3[0].key] = l2[s3[0].key] = s3[0], t3[s3[1].key] = l2[s3[1].key] = s3[1], t3[s3[2].key] = l2[s3[2].key] = s3[2], t3[s3[3].key] = l2[s3[3].key] = s3[3], delete e5[i4]);
                  }
                  for (const i4 in e5) {
                    const s3 = this.findLoadedParent(e5[i4], this._source.minzoom);
                    if (s3) {
                      t3[s3.tileID.key] = l2[s3.tileID.key] = s3.tileID;
                      for (const e6 in t3)
                        t3[e6].isChildOf(s3.tileID) && delete t3[e6];
                    }
                  }
                  for (const e6 in this._tiles)
                    t3[e6] || (this._coveredTiles[e6] = true);
                }
              }
              for (const t3 in l2)
                this._tiles[t3].clearFadeHold();
              const c5 = t2.keysDifference(this._tiles, l2);
              for (const t3 of c5) {
                const e4 = this._tiles[t3];
                e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(t3);
              }
              this._updateLoadedParentTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const t3 in this._tiles)
                this._tiles[t3].holdingForFade() && this._removeTile(t3);
            }
            _updateRetainedTiles(t3, e3) {
              const i3 = {}, s2 = {}, a3 = Math.max(e3 - Y.maxOverzooming, this._source.minzoom), o2 = Math.max(e3 + Y.maxUnderzooming, this._source.minzoom), r2 = {};
              for (const s3 of t3) {
                const t4 = this._addTile(s3);
                i3[s3.key] = s3, t4.hasData() || e3 < this._source.maxzoom && (r2[s3.key] = s3);
              }
              this._retainLoadedChildren(r2, e3, o2, i3);
              for (const o3 of t3) {
                let t4 = this._tiles[o3.key];
                if (t4.hasData())
                  continue;
                if (e3 + 1 > this._source.maxzoom) {
                  const t5 = o3.children(this._source.maxzoom)[0], e4 = this.getTile(t5);
                  if (e4 && e4.hasData()) {
                    i3[t5.key] = t5;
                    continue;
                  }
                } else {
                  const t5 = o3.children(this._source.maxzoom);
                  if (i3[t5[0].key] && i3[t5[1].key] && i3[t5[2].key] && i3[t5[3].key])
                    continue;
                }
                let r3 = t4.wasRequested();
                for (let e4 = o3.overscaledZ - 1; e4 >= a3; --e4) {
                  const a4 = o3.scaledTo(e4);
                  if (s2[a4.key])
                    break;
                  if (s2[a4.key] = true, t4 = this.getTile(a4), !t4 && r3 && (t4 = this._addTile(a4)), t4) {
                    const e5 = t4.hasData();
                    if ((r3 || e5) && (i3[a4.key] = a4), r3 = t4.wasRequested(), e5)
                      break;
                  }
                }
              }
              return i3;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t3 in this._tiles) {
                const e3 = [];
                let i3, s2 = this._tiles[t3].tileID;
                for (; s2.overscaledZ > 0; ) {
                  if (s2.key in this._loadedParentTiles) {
                    i3 = this._loadedParentTiles[s2.key];
                    break;
                  }
                  e3.push(s2.key);
                  const t4 = s2.scaledTo(s2.overscaledZ - 1);
                  if (i3 = this._getLoadedTile(t4), i3)
                    break;
                  s2 = t4;
                }
                for (const t4 of e3)
                  this._loadedParentTiles[t4] = i3;
              }
            }
            _addTile(e3) {
              let i3 = this._tiles[e3.key];
              if (i3)
                return i3;
              i3 = this._cache.getAndRemove(e3), i3 && (this._setTileReloadTimer(e3.key, i3), i3.tileID = e3, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i3)));
              const s2 = i3;
              return i3 || (i3 = new W(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e3.key, i3.state))), i3.uses++, this._tiles[e3.key] = i3, s2 || this._source.fire(new t2.Event("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3;
            }
            _setTileReloadTimer(t3, e3) {
              t3 in this._timers && (clearTimeout(this._timers[t3]), delete this._timers[t3]);
              const i3 = e3.getExpiryTimeout();
              i3 && (this._timers[t3] = setTimeout(() => {
                this._reloadTile(t3, "expired"), delete this._timers[t3];
              }, i3));
            }
            _removeTile(t3) {
              const e3 = this._tiles[t3];
              e3 && (e3.uses--, delete this._tiles[t3], this._timers[t3] && (clearTimeout(this._timers[t3]), delete this._timers[t3]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t3 in this._tiles)
                this._removeTile(t3);
              this._cache.reset();
            }
            tilesIn(e3, i3, s2) {
              const a3 = [], o2 = this.transform;
              if (!o2)
                return a3;
              const r2 = s2 ? o2.getCameraQueryGeometry(e3) : e3, n3 = e3.map((t3) => o2.pointCoordinate(t3, this.terrain)), l2 = r2.map((t3) => o2.pointCoordinate(t3, this.terrain)), c5 = this.getIds();
              let h2 = 1 / 0, u2 = 1 / 0, d3 = -1 / 0, _2 = -1 / 0;
              for (const t3 of l2)
                h2 = Math.min(h2, t3.x), u2 = Math.min(u2, t3.y), d3 = Math.max(d3, t3.x), _2 = Math.max(_2, t3.y);
              for (let e4 = 0; e4 < c5.length; e4++) {
                const s3 = this._tiles[c5[e4]];
                if (s3.holdingForFade())
                  continue;
                const r3 = s3.tileID, m4 = Math.pow(2, o2.zoom - s3.tileID.overscaledZ), p3 = i3 * s3.queryPadding * t2.EXTENT / s3.tileSize / m4, f2 = [r3.getTilePoint(new t2.MercatorCoordinate(h2, u2)), r3.getTilePoint(new t2.MercatorCoordinate(d3, _2))];
                if (f2[0].x - p3 < t2.EXTENT && f2[0].y - p3 < t2.EXTENT && f2[1].x + p3 >= 0 && f2[1].y + p3 >= 0) {
                  const t3 = n3.map((t4) => r3.getTilePoint(t4)), e5 = l2.map((t4) => r3.getTilePoint(t4));
                  a3.push({ tile: s3, tileID: r3, queryGeometry: t3, cameraQueryGeometry: e5, scale: m4 });
                }
              }
              return a3;
            }
            getVisibleCoordinates(t3) {
              const e3 = this.getRenderableIds(t3).map((t4) => this._tiles[t4].tileID);
              for (const t4 of e3)
                t4.posMatrix = this.transform.calculatePosMatrix(t4.toUnwrapped());
              return e3;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (Q(this._source.type)) {
                const e3 = t2.browser.now();
                for (const t3 in this._tiles)
                  if (this._tiles[t3].fadeEndTime >= e3)
                    return true;
              }
              return false;
            }
            setFeatureState(t3, e3, i3) {
              this._state.updateState(t3 = t3 || "_geojsonTileLayer", e3, i3);
            }
            removeFeatureState(t3, e3, i3) {
              this._state.removeFeatureState(t3 = t3 || "_geojsonTileLayer", e3, i3);
            }
            getFeatureState(t3, e3) {
              return this._state.getState(t3 = t3 || "_geojsonTileLayer", e3);
            }
            setDependencies(t3, e3, i3) {
              const s2 = this._tiles[t3];
              s2 && s2.setDependencies(e3, i3);
            }
            reloadTilesForDependencies(t3, e3) {
              for (const i3 in this._tiles)
                this._tiles[i3].hasDependency(t3, e3) && this._reloadTile(i3, "reloading");
              this._cache.filter((i3) => !i3.hasDependency(t3, e3));
            }
          }
          function J(t3, e3) {
            const i3 = Math.abs(2 * t3.wrap) - +(t3.wrap < 0), s2 = Math.abs(2 * e3.wrap) - +(e3.wrap < 0);
            return t3.overscaledZ - e3.overscaledZ || s2 - i3 || e3.canonical.y - t3.canonical.y || e3.canonical.x - t3.canonical.x;
          }
          function Q(t3) {
            return "raster" === t3 || "image" === t3 || "video" === t3;
          }
          Y.maxOverzooming = 10, Y.maxUnderzooming = 3;
          const tt = "mapboxgl_preloaded_worker_pool";
          class et {
            constructor() {
              this.active = {};
            }
            acquire(e3) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < et.workerCount; )
                  this.workers.push(new Worker(t2.config.WORKER_URL));
              return this.active[e3] = true, this.workers.slice();
            }
            release(t3) {
              delete this.active[t3], 0 === this.numActive() && (this.workers.forEach((t4) => {
                t4.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[tt];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const it = Math.floor(t2.browser.hardwareConcurrency / 2);
          let st;
          function at() {
            return st || (st = new et()), st;
          }
          et.workerCount = t2.isSafari(globalThis) ? Math.max(Math.min(it, 3), 1) : 1;
          class ot {
            constructor(t3, e3) {
              this.reset(t3, e3);
            }
            reset(t3, e3) {
              this.points = t3 || [], this._distances = [0];
              for (let t4 = 1; t4 < this.points.length; t4++)
                this._distances[t4] = this._distances[t4 - 1] + this.points[t4].dist(this.points[t4 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e3) {
              if (1 === this.points.length)
                return this.points[0];
              e3 = t2.clamp(e3, 0, 1);
              let i3 = 1, s2 = this._distances[i3];
              const a3 = e3 * this.paddedLength + this.padding;
              for (; s2 < a3 && i3 < this._distances.length; )
                s2 = this._distances[++i3];
              const o2 = i3 - 1, r2 = this._distances[o2], n3 = s2 - r2, l2 = n3 > 0 ? (a3 - r2) / n3 : 0;
              return this.points[o2].mult(1 - l2).add(this.points[i3].mult(l2));
            }
          }
          function rt(t3, e3) {
            let i3 = true;
            return "always" === t3 || "never" !== t3 && "never" !== e3 || (i3 = false), i3;
          }
          class nt {
            constructor(t3, e3, i3) {
              const s2 = this.boxCells = [], a3 = this.circleCells = [];
              this.xCellCount = Math.ceil(t3 / i3), this.yCellCount = Math.ceil(e3 / i3);
              for (let t4 = 0; t4 < this.xCellCount * this.yCellCount; t4++)
                s2.push([]), a3.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t3, this.height = e3, this.xScale = this.xCellCount / t3, this.yScale = this.yCellCount / e3, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t3, e3, i3, s2, a3) {
              this._forEachCell(e3, i3, s2, a3, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t3), this.bboxes.push(e3), this.bboxes.push(i3), this.bboxes.push(s2), this.bboxes.push(a3);
            }
            insertCircle(t3, e3, i3, s2) {
              this._forEachCell(e3 - s2, i3 - s2, e3 + s2, i3 + s2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t3), this.circles.push(e3), this.circles.push(i3), this.circles.push(s2);
            }
            _insertBoxCell(t3, e3, i3, s2, a3, o2) {
              this.boxCells[a3].push(o2);
            }
            _insertCircleCell(t3, e3, i3, s2, a3, o2) {
              this.circleCells[a3].push(o2);
            }
            _query(t3, e3, i3, s2, a3, o2, r2) {
              if (i3 < 0 || t3 > this.width || s2 < 0 || e3 > this.height)
                return [];
              const n3 = [];
              if (t3 <= 0 && e3 <= 0 && this.width <= i3 && this.height <= s2) {
                if (a3)
                  return [{ key: null, x1: t3, y1: e3, x2: i3, y2: s2 }];
                for (let t4 = 0; t4 < this.boxKeys.length; t4++)
                  n3.push({ key: this.boxKeys[t4], x1: this.bboxes[4 * t4], y1: this.bboxes[4 * t4 + 1], x2: this.bboxes[4 * t4 + 2], y2: this.bboxes[4 * t4 + 3] });
                for (let t4 = 0; t4 < this.circleKeys.length; t4++) {
                  const e4 = this.circles[3 * t4], i4 = this.circles[3 * t4 + 1], s3 = this.circles[3 * t4 + 2];
                  n3.push({ key: this.circleKeys[t4], x1: e4 - s3, y1: i4 - s3, x2: e4 + s3, y2: i4 + s3 });
                }
              } else
                this._forEachCell(t3, e3, i3, s2, this._queryCell, n3, { hitTest: a3, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
              return n3;
            }
            query(t3, e3, i3, s2) {
              return this._query(t3, e3, i3, s2, false, null);
            }
            hitTest(t3, e3, i3, s2, a3, o2) {
              return this._query(t3, e3, i3, s2, true, a3, o2).length > 0;
            }
            hitTestCircle(t3, e3, i3, s2, a3) {
              const o2 = t3 - i3, r2 = t3 + i3, n3 = e3 - i3, l2 = e3 + i3;
              if (r2 < 0 || o2 > this.width || l2 < 0 || n3 > this.height)
                return false;
              const c5 = [];
              return this._forEachCell(o2, n3, r2, l2, this._queryCellCircle, c5, { hitTest: true, overlapMode: s2, circle: { x: t3, y: e3, radius: i3 }, seenUids: { box: {}, circle: {} } }, a3), c5.length > 0;
            }
            _queryCell(t3, e3, i3, s2, a3, o2, r2, n3) {
              const { seenUids: l2, hitTest: c5, overlapMode: h2 } = r2, u2 = this.boxCells[a3];
              if (null !== u2) {
                const a4 = this.bboxes;
                for (const r3 of u2)
                  if (!l2.box[r3]) {
                    l2.box[r3] = true;
                    const u3 = 4 * r3, d4 = this.boxKeys[r3];
                    if (t3 <= a4[u3 + 2] && e3 <= a4[u3 + 3] && i3 >= a4[u3 + 0] && s2 >= a4[u3 + 1] && (!n3 || n3(d4)) && (!c5 || !rt(h2, d4.overlapMode)) && (o2.push({ key: d4, x1: a4[u3], y1: a4[u3 + 1], x2: a4[u3 + 2], y2: a4[u3 + 3] }), c5))
                      return true;
                  }
              }
              const d3 = this.circleCells[a3];
              if (null !== d3) {
                const a4 = this.circles;
                for (const r3 of d3)
                  if (!l2.circle[r3]) {
                    l2.circle[r3] = true;
                    const u3 = 3 * r3, d4 = this.circleKeys[r3];
                    if (this._circleAndRectCollide(a4[u3], a4[u3 + 1], a4[u3 + 2], t3, e3, i3, s2) && (!n3 || n3(d4)) && (!c5 || !rt(h2, d4.overlapMode))) {
                      const t4 = a4[u3], e4 = a4[u3 + 1], i4 = a4[u3 + 2];
                      if (o2.push({ key: d4, x1: t4 - i4, y1: e4 - i4, x2: t4 + i4, y2: e4 + i4 }), c5)
                        return true;
                    }
                  }
              }
              return false;
            }
            _queryCellCircle(t3, e3, i3, s2, a3, o2, r2, n3) {
              const { circle: l2, seenUids: c5, overlapMode: h2 } = r2, u2 = this.boxCells[a3];
              if (null !== u2) {
                const t4 = this.bboxes;
                for (const e4 of u2)
                  if (!c5.box[e4]) {
                    c5.box[e4] = true;
                    const i4 = 4 * e4, s3 = this.boxKeys[e4];
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t4[i4 + 0], t4[i4 + 1], t4[i4 + 2], t4[i4 + 3]) && (!n3 || n3(s3)) && !rt(h2, s3.overlapMode))
                      return o2.push(true), true;
                  }
              }
              const d3 = this.circleCells[a3];
              if (null !== d3) {
                const t4 = this.circles;
                for (const e4 of d3)
                  if (!c5.circle[e4]) {
                    c5.circle[e4] = true;
                    const i4 = 3 * e4, s3 = this.circleKeys[e4];
                    if (this._circlesCollide(t4[i4], t4[i4 + 1], t4[i4 + 2], l2.x, l2.y, l2.radius) && (!n3 || n3(s3)) && !rt(h2, s3.overlapMode))
                      return o2.push(true), true;
                  }
              }
            }
            _forEachCell(t3, e3, i3, s2, a3, o2, r2, n3) {
              const l2 = this._convertToXCellCoord(t3), c5 = this._convertToYCellCoord(e3), h2 = this._convertToXCellCoord(i3), u2 = this._convertToYCellCoord(s2);
              for (let d3 = l2; d3 <= h2; d3++)
                for (let l3 = c5; l3 <= u2; l3++)
                  if (a3.call(this, t3, e3, i3, s2, this.xCellCount * l3 + d3, o2, r2, n3))
                    return;
            }
            _convertToXCellCoord(t3) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t3 * this.xScale)));
            }
            _convertToYCellCoord(t3) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t3 * this.yScale)));
            }
            _circlesCollide(t3, e3, i3, s2, a3, o2) {
              const r2 = s2 - t3, n3 = a3 - e3, l2 = i3 + o2;
              return l2 * l2 > r2 * r2 + n3 * n3;
            }
            _circleAndRectCollide(t3, e3, i3, s2, a3, o2, r2) {
              const n3 = (o2 - s2) / 2, l2 = Math.abs(t3 - (s2 + n3));
              if (l2 > n3 + i3)
                return false;
              const c5 = (r2 - a3) / 2, h2 = Math.abs(e3 - (a3 + c5));
              if (h2 > c5 + i3)
                return false;
              if (l2 <= n3 || h2 <= c5)
                return true;
              const u2 = l2 - n3, d3 = h2 - c5;
              return u2 * u2 + d3 * d3 <= i3 * i3;
            }
          }
          function lt(e3, i3, s2, a3, o2) {
            const r2 = t2.create();
            return i3 ? (t2.scale(r2, r2, [1 / o2, 1 / o2, 1]), s2 || t2.rotateZ(r2, r2, a3.angle)) : t2.multiply(r2, a3.labelPlaneMatrix, e3), r2;
          }
          function ct(e3, i3, s2, a3, o2) {
            if (i3) {
              const i4 = t2.clone(e3);
              return t2.scale(i4, i4, [o2, o2, 1]), s2 || t2.rotateZ(i4, i4, -a3.angle), i4;
            }
            return a3.glCoordMatrix;
          }
          function ht(e3, i3, s2) {
            let a3;
            s2 ? (a3 = [e3.x, e3.y, s2(e3.x, e3.y), 1], t2.transformMat4(a3, a3, i3)) : (a3 = [e3.x, e3.y, 0, 1], Et3(a3, a3, i3));
            const o2 = a3[3];
            return { point: new t2.Point(a3[0] / o2, a3[1] / o2), signedDistanceFromCamera: o2 };
          }
          function ut(t3, e3) {
            return 0.5 + t3 / e3 * 0.5;
          }
          function dt(t3, e3) {
            const i3 = t3[0] / t3[3], s2 = t3[1] / t3[3];
            return i3 >= -e3[0] && i3 <= e3[0] && s2 >= -e3[1] && s2 <= e3[1];
          }
          function _t(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2) {
            const u2 = a3 ? e3.textSizeData : e3.iconSizeData, d3 = t2.evaluateSizeForZoom(u2, s2.transform.zoom), _2 = [256 / s2.width * 2 + 1, 256 / s2.height * 2 + 1], m4 = a3 ? e3.text.dynamicLayoutVertexArray : e3.icon.dynamicLayoutVertexArray;
            m4.clear();
            const p3 = e3.lineVertexArray, f2 = a3 ? e3.text.placedSymbolArray : e3.icon.placedSymbolArray, g3 = s2.transform.width / s2.transform.height;
            let v2 = false;
            for (let a4 = 0; a4 < f2.length; a4++) {
              const x2 = f2.get(a4);
              if (x2.hidden || x2.writingMode === t2.WritingMode.vertical && !v2) {
                Tt(x2.numGlyphs, m4);
                continue;
              }
              let y2;
              if (v2 = false, h2 ? (y2 = [x2.anchorX, x2.anchorY, h2(x2.anchorX, x2.anchorY), 1], t2.transformMat4(y2, y2, i3)) : (y2 = [x2.anchorX, x2.anchorY, 0, 1], Et3(y2, y2, i3)), !dt(y2, _2)) {
                Tt(x2.numGlyphs, m4);
                continue;
              }
              const b3 = ut(s2.transform.cameraToCenterDistance, y2[3]), w2 = t2.evaluateSizeForFeature(u2, d3, x2), T2 = n3 ? w2 / b3 : w2 * b3, E2 = new t2.Point(x2.anchorX, x2.anchorY), I2 = ht(E2, o2, h2).point, S2 = { projections: {}, offsets: {} }, C3 = ft(x2, T2, false, l2, i3, o2, r2, e3.glyphOffsetArray, p3, m4, I2, E2, S2, g3, c5, h2);
              v2 = C3.useVertical, (C3.notEnoughRoom || v2 || C3.needsFlipping && ft(x2, T2, true, l2, i3, o2, r2, e3.glyphOffsetArray, p3, m4, I2, E2, S2, g3, c5, h2).notEnoughRoom) && Tt(x2.numGlyphs, m4);
            }
            a3 ? e3.text.dynamicLayoutVertexBuffer.updateData(m4) : e3.icon.dynamicLayoutVertexBuffer.updateData(m4);
          }
          function mt(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3) {
            const _2 = n3.glyphStartIndex + n3.numGlyphs, m4 = n3.lineStartIndex, p3 = n3.lineStartIndex + n3.lineLength, f2 = e3.getoffsetX(n3.glyphStartIndex), g3 = e3.getoffsetX(_2 - 1), v2 = bt(t3 * f2, i3, s2, a3, o2, r2, n3.segment, m4, p3, l2, c5, h2, u2, d3);
            if (!v2)
              return null;
            const x2 = bt(t3 * g3, i3, s2, a3, o2, r2, n3.segment, m4, p3, l2, c5, h2, u2, d3);
            return x2 ? { first: v2, last: x2 } : null;
          }
          function pt(e3, i3, s2, a3) {
            return e3 === t2.WritingMode.horizontal && Math.abs(s2.y - i3.y) > Math.abs(s2.x - i3.x) * a3 ? { useVertical: true } : (e3 === t2.WritingMode.vertical ? i3.y < s2.y : i3.x > s2.x) ? { needsFlipping: true } : null;
          }
          function ft(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3, _2, m4, p3, f2) {
            const g3 = i3 / 24, v2 = e3.lineOffsetX * g3, x2 = e3.lineOffsetY * g3;
            let y2;
            if (e3.numGlyphs > 1) {
              const t3 = e3.glyphStartIndex + e3.numGlyphs, i4 = e3.lineStartIndex, o3 = e3.lineStartIndex + e3.lineLength, h3 = mt(g3, l2, v2, x2, s2, u2, d3, e3, c5, r2, _2, p3, f2);
              if (!h3)
                return { notEnoughRoom: true };
              const b3 = ht(h3.first.point, n3, f2).point, w2 = ht(h3.last.point, n3, f2).point;
              if (a3 && !s2) {
                const t4 = pt(e3.writingMode, b3, w2, m4);
                if (t4)
                  return t4;
              }
              y2 = [h3.first];
              for (let a4 = e3.glyphStartIndex + 1; a4 < t3 - 1; a4++)
                y2.push(bt(g3 * l2.getoffsetX(a4), v2, x2, s2, u2, d3, e3.segment, i4, o3, c5, r2, _2, p3, f2));
              y2.push(h3.last);
            } else {
              if (a3 && !s2) {
                const i5 = ht(d3, o2, f2).point, s3 = e3.lineStartIndex + e3.segment + 1, a4 = new t2.Point(c5.getx(s3), c5.gety(s3)), r3 = ht(a4, o2, f2), n4 = r3.signedDistanceFromCamera > 0 ? r3.point : gt(d3, a4, i5, 1, o2, f2), l3 = pt(e3.writingMode, i5, n4, m4);
                if (l3)
                  return l3;
              }
              const i4 = bt(g3 * l2.getoffsetX(e3.glyphStartIndex), v2, x2, s2, u2, d3, e3.segment, e3.lineStartIndex, e3.lineStartIndex + e3.lineLength, c5, r2, _2, p3, f2);
              if (!i4)
                return { notEnoughRoom: true };
              y2 = [i4];
            }
            for (const e4 of y2)
              t2.addDynamicAttributes(h2, e4.point, e4.angle);
            return {};
          }
          function gt(t3, e3, i3, s2, a3, o2) {
            const r2 = ht(t3.add(t3.sub(e3)._unit()), a3, o2).point, n3 = i3.sub(r2);
            return i3.add(n3._mult(s2 / n3.mag()));
          }
          function vt(e3, i3) {
            const { projectionCache: s2, lineVertexArray: a3, labelPlaneMatrix: o2, tileAnchorPoint: r2, distanceFromAnchor: n3, getElevation: l2, previousVertex: c5, direction: h2, absOffsetX: u2 } = i3;
            if (s2.projections[e3])
              return s2.projections[e3];
            const d3 = new t2.Point(a3.getx(e3), a3.gety(e3)), _2 = ht(d3, o2, l2);
            if (_2.signedDistanceFromCamera > 0)
              return s2.projections[e3] = _2.point, _2.point;
            const m4 = e3 - h2;
            return gt(0 === n3 ? r2 : new t2.Point(a3.getx(m4), a3.gety(m4)), d3, c5, u2 - n3 + 1, o2, l2);
          }
          function xt(t3, e3, i3) {
            return t3._unit()._perp()._mult(e3 * i3);
          }
          function yt(e3, i3, s2, a3, o2, r2, n3, l2) {
            const { projectionCache: c5, direction: h2 } = l2;
            if (c5.offsets[e3])
              return c5.offsets[e3];
            const u2 = s2.add(i3);
            if (e3 + h2 < a3 || e3 + h2 >= o2)
              return c5.offsets[e3] = u2, u2;
            const d3 = vt(e3 + h2, l2), _2 = xt(d3.sub(s2), n3, h2), m4 = s2.add(_2), p3 = d3.add(_2);
            return c5.offsets[e3] = t2.findLineIntersection(r2, u2, m4, p3) || u2, c5.offsets[e3];
          }
          function bt(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3, _2) {
            const m4 = s2 ? t3 - e3 : t3 + e3;
            let p3 = m4 > 0 ? 1 : -1, f2 = 0;
            s2 && (p3 *= -1, f2 = Math.PI), p3 < 0 && (f2 += Math.PI);
            let g3, v2, x2 = p3 > 0 ? n3 + r2 : n3 + r2 + 1, y2 = a3, b3 = a3, w2 = 0, T2 = 0;
            const E2 = Math.abs(m4), I2 = [];
            let S2;
            for (; w2 + T2 <= E2; ) {
              if (x2 += p3, x2 < n3 || x2 >= l2)
                return null;
              w2 += T2, b3 = y2, v2 = g3;
              const t4 = { projectionCache: u2, lineVertexArray: c5, labelPlaneMatrix: h2, tileAnchorPoint: o2, distanceFromAnchor: w2, getElevation: _2, previousVertex: b3, direction: p3, absOffsetX: E2 };
              if (y2 = vt(x2, t4), 0 === i3)
                I2.push(b3), S2 = y2.sub(b3);
              else {
                let e4;
                const s3 = y2.sub(b3);
                e4 = 0 === s3.mag() ? xt(vt(x2 + p3, t4).sub(y2), i3, p3) : xt(s3, i3, p3), v2 || (v2 = b3.add(e4)), g3 = yt(x2, e4, y2, n3, l2, v2, i3, t4), I2.push(v2), S2 = g3.sub(v2);
              }
              T2 = S2.mag();
            }
            const C3 = S2._mult((E2 - w2) / T2)._add(v2 || b3), P2 = f2 + Math.atan2(y2.y - b3.y, y2.x - b3.x);
            return I2.push(C3), { point: C3, angle: d3 ? P2 : 0, path: I2 };
          }
          const wt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function Tt(t3, e3) {
            for (let i3 = 0; i3 < t3; i3++) {
              const t4 = e3.length;
              e3.resize(t4 + 4), e3.float32.set(wt, 3 * t4);
            }
          }
          function Et3(t3, e3, i3) {
            const s2 = e3[0], a3 = e3[1];
            return t3[0] = i3[0] * s2 + i3[4] * a3 + i3[12], t3[1] = i3[1] * s2 + i3[5] * a3 + i3[13], t3[3] = i3[3] * s2 + i3[7] * a3 + i3[15], t3;
          }
          const It = 100;
          class St {
            constructor(t3, e3 = new nt(t3.width + 200, t3.height + 200, 25), i3 = new nt(t3.width + 200, t3.height + 200, 25)) {
              this.transform = t3, this.grid = e3, this.ignoredGrid = i3, this.pitchfactor = Math.cos(t3._pitch) * t3.cameraToCenterDistance, this.screenRightBoundary = t3.width + It, this.screenBottomBoundary = t3.height + It, this.gridRightBoundary = t3.width + 200, this.gridBottomBoundary = t3.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(t3, e3, i3, s2, a3, o2) {
              const r2 = this.projectAndGetPerspectiveRatio(s2, t3.anchorPointX, t3.anchorPointY, o2), n3 = i3 * r2.perspectiveRatio, l2 = t3.x1 * n3 + r2.point.x, c5 = t3.y1 * n3 + r2.point.y, h2 = t3.x2 * n3 + r2.point.x, u2 = t3.y2 * n3 + r2.point.y;
              return !this.isInsideGrid(l2, c5, h2, u2) || "always" !== e3 && this.grid.hitTest(l2, c5, h2, u2, e3, a3) || r2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l2, c5, h2, u2], offscreen: this.isOffscreen(l2, c5, h2, u2) };
            }
            placeCollisionCircles(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3, _2, m4) {
              const p3 = [], f2 = new t2.Point(i3.anchorX, i3.anchorY), g3 = ht(f2, r2, m4), v2 = ut(this.transform.cameraToCenterDistance, g3.signedDistanceFromCamera), x2 = (h2 ? o2 / v2 : o2 * v2) / t2.ONE_EM, y2 = ht(f2, n3, m4).point, b3 = mt(x2, a3, i3.lineOffsetX * x2, i3.lineOffsetY * x2, false, y2, f2, i3, s2, n3, { projections: {}, offsets: {} }, false, m4);
              let w2 = false, T2 = false, E2 = true;
              if (b3) {
                const i4 = 0.5 * d3 * v2 + _2, s3 = new t2.Point(-100, -100), a4 = new t2.Point(this.screenRightBoundary, this.screenBottomBoundary), o3 = new ot(), r3 = b3.first, n4 = b3.last;
                let h3 = [];
                for (let t3 = r3.path.length - 1; t3 >= 1; t3--)
                  h3.push(r3.path[t3]);
                for (let t3 = 1; t3 < n4.path.length; t3++)
                  h3.push(n4.path[t3]);
                const f3 = 2.5 * i4;
                if (l2) {
                  const t3 = h3.map((t4) => ht(t4, l2, m4));
                  h3 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
                }
                let g4 = [];
                if (h3.length > 0) {
                  const e4 = h3[0].clone(), i5 = h3[0].clone();
                  for (let t3 = 1; t3 < h3.length; t3++)
                    e4.x = Math.min(e4.x, h3[t3].x), e4.y = Math.min(e4.y, h3[t3].y), i5.x = Math.max(i5.x, h3[t3].x), i5.y = Math.max(i5.y, h3[t3].y);
                  g4 = e4.x >= s3.x && i5.x <= a4.x && e4.y >= s3.y && i5.y <= a4.y ? [h3] : i5.x < s3.x || e4.x > a4.x || i5.y < s3.y || e4.y > a4.y ? [] : t2.clipLine([h3], s3.x, s3.y, a4.x, a4.y);
                }
                for (const t3 of g4) {
                  o3.reset(t3, 0.25 * i4);
                  let s4 = 0;
                  s4 = o3.length <= 0.5 * i4 ? 1 : Math.ceil(o3.paddedLength / f3) + 1;
                  for (let t4 = 0; t4 < s4; t4++) {
                    const a5 = t4 / Math.max(s4 - 1, 1), r4 = o3.lerp(a5), n5 = r4.x + It, l3 = r4.y + It;
                    p3.push(n5, l3, i4, 0);
                    const h4 = n5 - i4, d4 = l3 - i4, _3 = n5 + i4, m5 = l3 + i4;
                    if (E2 = E2 && this.isOffscreen(h4, d4, _3, m5), T2 = T2 || this.isInsideGrid(h4, d4, _3, m5), "always" !== e3 && this.grid.hitTestCircle(n5, l3, i4, e3, u2) && (w2 = true, !c5))
                      return { circles: [], offscreen: false, collisionDetected: w2 };
                  }
                }
              }
              return { circles: !c5 && w2 || !T2 || v2 < this.perspectiveRatioCutoff ? [] : p3, offscreen: E2, collisionDetected: w2 };
            }
            queryRenderedSymbols(e3) {
              if (0 === e3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                return {};
              const i3 = [];
              let s2 = 1 / 0, a3 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
              for (const n4 of e3) {
                const e4 = new t2.Point(n4.x + It, n4.y + It);
                s2 = Math.min(s2, e4.x), a3 = Math.min(a3, e4.y), o2 = Math.max(o2, e4.x), r2 = Math.max(r2, e4.y), i3.push(e4);
              }
              const n3 = this.grid.query(s2, a3, o2, r2).concat(this.ignoredGrid.query(s2, a3, o2, r2)), l2 = {}, c5 = {};
              for (const e4 of n3) {
                const s3 = e4.key;
                if (void 0 === l2[s3.bucketInstanceId] && (l2[s3.bucketInstanceId] = {}), l2[s3.bucketInstanceId][s3.featureIndex])
                  continue;
                const a4 = [new t2.Point(e4.x1, e4.y1), new t2.Point(e4.x2, e4.y1), new t2.Point(e4.x2, e4.y2), new t2.Point(e4.x1, e4.y2)];
                t2.polygonIntersectsPolygon(i3, a4) && (l2[s3.bucketInstanceId][s3.featureIndex] = true, void 0 === c5[s3.bucketInstanceId] && (c5[s3.bucketInstanceId] = []), c5[s3.bucketInstanceId].push(s3.featureIndex));
              }
              return c5;
            }
            insertCollisionBox(t3, e3, i3, s2, a3, o2) {
              (i3 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s2, featureIndex: a3, collisionGroupID: o2, overlapMode: e3 }, t3[0], t3[1], t3[2], t3[3]);
            }
            insertCollisionCircles(t3, e3, i3, s2, a3, o2) {
              const r2 = i3 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: s2, featureIndex: a3, collisionGroupID: o2, overlapMode: e3 };
              for (let e4 = 0; e4 < t3.length; e4 += 4)
                r2.insertCircle(n3, t3[e4], t3[e4 + 1], t3[e4 + 2]);
            }
            projectAndGetPerspectiveRatio(e3, i3, s2, a3) {
              let o2;
              return a3 ? (o2 = [i3, s2, a3(i3, s2), 1], t2.transformMat4(o2, o2, e3)) : (o2 = [i3, s2, 0, 1], Et3(o2, o2, e3)), { point: new t2.Point((o2[0] / o2[3] + 1) / 2 * this.transform.width + It, (-o2[1] / o2[3] + 1) / 2 * this.transform.height + It), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o2[3] * 0.5 };
            }
            isOffscreen(t3, e3, i3, s2) {
              return i3 < It || t3 >= this.screenRightBoundary || s2 < It || e3 > this.screenBottomBoundary;
            }
            isInsideGrid(t3, e3, i3, s2) {
              return i3 >= 0 && t3 < this.gridRightBoundary && s2 >= 0 && e3 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e3 = t2.identity([]);
              return t2.translate(e3, e3, [-100, -100, 0]), e3;
            }
          }
          function Ct(e3, i3, s2) {
            return i3 * (t2.EXTENT / (e3.tileSize * Math.pow(2, s2 - e3.tileID.overscaledZ)));
          }
          class Pt {
            constructor(t3, e3, i3, s2) {
              this.opacity = t3 ? Math.max(0, Math.min(1, t3.opacity + (t3.placed ? e3 : -e3))) : s2 && i3 ? 1 : 0, this.placed = i3;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Dt {
            constructor(t3, e3, i3, s2, a3) {
              this.text = new Pt(t3 ? t3.text : null, e3, i3, a3), this.icon = new Pt(t3 ? t3.icon : null, e3, s2, a3);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class zt {
            constructor(t3, e3, i3) {
              this.text = t3, this.icon = e3, this.skipFade = i3;
            }
          }
          class Mt {
            constructor() {
              this.invProjMatrix = t2.create(), this.viewportMatrix = t2.create(), this.circles = [];
            }
          }
          class At {
            constructor(t3, e3, i3, s2, a3) {
              this.bucketInstanceId = t3, this.featureIndex = e3, this.sourceLayerIndex = i3, this.bucketIndex = s2, this.tileID = a3;
            }
          }
          class Lt {
            constructor(t3) {
              this.crossSourceCollisions = t3, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t3) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[t3]) {
                const e3 = ++this.maxGroupID;
                this.collisionGroups[t3] = { ID: e3, predicate: (t4) => t4.collisionGroupID === e3 };
              }
              return this.collisionGroups[t3];
            }
          }
          function Rt(e3, i3, s2, a3, o2) {
            const { horizontalAlign: r2, verticalAlign: n3 } = t2.getAnchorAlignment(e3), l2 = -(r2 - 0.5) * i3, c5 = -(n3 - 0.5) * s2, h2 = t2.evaluateVariableOffset(e3, a3);
            return new t2.Point(l2 + h2[0] * o2, c5 + h2[1] * o2);
          }
          function kt(e3, i3, s2, a3, o2, r2) {
            const { x1: n3, x2: l2, y1: c5, y2: h2, anchorPointX: u2, anchorPointY: d3 } = e3, _2 = new t2.Point(i3, s2);
            return a3 && _2._rotate(o2 ? r2 : -r2), { x1: n3 + _2.x, y1: c5 + _2.y, x2: l2 + _2.x, y2: h2 + _2.y, anchorPointX: u2, anchorPointY: d3 };
          }
          class Bt {
            constructor(t3, e3, i3, s2, a3) {
              this.transform = t3.clone(), this.terrain = e3, this.collisionIndex = new St(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i3, this.retainedQueryData = {}, this.collisionGroups = new Lt(s2), this.collisionCircleArrays = {}, this.prevPlacement = a3, a3 && (a3.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e3, i3, s2, a3) {
              const o2 = s2.getBucket(i3), r2 = s2.latestFeatureIndex;
              if (!o2 || !r2 || i3.id !== o2.layerIds[0])
                return;
              const n3 = s2.collisionBoxArray, l2 = o2.layers[0].layout, c5 = Math.pow(2, this.transform.zoom - s2.tileID.overscaledZ), h2 = s2.tileSize / t2.EXTENT, u2 = this.transform.calculatePosMatrix(s2.tileID.toUnwrapped()), d3 = "map" === l2.get("text-pitch-alignment"), _2 = "map" === l2.get("text-rotation-alignment"), m4 = Ct(s2, 1, this.transform.zoom), p3 = lt(u2, d3, _2, this.transform, m4);
              let f2 = null;
              if (d3) {
                const e4 = ct(u2, d3, _2, this.transform, m4);
                f2 = t2.multiply([], this.transform.labelPlaneMatrix, e4);
              }
              this.retainedQueryData[o2.bucketInstanceId] = new At(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, s2.tileID);
              const g3 = { bucket: o2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: p3, labelToScreenMatrix: f2, scale: c5, textPixelRatio: h2, holdingForFade: s2.holdingForFade(), collisionBoxArray: n3, partiallyEvaluatedTextSize: t2.evaluateSizeForZoom(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
              if (a3)
                for (const t3 of o2.sortKeyRanges) {
                  const { sortKey: i4, symbolInstanceStart: s3, symbolInstanceEnd: a4 } = t3;
                  e3.push({ sortKey: i4, symbolInstanceStart: s3, symbolInstanceEnd: a4, parameters: g3 });
                }
              else
                e3.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: g3 });
            }
            attemptAnchorPlacement(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3, _2, m4, p3) {
              const f2 = [u2.textOffset0, u2.textOffset1], g3 = Rt(t3, i3, s2, f2, a3), v2 = this.collisionIndex.placeCollisionBox(kt(e3, g3.x, g3.y, o2, r2, this.transform.angle), h2, n3, l2, c5.predicate, p3);
              if ((!m4 || 0 !== this.collisionIndex.placeCollisionBox(kt(m4, g3.x, g3.y, o2, r2, this.transform.angle), h2, n3, l2, c5.predicate, p3).box.length) && v2.box.length > 0) {
                let e4;
                if (this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (e4 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), 0 === u2.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                return this.variableOffsets[u2.crossTileID] = { textOffset: f2, width: i3, height: s2, anchor: t3, textBoxScale: a3, prevAnchor: e4 }, this.markUsedJustification(d3, t3, u2, _2), d3.allowVerticalPlacement && (this.markUsedOrientation(d3, _2, u2), this.placedOrientations[u2.crossTileID] = _2), { shift: g3, placedGlyphBoxes: v2 };
              }
            }
            placeLayerBucketPart(e3, i3, s2) {
              const { bucket: a3, layout: o2, posMatrix: r2, textLabelPlaneMatrix: n3, labelToScreenMatrix: l2, textPixelRatio: c5, holdingForFade: h2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d3, collisionGroup: _2 } = e3.parameters, m4 = o2.get("text-optional"), p3 = o2.get("icon-optional"), f2 = t2.getOverlapMode(o2, "text-overlap", "text-allow-overlap"), g3 = "always" === f2, v2 = t2.getOverlapMode(o2, "icon-overlap", "icon-allow-overlap"), x2 = "always" === v2, y2 = "map" === o2.get("text-rotation-alignment"), b3 = "map" === o2.get("text-pitch-alignment"), w2 = "none" !== o2.get("icon-text-fit"), T2 = "viewport-y" === o2.get("symbol-z-order"), E2 = g3 && (x2 || !a3.hasIconData() || p3), I2 = x2 && (g3 || !a3.hasTextData() || m4);
              !a3.collisionArrays && u2 && a3.deserializeCollisionBoxes(u2);
              const S2 = this.retainedQueryData[a3.bucketInstanceId].tileID, C3 = this.terrain ? (t3, e4) => this.terrain.getElevation(S2, t3, e4) : null, P2 = (e4, u3) => {
                if (i3[e4.crossTileID])
                  return;
                if (h2)
                  return void (this.placements[e4.crossTileID] = new zt(false, false, false));
                let x3 = false, T3 = false, S3 = true, P4 = null, D2 = { box: null, offscreen: null }, z2 = { box: null, offscreen: null }, M2 = null, A2 = null, L2 = null, R2 = 0, k2 = 0, B2 = 0;
                u3.textFeatureIndex ? R2 = u3.textFeatureIndex : e4.useRuntimeCollisionCircles && (R2 = e4.featureIndex), u3.verticalTextFeatureIndex && (k2 = u3.verticalTextFeatureIndex);
                const F2 = u3.textBox;
                if (F2) {
                  const i4 = (i5) => {
                    let s4 = t2.WritingMode.horizontal;
                    if (a3.allowVerticalPlacement && !i5 && this.prevPlacement) {
                      const t3 = this.prevPlacement.placedOrientations[e4.crossTileID];
                      t3 && (this.placedOrientations[e4.crossTileID] = t3, s4 = t3, this.markUsedOrientation(a3, s4, e4));
                    }
                    return s4;
                  }, s3 = (i5, s4) => {
                    if (a3.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                      for (const e5 of a3.writingModes)
                        if (e5 === t2.WritingMode.vertical ? (D2 = s4(), z2 = D2) : D2 = i5(), D2 && D2.box && D2.box.length)
                          break;
                    } else
                      D2 = i5();
                  };
                  if (o2.get("text-variable-anchor")) {
                    let n4 = o2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[e4.crossTileID]) {
                      const t3 = this.prevPlacement.variableOffsets[e4.crossTileID];
                      n4.indexOf(t3.anchor) > 0 && (n4 = n4.filter((e5) => e5 !== t3.anchor), n4.unshift(t3.anchor));
                    }
                    const l3 = (t3, i5, s4) => {
                      const o3 = t3.x2 - t3.x1, l4 = t3.y2 - t3.y1, h4 = e4.textBoxScale, u4 = w2 && "never" === v2 ? i5 : null;
                      let d4 = { box: [], offscreen: false };
                      const m5 = "never" !== f2 ? 2 * n4.length : n4.length;
                      for (let i6 = 0; i6 < m5; ++i6) {
                        const m6 = this.attemptAnchorPlacement(n4[i6 % n4.length], t3, o3, l4, h4, y2, b3, c5, r2, _2, i6 >= n4.length ? f2 : "never", e4, a3, s4, u4, C3);
                        if (m6 && (d4 = m6.placedGlyphBoxes, d4 && d4.box && d4.box.length)) {
                          x3 = true, P4 = m6.shift;
                          break;
                        }
                      }
                      return d4;
                    };
                    s3(() => l3(F2, u3.iconBox, t2.WritingMode.horizontal), () => {
                      const i5 = u3.verticalTextBox;
                      return a3.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && e4.numVerticalGlyphVertices > 0 && i5 ? l3(i5, u3.verticalIconBox, t2.WritingMode.vertical) : { box: null, offscreen: null };
                    }), D2 && (x3 = D2.box, S3 = D2.offscreen);
                    const h3 = i4(D2 && D2.box);
                    if (!x3 && this.prevPlacement) {
                      const t3 = this.prevPlacement.variableOffsets[e4.crossTileID];
                      t3 && (this.variableOffsets[e4.crossTileID] = t3, this.markUsedJustification(a3, t3.anchor, e4, h3));
                    }
                  } else {
                    const o3 = (t3, i5) => {
                      const s4 = this.collisionIndex.placeCollisionBox(t3, f2, c5, r2, _2.predicate, C3);
                      return s4 && s4.box && s4.box.length && (this.markUsedOrientation(a3, i5, e4), this.placedOrientations[e4.crossTileID] = i5), s4;
                    };
                    s3(() => o3(F2, t2.WritingMode.horizontal), () => {
                      const i5 = u3.verticalTextBox;
                      return a3.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && i5 ? o3(i5, t2.WritingMode.vertical) : { box: null, offscreen: null };
                    }), i4(D2 && D2.box && D2.box.length);
                  }
                }
                if (M2 = D2, x3 = M2 && M2.box && M2.box.length > 0, S3 = M2 && M2.offscreen, e4.useRuntimeCollisionCircles) {
                  const i4 = a3.text.placedSymbolArray.get(e4.centerJustifiedTextSymbolIndex), c6 = t2.evaluateSizeForFeature(a3.textSizeData, d3, i4), h3 = o2.get("text-padding");
                  A2 = this.collisionIndex.placeCollisionCircles(f2, i4, a3.lineVertexArray, a3.glyphOffsetArray, c6, r2, n3, l2, s2, b3, _2.predicate, e4.collisionCircleDiameter, h3, C3), A2.circles.length && A2.collisionDetected && !s2 && t2.warnOnce("Collisions detected, but collision boxes are not shown"), x3 = g3 || A2.circles.length > 0 && !A2.collisionDetected, S3 = S3 && A2.offscreen;
                }
                if (u3.iconFeatureIndex && (B2 = u3.iconFeatureIndex), u3.iconBox) {
                  const t3 = (t4) => {
                    const e5 = w2 && P4 ? kt(t4, P4.x, P4.y, y2, b3, this.transform.angle) : t4;
                    return this.collisionIndex.placeCollisionBox(e5, v2, c5, r2, _2.predicate, C3);
                  };
                  z2 && z2.box && z2.box.length && u3.verticalIconBox ? (L2 = t3(u3.verticalIconBox), T3 = L2.box.length > 0) : (L2 = t3(u3.iconBox), T3 = L2.box.length > 0), S3 = S3 && L2.offscreen;
                }
                const U2 = m4 || 0 === e4.numHorizontalGlyphVertices && 0 === e4.numVerticalGlyphVertices, O2 = p3 || 0 === e4.numIconVertices;
                if (U2 || O2 ? O2 ? U2 || (T3 = T3 && x3) : x3 = T3 && x3 : T3 = x3 = T3 && x3, x3 && M2 && M2.box && this.collisionIndex.insertCollisionBox(M2.box, f2, o2.get("text-ignore-placement"), a3.bucketInstanceId, z2 && z2.box && k2 ? k2 : R2, _2.ID), T3 && L2 && this.collisionIndex.insertCollisionBox(L2.box, v2, o2.get("icon-ignore-placement"), a3.bucketInstanceId, B2, _2.ID), A2 && (x3 && this.collisionIndex.insertCollisionCircles(A2.circles, f2, o2.get("text-ignore-placement"), a3.bucketInstanceId, R2, _2.ID), s2)) {
                  const t3 = a3.bucketInstanceId;
                  let e5 = this.collisionCircleArrays[t3];
                  void 0 === e5 && (e5 = this.collisionCircleArrays[t3] = new Mt());
                  for (let t4 = 0; t4 < A2.circles.length; t4 += 4)
                    e5.circles.push(A2.circles[t4 + 0]), e5.circles.push(A2.circles[t4 + 1]), e5.circles.push(A2.circles[t4 + 2]), e5.circles.push(A2.collisionDetected ? 1 : 0);
                }
                if (0 === e4.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === a3.bucketInstanceId)
                  throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[e4.crossTileID] = new zt(x3 || E2, T3 || I2, S3 || a3.justReloaded), i3[e4.crossTileID] = true;
              };
              if (T2) {
                if (0 !== e3.symbolInstanceStart)
                  throw new Error("bucket.bucketInstanceId should be 0");
                const t3 = a3.getSortedSymbolIndexes(this.transform.angle);
                for (let e4 = t3.length - 1; e4 >= 0; --e4) {
                  const i4 = t3[e4];
                  P2(a3.symbolInstances.get(i4), a3.collisionArrays[i4]);
                }
              } else
                for (let t3 = e3.symbolInstanceStart; t3 < e3.symbolInstanceEnd; t3++)
                  P2(a3.symbolInstances.get(t3), a3.collisionArrays[t3]);
              if (s2 && a3.bucketInstanceId in this.collisionCircleArrays) {
                const e4 = this.collisionCircleArrays[a3.bucketInstanceId];
                t2.invert(e4.invProjMatrix, r2), e4.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              a3.justReloaded = false;
            }
            markUsedJustification(e3, i3, s2, a3) {
              let o2;
              o2 = a3 === t2.WritingMode.vertical ? s2.verticalPlacedTextSymbolIndex : { left: s2.leftJustifiedTextSymbolIndex, center: s2.centerJustifiedTextSymbolIndex, right: s2.rightJustifiedTextSymbolIndex }[t2.getAnchorJustification(i3)];
              const r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex, s2.verticalPlacedTextSymbolIndex];
              for (const t3 of r2)
                t3 >= 0 && (e3.text.placedSymbolArray.get(t3).crossTileID = o2 >= 0 && t3 !== o2 ? 0 : s2.crossTileID);
            }
            markUsedOrientation(e3, i3, s2) {
              const a3 = i3 === t2.WritingMode.horizontal || i3 === t2.WritingMode.horizontalOnly ? i3 : 0, o2 = i3 === t2.WritingMode.vertical ? i3 : 0, r2 = [s2.leftJustifiedTextSymbolIndex, s2.centerJustifiedTextSymbolIndex, s2.rightJustifiedTextSymbolIndex];
              for (const t3 of r2)
                e3.text.placedSymbolArray.get(t3).placedOrientation = a3;
              s2.verticalPlacedTextSymbolIndex && (e3.text.placedSymbolArray.get(s2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
            }
            commit(t3) {
              this.commitTime = t3, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const e3 = this.prevPlacement;
              let i3 = false;
              this.prevZoomAdjustment = e3 ? e3.zoomAdjustment(this.transform.zoom) : 0;
              const s2 = e3 ? e3.symbolFadeChange(t3) : 1, a3 = e3 ? e3.opacities : {}, o2 = e3 ? e3.variableOffsets : {}, r2 = e3 ? e3.placedOrientations : {};
              for (const t4 in this.placements) {
                const e4 = this.placements[t4], o3 = a3[t4];
                o3 ? (this.opacities[t4] = new Dt(o3, s2, e4.text, e4.icon), i3 = i3 || e4.text !== o3.text.placed || e4.icon !== o3.icon.placed) : (this.opacities[t4] = new Dt(null, s2, e4.text, e4.icon, e4.skipFade), i3 = i3 || e4.text || e4.icon);
              }
              for (const t4 in a3) {
                const e4 = a3[t4];
                if (!this.opacities[t4]) {
                  const a4 = new Dt(e4, s2, false, false);
                  a4.isHidden() || (this.opacities[t4] = a4, i3 = i3 || e4.text.placed || e4.icon.placed);
                }
              }
              for (const t4 in o2)
                this.variableOffsets[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.variableOffsets[t4] = o2[t4]);
              for (const t4 in r2)
                this.placedOrientations[t4] || !this.opacities[t4] || this.opacities[t4].isHidden() || (this.placedOrientations[t4] = r2[t4]);
              if (e3 && void 0 === e3.lastPlacementChangeTime)
                throw new Error("Last placement time for previous placement is not defined");
              i3 ? this.lastPlacementChangeTime = t3 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e3 ? e3.lastPlacementChangeTime : t3);
            }
            updateLayerOpacities(t3, e3) {
              const i3 = {};
              for (const s2 of e3) {
                const e4 = s2.getBucket(t3);
                e4 && s2.latestFeatureIndex && t3.id === e4.layerIds[0] && this.updateBucketOpacities(e4, i3, s2.collisionBoxArray);
              }
            }
            updateBucketOpacities(e3, i3, s2) {
              e3.hasTextData() && (e3.text.opacityVertexArray.clear(), e3.text.hasVisibleVertices = false), e3.hasIconData() && (e3.icon.opacityVertexArray.clear(), e3.icon.hasVisibleVertices = false), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexArray.clear(), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexArray.clear();
              const a3 = e3.layers[0].layout, o2 = new Dt(null, 0, false, false, true), r2 = a3.get("text-allow-overlap"), n3 = a3.get("icon-allow-overlap"), l2 = a3.get("text-variable-anchor"), c5 = "map" === a3.get("text-rotation-alignment"), h2 = "map" === a3.get("text-pitch-alignment"), u2 = "none" !== a3.get("icon-text-fit"), d3 = new Dt(null, 0, r2 && (n3 || !e3.hasIconData() || a3.get("icon-optional")), n3 && (r2 || !e3.hasTextData() || a3.get("text-optional")), true);
              !e3.collisionArrays && s2 && (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) && e3.deserializeCollisionBoxes(s2);
              const _2 = (t3, e4, i4) => {
                for (let s3 = 0; s3 < e4 / 4; s3++)
                  t3.opacityVertexArray.emplaceBack(i4);
                t3.hasVisibleVertices = t3.hasVisibleVertices || i4 !== $t;
              };
              for (let s3 = 0; s3 < e3.symbolInstances.length; s3++) {
                const a4 = e3.symbolInstances.get(s3), { numHorizontalGlyphVertices: r3, numVerticalGlyphVertices: n4, crossTileID: m4 } = a4;
                let p3 = this.opacities[m4];
                i3[m4] ? p3 = o2 : p3 || (p3 = d3, this.opacities[m4] = p3), i3[m4] = true;
                const f2 = a4.numIconVertices > 0, g3 = this.placedOrientations[a4.crossTileID], v2 = g3 === t2.WritingMode.vertical, x2 = g3 === t2.WritingMode.horizontal || g3 === t2.WritingMode.horizontalOnly;
                if (r3 > 0 || n4 > 0) {
                  const t3 = jt(p3.text);
                  _2(e3.text, r3, v2 ? $t : t3), _2(e3.text, n4, x2 ? $t : t3);
                  const i4 = p3.text.isHidden();
                  [a4.rightJustifiedTextSymbolIndex, a4.centerJustifiedTextSymbolIndex, a4.leftJustifiedTextSymbolIndex].forEach((t4) => {
                    t4 >= 0 && (e3.text.placedSymbolArray.get(t4).hidden = i4 || v2 ? 1 : 0);
                  }), a4.verticalPlacedTextSymbolIndex >= 0 && (e3.text.placedSymbolArray.get(a4.verticalPlacedTextSymbolIndex).hidden = i4 || x2 ? 1 : 0);
                  const s4 = this.variableOffsets[a4.crossTileID];
                  s4 && this.markUsedJustification(e3, s4.anchor, a4, g3);
                  const o3 = this.placedOrientations[a4.crossTileID];
                  o3 && (this.markUsedJustification(e3, "left", a4, o3), this.markUsedOrientation(e3, o3, a4));
                }
                if (f2) {
                  const t3 = jt(p3.icon), i4 = !(u2 && a4.verticalPlacedIconSymbolIndex && v2);
                  a4.placedIconSymbolIndex >= 0 && (_2(e3.icon, a4.numIconVertices, i4 ? t3 : $t), e3.icon.placedSymbolArray.get(a4.placedIconSymbolIndex).hidden = p3.icon.isHidden()), a4.verticalPlacedIconSymbolIndex >= 0 && (_2(e3.icon, a4.numVerticalIconVertices, i4 ? $t : t3), e3.icon.placedSymbolArray.get(a4.verticalPlacedIconSymbolIndex).hidden = p3.icon.isHidden());
                }
                if (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) {
                  const i4 = e3.collisionArrays[s3];
                  if (i4) {
                    let s4 = new t2.Point(0, 0);
                    if (i4.textBox || i4.verticalTextBox) {
                      let t3 = true;
                      if (l2) {
                        const e4 = this.variableOffsets[m4];
                        e4 ? (s4 = Rt(e4.anchor, e4.width, e4.height, e4.textOffset, e4.textBoxScale), c5 && s4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t3 = false;
                      }
                      i4.textBox && Ft(e3.textCollisionBox.collisionVertexArray, p3.text.placed, !t3 || v2, s4.x, s4.y), i4.verticalTextBox && Ft(e3.textCollisionBox.collisionVertexArray, p3.text.placed, !t3 || x2, s4.x, s4.y);
                    }
                    const a5 = Boolean(!x2 && i4.verticalIconBox);
                    i4.iconBox && Ft(e3.iconCollisionBox.collisionVertexArray, p3.icon.placed, a5, u2 ? s4.x : 0, u2 ? s4.y : 0), i4.verticalIconBox && Ft(e3.iconCollisionBox.collisionVertexArray, p3.icon.placed, !a5, u2 ? s4.x : 0, u2 ? s4.y : 0);
                  }
                }
              }
              if (e3.sortFeatures(this.transform.angle), this.retainedQueryData[e3.bucketInstanceId] && (this.retainedQueryData[e3.bucketInstanceId].featureSortOrder = e3.featureSortOrder), e3.hasTextData() && e3.text.opacityVertexBuffer && e3.text.opacityVertexBuffer.updateData(e3.text.opacityVertexArray), e3.hasIconData() && e3.icon.opacityVertexBuffer && e3.icon.opacityVertexBuffer.updateData(e3.icon.opacityVertexArray), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexBuffer && e3.iconCollisionBox.collisionVertexBuffer.updateData(e3.iconCollisionBox.collisionVertexArray), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexBuffer && e3.textCollisionBox.collisionVertexBuffer.updateData(e3.textCollisionBox.collisionVertexArray), e3.text.opacityVertexArray.length !== e3.text.layoutVertexArray.length / 4)
                throw new Error(`bucket.text.opacityVertexArray.length (= ${e3.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e3.text.layoutVertexArray.length}) / 4`);
              if (e3.icon.opacityVertexArray.length !== e3.icon.layoutVertexArray.length / 4)
                throw new Error(`bucket.icon.opacityVertexArray.length (= ${e3.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e3.icon.layoutVertexArray.length}) / 4`);
              if (e3.bucketInstanceId in this.collisionCircleArrays) {
                const t3 = this.collisionCircleArrays[e3.bucketInstanceId];
                e3.placementInvProjMatrix = t3.invProjMatrix, e3.placementViewportMatrix = t3.viewportMatrix, e3.collisionCircleArray = t3.circles, delete this.collisionCircleArrays[e3.bucketInstanceId];
              }
            }
            symbolFadeChange(t3) {
              return 0 === this.fadeDuration ? 1 : (t3 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t3) {
              return Math.max(0, (this.transform.zoom - t3) / 1.5);
            }
            hasTransitions(t3) {
              return this.stale || t3 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t3, e3) {
              const i3 = this.zoomAtLastRecencyCheck === e3 ? 1 - this.zoomAdjustment(e3) : 1;
              return this.zoomAtLastRecencyCheck = e3, this.commitTime + this.fadeDuration * i3 > t3;
            }
            setStale() {
              this.stale = true;
            }
          }
          function Ft(t3, e3, i3, s2, a3) {
            t3.emplaceBack(e3 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a3 || 0), t3.emplaceBack(e3 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a3 || 0), t3.emplaceBack(e3 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a3 || 0), t3.emplaceBack(e3 ? 1 : 0, i3 ? 1 : 0, s2 || 0, a3 || 0);
          }
          const Ut = Math.pow(2, 25), Ot = Math.pow(2, 24), Nt = Math.pow(2, 17), Gt = Math.pow(2, 16), Zt = Math.pow(2, 9), Vt = Math.pow(2, 8), qt = Math.pow(2, 1);
          function jt(t3) {
            if (0 === t3.opacity && !t3.placed)
              return 0;
            if (1 === t3.opacity && t3.placed)
              return 4294967295;
            const e3 = t3.placed ? 1 : 0, i3 = Math.floor(127 * t3.opacity);
            return i3 * Ut + e3 * Ot + i3 * Nt + e3 * Gt + i3 * Zt + e3 * Vt + i3 * qt + e3;
          }
          const $t = 0;
          class Xt {
            constructor(t3) {
              this._sortAcrossTiles = "viewport-y" !== t3.layout.get("symbol-z-order") && !t3.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t3, e3, i3, s2, a3) {
              const o2 = this._bucketParts;
              for (; this._currentTileIndex < t3.length; )
                if (e3.getBucketParts(o2, s2, t3[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a3())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t4, e4) => t4.sortKey - e4.sortKey)); this._currentPartIndex < o2.length; )
                if (e3.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i3), this._currentPartIndex++, a3())
                  return true;
              return false;
            }
          }
          class Wt {
            constructor(t3, e3, i3, s2, a3, o2, r2, n3) {
              this.placement = new Bt(t3, e3, o2, r2, n3), this._currentPlacementIndex = i3.length - 1, this._forceFullPlacement = s2, this._showCollisionBoxes = a3, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e3, i3, s2) {
              const a3 = t2.browser.now(), o2 = () => !this._forceFullPlacement && t2.browser.now() - a3 > 2;
              for (; this._currentPlacementIndex >= 0; ) {
                const t3 = i3[e3[this._currentPlacementIndex]], a4 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === t3.type && (!t3.minzoom || t3.minzoom <= a4) && (!t3.maxzoom || t3.maxzoom > a4)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new Xt(t3)), this._inProgressLayer.continuePlacement(s2[t3.source], this.placement, this._showCollisionBoxes, t3, o2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(t3) {
              return this.placement.commit(t3), this.placement;
            }
          }
          const Ht = 512 / t2.EXTENT / 2;
          class Kt {
            constructor(e3, i3, s2) {
              this.tileID = e3, this.bucketInstanceId = s2, this._symbolsByKey = {};
              const a3 = /* @__PURE__ */ new Map();
              for (let t3 = 0; t3 < i3.length; t3++) {
                const e4 = i3.get(t3), s3 = e4.key, o2 = a3.get(s3);
                o2 ? o2.push(e4) : a3.set(s3, [e4]);
              }
              for (const [e4, i4] of a3) {
                const s3 = { positions: i4.map((t3) => ({ x: Math.floor(t3.anchorX * Ht), y: Math.floor(t3.anchorY * Ht) })), crossTileIDs: i4.map((t3) => t3.crossTileID) };
                if (s3.positions.length > 128) {
                  const e5 = new t2.KDBush(s3.positions.length, 16, Uint16Array);
                  for (const { x: t3, y: i5 } of s3.positions)
                    e5.add(t3, i5);
                  e5.finish(), delete s3.positions, s3.index = e5;
                }
                this._symbolsByKey[e4] = s3;
              }
            }
            getScaledCoordinates(e3, i3) {
              const { x: s2, y: a3, z: o2 } = this.tileID.canonical, { x: r2, y: n3, z: l2 } = i3.canonical, c5 = Ht / Math.pow(2, l2 - o2), h2 = (n3 * t2.EXTENT + e3.anchorY) * c5, u2 = a3 * t2.EXTENT * Ht;
              return { x: Math.floor((r2 * t2.EXTENT + e3.anchorX) * c5 - s2 * t2.EXTENT * Ht), y: Math.floor(h2 - u2) };
            }
            findMatches(t3, e3, i3) {
              const s2 = this.tileID.canonical.z < e3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e3.canonical.z);
              for (let a3 = 0; a3 < t3.length; a3++) {
                const o2 = t3.get(a3);
                if (o2.crossTileID)
                  continue;
                const r2 = this._symbolsByKey[o2.key];
                if (!r2)
                  continue;
                const n3 = this.getScaledCoordinates(o2, e3);
                if (r2.index) {
                  const t4 = r2.index.range(n3.x - s2, n3.y - s2, n3.x + s2, n3.y + s2).sort();
                  for (const e4 of t4) {
                    const t5 = r2.crossTileIDs[e4];
                    if (!i3[t5]) {
                      i3[t5] = true, o2.crossTileID = t5;
                      break;
                    }
                  }
                } else if (r2.positions)
                  for (let t4 = 0; t4 < r2.positions.length; t4++) {
                    const e4 = r2.positions[t4], a4 = r2.crossTileIDs[t4];
                    if (Math.abs(e4.x - n3.x) <= s2 && Math.abs(e4.y - n3.y) <= s2 && !i3[a4]) {
                      i3[a4] = true, o2.crossTileID = a4;
                      break;
                    }
                  }
              }
            }
            getCrossTileIDsLists() {
              return Object.values(this._symbolsByKey).map(({ crossTileIDs: t3 }) => t3);
            }
          }
          class Yt {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Jt {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t3) {
              const e3 = Math.round((t3 - this.lng) / 360);
              if (0 !== e3)
                for (const t4 in this.indexes) {
                  const i3 = this.indexes[t4], s2 = {};
                  for (const t5 in i3) {
                    const a3 = i3[t5];
                    a3.tileID = a3.tileID.unwrapTo(a3.tileID.wrap + e3), s2[a3.tileID.key] = a3;
                  }
                  this.indexes[t4] = s2;
                }
              this.lng = t3;
            }
            addBucket(t3, e3, i3) {
              if (this.indexes[t3.overscaledZ] && this.indexes[t3.overscaledZ][t3.key]) {
                if (this.indexes[t3.overscaledZ][t3.key].bucketInstanceId === e3.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(t3.overscaledZ, this.indexes[t3.overscaledZ][t3.key]);
              }
              for (let t4 = 0; t4 < e3.symbolInstances.length; t4++)
                e3.symbolInstances.get(t4).crossTileID = 0;
              this.usedCrossTileIDs[t3.overscaledZ] || (this.usedCrossTileIDs[t3.overscaledZ] = {});
              const s2 = this.usedCrossTileIDs[t3.overscaledZ];
              for (const i4 in this.indexes) {
                const a3 = this.indexes[i4];
                if (Number(i4) > t3.overscaledZ)
                  for (const i5 in a3) {
                    const o2 = a3[i5];
                    o2.tileID.isChildOf(t3) && o2.findMatches(e3.symbolInstances, t3, s2);
                  }
                else {
                  const o2 = a3[t3.scaledTo(Number(i4)).key];
                  o2 && o2.findMatches(e3.symbolInstances, t3, s2);
                }
              }
              for (let t4 = 0; t4 < e3.symbolInstances.length; t4++) {
                const a3 = e3.symbolInstances.get(t4);
                a3.crossTileID || (a3.crossTileID = i3.generate(), s2[a3.crossTileID] = true);
              }
              return void 0 === this.indexes[t3.overscaledZ] && (this.indexes[t3.overscaledZ] = {}), this.indexes[t3.overscaledZ][t3.key] = new Kt(t3, e3.symbolInstances, e3.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(t3, e3) {
              for (const i3 of e3.getCrossTileIDsLists())
                for (const e4 of i3)
                  delete this.usedCrossTileIDs[t3][e4];
            }
            removeStaleBuckets(t3) {
              let e3 = false;
              for (const i3 in this.indexes) {
                const s2 = this.indexes[i3];
                for (const a3 in s2)
                  t3[s2[a3].bucketInstanceId] || (this.removeBucketCrossTileIDs(i3, s2[a3]), delete s2[a3], e3 = true);
              }
              return e3;
            }
          }
          class Qt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Yt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t3, e3, i3) {
              let s2 = this.layerIndexes[t3.id];
              void 0 === s2 && (s2 = this.layerIndexes[t3.id] = new Jt());
              let a3 = false;
              const o2 = {};
              s2.handleWrapJump(i3);
              for (const i4 of e3) {
                const e4 = i4.getBucket(t3);
                e4 && t3.id === e4.layerIds[0] && (e4.bucketInstanceId || (e4.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i4.tileID, e4, this.crossTileIDs) && (a3 = true), o2[e4.bucketInstanceId] = true);
              }
              return s2.removeStaleBuckets(o2) && (a3 = true), a3;
            }
            pruneUnusedLayers(t3) {
              const e3 = {};
              t3.forEach((t4) => {
                e3[t4] = true;
              });
              for (const t4 in this.layerIndexes)
                e3[t4] || delete this.layerIndexes[t4];
            }
          }
          const te = (e3, i3) => t2.emitValidationErrors(e3, i3 && i3.filter((t3) => "source.canvas" !== t3.identifier)), ee = t2.pick(t2.operations, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]), ie3 = t2.pick(t2.operations, ["setCenter", "setZoom", "setBearing", "setPitch"]), se = t2.emptyStyle();
          class ae extends t2.Evented {
            constructor(e3, i3 = {}) {
              super(), this.map = e3, this.dispatcher = new M(at(), this, e3._getMapId()), this.imageManager = new b2(), this.imageManager.setEventedParent(this), this.glyphManager = new I(e3._requestManager, i3.localIdeographFontFamily), this.lineAtlas = new z(256, 512), this.crossTileSymbolIndex = new Qt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t2.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t2.getReferrer());
              const s2 = this;
              this._rtlTextPluginCallback = ae.registerForPluginStateChange((e4) => {
                s2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e4.pluginStatus, pluginURL: e4.pluginURL }, (e5, i4) => {
                  if (t2.triggerPluginCompletionEvent(e5), i4 && i4.every((t3) => t3))
                    for (const t3 in s2.sourceCaches) {
                      const e6 = s2.sourceCaches[t3].getSource().type;
                      "vector" !== e6 && "geojson" !== e6 || s2.sourceCaches[t3].reload();
                    }
                });
              }), this.on("data", (t3) => {
                if ("source" !== t3.dataType || "metadata" !== t3.sourceDataType)
                  return;
                const e4 = this.sourceCaches[t3.sourceId];
                if (!e4)
                  return;
                const i4 = e4.getSource();
                if (i4 && i4.vectorLayerIds)
                  for (const t4 in this._layers) {
                    const e5 = this._layers[t4];
                    e5.source === i4.id && this._validateLayer(e5);
                  }
              });
            }
            loadURL(e3, i3 = {}, s2) {
              this.fire(new t2.Event("dataloading", { dataType: "style" })), i3.validate = "boolean" != typeof i3.validate || i3.validate;
              const a3 = this.map._requestManager.transformRequest(e3, h.Style);
              this._request = t2.getJSON(a3, (e4, a4) => {
                this._request = null, e4 ? this.fire(new t2.ErrorEvent(e4)) : a4 && this._load(a4, i3, s2);
              });
            }
            loadJSON(e3, i3 = {}, s2) {
              this.fire(new t2.Event("dataloading", { dataType: "style" })), this._request = t2.browser.frame(() => {
                this._request = null, i3.validate = false !== i3.validate, this._load(e3, i3, s2);
              });
            }
            loadEmpty() {
              this.fire(new t2.Event("dataloading", { dataType: "style" })), this._load(se, { validate: false });
            }
            _load(e3, i3, s2) {
              const a3 = i3.transformStyle ? i3.transformStyle(s2, e3) : e3;
              if (!i3.validate || !te(this, t2.validateStyle(a3))) {
                this._loaded = true, this.stylesheet = a3;
                for (const t3 in a3.sources)
                  this.addSource(t3, a3.sources[t3], { validate: false });
                a3.sprite ? this._loadSprite(a3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(a3.glyphs), this._createLayers(), this.light = new D(this.stylesheet.light), this.map.setTerrain(this.stylesheet.terrain), this.fire(new t2.Event("data", { dataType: "style" })), this.fire(new t2.Event("style.load"));
              }
            }
            _createLayers() {
              const e3 = t2.derefLayers(this.stylesheet.layers);
              this.dispatcher.broadcast("setLayers", e3), this._order = e3.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
              for (const i3 of e3) {
                const e4 = t2.createStyleLayer(i3);
                e4.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = e4;
              }
            }
            _loadSprite(e3, i3 = false, s2 = void 0) {
              this.imageManager.setLoaded(false), this._spriteRequest = function(e4, i4, s3, a3) {
                const o2 = g2(e4), r2 = o2.length, n3 = s3 > 1 ? "@2x" : "", l2 = {}, u2 = {}, d3 = {};
                for (const { id: e5, url: s4 } of o2) {
                  const o3 = i4.transformRequest(i4.normalizeSpriteURL(s4, n3, ".json"), h.SpriteJSON), _2 = `${e5}_${o3.url}`;
                  l2[_2] = t2.getJSON(o3, (t3, i5) => {
                    delete l2[_2], u2[e5] = i5, v(a3, u2, d3, t3, r2);
                  });
                  const m4 = i4.transformRequest(i4.normalizeSpriteURL(s4, n3, ".png"), h.SpriteImage), p3 = `${e5}_${m4.url}`;
                  l2[p3] = c4.getImage(m4, (t3, i5) => {
                    delete l2[p3], d3[e5] = i5, v(a3, u2, d3, t3, r2);
                  });
                }
                return { cancel() {
                  for (const t3 of Object.values(l2))
                    t3.cancel();
                } };
              }(e3, this.map._requestManager, this.map.getPixelRatio(), (e4, a3) => {
                if (this._spriteRequest = null, e4)
                  this.fire(new t2.ErrorEvent(e4));
                else if (a3)
                  for (const t3 in a3) {
                    this._spritesImagesIds[t3] = [];
                    const e5 = this._spritesImagesIds[t3] ? this._spritesImagesIds[t3].filter((t4) => !(t4 in a3)) : [];
                    for (const t4 of e5)
                      this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                    for (const e6 in a3[t3]) {
                      const s3 = "default" === t3 ? e6 : `${t3}:${e6}`;
                      this._spritesImagesIds[t3].push(s3), s3 in this.imageManager.images ? this.imageManager.updateImage(s3, a3[t3][e6], false) : this.imageManager.addImage(s3, a3[t3][e6]), i3 && (this._changedImages[s3] = true);
                    }
                  }
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i3 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.Event("data", { dataType: "style" })), s2 && s2(e4);
              });
            }
            _unloadSprite() {
              for (const t3 of Object.values(this._spritesImagesIds).flat())
                this.imageManager.removeImage(t3), this._changedImages[t3] = true;
              this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.Event("data", { dataType: "style" }));
            }
            _validateLayer(e3) {
              const i3 = this.sourceCaches[e3.source];
              if (!i3)
                return;
              const s2 = e3.sourceLayer;
              if (!s2)
                return;
              const a3 = i3.getSource();
              ("geojson" === a3.type || a3.vectorLayerIds && -1 === a3.vectorLayerIds.indexOf(s2)) && this.fire(new t2.ErrorEvent(new Error(`Source layer "${s2}" does not exist on source "${a3.id}" as specified by style layer "${e3.id}".`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const t3 in this.sourceCaches)
                if (!this.sourceCaches[t3].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeByIds(t3) {
              const e3 = this._serializedAllLayers();
              if (!t3 || 0 === t3.length)
                return Object.values(e3);
              const i3 = [];
              for (const s2 of t3)
                e3[s2] && i3.push(e3[s2]);
              return i3;
            }
            _serializedAllLayers() {
              let t3 = this._serializedLayers;
              if (t3)
                return t3;
              t3 = this._serializedLayers = {};
              const e3 = Object.keys(this._layers);
              for (const i3 of e3) {
                const e4 = this._layers[i3];
                "custom" !== e4.type && (t3[i3] = e4.serialize());
              }
              return t3;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              for (const t3 in this.sourceCaches)
                if (this.sourceCaches[t3].hasTransition())
                  return true;
              for (const t3 in this._layers)
                if (this._layers[t3].hasTransition())
                  return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading.");
            }
            update(e3) {
              if (!this._loaded)
                return;
              const i3 = this._changed;
              if (this._changed) {
                const t3 = Object.keys(this._updatedLayers), i4 = Object.keys(this._removedLayers);
                (t3.length || i4.length) && this._updateWorkerLayers(t3, i4);
                for (const t4 in this._updatedSources) {
                  const e4 = this._updatedSources[t4];
                  if ("reload" === e4)
                    this._reloadSource(t4);
                  else {
                    if ("clear" !== e4)
                      throw new Error(`Invalid action ${e4}`);
                    this._clearSource(t4);
                  }
                }
                this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                for (const t4 in this._updatedPaintProps)
                  this._layers[t4].updateTransitions(e3);
                this.light.updateTransitions(e3), this._resetUpdates();
              }
              const s2 = {};
              for (const t3 in this.sourceCaches) {
                const e4 = this.sourceCaches[t3];
                s2[t3] = e4.used, e4.used = false;
              }
              for (const t3 of this._order) {
                const i4 = this._layers[t3];
                i4.recalculate(e3, this._availableImages), !i4.isHidden(e3.zoom) && i4.source && (this.sourceCaches[i4.source].used = true);
              }
              for (const e4 in s2) {
                const i4 = this.sourceCaches[e4];
                s2[e4] !== i4.used && i4.fire(new t2.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e4 }));
              }
              this.light.recalculate(e3), this.z = e3.zoom, i3 && this.fire(new t2.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const t3 = Object.keys(this._changedImages);
              if (t3.length) {
                for (const e3 in this.sourceCaches)
                  this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t3);
                this._changedImages = {};
              }
            }
            _updateTilesForChangedGlyphs() {
              if (this._glyphsDidChange) {
                for (const t3 in this.sourceCaches)
                  this.sourceCaches[t3].reloadTilesForDependencies(["glyphs"], [""]);
                this._glyphsDidChange = false;
              }
            }
            _updateWorkerLayers(t3, e3) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t3), removedIds: e3 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
            }
            setState(e3, i3 = {}) {
              this._checkLoaded();
              const s2 = this.serialize();
              if (e3 = i3.transformStyle ? i3.transformStyle(s2, e3) : e3, te(this, t2.validateStyle(e3)))
                return false;
              (e3 = t2.clone$1(e3)).layers = t2.derefLayers(e3.layers);
              const a3 = t2.diffStyles(s2, e3).filter((t3) => !(t3.command in ie3));
              if (0 === a3.length)
                return false;
              const o2 = a3.filter((t3) => !(t3.command in ee));
              if (o2.length > 0)
                throw new Error(`Unimplemented: ${o2.map((t3) => t3.command).join(", ")}.`);
              for (const t3 of a3)
                "setTransition" !== t3.command && this[t3.command].apply(this, t3.args);
              return this.stylesheet = e3, true;
            }
            addImage(e3, i3) {
              if (this.getImage(e3))
                return this.fire(new t2.ErrorEvent(new Error(`An image named "${e3}" already exists.`)));
              this.imageManager.addImage(e3, i3), this._afterImageUpdated(e3);
            }
            updateImage(t3, e3) {
              this.imageManager.updateImage(t3, e3);
            }
            getImage(t3) {
              return this.imageManager.getImage(t3);
            }
            removeImage(e3) {
              if (!this.getImage(e3))
                return this.fire(new t2.ErrorEvent(new Error(`An image named "${e3}" does not exist.`)));
              this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
            }
            _afterImageUpdated(e3) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e3, i3, s2 = {}) {
              if (this._checkLoaded(), void 0 !== this.sourceCaches[e3])
                throw new Error(`Source "${e3}" already exists.`);
              if (!i3.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i3).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t2.validateStyle.source, `sources.${e3}`, i3, null, s2))
                return;
              this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
              const a3 = this.sourceCaches[e3] = new Y(e3, i3, this.dispatcher);
              a3.style = this, a3.setEventedParent(this, () => ({ isSourceLoaded: a3.loaded(), source: a3.serialize(), sourceId: e3 })), a3.onAdd(this.map), this._changed = true;
            }
            removeSource(e3) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
                throw new Error("There is no source with this ID");
              for (const i4 in this._layers)
                if (this._layers[i4].source === e3)
                  return this.fire(new t2.ErrorEvent(new Error(`Source "${e3}" cannot be removed while layer "${i4}" is using it.`)));
              const i3 = this.sourceCaches[e3];
              delete this.sourceCaches[e3], delete this._updatedSources[e3], i3.fire(new t2.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), i3.setEventedParent(null), i3.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(t3, e3) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[t3])
                throw new Error(`There is no source with this ID=${t3}`);
              const i3 = this.sourceCaches[t3].getSource();
              if ("geojson" !== i3.type)
                throw new Error(`geojsonSource.type is ${i3.type}, which is !== 'geojson`);
              i3.setData(e3), this._changed = true;
            }
            getSource(t3) {
              return this.sourceCaches[t3] && this.sourceCaches[t3].getSource();
            }
            addLayer(e3, i3, s2 = {}) {
              this._checkLoaded();
              const a3 = e3.id;
              if (this.getLayer(a3))
                return void this.fire(new t2.ErrorEvent(new Error(`Layer "${a3}" already exists on this map.`)));
              let o2;
              if ("custom" === e3.type) {
                if (te(this, t2.validateCustomStyleLayer(e3)))
                  return;
                o2 = t2.createStyleLayer(e3);
              } else {
                if ("object" == typeof e3.source && (this.addSource(a3, e3.source), e3 = t2.clone$1(e3), e3 = t2.extend(e3, { source: a3 })), this._validate(t2.validateStyle.layer, `layers.${a3}`, e3, { arrayIndex: -1 }, s2))
                  return;
                o2 = t2.createStyleLayer(e3), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: a3 } });
              }
              const r2 = i3 ? this._order.indexOf(i3) : this._order.length;
              if (i3 && -1 === r2)
                this.fire(new t2.ErrorEvent(new Error(`Cannot add layer "${a3}" before non-existing layer "${i3}".`)));
              else {
                if (this._order.splice(r2, 0, a3), this._layerOrderChanged = true, this._layers[a3] = o2, this._removedLayers[a3] && o2.source && "custom" !== o2.type) {
                  const t3 = this._removedLayers[a3];
                  delete this._removedLayers[a3], t3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
                }
                this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
              }
            }
            moveLayer(e3, i3) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e3])
                return void this.fire(new t2.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be moved.`)));
              if (e3 === i3)
                return;
              const s2 = this._order.indexOf(e3);
              this._order.splice(s2, 1);
              const a3 = i3 ? this._order.indexOf(i3) : this._order.length;
              i3 && -1 === a3 ? this.fire(new t2.ErrorEvent(new Error(`Cannot move layer "${e3}" before non-existing layer "${i3}".`))) : (this._order.splice(a3, 0, e3), this._layerOrderChanged = true);
            }
            removeLayer(e3) {
              this._checkLoaded();
              const i3 = this._layers[e3];
              if (!i3)
                return void this.fire(new t2.ErrorEvent(new Error(`Cannot remove non-existing layer "${e3}".`)));
              i3.setEventedParent(null);
              const s2 = this._order.indexOf(e3);
              this._order.splice(s2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i3, delete this._layers[e3], this._serializedLayers && delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i3.onRemove && i3.onRemove(this.map);
            }
            getLayer(t3) {
              return this._layers[t3];
            }
            hasLayer(t3) {
              return t3 in this._layers;
            }
            setLayerZoomRange(e3, i3, s2) {
              this._checkLoaded();
              const a3 = this.getLayer(e3);
              a3 ? a3.minzoom === i3 && a3.maxzoom === s2 || (null != i3 && (a3.minzoom = i3), null != s2 && (a3.maxzoom = s2), this._updateLayer(a3)) : this.fire(new t2.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e3}".`)));
            }
            setFilter(e3, i3, s2 = {}) {
              this._checkLoaded();
              const a3 = this.getLayer(e3);
              if (a3) {
                if (!t2.deepEqual(a3.filter, i3))
                  return null == i3 ? (a3.filter = void 0, void this._updateLayer(a3)) : void (this._validate(t2.validateStyle.filter, `layers.${a3.id}.filter`, i3, null, s2) || (a3.filter = t2.clone$1(i3), this._updateLayer(a3)));
              } else
                this.fire(new t2.ErrorEvent(new Error(`Cannot filter non-existing layer "${e3}".`)));
            }
            getFilter(e3) {
              return t2.clone$1(this.getLayer(e3).filter);
            }
            setLayoutProperty(e3, i3, s2, a3 = {}) {
              this._checkLoaded();
              const o2 = this.getLayer(e3);
              o2 ? t2.deepEqual(o2.getLayoutProperty(i3), s2) || (o2.setLayoutProperty(i3, s2, a3), this._updateLayer(o2)) : this.fire(new t2.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
            }
            getLayoutProperty(e3, i3) {
              const s2 = this.getLayer(e3);
              if (s2)
                return s2.getLayoutProperty(i3);
              this.fire(new t2.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e3}".`)));
            }
            setPaintProperty(e3, i3, s2, a3 = {}) {
              this._checkLoaded();
              const o2 = this.getLayer(e3);
              o2 ? t2.deepEqual(o2.getPaintProperty(i3), s2) || (o2.setPaintProperty(i3, s2, a3) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t2.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
            }
            getPaintProperty(t3, e3) {
              return this.getLayer(t3).getPaintProperty(e3);
            }
            setFeatureState(e3, i3) {
              this._checkLoaded();
              const s2 = e3.source, a3 = e3.sourceLayer, o2 = this.sourceCaches[s2];
              if (void 0 === o2)
                return void this.fire(new t2.ErrorEvent(new Error(`The source '${s2}' does not exist in the map's style.`)));
              const r2 = o2.getSource().type;
              "geojson" === r2 && a3 ? this.fire(new t2.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r2 || a3 ? (void 0 === e3.id && this.fire(new t2.ErrorEvent(new Error("The feature id parameter must be provided."))), o2.setFeatureState(a3, e3.id, i3)) : this.fire(new t2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e3, i3) {
              this._checkLoaded();
              const s2 = e3.source, a3 = this.sourceCaches[s2];
              if (void 0 === a3)
                return void this.fire(new t2.ErrorEvent(new Error(`The source '${s2}' does not exist in the map's style.`)));
              const o2 = a3.getSource().type, r2 = "vector" === o2 ? e3.sourceLayer : void 0;
              "vector" !== o2 || r2 ? i3 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t2.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a3.removeFeatureState(r2, e3.id, i3) : this.fire(new t2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e3) {
              this._checkLoaded();
              const i3 = e3.source, s2 = e3.sourceLayer, a3 = this.sourceCaches[i3];
              if (void 0 !== a3)
                return "vector" !== a3.getSource().type || s2 ? (void 0 === e3.id && this.fire(new t2.ErrorEvent(new Error("The feature id parameter must be provided."))), a3.getFeatureState(s2, e3.id)) : void this.fire(new t2.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t2.ErrorEvent(new Error(`The source '${i3}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t2.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              if (!this._loaded)
                return;
              const e3 = t2.mapObject(this.sourceCaches, (t3) => t3.serialize()), i3 = this._serializeByIds(this._order), s2 = this.stylesheet;
              return t2.filterObject({ version: s2.version, name: s2.name, metadata: s2.metadata, light: s2.light, center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch, sprite: s2.sprite, glyphs: s2.glyphs, transition: s2.transition, sources: e3, layers: i3 }, (t3) => void 0 !== t3);
            }
            _updateLayer(t3) {
              this._updatedLayers[t3.id] = true, t3.source && !this._updatedSources[t3.source] && "raster" !== this.sourceCaches[t3.source].getSource().type && (this._updatedSources[t3.source] = "reload", this.sourceCaches[t3.source].pause()), this._serializedLayers = null, this._changed = true;
            }
            _flattenAndSortRenderedFeatures(t3) {
              const e3 = (t4) => "fill-extrusion" === this._layers[t4].type, i3 = {}, s2 = [];
              for (let a4 = this._order.length - 1; a4 >= 0; a4--) {
                const o2 = this._order[a4];
                if (e3(o2)) {
                  i3[o2] = a4;
                  for (const e4 of t3) {
                    const t4 = e4[o2];
                    if (t4)
                      for (const e5 of t4)
                        s2.push(e5);
                  }
                }
              }
              s2.sort((t4, e4) => e4.intersectionZ - t4.intersectionZ);
              const a3 = [];
              for (let o2 = this._order.length - 1; o2 >= 0; o2--) {
                const r2 = this._order[o2];
                if (e3(r2))
                  for (let t4 = s2.length - 1; t4 >= 0; t4--) {
                    const e4 = s2[t4].feature;
                    if (i3[e4.layer.id] < o2)
                      break;
                    a3.push(e4), s2.pop();
                  }
                else
                  for (const e4 of t3) {
                    const t4 = e4[r2];
                    if (t4)
                      for (const e5 of t4)
                        a3.push(e5.feature);
                  }
              }
              return a3;
            }
            queryRenderedFeatures(e3, i3, s2) {
              i3 && i3.filter && this._validate(t2.validateStyle.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
              const a3 = {};
              if (i3 && i3.layers) {
                if (!Array.isArray(i3.layers))
                  return this.fire(new t2.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const e4 of i3.layers) {
                  const i4 = this._layers[e4];
                  if (!i4)
                    return this.fire(new t2.ErrorEvent(new Error(`The layer '${e4}' does not exist in the map's style and cannot be queried for features.`))), [];
                  a3[i4.source] = true;
                }
              }
              const o2 = [];
              i3.availableImages = this._availableImages;
              const r2 = this._serializedAllLayers();
              for (const t3 in this.sourceCaches)
                i3.layers && !a3[t3] || o2.push($11(this.sourceCaches[t3], this._layers, r2, e3, i3, s2));
              return this.placement && o2.push(function(t3, e4, i4, s3, a4, o3, r3) {
                const n3 = {}, l2 = o3.queryRenderedSymbols(s3), c5 = [];
                for (const t4 of Object.keys(l2).map(Number))
                  c5.push(r3[t4]);
                c5.sort(X);
                for (const i5 of c5) {
                  const s4 = i5.featureIndex.lookupSymbolFeatures(l2[i5.bucketInstanceId], e4, i5.bucketIndex, i5.sourceLayerIndex, a4.filter, a4.layers, a4.availableImages, t3);
                  for (const t4 in s4) {
                    const e5 = n3[t4] = n3[t4] || [], a5 = s4[t4];
                    a5.sort((t5, e6) => {
                      const s5 = i5.featureSortOrder;
                      if (s5) {
                        const i6 = s5.indexOf(t5.featureIndex);
                        return s5.indexOf(e6.featureIndex) - i6;
                      }
                      return e6.featureIndex - t5.featureIndex;
                    });
                    for (const t5 of a5)
                      e5.push(t5);
                  }
                }
                for (const e5 in n3)
                  n3[e5].forEach((s4) => {
                    const a5 = s4.feature, o4 = i4[t3[e5].source].getFeatureState(a5.layer["source-layer"], a5.id);
                    a5.source = a5.layer.source, a5.layer["source-layer"] && (a5.sourceLayer = a5.layer["source-layer"]), a5.state = o4;
                  });
                return n3;
              }(this._layers, r2, this.sourceCaches, e3, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
            }
            querySourceFeatures(e3, i3) {
              i3 && i3.filter && this._validate(t2.validateStyle.filter, "querySourceFeatures.filter", i3.filter, null, i3);
              const s2 = this.sourceCaches[e3];
              return s2 ? function(t3, e4) {
                const i4 = t3.getRenderableIds().map((e5) => t3.getTileByID(e5)), s3 = [], a3 = {};
                for (let t4 = 0; t4 < i4.length; t4++) {
                  const o2 = i4[t4], r2 = o2.tileID.canonical.key;
                  a3[r2] || (a3[r2] = true, o2.querySourceFeatures(s3, e4));
                }
                return s3;
              }(s2, i3) : [];
            }
            addSourceType(t3, e3, i3) {
              return q(t3) ? i3(new Error(`A source type called "${t3}" already exists.`)) : (((t4, e4) => {
                V[t4] = e4;
              })(t3, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t3, url: e3.workerSourceURL }, i3) : i3(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e3, i3 = {}) {
              this._checkLoaded();
              const s2 = this.light.getLight();
              let a3 = false;
              for (const i4 in e3)
                if (!t2.deepEqual(e3[i4], s2[i4])) {
                  a3 = true;
                  break;
                }
              if (!a3)
                return;
              const o2 = { now: t2.browser.now(), transition: t2.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e3, i3), this.light.updateTransitions(o2);
            }
            _validate(e3, i3, s2, a3, o2 = {}) {
              return (!o2 || false !== o2.validate) && te(this, e3.call(t2.validateStyle, t2.extend({ key: i3, style: this.serialize(), value: s2, styleSpec: t2.v8Spec }, a3)));
            }
            _remove(e3 = true) {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t2.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const t3 in this._layers)
                this._layers[t3].setEventedParent(null);
              for (const t3 in this.sourceCaches) {
                const e4 = this.sourceCaches[t3];
                e4.setEventedParent(null), e4.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e3);
            }
            _clearSource(t3) {
              this.sourceCaches[t3].clearTiles();
            }
            _reloadSource(t3) {
              this.sourceCaches[t3].resume(), this.sourceCaches[t3].reload();
            }
            _updateSources(t3) {
              for (const e3 in this.sourceCaches)
                this.sourceCaches[e3].update(t3, this.map.terrain);
            }
            _generateCollisionBoxes() {
              for (const t3 in this.sourceCaches)
                this._reloadSource(t3);
            }
            _updatePlacement(e3, i3, s2, a3, o2 = false) {
              let r2 = false, n3 = false;
              const l2 = {};
              for (const t3 of this._order) {
                const i4 = this._layers[t3];
                if ("symbol" !== i4.type)
                  continue;
                if (!l2[i4.source]) {
                  const t4 = this.sourceCaches[i4.source];
                  l2[i4.source] = t4.getRenderableIds(true).map((e4) => t4.getTileByID(e4)).sort((t5, e4) => e4.tileID.overscaledZ - t5.tileID.overscaledZ || (t5.tileID.isLessThan(e4.tileID) ? -1 : 1));
                }
                const s3 = this.crossTileSymbolIndex.addLayer(i4, l2[i4.source], e3.center.lng);
                r2 = r2 || s3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o2 = o2 || this._layerOrderChanged || 0 === s2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t2.browser.now(), e3.zoom)) && (this.pauseablePlacement = new Wt(e3, this.map.terrain, this._order, o2, i3, s2, a3, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t2.browser.now()), n3 = true), r2 && this.pauseablePlacement.placement.setStale()), n3 || r2)
                for (const t3 of this._order) {
                  const e4 = this._layers[t3];
                  "symbol" === e4.type && this.placement.updateLayerOpacities(e4, l2[e4.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t2.browser.now());
            }
            _releaseSymbolFadeTiles() {
              for (const t3 in this.sourceCaches)
                this.sourceCaches[t3].releaseSymbolFadeTiles();
            }
            getImages(t3, e3, i3) {
              this.imageManager.getImages(e3.icons, i3), this._updateTilesForChangedImages();
              const s2 = this.sourceCaches[e3.source];
              s2 && s2.setDependencies(e3.tileID.key, e3.type, e3.icons);
            }
            getGlyphs(t3, e3, i3) {
              this.glyphManager.getGlyphs(e3.stacks, i3);
              const s2 = this.sourceCaches[e3.source];
              s2 && s2.setDependencies(e3.tileID.key, e3.type, [""]);
            }
            getResource(e3, i3, s2) {
              return t2.makeRequest(i3, s2);
            }
            getGlyphsUrl() {
              return this.stylesheet.glyphs || null;
            }
            setGlyphs(e3, i3 = {}) {
              this._checkLoaded(), e3 && this._validate(t2.validateStyle.glyphs, "glyphs", e3, null, i3) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e3, this.glyphManager.entries = {}, this.glyphManager.setURL(e3));
            }
            addSprite(e3, i3, s2 = {}, a3) {
              this._checkLoaded();
              const o2 = [{ id: e3, url: i3 }], r2 = [...g2(this.stylesheet.sprite), ...o2];
              this._validate(t2.validateStyle.sprite, "sprite", r2, null, s2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, a3));
            }
            removeSprite(e3) {
              this._checkLoaded();
              const i3 = g2(this.stylesheet.sprite);
              if (i3.find((t3) => t3.id === e3)) {
                if (this._spritesImagesIds[e3])
                  for (const t3 of this._spritesImagesIds[e3])
                    this.imageManager.removeImage(t3), this._changedImages[t3] = true;
                i3.splice(i3.findIndex((t3) => t3.id === e3), 1), this.stylesheet.sprite = i3.length > 0 ? i3 : void 0, delete this._spritesImagesIds[e3], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t2.Event("data", { dataType: "style" }));
              } else
                this.fire(new t2.ErrorEvent(new Error(`Sprite "${e3}" doesn't exists on this map.`)));
            }
            getSprite() {
              return g2(this.stylesheet.sprite);
            }
            setSprite(e3, i3 = {}, s2) {
              this._checkLoaded(), e3 && this._validate(t2.validateStyle.sprite, "sprite", e3, null, i3) || (this.stylesheet.sprite = e3, e3 ? this._loadSprite(e3, true, s2) : (this._unloadSprite(), s2 && s2(null)));
            }
          }
          ae.registerForPluginStateChange = t2.registerForPluginStateChange;
          var oe = t2.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), re = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
          const ne = { prelude: le("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: le("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: le("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: le("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: le("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: le("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: le("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: le("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: le("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: le("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: le("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: le("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: le("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: le("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: le("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: le("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: le("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: le("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: le("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: le("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: le("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: le("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: le("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: le("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: le("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", re), terrainDepth: le("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", re), terrainCoords: le("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", re) };
          function le(t3, e3) {
            const i3 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s2 = e3.match(/attribute ([\w]+) ([\w]+)/g), a3 = t3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(a3) : a3, n3 = {};
            return { fragmentSource: t3 = t3.replace(i3, (t4, e4, i4, s3, a4) => (n3[a4] = true, "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a4}
varying ${i4} ${s3} ${a4};
#else
uniform ${i4} ${s3} u_${a4};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a4}
    ${i4} ${s3} ${a4} = u_${a4};
#endif
`)), vertexSource: e3 = e3.replace(i3, (t4, e4, i4, s3, a4) => {
              const o3 = "float" === s3 ? "vec2" : "vec4", r3 = a4.match(/color/) ? "color" : o3;
              return n3[a4] ? "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o3} a_${a4};
varying ${i4} ${s3} ${a4};
#else
uniform ${i4} ${s3} u_${a4};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = a_${a4};
#else
    ${i4} ${s3} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${a4} = unpack_mix_${r3}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s3} ${a4} = u_${a4};
#endif
` : "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a4}
uniform lowp float u_${a4}_t;
attribute ${i4} ${o3} a_${a4};
#else
uniform ${i4} ${s3} u_${a4};
#endif
` : "vec4" === r3 ? `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s3} ${a4} = a_${a4};
#else
    ${i4} ${s3} ${a4} = u_${a4};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a4}
    ${i4} ${s3} ${a4} = unpack_mix_${r3}(a_${a4}, u_${a4}_t);
#else
    ${i4} ${s3} ${a4} = u_${a4};
#endif
`;
            }), staticAttributes: s2, staticUniforms: r2 };
          }
          class ce {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t3, e3, i3, s2, a3, o2, r2, n3, l2) {
              this.context = t3;
              let c5 = this.boundPaintVertexBuffers.length !== s2.length;
              for (let t4 = 0; !c5 && t4 < s2.length; t4++)
                this.boundPaintVertexBuffers[t4] !== s2[t4] && (c5 = true);
              !this.vao || this.boundProgram !== e3 || this.boundLayoutVertexBuffer !== i3 || c5 || this.boundIndexBuffer !== a3 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n3 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(e3, i3, s2, a3, o2, r2, n3, l2) : (t3.bindVertexArray.set(this.vao), r2 && r2.bind(), a3 && a3.dynamicDraw && a3.bind(), n3 && n3.bind(), l2 && l2.bind());
            }
            freshBind(t3, e3, i3, s2, a3, o2, r2, n3) {
              const l2 = t3.numAttributes, c5 = this.context, h2 = c5.gl;
              this.vao && this.destroy(), this.vao = c5.createVertexArray(), c5.bindVertexArray.set(this.vao), this.boundProgram = t3, this.boundLayoutVertexBuffer = e3, this.boundPaintVertexBuffers = i3, this.boundIndexBuffer = s2, this.boundVertexOffset = a3, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n3, e3.enableAttributes(h2, t3);
              for (const e4 of i3)
                e4.enableAttributes(h2, t3);
              o2 && o2.enableAttributes(h2, t3), r2 && r2.enableAttributes(h2, t3), n3 && n3.enableAttributes(h2, t3), e3.bind(), e3.setVertexAttribPointers(h2, t3, a3);
              for (const e4 of i3)
                e4.bind(), e4.setVertexAttribPointers(h2, t3, a3);
              o2 && (o2.bind(), o2.setVertexAttribPointers(h2, t3, a3)), s2 && s2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(h2, t3, a3)), n3 && (n3.bind(), n3.setVertexAttribPointers(h2, t3, a3)), c5.currentNumAttributes = l2;
            }
            destroy() {
              this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          function he(t3) {
            const e3 = [];
            for (let i3 = 0; i3 < t3.length; i3++) {
              if (null === t3[i3])
                continue;
              const s2 = t3[i3].split(" ");
              e3.push(s2.pop());
            }
            return e3;
          }
          class ue {
            constructor(e3, i3, s2, a3, o2, r2, n3) {
              const l2 = e3.gl;
              this.program = l2.createProgram();
              const c5 = he(s2.staticAttributes), h2 = a3 ? a3.getBinderAttributes() : [], u2 = c5.concat(h2), d3 = ne.prelude.staticUniforms ? he(ne.prelude.staticUniforms) : [], _2 = s2.staticUniforms ? he(s2.staticUniforms) : [], m4 = a3 ? a3.getBinderUniforms() : [], p3 = d3.concat(_2).concat(m4), f2 = [];
              for (const t3 of p3)
                f2.indexOf(t3) < 0 && f2.push(t3);
              const g3 = a3 ? a3.defines() : [];
              r2 && g3.push("#define OVERDRAW_INSPECTOR;"), n3 && g3.push("#define TERRAIN3D;");
              const v2 = g3.concat(ne.prelude.fragmentSource, s2.fragmentSource).join("\n"), x2 = g3.concat(ne.prelude.vertexSource, s2.vertexSource).join("\n"), y2 = l2.createShader(l2.FRAGMENT_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(y2, v2), l2.compileShader(y2), l2.attachShader(this.program, y2);
              const b3 = l2.createShader(l2.VERTEX_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(b3, x2), l2.compileShader(b3), l2.attachShader(this.program, b3), this.attributes = {};
              const w2 = {};
              this.numAttributes = u2.length;
              for (let t3 = 0; t3 < this.numAttributes; t3++)
                u2[t3] && (l2.bindAttribLocation(this.program, t3, u2[t3]), this.attributes[u2[t3]] = t3);
              l2.linkProgram(this.program), l2.deleteShader(b3), l2.deleteShader(y2);
              for (let t3 = 0; t3 < f2.length; t3++) {
                const e4 = f2[t3];
                if (e4 && !w2[e4]) {
                  const t4 = l2.getUniformLocation(this.program, e4);
                  t4 && (w2[e4] = t4);
                }
              }
              this.fixedUniforms = o2(e3, w2), this.terrainUniforms = ((e4, i4) => ({ u_depth: new t2.Uniform1i(e4, i4.u_depth), u_terrain: new t2.Uniform1i(e4, i4.u_terrain), u_terrain_dim: new t2.Uniform1f(e4, i4.u_terrain_dim), u_terrain_matrix: new t2.UniformMatrix4f(e4, i4.u_terrain_matrix), u_terrain_unpack: new t2.Uniform4f(e4, i4.u_terrain_unpack), u_terrain_exaggeration: new t2.Uniform1f(e4, i4.u_terrain_exaggeration) }))(e3, w2), this.binderUniforms = a3 ? a3.getUniforms(e3, w2) : [];
            }
            draw(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3, _2, m4, p3, f2, g3) {
              const v2 = t3.gl;
              if (this.failedToCreate)
                return;
              if (t3.program.set(this.program), t3.setDepthMode(i3), t3.setStencilMode(s2), t3.setColorMode(a3), t3.setCullFace(o2), n3) {
                t3.activeTexture.set(v2.TEXTURE2), v2.bindTexture(v2.TEXTURE_2D, n3.depthTexture), t3.activeTexture.set(v2.TEXTURE3), v2.bindTexture(v2.TEXTURE_2D, n3.texture);
                for (const t4 in this.terrainUniforms)
                  this.terrainUniforms[t4].set(n3[t4]);
              }
              for (const t4 in this.fixedUniforms)
                this.fixedUniforms[t4].set(r2[t4]);
              m4 && m4.setUniforms(t3, this.binderUniforms, d3, { zoom: _2 });
              let x2 = 0;
              switch (e3) {
                case v2.LINES:
                  x2 = 2;
                  break;
                case v2.TRIANGLES:
                  x2 = 3;
                  break;
                case v2.LINE_STRIP:
                  x2 = 1;
              }
              for (const i4 of u2.get()) {
                const s3 = i4.vaos || (i4.vaos = {});
                (s3[l2] || (s3[l2] = new ce())).bind(t3, this, c5, m4 ? m4.getPaintVertexBuffers() : [], h2, i4.vertexOffset, p3, f2, g3), v2.drawElements(e3, i4.primitiveLength * x2, v2.UNSIGNED_SHORT, i4.primitiveOffset * x2 * 2);
              }
            }
          }
          function de(t3, e3, i3) {
            const s2 = 1 / Ct(i3, 1, e3.transform.tileZoom), a3 = Math.pow(2, i3.tileID.overscaledZ), o2 = i3.tileSize * Math.pow(2, e3.transform.tileZoom) / a3, r2 = o2 * (i3.tileID.canonical.x + i3.tileID.wrap * a3), n3 = o2 * i3.tileID.canonical.y;
            return { u_image: 0, u_texsize: i3.imageAtlasTexture.size, u_scale: [s2, t3.fromScale, t3.toScale], u_fade: t3.t, u_pixel_coord_upper: [r2 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n3] };
          }
          const _e = (e3, i3, s2, a3) => {
            const o2 = i3.style.light, r2 = o2.properties.get("position"), n3 = [r2.x, r2.y, r2.z], l2 = function() {
              var e4 = new t2.ARRAY_TYPE(9);
              return t2.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0, e4[3] = 0, e4[5] = 0, e4[6] = 0, e4[7] = 0), e4[0] = 1, e4[4] = 1, e4[8] = 1, e4;
            }();
            "viewport" === o2.properties.get("anchor") && function(t3, e4) {
              var i4 = Math.sin(e4), s3 = Math.cos(e4);
              t3[0] = s3, t3[1] = i4, t3[2] = 0, t3[3] = -i4, t3[4] = s3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
            }(l2, -i3.transform.angle), function(t3, e4, i4) {
              var s3 = e4[0], a4 = e4[1], o3 = e4[2];
              t3[0] = s3 * i4[0] + a4 * i4[3] + o3 * i4[6], t3[1] = s3 * i4[1] + a4 * i4[4] + o3 * i4[7], t3[2] = s3 * i4[2] + a4 * i4[5] + o3 * i4[8];
            }(n3, n3, l2);
            const c5 = o2.properties.get("color");
            return { u_matrix: e3, u_lightpos: n3, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [c5.r, c5.g, c5.b], u_vertical_gradient: +s2, u_opacity: a3 };
          }, me = (e3, i3, s2, a3, o2, r2, n3) => t2.extend(_e(e3, i3, s2, a3), de(r2, i3, n3), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n3.tileSize / 8 }), pe = (t3) => ({ u_matrix: t3 }), fe = (e3, i3, s2, a3) => t2.extend(pe(e3), de(s2, i3, a3)), ge = (t3, e3) => ({ u_matrix: t3, u_world: e3 }), ve = (e3, i3, s2, a3, o2) => t2.extend(fe(e3, i3, s2, a3), { u_world: o2 }), xe = (t3, e3, i3, s2) => {
            const a3 = t3.transform;
            let o2, r2;
            if ("map" === s2.paint.get("circle-pitch-alignment")) {
              const t4 = Ct(i3, 1, a3.zoom);
              o2 = true, r2 = [t4, t4];
            } else
              o2 = false, r2 = a3.pixelsToGLUnits;
            return { u_camera_to_center_distance: a3.cameraToCenterDistance, u_scale_with_map: +("map" === s2.paint.get("circle-pitch-scale")), u_matrix: t3.translatePosMatrix(e3.posMatrix, i3, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_pitch_with_map: +o2, u_device_pixel_ratio: t3.pixelRatio, u_extrude_scale: r2 };
          }, ye = (t3, e3, i3) => {
            const s2 = Ct(i3, 1, e3.zoom), a3 = Math.pow(2, e3.zoom - i3.tileID.overscaledZ), o2 = i3.tileID.overscaleFactor();
            return { u_matrix: t3, u_camera_to_center_distance: e3.cameraToCenterDistance, u_pixels_to_tile_units: s2, u_extrude_scale: [e3.pixelsToGLUnits[0] / (s2 * a3), e3.pixelsToGLUnits[1] / (s2 * a3)], u_overscale_factor: o2 };
          }, be = (t3, e3, i3 = 1) => ({ u_matrix: t3, u_color: e3, u_overlay: 0, u_overlay_scale: i3 }), we = (t3) => ({ u_matrix: t3 }), Te = (t3, e3, i3, s2) => ({ u_matrix: t3, u_extrude_scale: Ct(e3, 1, i3), u_intensity: s2 });
          function Ee(e3, i3) {
            const s2 = Math.pow(2, i3.canonical.z), a3 = i3.canonical.y;
            return [new t2.MercatorCoordinate(0, a3 / s2).toLngLat().lat, new t2.MercatorCoordinate(0, (a3 + 1) / s2).toLngLat().lat];
          }
          const Ie = (t3, e3, i3, s2) => {
            const a3 = t3.transform;
            return { u_matrix: ze(t3, e3, i3, s2), u_ratio: 1 / Ct(e3, 1, a3.zoom), u_device_pixel_ratio: t3.pixelRatio, u_units_to_pixels: [1 / a3.pixelsToGLUnits[0], 1 / a3.pixelsToGLUnits[1]] };
          }, Se = (e3, i3, s2, a3, o2) => t2.extend(Ie(e3, i3, s2, o2), { u_image: 0, u_image_height: a3 }), Ce = (t3, e3, i3, s2, a3) => {
            const o2 = t3.transform, r2 = De(e3, o2);
            return { u_matrix: ze(t3, e3, i3, a3), u_texsize: e3.imageAtlasTexture.size, u_ratio: 1 / Ct(e3, 1, o2.zoom), u_device_pixel_ratio: t3.pixelRatio, u_image: 0, u_scale: [r2, s2.fromScale, s2.toScale], u_fade: s2.t, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
          }, Pe = (e3, i3, s2, a3, o2, r2) => {
            const n3 = e3.lineAtlas, l2 = De(i3, e3.transform), c5 = "round" === s2.layout.get("line-cap"), h2 = n3.getDash(a3.from, c5), u2 = n3.getDash(a3.to, c5), d3 = h2.width * o2.fromScale, _2 = u2.width * o2.toScale;
            return t2.extend(Ie(e3, i3, s2, r2), { u_patternscale_a: [l2 / d3, -h2.height / 2], u_patternscale_b: [l2 / _2, -u2.height / 2], u_sdfgamma: n3.width / (256 * Math.min(d3, _2) * e3.pixelRatio) / 2, u_image: 0, u_tex_y_a: h2.y, u_tex_y_b: u2.y, u_mix: o2.t });
          };
          function De(t3, e3) {
            return 1 / Ct(t3, 1, e3.tileZoom);
          }
          function ze(t3, e3, i3, s2) {
            return t3.translatePosMatrix(s2 ? s2.posMatrix : e3.tileID.posMatrix, e3, i3.paint.get("line-translate"), i3.paint.get("line-translate-anchor"));
          }
          const Me = (t3, e3, i3, s2, a3) => {
            return { u_matrix: t3, u_tl_parent: e3, u_scale_parent: i3, u_buffer_scale: 1, u_fade_t: s2.mix, u_opacity: s2.opacity * a3.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a3.paint.get("raster-brightness-min"), u_brightness_high: a3.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = a3.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (o2 = a3.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: Ae(a3.paint.get("raster-hue-rotate")) };
            var o2, r2;
          };
          function Ae(t3) {
            t3 *= Math.PI / 180;
            const e3 = Math.sin(t3), i3 = Math.cos(t3);
            return [(2 * i3 + 1) / 3, (-Math.sqrt(3) * e3 - i3 + 1) / 3, (Math.sqrt(3) * e3 - i3 + 1) / 3];
          }
          const Le = (t3, e3, i3, s2, a3, o2, r2, n3, l2, c5) => {
            const h2 = a3.transform;
            return { u_is_size_zoom_constant: +("constant" === t3 || "source" === t3), u_is_size_feature_constant: +("constant" === t3 || "camera" === t3), u_size_t: e3 ? e3.uSizeT : 0, u_size: e3 ? e3.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i3, u_aspect_ratio: h2.width / h2.height, u_fade_change: a3.options.fadeDuration ? a3.symbolFadeChange : 1, u_matrix: o2, u_label_plane_matrix: r2, u_coord_matrix: n3, u_is_text: +l2, u_pitch_with_map: +s2, u_texsize: c5, u_texture: 0 };
          }, Re = (e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2) => {
            const d3 = o2.transform;
            return t2.extend(Le(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2), { u_gamma_scale: a3 ? Math.cos(d3._pitch) * d3.cameraToCenterDistance : 1, u_device_pixel_ratio: o2.pixelRatio, u_is_halo: +u2 });
          }, ke = (e3, i3, s2, a3, o2, r2, n3, l2, c5, h2) => t2.extend(Re(e3, i3, s2, a3, o2, r2, n3, l2, true, c5, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Be = (t3, e3, i3) => ({ u_matrix: t3, u_opacity: e3, u_color: i3 }), Fe = (e3, i3, s2, a3, o2, r2) => t2.extend(function(t3, e4, i4, s3) {
            const a4 = i4.imageManager.getPattern(t3.from.toString()), o3 = i4.imageManager.getPattern(t3.to.toString()), { width: r3, height: n3 } = i4.imageManager.getPixelSize(), l2 = Math.pow(2, s3.tileID.overscaledZ), c5 = s3.tileSize * Math.pow(2, i4.transform.tileZoom) / l2, h2 = c5 * (s3.tileID.canonical.x + s3.tileID.wrap * l2), u2 = c5 * s3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a4.tl, u_pattern_br_a: a4.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [r3, n3], u_mix: e4.t, u_pattern_size_a: a4.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: e4.fromScale, u_scale_b: e4.toScale, u_tile_units_to_pixels: 1 / Ct(s3, 1, i4.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
          }(a3, r2, s2, o2), { u_matrix: e3, u_opacity: i3 }), Ue = { fillExtrusion: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_lightpos: new t2.Uniform3f(e3, i3.u_lightpos), u_lightintensity: new t2.Uniform1f(e3, i3.u_lightintensity), u_lightcolor: new t2.Uniform3f(e3, i3.u_lightcolor), u_vertical_gradient: new t2.Uniform1f(e3, i3.u_vertical_gradient), u_opacity: new t2.Uniform1f(e3, i3.u_opacity) }), fillExtrusionPattern: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_lightpos: new t2.Uniform3f(e3, i3.u_lightpos), u_lightintensity: new t2.Uniform1f(e3, i3.u_lightintensity), u_lightcolor: new t2.Uniform3f(e3, i3.u_lightcolor), u_vertical_gradient: new t2.Uniform1f(e3, i3.u_vertical_gradient), u_height_factor: new t2.Uniform1f(e3, i3.u_height_factor), u_image: new t2.Uniform1i(e3, i3.u_image), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_pixel_coord_upper: new t2.Uniform2f(e3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.Uniform2f(e3, i3.u_pixel_coord_lower), u_scale: new t2.Uniform3f(e3, i3.u_scale), u_fade: new t2.Uniform1f(e3, i3.u_fade), u_opacity: new t2.Uniform1f(e3, i3.u_opacity) }), fill: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix) }), fillPattern: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_image: new t2.Uniform1i(e3, i3.u_image), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_pixel_coord_upper: new t2.Uniform2f(e3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.Uniform2f(e3, i3.u_pixel_coord_lower), u_scale: new t2.Uniform3f(e3, i3.u_scale), u_fade: new t2.Uniform1f(e3, i3.u_fade) }), fillOutline: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_world: new t2.Uniform2f(e3, i3.u_world) }), fillOutlinePattern: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_world: new t2.Uniform2f(e3, i3.u_world), u_image: new t2.Uniform1i(e3, i3.u_image), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_pixel_coord_upper: new t2.Uniform2f(e3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.Uniform2f(e3, i3.u_pixel_coord_lower), u_scale: new t2.Uniform3f(e3, i3.u_scale), u_fade: new t2.Uniform1f(e3, i3.u_fade) }), circle: (e3, i3) => ({ u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_scale_with_map: new t2.Uniform1i(e3, i3.u_scale_with_map), u_pitch_with_map: new t2.Uniform1i(e3, i3.u_pitch_with_map), u_extrude_scale: new t2.Uniform2f(e3, i3.u_extrude_scale), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix) }), collisionBox: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_pixels_to_tile_units: new t2.Uniform1f(e3, i3.u_pixels_to_tile_units), u_extrude_scale: new t2.Uniform2f(e3, i3.u_extrude_scale), u_overscale_factor: new t2.Uniform1f(e3, i3.u_overscale_factor) }), collisionCircle: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_inv_matrix: new t2.UniformMatrix4f(e3, i3.u_inv_matrix), u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_viewport_size: new t2.Uniform2f(e3, i3.u_viewport_size) }), debug: (e3, i3) => ({ u_color: new t2.UniformColor(e3, i3.u_color), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_overlay: new t2.Uniform1i(e3, i3.u_overlay), u_overlay_scale: new t2.Uniform1f(e3, i3.u_overlay_scale) }), clippingMask: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix) }), heatmap: (e3, i3) => ({ u_extrude_scale: new t2.Uniform1f(e3, i3.u_extrude_scale), u_intensity: new t2.Uniform1f(e3, i3.u_intensity), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix) }), heatmapTexture: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_world: new t2.Uniform2f(e3, i3.u_world), u_image: new t2.Uniform1i(e3, i3.u_image), u_color_ramp: new t2.Uniform1i(e3, i3.u_color_ramp), u_opacity: new t2.Uniform1f(e3, i3.u_opacity) }), hillshade: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_image: new t2.Uniform1i(e3, i3.u_image), u_latrange: new t2.Uniform2f(e3, i3.u_latrange), u_light: new t2.Uniform2f(e3, i3.u_light), u_shadow: new t2.UniformColor(e3, i3.u_shadow), u_highlight: new t2.UniformColor(e3, i3.u_highlight), u_accent: new t2.UniformColor(e3, i3.u_accent) }), hillshadePrepare: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_image: new t2.Uniform1i(e3, i3.u_image), u_dimension: new t2.Uniform2f(e3, i3.u_dimension), u_zoom: new t2.Uniform1f(e3, i3.u_zoom), u_unpack: new t2.Uniform4f(e3, i3.u_unpack) }), line: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_ratio: new t2.Uniform1f(e3, i3.u_ratio), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.Uniform2f(e3, i3.u_units_to_pixels) }), lineGradient: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_ratio: new t2.Uniform1f(e3, i3.u_ratio), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.Uniform2f(e3, i3.u_units_to_pixels), u_image: new t2.Uniform1i(e3, i3.u_image), u_image_height: new t2.Uniform1f(e3, i3.u_image_height) }), linePattern: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_ratio: new t2.Uniform1f(e3, i3.u_ratio), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_image: new t2.Uniform1i(e3, i3.u_image), u_units_to_pixels: new t2.Uniform2f(e3, i3.u_units_to_pixels), u_scale: new t2.Uniform3f(e3, i3.u_scale), u_fade: new t2.Uniform1f(e3, i3.u_fade) }), lineSDF: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_ratio: new t2.Uniform1f(e3, i3.u_ratio), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_units_to_pixels: new t2.Uniform2f(e3, i3.u_units_to_pixels), u_patternscale_a: new t2.Uniform2f(e3, i3.u_patternscale_a), u_patternscale_b: new t2.Uniform2f(e3, i3.u_patternscale_b), u_sdfgamma: new t2.Uniform1f(e3, i3.u_sdfgamma), u_image: new t2.Uniform1i(e3, i3.u_image), u_tex_y_a: new t2.Uniform1f(e3, i3.u_tex_y_a), u_tex_y_b: new t2.Uniform1f(e3, i3.u_tex_y_b), u_mix: new t2.Uniform1f(e3, i3.u_mix) }), raster: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_tl_parent: new t2.Uniform2f(e3, i3.u_tl_parent), u_scale_parent: new t2.Uniform1f(e3, i3.u_scale_parent), u_buffer_scale: new t2.Uniform1f(e3, i3.u_buffer_scale), u_fade_t: new t2.Uniform1f(e3, i3.u_fade_t), u_opacity: new t2.Uniform1f(e3, i3.u_opacity), u_image0: new t2.Uniform1i(e3, i3.u_image0), u_image1: new t2.Uniform1i(e3, i3.u_image1), u_brightness_low: new t2.Uniform1f(e3, i3.u_brightness_low), u_brightness_high: new t2.Uniform1f(e3, i3.u_brightness_high), u_saturation_factor: new t2.Uniform1f(e3, i3.u_saturation_factor), u_contrast_factor: new t2.Uniform1f(e3, i3.u_contrast_factor), u_spin_weights: new t2.Uniform3f(e3, i3.u_spin_weights) }), symbolIcon: (e3, i3) => ({ u_is_size_zoom_constant: new t2.Uniform1i(e3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.Uniform1i(e3, i3.u_is_size_feature_constant), u_size_t: new t2.Uniform1f(e3, i3.u_size_t), u_size: new t2.Uniform1f(e3, i3.u_size), u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_pitch: new t2.Uniform1f(e3, i3.u_pitch), u_rotate_symbol: new t2.Uniform1i(e3, i3.u_rotate_symbol), u_aspect_ratio: new t2.Uniform1f(e3, i3.u_aspect_ratio), u_fade_change: new t2.Uniform1f(e3, i3.u_fade_change), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_label_plane_matrix: new t2.UniformMatrix4f(e3, i3.u_label_plane_matrix), u_coord_matrix: new t2.UniformMatrix4f(e3, i3.u_coord_matrix), u_is_text: new t2.Uniform1i(e3, i3.u_is_text), u_pitch_with_map: new t2.Uniform1i(e3, i3.u_pitch_with_map), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_texture: new t2.Uniform1i(e3, i3.u_texture) }), symbolSDF: (e3, i3) => ({ u_is_size_zoom_constant: new t2.Uniform1i(e3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.Uniform1i(e3, i3.u_is_size_feature_constant), u_size_t: new t2.Uniform1f(e3, i3.u_size_t), u_size: new t2.Uniform1f(e3, i3.u_size), u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_pitch: new t2.Uniform1f(e3, i3.u_pitch), u_rotate_symbol: new t2.Uniform1i(e3, i3.u_rotate_symbol), u_aspect_ratio: new t2.Uniform1f(e3, i3.u_aspect_ratio), u_fade_change: new t2.Uniform1f(e3, i3.u_fade_change), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_label_plane_matrix: new t2.UniformMatrix4f(e3, i3.u_label_plane_matrix), u_coord_matrix: new t2.UniformMatrix4f(e3, i3.u_coord_matrix), u_is_text: new t2.Uniform1i(e3, i3.u_is_text), u_pitch_with_map: new t2.Uniform1i(e3, i3.u_pitch_with_map), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_texture: new t2.Uniform1i(e3, i3.u_texture), u_gamma_scale: new t2.Uniform1f(e3, i3.u_gamma_scale), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_is_halo: new t2.Uniform1i(e3, i3.u_is_halo) }), symbolTextAndIcon: (e3, i3) => ({ u_is_size_zoom_constant: new t2.Uniform1i(e3, i3.u_is_size_zoom_constant), u_is_size_feature_constant: new t2.Uniform1i(e3, i3.u_is_size_feature_constant), u_size_t: new t2.Uniform1f(e3, i3.u_size_t), u_size: new t2.Uniform1f(e3, i3.u_size), u_camera_to_center_distance: new t2.Uniform1f(e3, i3.u_camera_to_center_distance), u_pitch: new t2.Uniform1f(e3, i3.u_pitch), u_rotate_symbol: new t2.Uniform1i(e3, i3.u_rotate_symbol), u_aspect_ratio: new t2.Uniform1f(e3, i3.u_aspect_ratio), u_fade_change: new t2.Uniform1f(e3, i3.u_fade_change), u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_label_plane_matrix: new t2.UniformMatrix4f(e3, i3.u_label_plane_matrix), u_coord_matrix: new t2.UniformMatrix4f(e3, i3.u_coord_matrix), u_is_text: new t2.Uniform1i(e3, i3.u_is_text), u_pitch_with_map: new t2.Uniform1i(e3, i3.u_pitch_with_map), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_texsize_icon: new t2.Uniform2f(e3, i3.u_texsize_icon), u_texture: new t2.Uniform1i(e3, i3.u_texture), u_texture_icon: new t2.Uniform1i(e3, i3.u_texture_icon), u_gamma_scale: new t2.Uniform1f(e3, i3.u_gamma_scale), u_device_pixel_ratio: new t2.Uniform1f(e3, i3.u_device_pixel_ratio), u_is_halo: new t2.Uniform1i(e3, i3.u_is_halo) }), background: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_opacity: new t2.Uniform1f(e3, i3.u_opacity), u_color: new t2.UniformColor(e3, i3.u_color) }), backgroundPattern: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_opacity: new t2.Uniform1f(e3, i3.u_opacity), u_image: new t2.Uniform1i(e3, i3.u_image), u_pattern_tl_a: new t2.Uniform2f(e3, i3.u_pattern_tl_a), u_pattern_br_a: new t2.Uniform2f(e3, i3.u_pattern_br_a), u_pattern_tl_b: new t2.Uniform2f(e3, i3.u_pattern_tl_b), u_pattern_br_b: new t2.Uniform2f(e3, i3.u_pattern_br_b), u_texsize: new t2.Uniform2f(e3, i3.u_texsize), u_mix: new t2.Uniform1f(e3, i3.u_mix), u_pattern_size_a: new t2.Uniform2f(e3, i3.u_pattern_size_a), u_pattern_size_b: new t2.Uniform2f(e3, i3.u_pattern_size_b), u_scale_a: new t2.Uniform1f(e3, i3.u_scale_a), u_scale_b: new t2.Uniform1f(e3, i3.u_scale_b), u_pixel_coord_upper: new t2.Uniform2f(e3, i3.u_pixel_coord_upper), u_pixel_coord_lower: new t2.Uniform2f(e3, i3.u_pixel_coord_lower), u_tile_units_to_pixels: new t2.Uniform1f(e3, i3.u_tile_units_to_pixels) }), terrain: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_texture: new t2.Uniform1i(e3, i3.u_texture), u_ele_delta: new t2.Uniform1f(e3, i3.u_ele_delta) }), terrainDepth: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_ele_delta: new t2.Uniform1f(e3, i3.u_ele_delta) }), terrainCoords: (e3, i3) => ({ u_matrix: new t2.UniformMatrix4f(e3, i3.u_matrix), u_texture: new t2.Uniform1i(e3, i3.u_texture), u_terrain_coords_id: new t2.Uniform1f(e3, i3.u_terrain_coords_id), u_ele_delta: new t2.Uniform1f(e3, i3.u_ele_delta) }) };
          class Oe {
            constructor(t3, e3, i3) {
              this.context = t3;
              const s2 = t3.gl;
              this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i3), this.context.unbindVAO(), t3.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t3) {
              const e3 = this.context.gl;
              if (!this.dynamicDraw)
                throw new Error("Attempted to update data while not in dynamic mode.");
              this.context.unbindVAO(), this.bind(), e3.bufferSubData(e3.ELEMENT_ARRAY_BUFFER, 0, t3.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Ne = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class Ge {
            constructor(t3, e3, i3, s2) {
              this.length = e3.length, this.attributes = i3, this.itemSize = e3.bytesPerElement, this.dynamicDraw = s2, this.context = t3;
              const a3 = t3.gl;
              this.buffer = a3.createBuffer(), t3.bindVertexBuffer.set(this.buffer), a3.bufferData(a3.ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? a3.DYNAMIC_DRAW : a3.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t3) {
              if (t3.length !== this.length)
                throw new Error(`Length of new data is ${t3.length}, which doesn't match current length of ${this.length}`);
              const e3 = this.context.gl;
              this.bind(), e3.bufferSubData(e3.ARRAY_BUFFER, 0, t3.arrayBuffer);
            }
            enableAttributes(t3, e3) {
              for (let i3 = 0; i3 < this.attributes.length; i3++) {
                const s2 = e3.attributes[this.attributes[i3].name];
                void 0 !== s2 && t3.enableVertexAttribArray(s2);
              }
            }
            setVertexAttribPointers(t3, e3, i3) {
              for (let s2 = 0; s2 < this.attributes.length; s2++) {
                const a3 = this.attributes[s2], o2 = e3.attributes[a3.name];
                void 0 !== o2 && t3.vertexAttribPointer(o2, a3.components, t3[Ne[a3.type]], false, this.itemSize, a3.offset + this.itemSize * (i3 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Ze = /* @__PURE__ */ new WeakMap();
          function Ve(t3) {
            if (Ze.has(t3))
              return Ze.get(t3);
            {
              const e3 = t3.getParameter(t3.VERSION).startsWith("WebGL 2.0");
              return Ze.set(t3, e3), e3;
            }
          }
          class qe {
            constructor(t3) {
              this.gl = t3.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(t3) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class je extends qe {
            getDefault() {
              return t2.Color.transparent;
            }
            set(t3) {
              const e3 = this.current;
              (t3.r !== e3.r || t3.g !== e3.g || t3.b !== e3.b || t3.a !== e3.a || this.dirty) && (this.gl.clearColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
            }
          }
          class $e extends qe {
            getDefault() {
              return 1;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
            }
          }
          class Xe extends qe {
            getDefault() {
              return 0;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
            }
          }
          class We extends qe {
            getDefault() {
              return [true, true, true, true];
            }
            set(t3) {
              const e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
            }
          }
          class He extends qe {
            getDefault() {
              return true;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
            }
          }
          class Ke extends qe {
            getDefault() {
              return 255;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
            }
          }
          class Ye extends qe {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(t3) {
              const e3 = this.current;
              (t3.func !== e3.func || t3.ref !== e3.ref || t3.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
            }
          }
          class Je extends qe {
            getDefault() {
              const t3 = this.gl;
              return [t3.KEEP, t3.KEEP, t3.KEEP];
            }
            set(t3) {
              const e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
            }
          }
          class Qe extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t3 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t3, this.dirty = false;
            }
          }
          class ti extends qe {
            getDefault() {
              return [0, 1];
            }
            set(t3) {
              const e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
            }
          }
          class ei extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t3 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t3, this.dirty = false;
            }
          }
          class ii extends qe {
            getDefault() {
              return this.gl.LESS;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
            }
          }
          class si extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t3 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t3, this.dirty = false;
            }
          }
          class ai extends qe {
            getDefault() {
              const t3 = this.gl;
              return [t3.ONE, t3.ZERO];
            }
            set(t3) {
              const e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
            }
          }
          class oi extends qe {
            getDefault() {
              return t2.Color.transparent;
            }
            set(t3) {
              const e3 = this.current;
              (t3.r !== e3.r || t3.g !== e3.g || t3.b !== e3.b || t3.a !== e3.a || this.dirty) && (this.gl.blendColor(t3.r, t3.g, t3.b, t3.a), this.current = t3, this.dirty = false);
            }
          }
          class ri extends qe {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
            }
          }
          class ni extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t3 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t3, this.dirty = false;
            }
          }
          class li extends qe {
            getDefault() {
              return this.gl.BACK;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
            }
          }
          class ci extends qe {
            getDefault() {
              return this.gl.CCW;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
            }
          }
          class hi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
            }
          }
          class ui extends qe {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
            }
          }
          class di extends qe {
            getDefault() {
              const t3 = this.gl;
              return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
            }
            set(t3) {
              const e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
            }
          }
          class _i extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindFramebuffer(e3.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class mi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindRenderbuffer(e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class pi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindTexture(e3.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
            }
          }
          class fi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindBuffer(e3.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class gi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              const e3 = this.gl;
              e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class vi extends qe {
            getDefault() {
              return null;
            }
            set(t3) {
              var e3;
              if (t3 === this.current && !this.dirty)
                return;
              const i3 = this.gl;
              Ve(i3) ? i3.bindVertexArray(t3) : null === (e3 = i3.getExtension("OES_vertex_array_object")) || void 0 === e3 || e3.bindVertexArrayOES(t3), this.current = t3, this.dirty = false;
            }
          }
          class xi extends qe {
            getDefault() {
              return 4;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
            }
          }
          class yi extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
            }
          }
          class bi extends qe {
            getDefault() {
              return false;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
            }
          }
          class wi extends qe {
            constructor(t3, e3) {
              super(t3), this.context = t3, this.parent = e3;
            }
            getDefault() {
              return null;
            }
          }
          class Ti extends wi {
            setDirty() {
              this.dirty = true;
            }
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e3 = this.gl;
              e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
            }
          }
          class Ei extends wi {
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e3 = this.gl;
              e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class Ii extends wi {
            set(t3) {
              if (t3 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e3 = this.gl;
              e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_STENCIL_ATTACHMENT, e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
            }
          }
          class Si {
            constructor(t3, e3, i3, s2, a3) {
              this.context = t3, this.width = e3, this.height = i3;
              const o2 = t3.gl, r2 = this.framebuffer = o2.createFramebuffer();
              if (this.colorAttachment = new Ti(t3, r2), s2)
                this.depthAttachment = a3 ? new Ii(t3, r2) : new Ei(t3, r2);
              else if (a3)
                throw new Error("Stencil cannot be setted without depth");
              if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE)
                throw new Error("Framebuffer is not complete");
            }
            destroy() {
              const t3 = this.context.gl, e3 = this.colorAttachment.get();
              if (e3 && t3.deleteTexture(e3), this.depthAttachment) {
                const e4 = this.depthAttachment.get();
                e4 && t3.deleteRenderbuffer(e4);
              }
              t3.deleteFramebuffer(this.framebuffer);
            }
          }
          class Ci {
            constructor(t3, e3, i3) {
              this.blendFunction = t3, this.blendColor = e3, this.mask = i3;
            }
          }
          Ci.Replace = [1, 0], Ci.disabled = new Ci(Ci.Replace, t2.Color.transparent, [false, false, false, false]), Ci.unblended = new Ci(Ci.Replace, t2.Color.transparent, [true, true, true, true]), Ci.alphaBlended = new Ci([1, 771], t2.Color.transparent, [true, true, true, true]);
          class Pi {
            constructor(t3) {
              var e3, i3;
              if (this.gl = t3, this.clearColor = new je(this), this.clearDepth = new $e(this), this.clearStencil = new Xe(this), this.colorMask = new We(this), this.depthMask = new He(this), this.stencilMask = new Ke(this), this.stencilFunc = new Ye(this), this.stencilOp = new Je(this), this.stencilTest = new Qe(this), this.depthRange = new ti(this), this.depthTest = new ei(this), this.depthFunc = new ii(this), this.blend = new si(this), this.blendFunc = new ai(this), this.blendColor = new oi(this), this.blendEquation = new ri(this), this.cullFace = new ni(this), this.cullFaceSide = new li(this), this.frontFace = new ci(this), this.program = new hi(this), this.activeTexture = new ui(this), this.viewport = new di(this), this.bindFramebuffer = new _i(this), this.bindRenderbuffer = new mi(this), this.bindTexture = new pi(this), this.bindVertexBuffer = new fi(this), this.bindElementBuffer = new gi(this), this.bindVertexArray = new vi(this), this.pixelStoreUnpack = new xi(this), this.pixelStoreUnpackPremultiplyAlpha = new yi(this), this.pixelStoreUnpackFlipY = new bi(this), this.extTextureFilterAnisotropic = t3.getExtension("EXT_texture_filter_anisotropic") || t3.getExtension("MOZ_EXT_texture_filter_anisotropic") || t3.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t3.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t3.getParameter(t3.MAX_TEXTURE_SIZE), Ve(t3)) {
                this.HALF_FLOAT = t3.HALF_FLOAT;
                const s2 = t3.getExtension("EXT_color_buffer_half_float");
                this.RGBA16F = null !== (e3 = t3.RGBA16F) && void 0 !== e3 ? e3 : null == s2 ? void 0 : s2.RGBA16F_EXT, this.RGB16F = null !== (i3 = t3.RGB16F) && void 0 !== i3 ? i3 : null == s2 ? void 0 : s2.RGB16F_EXT, t3.getExtension("EXT_color_buffer_float");
              } else {
                t3.getExtension("EXT_color_buffer_half_float"), t3.getExtension("OES_texture_half_float_linear");
                const e4 = t3.getExtension("OES_texture_half_float");
                this.HALF_FLOAT = null == e4 ? void 0 : e4.HALF_FLOAT_OES;
              }
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(t3, e3) {
              return new Oe(this, t3, e3);
            }
            createVertexBuffer(t3, e3, i3) {
              return new Ge(this, t3, e3, i3);
            }
            createRenderbuffer(t3, e3, i3) {
              const s2 = this.gl, a3 = s2.createRenderbuffer();
              return this.bindRenderbuffer.set(a3), s2.renderbufferStorage(s2.RENDERBUFFER, t3, e3, i3), this.bindRenderbuffer.set(null), a3;
            }
            createFramebuffer(t3, e3, i3, s2) {
              return new Si(this, t3, e3, i3, s2);
            }
            clear({ color: t3, depth: e3, stencil: i3 }) {
              const s2 = this.gl;
              let a3 = 0;
              t3 && (a3 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(t3), this.colorMask.set([true, true, true, true])), void 0 !== e3 && (a3 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e3), this.depthMask.set(true)), void 0 !== i3 && (a3 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i3), this.stencilMask.set(255)), s2.clear(a3);
            }
            setCullFace(t3) {
              false === t3.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t3.mode), this.frontFace.set(t3.frontFace));
            }
            setDepthMode(t3) {
              t3.func !== this.gl.ALWAYS || t3.mask ? (this.depthTest.set(true), this.depthFunc.set(t3.func), this.depthMask.set(t3.mask), this.depthRange.set(t3.range)) : this.depthTest.set(false);
            }
            setStencilMode(t3) {
              t3.test.func !== this.gl.ALWAYS || t3.mask ? (this.stencilTest.set(true), this.stencilMask.set(t3.mask), this.stencilOp.set([t3.fail, t3.depthFail, t3.pass]), this.stencilFunc.set({ func: t3.test.func, ref: t3.ref, mask: t3.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(e3) {
              t2.deepEqual(e3.blendFunction, Ci.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e3.blendFunction), this.blendColor.set(e3.blendColor)), this.colorMask.set(e3.mask);
            }
            createVertexArray() {
              var t3;
              return Ve(this.gl) ? this.gl.createVertexArray() : null === (t3 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t3 ? void 0 : t3.createVertexArrayOES();
            }
            deleteVertexArray(t3) {
              var e3;
              return Ve(this.gl) ? this.gl.deleteVertexArray(t3) : null === (e3 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e3 ? void 0 : e3.deleteVertexArrayOES(t3);
            }
            unbindVAO() {
              this.bindVertexArray.set(null);
            }
          }
          class Di {
            constructor(t3, e3, i3) {
              this.func = t3, this.mask = e3, this.range = i3;
            }
          }
          Di.ReadOnly = false, Di.ReadWrite = true, Di.disabled = new Di(519, Di.ReadOnly, [0, 1]);
          const zi = 7680;
          class Mi {
            constructor(t3, e3, i3, s2, a3, o2) {
              this.test = t3, this.ref = e3, this.mask = i3, this.fail = s2, this.depthFail = a3, this.pass = o2;
            }
          }
          Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, zi, zi, zi);
          class Ai {
            constructor(t3, e3, i3) {
              this.enable = t3, this.mode = e3, this.frontFace = i3;
            }
          }
          let Li;
          function Ri(e3, i3, s2, a3, o2, r2, n3) {
            const l2 = e3.context, c5 = l2.gl, h2 = e3.useProgram("collisionBox"), u2 = [];
            let d3 = 0, _2 = 0;
            for (let m5 = 0; m5 < a3.length; m5++) {
              const p4 = a3[m5], f3 = i3.getTile(p4), g4 = f3.getBucket(s2);
              if (!g4)
                continue;
              let v3 = p4.posMatrix;
              0 === o2[0] && 0 === o2[1] || (v3 = e3.translatePosMatrix(p4.posMatrix, f3, o2, r2));
              const x3 = n3 ? g4.textCollisionBox : g4.iconCollisionBox, y2 = g4.collisionCircleArray;
              if (y2.length > 0) {
                const i4 = t2.create(), s3 = v3;
                t2.mul(i4, g4.placementInvProjMatrix, e3.transform.glCoordMatrix), t2.mul(i4, i4, g4.placementViewportMatrix), u2.push({ circleArray: y2, circleOffset: _2, transform: s3, invTransform: i4, coord: p4 }), d3 += y2.length / 4, _2 = d3;
              }
              x3 && h2.draw(l2, c5.LINES, Di.disabled, Mi.disabled, e3.colorModeForRenderPass(), Ai.disabled, ye(v3, e3.transform, f3), e3.style.map.terrain && e3.style.map.terrain.getTerrainData(p4), s2.id, x3.layoutVertexBuffer, x3.indexBuffer, x3.segments, null, e3.transform.zoom, null, null, x3.collisionVertexBuffer);
            }
            if (!n3 || !u2.length)
              return;
            const m4 = e3.useProgram("collisionCircle"), p3 = new t2.CollisionCircleLayoutArray();
            p3.resize(4 * d3), p3._trim();
            let f2 = 0;
            for (const t3 of u2)
              for (let e4 = 0; e4 < t3.circleArray.length / 4; e4++) {
                const i4 = 4 * e4, s3 = t3.circleArray[i4 + 0], a4 = t3.circleArray[i4 + 1], o3 = t3.circleArray[i4 + 2], r3 = t3.circleArray[i4 + 3];
                p3.emplace(f2++, s3, a4, o3, r3, 0), p3.emplace(f2++, s3, a4, o3, r3, 1), p3.emplace(f2++, s3, a4, o3, r3, 2), p3.emplace(f2++, s3, a4, o3, r3, 3);
              }
            (!Li || Li.length < 2 * d3) && (Li = function(e4) {
              const i4 = 2 * e4, s3 = new t2.QuadTriangleArray();
              s3.resize(i4), s3._trim();
              for (let t3 = 0; t3 < i4; t3++) {
                const e5 = 6 * t3;
                s3.uint16[e5 + 0] = 4 * t3 + 0, s3.uint16[e5 + 1] = 4 * t3 + 1, s3.uint16[e5 + 2] = 4 * t3 + 2, s3.uint16[e5 + 3] = 4 * t3 + 2, s3.uint16[e5 + 4] = 4 * t3 + 3, s3.uint16[e5 + 5] = 4 * t3 + 0;
              }
              return s3;
            }(d3));
            const g3 = l2.createIndexBuffer(Li, true), v2 = l2.createVertexBuffer(p3, t2.collisionCircleLayout.members, true);
            for (const i4 of u2) {
              const a4 = { u_matrix: i4.transform, u_inv_matrix: i4.invTransform, u_camera_to_center_distance: (x2 = e3.transform).cameraToCenterDistance, u_viewport_size: [x2.width, x2.height] };
              m4.draw(l2, c5.TRIANGLES, Di.disabled, Mi.disabled, e3.colorModeForRenderPass(), Ai.disabled, a4, e3.style.map.terrain && e3.style.map.terrain.getTerrainData(i4.coord), s2.id, v2, g3, t2.SegmentVector.simpleSegment(0, 2 * i4.circleOffset, i4.circleArray.length, i4.circleArray.length / 2), null, e3.transform.zoom, null, null, null);
            }
            var x2;
            v2.destroy(), g3.destroy();
          }
          Ai.disabled = new Ai(false, 1029, 2305), Ai.backCCW = new Ai(true, 1029, 2305);
          const ki = t2.identity(new Float32Array(16));
          function Bi(e3, i3, s2, a3, o2, r2) {
            const { horizontalAlign: n3, verticalAlign: l2 } = t2.getAnchorAlignment(e3), c5 = -(n3 - 0.5) * i3, h2 = -(l2 - 0.5) * s2, u2 = t2.evaluateVariableOffset(e3, a3);
            return new t2.Point((c5 / o2 + u2[0]) * r2, (h2 / o2 + u2[1]) * r2);
          }
          function Fi(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2) {
            const d3 = e3.text.placedSymbolArray, _2 = e3.text.dynamicLayoutVertexArray, m4 = e3.icon.dynamicLayoutVertexArray, p3 = {};
            _2.clear();
            for (let m5 = 0; m5 < d3.length; m5++) {
              const f2 = d3.get(m5), g3 = f2.hidden || !f2.crossTileID || e3.allowVerticalPlacement && !f2.placedOrientation ? null : a3[f2.crossTileID];
              if (g3) {
                const a4 = new t2.Point(f2.anchorX, f2.anchorY), d4 = ht(a4, s2 ? n3 : r2, u2), m6 = ut(o2.cameraToCenterDistance, d4.signedDistanceFromCamera);
                let v2 = t2.evaluateSizeForFeature(e3.textSizeData, c5, f2) * m6 / t2.ONE_EM;
                s2 && (v2 *= e3.tilePixelRatio / l2);
                const { width: x2, height: y2, anchor: b3, textOffset: w2, textBoxScale: T2 } = g3, E2 = Bi(b3, x2, y2, w2, T2, v2), I2 = s2 ? ht(a4.add(E2), r2, u2).point : d4.point.add(i3 ? E2.rotate(-o2.angle) : E2), S2 = e3.allowVerticalPlacement && f2.placedOrientation === t2.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let e4 = 0; e4 < f2.numGlyphs; e4++)
                  t2.addDynamicAttributes(_2, I2, S2);
                h2 && f2.associatedIconIndex >= 0 && (p3[f2.associatedIconIndex] = { shiftedAnchor: I2, angle: S2 });
              } else
                Tt(f2.numGlyphs, _2);
            }
            if (h2) {
              m4.clear();
              const i4 = e3.icon.placedSymbolArray;
              for (let e4 = 0; e4 < i4.length; e4++) {
                const s3 = i4.get(e4);
                if (s3.hidden)
                  Tt(s3.numGlyphs, m4);
                else {
                  const i5 = p3[e4];
                  if (i5)
                    for (let e5 = 0; e5 < s3.numGlyphs; e5++)
                      t2.addDynamicAttributes(m4, i5.shiftedAnchor, i5.angle);
                  else
                    Tt(s3.numGlyphs, m4);
                }
              }
              e3.icon.dynamicLayoutVertexBuffer.updateData(m4);
            }
            e3.text.dynamicLayoutVertexBuffer.updateData(_2);
          }
          function Ui(t3, e3, i3) {
            return i3.iconsInText && e3 ? "symbolTextAndIcon" : t3 ? "symbolSDF" : "symbolIcon";
          }
          function Oi(e3, i3, s2, a3, o2, r2, n3, l2, c5, h2, u2, d3) {
            const _2 = e3.context, m4 = _2.gl, p3 = e3.transform, f2 = "map" === l2, g3 = "map" === c5, v2 = "viewport" !== l2 && "point" !== s2.layout.get("symbol-placement"), x2 = f2 && !g3 && !v2, y2 = !s2.layout.get("symbol-sort-key").isConstant();
            let b3 = false;
            const w2 = e3.depthModeForSublayer(0, Di.ReadOnly), T2 = s2.layout.get("text-variable-anchor"), E2 = [];
            for (const l3 of a3) {
              const a4 = i3.getTile(l3), c6 = a4.getBucket(s2);
              if (!c6)
                continue;
              const u3 = o2 ? c6.text : c6.icon;
              if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices)
                continue;
              const d4 = u3.programConfigurations.get(s2.id), _3 = o2 || c6.sdfIcons, w3 = o2 ? c6.textSizeData : c6.iconSizeData, I2 = g3 || 0 !== p3.pitch, S2 = e3.useProgram(Ui(_3, o2, c6), d4), C3 = t2.evaluateSizeForZoom(w3, p3.zoom), P2 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(l3);
              let D2, z2, M2, A2, L2 = [0, 0], R2 = null;
              if (o2)
                z2 = a4.glyphAtlasTexture, M2 = m4.LINEAR, D2 = a4.glyphAtlasTexture.size, c6.iconsInText && (L2 = a4.imageAtlasTexture.size, R2 = a4.imageAtlasTexture, A2 = I2 || e3.options.rotating || e3.options.zooming || "composite" === w3.kind || "camera" === w3.kind ? m4.LINEAR : m4.NEAREST);
              else {
                const t3 = 1 !== s2.layout.get("icon-size").constantOr(0) || c6.iconsNeedLinear;
                z2 = a4.imageAtlasTexture, M2 = _3 || e3.options.rotating || e3.options.zooming || t3 || I2 ? m4.LINEAR : m4.NEAREST, D2 = a4.imageAtlasTexture.size;
              }
              const k2 = Ct(a4, 1, e3.transform.zoom), B2 = lt(l3.posMatrix, g3, f2, e3.transform, k2), F2 = ct(l3.posMatrix, g3, f2, e3.transform, k2), U2 = T2 && c6.hasTextData(), O2 = "none" !== s2.layout.get("icon-text-fit") && U2 && c6.hasIconData();
              if (v2) {
                const t3 = e3.style.map.terrain ? (t4, i5) => e3.style.map.terrain.getElevation(l3, t4, i5) : null, i4 = "map" === s2.layout.get("text-rotation-alignment");
                _t(c6, l3.posMatrix, e3, o2, B2, F2, g3, h2, i4, t3);
              }
              const N2 = e3.translatePosMatrix(l3.posMatrix, a4, r2, n3), G2 = v2 || o2 && T2 || O2 ? ki : B2, Z2 = e3.translatePosMatrix(F2, a4, r2, n3, true), V2 = _3 && 0 !== s2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let q2;
              q2 = _3 ? c6.iconsInText ? ke(w3.kind, C3, x2, g3, e3, N2, G2, Z2, D2, L2) : Re(w3.kind, C3, x2, g3, e3, N2, G2, Z2, o2, D2, true) : Le(w3.kind, C3, x2, g3, e3, N2, G2, Z2, o2, D2);
              const j2 = { program: S2, buffers: u3, uniformValues: q2, atlasTexture: z2, atlasTextureIcon: R2, atlasInterpolation: M2, atlasInterpolationIcon: A2, isSDF: _3, hasHalo: V2 };
              if (y2 && c6.canOverlap) {
                b3 = true;
                const e4 = u3.segments.get();
                for (const i4 of e4)
                  E2.push({ segments: new t2.SegmentVector([i4]), sortKey: i4.sortKey, state: j2, terrainData: P2 });
              } else
                E2.push({ segments: u3.segments, sortKey: 0, state: j2, terrainData: P2 });
            }
            b3 && E2.sort((t3, e4) => t3.sortKey - e4.sortKey);
            for (const t3 of E2) {
              const i4 = t3.state;
              if (_2.activeTexture.set(m4.TEXTURE0), i4.atlasTexture.bind(i4.atlasInterpolation, m4.CLAMP_TO_EDGE), i4.atlasTextureIcon && (_2.activeTexture.set(m4.TEXTURE1), i4.atlasTextureIcon && i4.atlasTextureIcon.bind(i4.atlasInterpolationIcon, m4.CLAMP_TO_EDGE)), i4.isSDF) {
                const a4 = i4.uniformValues;
                i4.hasHalo && (a4.u_is_halo = 1, Ni(i4.buffers, t3.segments, s2, e3, i4.program, w2, u2, d3, a4, t3.terrainData)), a4.u_is_halo = 0;
              }
              Ni(i4.buffers, t3.segments, s2, e3, i4.program, w2, u2, d3, i4.uniformValues, t3.terrainData);
            }
          }
          function Ni(t3, e3, i3, s2, a3, o2, r2, n3, l2, c5) {
            const h2 = s2.context;
            a3.draw(h2, h2.gl.TRIANGLES, o2, r2, n3, Ai.disabled, l2, c5, i3.id, t3.layoutVertexBuffer, t3.indexBuffer, e3, i3.paint, s2.transform.zoom, t3.programConfigurations.get(i3.id), t3.dynamicLayoutVertexBuffer, t3.opacityVertexBuffer);
          }
          function Gi(t3, e3, i3, s2, a3) {
            if (!i3 || !s2 || !s2.imageAtlas)
              return;
            const o2 = s2.imageAtlas.patternPositions;
            let r2 = o2[i3.to.toString()], n3 = o2[i3.from.toString()];
            if (!r2 || !n3) {
              const t4 = a3.getPaintProperty(e3);
              r2 = o2[t4], n3 = o2[t4];
            }
            r2 && n3 && t3.setConstantPatternPositions(r2, n3);
          }
          function Zi(t3, e3, i3, s2, a3, o2, r2) {
            const n3 = t3.context.gl, l2 = "fill-pattern", c5 = i3.paint.get(l2), h2 = c5 && c5.constantOr(1), u2 = i3.getCrossfadeParameters();
            let d3, _2, m4, p3, f2;
            r2 ? (_2 = h2 && !i3.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d3 = n3.LINES) : (_2 = h2 ? "fillPattern" : "fill", d3 = n3.TRIANGLES);
            const g3 = c5.constantOr(null);
            for (const c6 of s2) {
              const s3 = e3.getTile(c6);
              if (h2 && !s3.patternsLoaded())
                continue;
              const v2 = s3.getBucket(i3);
              if (!v2)
                continue;
              const x2 = v2.programConfigurations.get(i3.id), y2 = t3.useProgram(_2, x2), b3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(c6);
              h2 && (t3.context.activeTexture.set(n3.TEXTURE0), s3.imageAtlasTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), x2.updatePaintBuffers(u2)), Gi(x2, l2, g3, s3, i3);
              const w2 = b3 ? c6 : null, T2 = t3.translatePosMatrix(w2 ? w2.posMatrix : c6.posMatrix, s3, i3.paint.get("fill-translate"), i3.paint.get("fill-translate-anchor"));
              if (r2) {
                p3 = v2.indexBuffer2, f2 = v2.segments2;
                const e4 = [n3.drawingBufferWidth, n3.drawingBufferHeight];
                m4 = "fillOutlinePattern" === _2 && h2 ? ve(T2, t3, u2, s3, e4) : ge(T2, e4);
              } else
                p3 = v2.indexBuffer, f2 = v2.segments, m4 = h2 ? fe(T2, t3, u2, s3) : pe(T2);
              y2.draw(t3.context, d3, a3, t3.stencilModeForClipping(c6), o2, Ai.disabled, m4, b3, i3.id, v2.layoutVertexBuffer, p3, f2, i3.paint, t3.transform.zoom, x2);
            }
          }
          function Vi(t3, e3, i3, s2, a3, o2, r2) {
            const n3 = t3.context, l2 = n3.gl, c5 = "fill-extrusion-pattern", h2 = i3.paint.get(c5), u2 = h2.constantOr(1), d3 = i3.getCrossfadeParameters(), _2 = i3.paint.get("fill-extrusion-opacity"), m4 = h2.constantOr(null);
            for (const h3 of s2) {
              const s3 = e3.getTile(h3), p3 = s3.getBucket(i3);
              if (!p3)
                continue;
              const f2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(h3), g3 = p3.programConfigurations.get(i3.id), v2 = t3.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", g3);
              u2 && (t3.context.activeTexture.set(l2.TEXTURE0), s3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), g3.updatePaintBuffers(d3)), Gi(g3, c5, m4, s3, i3);
              const x2 = t3.translatePosMatrix(h3.posMatrix, s3, i3.paint.get("fill-extrusion-translate"), i3.paint.get("fill-extrusion-translate-anchor")), y2 = i3.paint.get("fill-extrusion-vertical-gradient"), b3 = u2 ? me(x2, t3, y2, _2, h3, d3, s3) : _e(x2, t3, y2, _2);
              v2.draw(n3, n3.gl.TRIANGLES, a3, o2, r2, Ai.backCCW, b3, f2, i3.id, p3.layoutVertexBuffer, p3.indexBuffer, p3.segments, i3.paint, t3.transform.zoom, g3, t3.style.map.terrain && p3.centroidVertexBuffer);
            }
          }
          function qi(t3, e3, i3, s2, a3, o2, r2) {
            const n3 = t3.context, l2 = n3.gl, c5 = i3.fbo;
            if (!c5)
              return;
            const h2 = t3.useProgram("hillshade"), u2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e3);
            n3.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c5.colorAttachment.get()), h2.draw(n3, l2.TRIANGLES, a3, o2, r2, Ai.disabled, ((t4, e4, i4, s3) => {
              const a4 = i4.paint.get("hillshade-shadow-color"), o3 = i4.paint.get("hillshade-highlight-color"), r3 = i4.paint.get("hillshade-accent-color");
              let n4 = i4.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === i4.paint.get("hillshade-illumination-anchor") && (n4 -= t4.transform.angle);
              const l3 = !t4.options.moving;
              return { u_matrix: s3 ? s3.posMatrix : t4.transform.calculatePosMatrix(e4.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Ee(0, e4.tileID), u_light: [i4.paint.get("hillshade-exaggeration"), n4], u_shadow: a4, u_highlight: o3, u_accent: r3 };
            })(t3, i3, s2, u2 ? e3 : null), u2, s2.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
          }
          function ji(e3, i3, s2, a3, o2, r2) {
            const n3 = e3.context, l2 = n3.gl, c5 = i3.dem;
            if (c5 && c5.data) {
              const h2 = c5.dim, u2 = c5.stride, d3 = c5.getPixels();
              if (n3.activeTexture.set(l2.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i3.demTexture = i3.demTexture || e3.getTileTexture(u2), i3.demTexture) {
                const t3 = i3.demTexture;
                t3.update(d3, { premultiply: false }), t3.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              } else
                i3.demTexture = new x(n3, d3, l2.RGBA, { premultiply: false }), i3.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              n3.activeTexture.set(l2.TEXTURE0);
              let _2 = i3.fbo;
              if (!_2) {
                const t3 = new x(n3, { width: h2, height: h2, data: null }, l2.RGBA);
                t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i3.fbo = n3.createFramebuffer(h2, h2, true, false), _2.colorAttachment.set(t3.texture);
              }
              n3.bindFramebuffer.set(_2.framebuffer), n3.viewport.set([0, 0, h2, h2]), e3.useProgram("hillshadePrepare").draw(n3, l2.TRIANGLES, a3, o2, r2, Ai.disabled, ((e4, i4) => {
                const s3 = i4.stride, a4 = t2.create();
                return t2.ortho(a4, 0, t2.EXTENT, -t2.EXTENT, 0, 0, 1), t2.translate(a4, a4, [0, -t2.EXTENT, 0]), { u_matrix: a4, u_image: 1, u_dimension: [s3, s3], u_zoom: e4.overscaledZ, u_unpack: i4.getUnpackVector() };
              })(i3.tileID, c5), null, s2.id, e3.rasterBoundsBuffer, e3.quadTriangleIndexBuffer, e3.rasterBoundsSegments), i3.needsHillshadePrepare = false;
            }
          }
          function $i(e3, i3, s2, a3, o2, r2) {
            const n3 = a3.paint.get("raster-fade-duration");
            if (!r2 && n3 > 0) {
              const a4 = t2.browser.now(), r3 = (a4 - e3.timeAdded) / n3, l2 = i3 ? (a4 - i3.timeAdded) / n3 : -1, c5 = s2.getSource(), h2 = o2.coveringZoomLevel({ tileSize: c5.tileSize, roundZoom: c5.roundZoom }), u2 = !i3 || Math.abs(i3.tileID.overscaledZ - h2) > Math.abs(e3.tileID.overscaledZ - h2), d3 = u2 && e3.refreshedUponExpiration ? 1 : t2.clamp(u2 ? r3 : 1 - l2, 0, 1);
              return e3.refreshedUponExpiration && r3 >= 1 && (e3.refreshedUponExpiration = false), i3 ? { opacity: 1, mix: 1 - d3 } : { opacity: d3, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const Xi = new t2.Color(1, 0, 0, 1), Wi = new t2.Color(0, 1, 0, 1), Hi = new t2.Color(0, 0, 1, 1), Ki = new t2.Color(1, 0, 1, 1), Yi = new t2.Color(0, 1, 1, 1);
          function Ji(t3, e3, i3, s2) {
            ts(t3, 0, e3 + i3 / 2, t3.transform.width, i3, s2);
          }
          function Qi(t3, e3, i3, s2) {
            ts(t3, e3 - i3 / 2, 0, i3, t3.transform.height, s2);
          }
          function ts(t3, e3, i3, s2, a3, o2) {
            const r2 = t3.context, n3 = r2.gl;
            n3.enable(n3.SCISSOR_TEST), n3.scissor(e3 * t3.pixelRatio, i3 * t3.pixelRatio, s2 * t3.pixelRatio, a3 * t3.pixelRatio), r2.clear({ color: o2 }), n3.disable(n3.SCISSOR_TEST);
          }
          function es(e3, i3, s2) {
            const a3 = e3.context, o2 = a3.gl, r2 = s2.posMatrix, n3 = e3.useProgram("debug"), l2 = Di.disabled, c5 = Mi.disabled, h2 = e3.colorModeForRenderPass(), u2 = "$debug", d3 = e3.style.map.terrain && e3.style.map.terrain.getTerrainData(s2);
            a3.activeTexture.set(o2.TEXTURE0);
            const _2 = i3.getTileByID(s2.key).latestRawTileData, m4 = Math.floor((_2 && _2.byteLength || 0) / 1024), p3 = i3.getTile(s2).tileSize, f2 = 512 / Math.min(p3, 512) * (s2.overscaledZ / e3.transform.zoom) * 0.5;
            let g3 = s2.canonical.toString();
            s2.overscaledZ !== s2.canonical.z && (g3 += ` => ${s2.overscaledZ}`), function(t3, e4) {
              t3.initDebugOverlayCanvas();
              const i4 = t3.debugOverlayCanvas, s3 = t3.context.gl, a4 = t3.debugOverlayCanvas.getContext("2d");
              a4.clearRect(0, 0, i4.width, i4.height), a4.shadowColor = "white", a4.shadowBlur = 2, a4.lineWidth = 1.5, a4.strokeStyle = "white", a4.textBaseline = "top", a4.font = "bold 36px Open Sans, sans-serif", a4.fillText(e4, 5, 5), a4.strokeText(e4, 5, 5), t3.debugOverlayTexture.update(i4), t3.debugOverlayTexture.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
            }(e3, `${g3} ${m4}kB`), n3.draw(a3, o2.TRIANGLES, l2, c5, Ci.alphaBlended, Ai.disabled, be(r2, t2.Color.transparent, f2), null, u2, e3.debugBuffer, e3.quadTriangleIndexBuffer, e3.debugSegments), n3.draw(a3, o2.LINE_STRIP, l2, c5, h2, Ai.disabled, be(r2, t2.Color.red), d3, u2, e3.debugBuffer, e3.tileBorderIndexBuffer, e3.debugSegments);
          }
          function is(t3, e3, i3) {
            const s2 = t3.context, a3 = s2.gl, o2 = t3.colorModeForRenderPass(), r2 = new Di(a3.LEQUAL, Di.ReadWrite, t3.depthRangeFor3D), n3 = t3.useProgram("terrain"), l2 = e3.getTerrainMesh();
            s2.bindFramebuffer.set(null), s2.viewport.set([0, 0, t3.width, t3.height]);
            for (const c5 of i3) {
              const i4 = t3.renderToTexture.getTexture(c5), h2 = e3.getTerrainData(c5.tileID);
              s2.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, i4.texture);
              const u2 = { u_matrix: t3.transform.calculatePosMatrix(c5.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e3.getMeshFrameDelta(t3.transform.zoom) };
              n3.draw(s2, a3.TRIANGLES, r2, Mi.disabled, o2, Ai.backCCW, u2, h2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
            }
          }
          class ss {
            constructor(e3, i3) {
              this.context = new Pi(e3), this.transform = i3, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t2.create(), renderTime: 0 }, this.setup(), this.numSublayers = Y.maxUnderzooming + Y.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Qt();
            }
            resize(t3, e3, i3) {
              if (this.width = Math.floor(t3 * i3), this.height = Math.floor(e3 * i3), this.pixelRatio = i3, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const t4 of this.style._order)
                  this.style._layers[t4].resize();
            }
            setup() {
              const e3 = this.context, i3 = new t2.PosArray();
              i3.emplaceBack(0, 0), i3.emplaceBack(t2.EXTENT, 0), i3.emplaceBack(0, t2.EXTENT), i3.emplaceBack(t2.EXTENT, t2.EXTENT), this.tileExtentBuffer = e3.createVertexBuffer(i3, oe.members), this.tileExtentSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2);
              const s2 = new t2.PosArray();
              s2.emplaceBack(0, 0), s2.emplaceBack(t2.EXTENT, 0), s2.emplaceBack(0, t2.EXTENT), s2.emplaceBack(t2.EXTENT, t2.EXTENT), this.debugBuffer = e3.createVertexBuffer(s2, oe.members), this.debugSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 5);
              const a3 = new t2.RasterBoundsArray();
              a3.emplaceBack(0, 0, 0, 0), a3.emplaceBack(t2.EXTENT, 0, t2.EXTENT, 0), a3.emplaceBack(0, t2.EXTENT, 0, t2.EXTENT), a3.emplaceBack(t2.EXTENT, t2.EXTENT, t2.EXTENT, t2.EXTENT), this.rasterBoundsBuffer = e3.createVertexBuffer(a3, O.members), this.rasterBoundsSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o2 = new t2.PosArray();
              o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = e3.createVertexBuffer(o2, oe.members), this.viewportSegments = t2.SegmentVector.simpleSegment(0, 0, 4, 2);
              const r2 = new t2.LineStripIndexArray();
              r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = e3.createIndexBuffer(r2);
              const n3 = new t2.TriangleIndexArray();
              n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e3.createIndexBuffer(n3);
              const l2 = this.context.gl;
              this.stencilClearMode = new Mi({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
            }
            clearStencil() {
              const e3 = this.context, i3 = e3.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const s2 = t2.create();
              t2.ortho(s2, 0, this.width, this.height, 0, 0, 1), t2.scale(s2, s2, [i3.drawingBufferWidth, i3.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e3, i3.TRIANGLES, Di.disabled, this.stencilClearMode, Ci.disabled, Ai.disabled, we(s2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(t3, e3) {
              if (this.currentStencilSource === t3.source || !t3.isTileClipped() || !e3 || !e3.length)
                return;
              this.currentStencilSource = t3.source;
              const i3 = this.context, s2 = i3.gl;
              this.nextStencilID + e3.length > 256 && this.clearStencil(), i3.setColorMode(Ci.disabled), i3.setDepthMode(Di.disabled);
              const a3 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const t4 of e3) {
                const e4 = this._tileClippingMaskIDs[t4.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t4);
                a3.draw(i3, s2.TRIANGLES, Di.disabled, new Mi({ func: s2.ALWAYS, mask: 0 }, e4, 255, s2.KEEP, s2.KEEP, s2.REPLACE), Ci.disabled, Ai.disabled, we(t4.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const t3 = this.nextStencilID++, e3 = this.context.gl;
              return new Mi({ func: e3.NOTEQUAL, mask: 255 }, t3, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
            }
            stencilModeForClipping(t3) {
              const e3 = this.context.gl;
              return new Mi({ func: e3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t3.key], 0, e3.KEEP, e3.KEEP, e3.REPLACE);
            }
            stencilConfigForOverlap(t3) {
              const e3 = this.context.gl, i3 = t3.sort((t4, e4) => e4.overscaledZ - t4.overscaledZ), s2 = i3[i3.length - 1].overscaledZ, a3 = i3[0].overscaledZ - s2 + 1;
              if (a3 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + a3 > 256 && this.clearStencil();
                const t4 = {};
                for (let i4 = 0; i4 < a3; i4++)
                  t4[i4 + s2] = new Mi({ func: e3.GEQUAL, mask: 255 }, i4 + this.nextStencilID, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
                return this.nextStencilID += a3, [t4, i3];
              }
              return [{ [s2]: Mi.disabled }, i3];
            }
            colorModeForRenderPass() {
              const e3 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i3 = 1 / 8;
                return new Ci([e3.CONSTANT_COLOR, e3.ONE], new t2.Color(i3, i3, i3, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? Ci.unblended : Ci.alphaBlended;
            }
            depthModeForSublayer(t3, e3, i3) {
              if (!this.opaquePassEnabledForLayer())
                return Di.disabled;
              const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t3) * this.depthEpsilon;
              return new Di(i3 || this.context.gl.LEQUAL, e3, [s2, s2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e3, i3) {
              this.style = e3, this.options = i3, this.lineAtlas = e3.lineAtlas, this.imageManager = e3.imageManager, this.glyphManager = e3.glyphManager, this.symbolFadeChange = e3.placement.symbolFadeChange(t2.browser.now()), this.imageManager.beginFrame();
              const s2 = this.style._order, a3 = this.style.sourceCaches, o2 = {}, r2 = {}, n3 = {};
              for (const t3 in a3) {
                const e4 = a3[t3];
                e4.used && e4.prepare(this.context), o2[t3] = e4.getVisibleCoordinates(), r2[t3] = o2[t3].slice().reverse(), n3[t3] = e4.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let t3 = 0; t3 < s2.length; t3++)
                if (this.style._layers[s2[t3]].is3D()) {
                  this.opaquePassCutoff = t3;
                  break;
                }
              if (this.renderToTexture) {
                this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
                const e4 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                (this.terrainFacilitator.dirty || !t2.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e4.length) && (t2.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e5, i4) {
                  const s3 = e5.context, a4 = s3.gl, o3 = Ci.unblended, r3 = new Di(a4.LEQUAL, Di.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l2 = i4.sourceCache.getRenderableTiles(), c5 = e5.useProgram("terrainDepth");
                  s3.bindFramebuffer.set(i4.getFramebuffer("depth").framebuffer), s3.viewport.set([0, 0, e5.width / devicePixelRatio, e5.height / devicePixelRatio]), s3.clear({ color: t2.Color.transparent, depth: 1 });
                  for (const t3 of l2) {
                    const l3 = i4.getTerrainData(t3.tileID), h2 = { u_matrix: e5.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_ele_delta: i4.getMeshFrameDelta(e5.transform.zoom) };
                    c5.draw(s3, a4.TRIANGLES, r3, Mi.disabled, o3, Ai.backCCW, h2, l3, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments);
                  }
                  s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, e5.width, e5.height]);
                }(this, this.style.map.terrain), function(e5, i4) {
                  const s3 = e5.context, a4 = s3.gl, o3 = Ci.unblended, r3 = new Di(a4.LEQUAL, Di.ReadWrite, [0, 1]), n4 = i4.getTerrainMesh(), l2 = i4.getCoordsTexture(), c5 = i4.sourceCache.getRenderableTiles(), h2 = e5.useProgram("terrainCoords");
                  s3.bindFramebuffer.set(i4.getFramebuffer("coords").framebuffer), s3.viewport.set([0, 0, e5.width / devicePixelRatio, e5.height / devicePixelRatio]), s3.clear({ color: t2.Color.transparent, depth: 1 }), i4.coordsIndex = [];
                  for (const t3 of c5) {
                    const c6 = i4.getTerrainData(t3.tileID);
                    s3.activeTexture.set(a4.TEXTURE0), a4.bindTexture(a4.TEXTURE_2D, l2.texture);
                    const u2 = { u_matrix: e5.transform.calculatePosMatrix(t3.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i4.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i4.getMeshFrameDelta(e5.transform.zoom) };
                    h2.draw(s3, a4.TRIANGLES, r3, Mi.disabled, o3, Ai.backCCW, u2, c6, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments), i4.coordsIndex.push(t3.tileID.key);
                  }
                  s3.bindFramebuffer.set(null), s3.viewport.set([0, 0, e5.width, e5.height]);
                }(this, this.style.map.terrain));
              }
              this.renderPass = "offscreen";
              for (const t3 of s2) {
                const e4 = this.style._layers[t3];
                if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom))
                  continue;
                const i4 = r2[e4.source];
                ("custom" === e4.type || i4.length) && this.renderLayer(this, a3[e4.source], e4, i4);
              }
              if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i3.showOverdrawInspector ? t2.Color.black : t2.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i3.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e3._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
                for (this.renderPass = "opaque", this.currentLayer = s2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const t3 = this.style._layers[s2[this.currentLayer]], e4 = a3[t3.source], i4 = o2[t3.source];
                  this._renderTileClippingMasks(t3, i4), this.renderLayer(this, e4, t3, i4);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s2.length; this.currentLayer++) {
                const t3 = this.style._layers[s2[this.currentLayer]], e4 = a3[t3.source];
                if (this.renderToTexture && this.renderToTexture.renderLayer(t3))
                  continue;
                const i4 = ("symbol" === t3.type ? n3 : r2)[t3.source];
                this._renderTileClippingMasks(t3, o2[t3.source]), this.renderLayer(this, e4, t3, i4);
              }
              if (this.options.showTileBoundaries) {
                const t3 = function(t4, e4) {
                  let i4 = null;
                  const s3 = Object.values(t4._layers).flatMap((i5) => i5.source && !i5.isHidden(e4) ? [t4.sourceCaches[i5.source]] : []), a4 = s3.filter((t5) => "vector" === t5.getSource().type), o3 = s3.filter((t5) => "vector" !== t5.getSource().type), r3 = (t5) => {
                    (!i4 || i4.getSource().maxzoom < t5.getSource().maxzoom) && (i4 = t5);
                  };
                  return a4.forEach((t5) => r3(t5)), i4 || o3.forEach((t5) => r3(t5)), i4;
                }(this.style, this.transform.zoom);
                t3 && function(t4, e4, i4) {
                  for (let s3 = 0; s3 < i4.length; s3++)
                    es(t4, e4, i4[s3]);
                }(this, t3, t3.getVisibleCoordinates());
              }
              this.options.showPadding && function(t3) {
                const e4 = t3.transform.padding;
                Ji(t3, t3.transform.height - (e4.top || 0), 3, Xi), Ji(t3, e4.bottom || 0, 3, Wi), Qi(t3, e4.left || 0, 3, Hi), Qi(t3, t3.transform.width - (e4.right || 0), 3, Ki);
                const i4 = t3.transform.centerPoint;
                !function(t4, e5, i5, s3) {
                  ts(t4, e5 - 1, i5 - 10, 2, 20, s3), ts(t4, e5 - 10, i5 - 1, 20, 2, s3);
                }(t3, i4.x, t3.transform.height - i4.y, Yi);
              }(this), this.context.setDefault();
            }
            renderLayer(e3, i3, s2, a3) {
              if (!s2.isHidden(this.transform.zoom) && ("background" === s2.type || "custom" === s2.type || (a3 || []).length))
                switch (this.id = s2.id, s2.type) {
                  case "symbol":
                    !function(e4, i4, s3, a4, o2) {
                      if ("translucent" !== e4.renderPass)
                        return;
                      const r2 = Mi.disabled, n3 = e4.colorModeForRenderPass();
                      s3.layout.get("text-variable-anchor") && function(e5, i5, s4, a5, o3, r3, n4) {
                        const l2 = i5.transform, c5 = "map" === o3, h2 = "map" === r3;
                        for (const o4 of e5) {
                          const e6 = a5.getTile(o4), r4 = e6.getBucket(s4);
                          if (!r4 || !r4.text || !r4.text.segments.get().length)
                            continue;
                          const u2 = t2.evaluateSizeForZoom(r4.textSizeData, l2.zoom), d3 = Ct(e6, 1, i5.transform.zoom), _2 = lt(o4.posMatrix, h2, c5, i5.transform, d3), m4 = "none" !== s4.layout.get("icon-text-fit") && r4.hasIconData();
                          if (u2) {
                            const t3 = Math.pow(2, l2.zoom - e6.tileID.overscaledZ);
                            Fi(r4, c5, h2, n4, l2, _2, o4.posMatrix, t3, u2, m4, i5.style.map.terrain ? (t4, e7) => i5.style.map.terrain.getElevation(o4, t4, e7) : null);
                          }
                        }
                      }(a4, e4, s3, i4, s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), o2), 0 !== s3.paint.get("icon-opacity").constantOr(1) && Oi(e4, i4, s3, a4, false, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), s3.layout.get("icon-rotation-alignment"), s3.layout.get("icon-pitch-alignment"), s3.layout.get("icon-keep-upright"), r2, n3), 0 !== s3.paint.get("text-opacity").constantOr(1) && Oi(e4, i4, s3, a4, true, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), s3.layout.get("text-rotation-alignment"), s3.layout.get("text-pitch-alignment"), s3.layout.get("text-keep-upright"), r2, n3), i4.map.showCollisionBoxes && (Ri(e4, i4, s3, a4, s3.paint.get("text-translate"), s3.paint.get("text-translate-anchor"), true), Ri(e4, i4, s3, a4, s3.paint.get("icon-translate"), s3.paint.get("icon-translate-anchor"), false));
                    }(e3, i3, s2, a3, this.style.placement.variableOffsets);
                    break;
                  case "circle":
                    !function(e4, i4, s3, a4) {
                      if ("translucent" !== e4.renderPass)
                        return;
                      const o2 = s3.paint.get("circle-opacity"), r2 = s3.paint.get("circle-stroke-width"), n3 = s3.paint.get("circle-stroke-opacity"), l2 = !s3.layout.get("circle-sort-key").isConstant();
                      if (0 === o2.constantOr(1) && (0 === r2.constantOr(1) || 0 === n3.constantOr(1)))
                        return;
                      const c5 = e4.context, h2 = c5.gl, u2 = e4.depthModeForSublayer(0, Di.ReadOnly), d3 = Mi.disabled, _2 = e4.colorModeForRenderPass(), m4 = [];
                      for (let o3 = 0; o3 < a4.length; o3++) {
                        const r3 = a4[o3], n4 = i4.getTile(r3), c6 = n4.getBucket(s3);
                        if (!c6)
                          continue;
                        const h3 = c6.programConfigurations.get(s3.id), u3 = e4.useProgram("circle", h3), d4 = c6.layoutVertexBuffer, _3 = c6.indexBuffer, p3 = e4.style.map.terrain && e4.style.map.terrain.getTerrainData(r3), f2 = { programConfiguration: h3, program: u3, layoutVertexBuffer: d4, indexBuffer: _3, uniformValues: xe(e4, r3, n4, s3), terrainData: p3 };
                        if (l2) {
                          const e5 = c6.segments.get();
                          for (const i5 of e5)
                            m4.push({ segments: new t2.SegmentVector([i5]), sortKey: i5.sortKey, state: f2 });
                        } else
                          m4.push({ segments: c6.segments, sortKey: 0, state: f2 });
                      }
                      l2 && m4.sort((t3, e5) => t3.sortKey - e5.sortKey);
                      for (const t3 of m4) {
                        const { programConfiguration: i5, program: a5, layoutVertexBuffer: o3, indexBuffer: r3, uniformValues: n4, terrainData: l3 } = t3.state;
                        a5.draw(c5, h2.TRIANGLES, u2, d3, _2, Ai.disabled, n4, l3, s3.id, o3, r3, t3.segments, s3.paint, e4.transform.zoom, i5);
                      }
                    }(e3, i3, s2, a3);
                    break;
                  case "heatmap":
                    !function(e4, i4, s3, a4) {
                      if (0 !== s3.paint.get("heatmap-opacity"))
                        if ("offscreen" === e4.renderPass) {
                          const o2 = e4.context, r2 = o2.gl, n3 = Mi.disabled, l2 = new Ci([r2.ONE, r2.ONE], t2.Color.transparent, [true, true, true, true]);
                          !function(t3, e5, i5) {
                            const s4 = t3.gl;
                            t3.activeTexture.set(s4.TEXTURE1), t3.viewport.set([0, 0, e5.width / 4, e5.height / 4]);
                            let a5 = i5.heatmapFbo;
                            if (a5)
                              s4.bindTexture(s4.TEXTURE_2D, a5.colorAttachment.get()), t3.bindFramebuffer.set(a5.framebuffer);
                            else {
                              const o3 = s4.createTexture();
                              s4.bindTexture(s4.TEXTURE_2D, o3), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_S, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_WRAP_T, s4.CLAMP_TO_EDGE), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MIN_FILTER, s4.LINEAR), s4.texParameteri(s4.TEXTURE_2D, s4.TEXTURE_MAG_FILTER, s4.LINEAR), a5 = i5.heatmapFbo = t3.createFramebuffer(e5.width / 4, e5.height / 4, false, false), function(t4, e6, i6, s5) {
                                var a6, o4;
                                const r3 = t4.gl, n4 = null !== (a6 = t4.HALF_FLOAT) && void 0 !== a6 ? a6 : r3.UNSIGNED_BYTE, l3 = null !== (o4 = t4.RGBA16F) && void 0 !== o4 ? o4 : r3.RGBA;
                                r3.texImage2D(r3.TEXTURE_2D, 0, l3, e6.width / 4, e6.height / 4, 0, r3.RGBA, n4, null), s5.colorAttachment.set(i6);
                              }(t3, e5, o3, a5);
                            }
                          }(o2, e4, s3), o2.clear({ color: t2.Color.transparent });
                          for (let t3 = 0; t3 < a4.length; t3++) {
                            const c5 = a4[t3];
                            if (i4.hasRenderableParent(c5))
                              continue;
                            const h2 = i4.getTile(c5), u2 = h2.getBucket(s3);
                            if (!u2)
                              continue;
                            const d3 = u2.programConfigurations.get(s3.id), _2 = e4.useProgram("heatmap", d3), { zoom: m4 } = e4.transform;
                            _2.draw(o2, r2.TRIANGLES, Di.disabled, n3, l2, Ai.disabled, Te(c5.posMatrix, h2, m4, s3.paint.get("heatmap-intensity")), null, s3.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, s3.paint, e4.transform.zoom, d3);
                          }
                          o2.viewport.set([0, 0, e4.width, e4.height]);
                        } else
                          "translucent" === e4.renderPass && (e4.context.setColorMode(e4.colorModeForRenderPass()), function(e5, i5) {
                            const s4 = e5.context, a5 = s4.gl, o2 = i5.heatmapFbo;
                            if (!o2)
                              return;
                            s4.activeTexture.set(a5.TEXTURE0), a5.bindTexture(a5.TEXTURE_2D, o2.colorAttachment.get()), s4.activeTexture.set(a5.TEXTURE1);
                            let r2 = i5.colorRampTexture;
                            r2 || (r2 = i5.colorRampTexture = new x(s4, i5.colorRamp, a5.RGBA)), r2.bind(a5.LINEAR, a5.CLAMP_TO_EDGE), e5.useProgram("heatmapTexture").draw(s4, a5.TRIANGLES, Di.disabled, Mi.disabled, e5.colorModeForRenderPass(), Ai.disabled, ((e6, i6, s5, a6) => {
                              const o3 = t2.create();
                              t2.ortho(o3, 0, e6.width, e6.height, 0, 0, 1);
                              const r3 = e6.context.gl;
                              return { u_matrix: o3, u_world: [r3.drawingBufferWidth, r3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i6.paint.get("heatmap-opacity") };
                            })(e5, i5), null, i5.id, e5.viewportBuffer, e5.quadTriangleIndexBuffer, e5.viewportSegments, i5.paint, e5.transform.zoom);
                          }(e4, s3));
                    }(e3, i3, s2, a3);
                    break;
                  case "line":
                    !function(e4, i4, s3, a4) {
                      if ("translucent" !== e4.renderPass)
                        return;
                      const o2 = s3.paint.get("line-opacity"), r2 = s3.paint.get("line-width");
                      if (0 === o2.constantOr(1) || 0 === r2.constantOr(1))
                        return;
                      const n3 = e4.depthModeForSublayer(0, Di.ReadOnly), l2 = e4.colorModeForRenderPass(), c5 = s3.paint.get("line-dasharray"), h2 = s3.paint.get("line-pattern"), u2 = h2.constantOr(1), d3 = s3.paint.get("line-gradient"), _2 = s3.getCrossfadeParameters(), m4 = u2 ? "linePattern" : c5 ? "lineSDF" : d3 ? "lineGradient" : "line", p3 = e4.context, f2 = p3.gl;
                      let g3 = true;
                      for (const o3 of a4) {
                        const a5 = i4.getTile(o3);
                        if (u2 && !a5.patternsLoaded())
                          continue;
                        const r3 = a5.getBucket(s3);
                        if (!r3)
                          continue;
                        const v2 = r3.programConfigurations.get(s3.id), y2 = e4.context.program.get(), b3 = e4.useProgram(m4, v2), w2 = g3 || b3.program !== y2, T2 = e4.style.map.terrain && e4.style.map.terrain.getTerrainData(o3), E2 = h2.constantOr(null);
                        if (E2 && a5.imageAtlas) {
                          const t3 = a5.imageAtlas, e5 = t3.patternPositions[E2.to.toString()], i5 = t3.patternPositions[E2.from.toString()];
                          e5 && i5 && v2.setConstantPatternPositions(e5, i5);
                        }
                        const I2 = T2 ? o3 : null, S2 = u2 ? Ce(e4, a5, s3, _2, I2) : c5 ? Pe(e4, a5, s3, c5, _2, I2) : d3 ? Se(e4, a5, s3, r3.lineClipsArray.length, I2) : Ie(e4, a5, s3, I2);
                        if (u2)
                          p3.activeTexture.set(f2.TEXTURE0), a5.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
                        else if (c5 && (w2 || e4.lineAtlas.dirty))
                          p3.activeTexture.set(f2.TEXTURE0), e4.lineAtlas.bind(p3);
                        else if (d3) {
                          const a6 = r3.gradients[s3.id];
                          let n4 = a6.texture;
                          if (s3.gradientVersion !== a6.version) {
                            let l3 = 256;
                            if (s3.stepInterpolant) {
                              const s4 = i4.getSource().maxzoom, a7 = o3.canonical.z === s4 ? Math.ceil(1 << e4.transform.maxZoom - o3.canonical.z) : 1;
                              l3 = t2.clamp(t2.nextPowerOfTwo(r3.maxLineLength / t2.EXTENT * 1024 * a7), 256, p3.maxTextureSize);
                            }
                            a6.gradient = t2.renderColorRamp({ expression: s3.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: a6.gradient || void 0, clips: r3.lineClipsArray }), a6.texture ? a6.texture.update(a6.gradient) : a6.texture = new x(p3, a6.gradient, f2.RGBA), a6.version = s3.gradientVersion, n4 = a6.texture;
                          }
                          p3.activeTexture.set(f2.TEXTURE0), n4.bind(s3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                        }
                        b3.draw(p3, f2.TRIANGLES, n3, e4.stencilModeForClipping(o3), l2, Ai.disabled, S2, T2, s3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, s3.paint, e4.transform.zoom, v2, r3.layoutVertexBuffer2), g3 = false;
                      }
                    }(e3, i3, s2, a3);
                    break;
                  case "fill":
                    !function(e4, i4, s3, a4) {
                      const o2 = s3.paint.get("fill-color"), r2 = s3.paint.get("fill-opacity");
                      if (0 === r2.constantOr(1))
                        return;
                      const n3 = e4.colorModeForRenderPass(), l2 = s3.paint.get("fill-pattern"), c5 = e4.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === o2.constantOr(t2.Color.transparent).a && 1 === r2.constantOr(0) ? "opaque" : "translucent";
                      if (e4.renderPass === c5) {
                        const t3 = e4.depthModeForSublayer(1, "opaque" === e4.renderPass ? Di.ReadWrite : Di.ReadOnly);
                        Zi(e4, i4, s3, a4, t3, n3, false);
                      }
                      if ("translucent" === e4.renderPass && s3.paint.get("fill-antialias")) {
                        const t3 = e4.depthModeForSublayer(s3.getPaintProperty("fill-outline-color") ? 2 : 0, Di.ReadOnly);
                        Zi(e4, i4, s3, a4, t3, n3, true);
                      }
                    }(e3, i3, s2, a3);
                    break;
                  case "fill-extrusion":
                    !function(t3, e4, i4, s3) {
                      const a4 = i4.paint.get("fill-extrusion-opacity");
                      if (0 !== a4 && "translucent" === t3.renderPass) {
                        const o2 = new Di(t3.context.gl.LEQUAL, Di.ReadWrite, t3.depthRangeFor3D);
                        if (1 !== a4 || i4.paint.get("fill-extrusion-pattern").constantOr(1))
                          Vi(t3, e4, i4, s3, o2, Mi.disabled, Ci.disabled), Vi(t3, e4, i4, s3, o2, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                        else {
                          const a5 = t3.colorModeForRenderPass();
                          Vi(t3, e4, i4, s3, o2, Mi.disabled, a5);
                        }
                      }
                    }(e3, i3, s2, a3);
                    break;
                  case "hillshade":
                    !function(t3, e4, i4, s3) {
                      if ("offscreen" !== t3.renderPass && "translucent" !== t3.renderPass)
                        return;
                      const a4 = t3.context, o2 = t3.depthModeForSublayer(0, Di.ReadOnly), r2 = t3.colorModeForRenderPass(), [n3, l2] = "translucent" === t3.renderPass ? t3.stencilConfigForOverlap(s3) : [{}, s3];
                      for (const s4 of l2) {
                        const a5 = e4.getTile(s4);
                        void 0 !== a5.needsHillshadePrepare && a5.needsHillshadePrepare && "offscreen" === t3.renderPass ? ji(t3, a5, i4, o2, Mi.disabled, r2) : "translucent" === t3.renderPass && qi(t3, s4, a5, i4, o2, n3[s4.overscaledZ], r2);
                      }
                      a4.viewport.set([0, 0, t3.width, t3.height]);
                    }(e3, i3, s2, a3);
                    break;
                  case "raster":
                    !function(t3, e4, i4, s3) {
                      if ("translucent" !== t3.renderPass)
                        return;
                      if (0 === i4.paint.get("raster-opacity"))
                        return;
                      if (!s3.length)
                        return;
                      const a4 = t3.context, o2 = a4.gl, r2 = e4.getSource(), n3 = t3.useProgram("raster"), l2 = t3.colorModeForRenderPass(), [c5, h2] = r2 instanceof N ? [{}, s3] : t3.stencilConfigForOverlap(s3), u2 = h2[h2.length - 1].overscaledZ, d3 = !t3.options.moving;
                      for (const s4 of h2) {
                        const h3 = t3.depthModeForSublayer(s4.overscaledZ - u2, 1 === i4.paint.get("raster-opacity") ? Di.ReadWrite : Di.ReadOnly, o2.LESS), _2 = e4.getTile(s4);
                        _2.registerFadeDuration(i4.paint.get("raster-fade-duration"));
                        const m4 = e4.findLoadedParent(s4, 0), p3 = $i(_2, m4, e4, i4, t3.transform, t3.style.map.terrain);
                        let f2, g3;
                        const v2 = "nearest" === i4.paint.get("raster-resampling") ? o2.NEAREST : o2.LINEAR;
                        a4.activeTexture.set(o2.TEXTURE0), _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), a4.activeTexture.set(o2.TEXTURE1), m4 ? (m4.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, m4.tileID.overscaledZ - _2.tileID.overscaledZ), g3 = [_2.tileID.canonical.x * f2 % 1, _2.tileID.canonical.y * f2 % 1]) : _2.texture.bind(v2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST);
                        const x2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(s4), y2 = x2 ? s4 : null, b3 = y2 ? y2.posMatrix : t3.transform.calculatePosMatrix(s4.toUnwrapped(), d3), w2 = Me(b3, g3 || [0, 0], f2 || 1, p3, i4);
                        r2 instanceof N ? n3.draw(a4, o2.TRIANGLES, h3, Mi.disabled, l2, Ai.disabled, w2, x2, i4.id, r2.boundsBuffer, t3.quadTriangleIndexBuffer, r2.boundsSegments) : n3.draw(a4, o2.TRIANGLES, h3, c5[s4.overscaledZ], l2, Ai.disabled, w2, x2, i4.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                      }
                    }(e3, i3, s2, a3);
                    break;
                  case "background":
                    !function(t3, e4, i4, s3) {
                      const a4 = i4.paint.get("background-color"), o2 = i4.paint.get("background-opacity");
                      if (0 === o2)
                        return;
                      const r2 = t3.context, n3 = r2.gl, l2 = t3.transform, c5 = l2.tileSize, h2 = i4.paint.get("background-pattern");
                      if (t3.isPatternMissing(h2))
                        return;
                      const u2 = !h2 && 1 === a4.a && 1 === o2 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                      if (t3.renderPass !== u2)
                        return;
                      const d3 = Mi.disabled, _2 = t3.depthModeForSublayer(0, "opaque" === u2 ? Di.ReadWrite : Di.ReadOnly), m4 = t3.colorModeForRenderPass(), p3 = t3.useProgram(h2 ? "backgroundPattern" : "background"), f2 = s3 || l2.coveringTiles({ tileSize: c5, terrain: t3.style.map.terrain });
                      h2 && (r2.activeTexture.set(n3.TEXTURE0), t3.imageManager.bind(t3.context));
                      const g3 = i4.getCrossfadeParameters();
                      for (const e5 of f2) {
                        const l3 = s3 ? e5.posMatrix : t3.transform.calculatePosMatrix(e5.toUnwrapped()), u3 = h2 ? Fe(l3, o2, t3, h2, { tileID: e5, tileSize: c5 }, g3) : Be(l3, o2, a4), f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e5);
                        p3.draw(r2, n3.TRIANGLES, _2, d3, m4, Ai.disabled, u3, f3, i4.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                      }
                    }(e3, 0, s2, a3);
                    break;
                  case "custom":
                    !function(t3, e4, i4) {
                      const s3 = t3.context, a4 = i4.implementation;
                      if ("offscreen" === t3.renderPass) {
                        const e5 = a4.prerender;
                        e5 && (t3.setCustomLayerDefaults(), s3.setColorMode(t3.colorModeForRenderPass()), e5.call(a4, s3.gl, t3.transform.customLayerMatrix()), s3.setDirty(), t3.setBaseState());
                      } else if ("translucent" === t3.renderPass) {
                        t3.setCustomLayerDefaults(), s3.setColorMode(t3.colorModeForRenderPass()), s3.setStencilMode(Mi.disabled);
                        const e5 = "3d" === a4.renderingMode ? new Di(t3.context.gl.LEQUAL, Di.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Di.ReadOnly);
                        s3.setDepthMode(e5), a4.render(s3.gl, t3.transform.customLayerMatrix()), s3.setDirty(), t3.setBaseState(), s3.bindFramebuffer.set(null);
                      }
                    }(e3, 0, s2);
                }
            }
            translatePosMatrix(e3, i3, s2, a3, o2) {
              if (!s2[0] && !s2[1])
                return e3;
              const r2 = o2 ? "map" === a3 ? this.transform.angle : 0 : "viewport" === a3 ? -this.transform.angle : 0;
              if (r2) {
                const t3 = Math.sin(r2), e4 = Math.cos(r2);
                s2 = [s2[0] * e4 - s2[1] * t3, s2[0] * t3 + s2[1] * e4];
              }
              const n3 = [o2 ? s2[0] : Ct(i3, s2[0], this.transform.zoom), o2 ? s2[1] : Ct(i3, s2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return t2.translate(l2, e3, n3), l2;
            }
            saveTileTexture(t3) {
              const e3 = this._tileTextures[t3.size[0]];
              e3 ? e3.push(t3) : this._tileTextures[t3.size[0]] = [t3];
            }
            getTileTexture(t3) {
              const e3 = this._tileTextures[t3];
              return e3 && e3.length > 0 ? e3.pop() : null;
            }
            isPatternMissing(t3) {
              if (!t3)
                return false;
              if (!t3.from || !t3.to)
                return true;
              const e3 = this.imageManager.getPattern(t3.from.toString()), i3 = this.imageManager.getPattern(t3.to.toString());
              return !e3 || !i3;
            }
            useProgram(t3, e3) {
              this.cache = this.cache || {};
              const i3 = t3 + (e3 ? e3.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
              return this.cache[i3] || (this.cache[i3] = new ue(this.context, t3, ne[t3], e3, Ue[t3], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i3];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const t3 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t3.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new x(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
            overLimit() {
              const { drawingBufferWidth: t3, drawingBufferHeight: e3 } = this.context.gl;
              return this.width !== t3 || this.height !== e3;
            }
          }
          class as {
            constructor(t3, e3) {
              this.points = t3, this.planes = e3;
            }
            static fromInvProjectionMatrix(e3, i3, s2) {
              const a3 = Math.pow(2, s2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s3) => {
                const o3 = 1 / (s3 = t2.transformMat4([], s3, e3))[3] / i3 * a3;
                return t2.mul$1(s3, s3, [o3, o3, 1 / s3[3], o3]);
              }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
                const e4 = function(t4, e5) {
                  var i5 = e5[0], s4 = e5[1], a5 = e5[2], o3 = i5 * i5 + s4 * s4 + a5 * a5;
                  return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t4[0] = e5[0] * o3, t4[1] = e5[1] * o3, t4[2] = e5[2] * o3, t4;
                }([], function(t4, e5, i5) {
                  var s4 = e5[0], a5 = e5[1], o3 = e5[2], r3 = i5[0], n3 = i5[1], l2 = i5[2];
                  return t4[0] = a5 * l2 - o3 * n3, t4[1] = o3 * r3 - s4 * l2, t4[2] = s4 * n3 - a5 * r3, t4;
                }([], p2([], o2[t3[0]], o2[t3[1]]), p2([], o2[t3[2]], o2[t3[1]]))), i4 = -((s3 = e4)[0] * (a4 = o2[t3[1]])[0] + s3[1] * a4[1] + s3[2] * a4[2]);
                var s3, a4;
                return e4.concat(i4);
              });
              return new as(o2, r2);
            }
          }
          class os {
            constructor(t3, e3) {
              this.min = t3, this.max = e3, this.center = function(t4, e4, i3) {
                return t4[0] = 0.5 * e4[0], t4[1] = 0.5 * e4[1], t4[2] = 0.5 * e4[2], t4;
              }([], function(t4, e4, i3) {
                return t4[0] = e4[0] + i3[0], t4[1] = e4[1] + i3[1], t4[2] = e4[2] + i3[2], t4;
              }([], this.min, this.max));
            }
            quadrant(t3) {
              const e3 = [t3 % 2 == 0, t3 < 2], i3 = _(this.min), s2 = _(this.max);
              for (let t4 = 0; t4 < e3.length; t4++)
                i3[t4] = e3[t4] ? this.min[t4] : this.center[t4], s2[t4] = e3[t4] ? this.center[t4] : this.max[t4];
              return s2[2] = this.max[2], new os(i3, s2);
            }
            distanceX(t3) {
              return Math.max(Math.min(this.max[0], t3[0]), this.min[0]) - t3[0];
            }
            distanceY(t3) {
              return Math.max(Math.min(this.max[1], t3[1]), this.min[1]) - t3[1];
            }
            intersects(e3) {
              const i3 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
              let s2 = true;
              for (let a3 = 0; a3 < e3.planes.length; a3++) {
                const o2 = e3.planes[a3];
                let r2 = 0;
                for (let e4 = 0; e4 < i3.length; e4++)
                  t2.dot(o2, i3[e4]) >= 0 && r2++;
                if (0 === r2)
                  return 0;
                r2 !== i3.length && (s2 = false);
              }
              if (s2)
                return 2;
              for (let t3 = 0; t3 < 3; t3++) {
                let i4 = Number.MAX_VALUE, s3 = -Number.MAX_VALUE;
                for (let a3 = 0; a3 < e3.points.length; a3++) {
                  const o2 = e3.points[a3][t3] - this.min[t3];
                  i4 = Math.min(i4, o2), s3 = Math.max(s3, o2);
                }
                if (s3 < 0 || i4 > this.max[t3] - this.min[t3])
                  return 0;
              }
              return 1;
            }
          }
          class rs {
            constructor(t3 = 0, e3 = 0, i3 = 0, s2 = 0) {
              if (isNaN(t3) || t3 < 0 || isNaN(e3) || e3 < 0 || isNaN(i3) || i3 < 0 || isNaN(s2) || s2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = t3, this.bottom = e3, this.left = i3, this.right = s2;
            }
            interpolate(e3, i3, s2) {
              return null != i3.top && null != e3.top && (this.top = t2.interpolate.number(e3.top, i3.top, s2)), null != i3.bottom && null != e3.bottom && (this.bottom = t2.interpolate.number(e3.bottom, i3.bottom, s2)), null != i3.left && null != e3.left && (this.left = t2.interpolate.number(e3.left, i3.left, s2)), null != i3.right && null != e3.right && (this.right = t2.interpolate.number(e3.right, i3.right, s2)), this;
            }
            getCenter(e3, i3) {
              const s2 = t2.clamp((this.left + e3 - this.right) / 2, 0, e3), a3 = t2.clamp((this.top + i3 - this.bottom) / 2, 0, i3);
              return new t2.Point(s2, a3);
            }
            equals(t3) {
              return this.top === t3.top && this.bottom === t3.bottom && this.left === t3.left && this.right === t3.right;
            }
            clone() {
              return new rs(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          class ns {
            constructor(e3, i3, s2, a3, o2) {
              this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = false, this._renderWorldCopies = void 0 === o2 || !!o2, this._minZoom = e3 || 0, this._maxZoom = i3 || 22, this._minPitch = null == s2 ? 0 : s2, this._maxPitch = null == a3 ? 60 : a3, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t2.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new rs(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            clone() {
              const t3 = new ns(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
              return t3.apply(this), t3;
            }
            apply(t3) {
              this.tileSize = t3.tileSize, this.latRange = t3.latRange, this.width = t3.width, this.height = t3.height, this._center = t3._center, this._elevation = t3._elevation, this.zoom = t3.zoom, this.angle = t3.angle, this._fov = t3._fov, this._pitch = t3._pitch, this._unmodified = t3._unmodified, this._edgeInsets = t3._edgeInsets.clone(), this._calcMatrices();
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(t3) {
              this._minZoom !== t3 && (this._minZoom = t3, this.zoom = Math.max(this.zoom, t3));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(t3) {
              this._maxZoom !== t3 && (this._maxZoom = t3, this.zoom = Math.min(this.zoom, t3));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(t3) {
              this._minPitch !== t3 && (this._minPitch = t3, this.pitch = Math.max(this.pitch, t3));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(t3) {
              this._maxPitch !== t3 && (this._maxPitch = t3, this.pitch = Math.min(this.pitch, t3));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            set renderWorldCopies(t3) {
              void 0 === t3 ? t3 = true : null === t3 && (t3 = false), this._renderWorldCopies = t3;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t2.Point(this.width, this.height);
            }
            get bearing() {
              return -this.angle / Math.PI * 180;
            }
            set bearing(e3) {
              const i3 = -t2.wrap(e3, -180, 180) * Math.PI / 180;
              this.angle !== i3 && (this._unmodified = false, this.angle = i3, this._calcMatrices(), this.rotationMatrix = function() {
                var e4 = new t2.ARRAY_TYPE(4);
                return t2.ARRAY_TYPE != Float32Array && (e4[1] = 0, e4[2] = 0), e4[0] = 1, e4[3] = 1, e4;
              }(), function(t3, e4, i4) {
                var s2 = e4[0], a3 = e4[1], o2 = e4[2], r2 = e4[3], n3 = Math.sin(i4), l2 = Math.cos(i4);
                t3[0] = s2 * l2 + o2 * n3, t3[1] = a3 * l2 + r2 * n3, t3[2] = s2 * -n3 + o2 * l2, t3[3] = a3 * -n3 + r2 * l2;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(e3) {
              const i3 = t2.clamp(e3, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i3 && (this._unmodified = false, this._pitch = i3, this._calcMatrices());
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t3) {
              t3 = Math.max(0.01, Math.min(60, t3)), this._fov !== t3 && (this._unmodified = false, this._fov = t3 / 180 * Math.PI, this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(t3) {
              const e3 = Math.min(Math.max(t3, this.minZoom), this.maxZoom);
              this._zoom !== e3 && (this._unmodified = false, this._zoom = e3, this.tileZoom = Math.max(0, Math.floor(e3)), this.scale = this.zoomScale(e3), this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            set center(t3) {
              t3.lat === this._center.lat && t3.lng === this._center.lng || (this._unmodified = false, this._center = t3, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(t3) {
              t3 !== this._elevation && (this._elevation = t3, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(t3) {
              this._edgeInsets.equals(t3) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t3, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            isPaddingEqual(t3) {
              return this._edgeInsets.equals(t3);
            }
            interpolatePadding(t3, e3, i3) {
              this._unmodified = false, this._edgeInsets.interpolate(t3, e3, i3), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t3) {
              const e3 = (t3.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t3.tileSize));
              return Math.max(0, e3);
            }
            getVisibleUnwrappedCoordinates(e3) {
              const i3 = [new t2.UnwrappedTileID(0, e3)];
              if (this._renderWorldCopies) {
                const s2 = this.pointCoordinate(new t2.Point(0, 0)), a3 = this.pointCoordinate(new t2.Point(this.width, 0)), o2 = this.pointCoordinate(new t2.Point(this.width, this.height)), r2 = this.pointCoordinate(new t2.Point(0, this.height)), n3 = Math.floor(Math.min(s2.x, a3.x, o2.x, r2.x)), l2 = Math.floor(Math.max(s2.x, a3.x, o2.x, r2.x)), c5 = 1;
                for (let s3 = n3 - c5; s3 <= l2 + c5; s3++)
                  0 !== s3 && i3.push(new t2.UnwrappedTileID(s3, e3));
              }
              return i3;
            }
            coveringTiles(e3) {
              var i3, s2;
              let a3 = this.coveringZoomLevel(e3);
              const o2 = a3;
              if (void 0 !== e3.minzoom && a3 < e3.minzoom)
                return [];
              void 0 !== e3.maxzoom && a3 > e3.maxzoom && (a3 = e3.maxzoom);
              const r2 = this.pointCoordinate(this.getCameraPoint()), n3 = t2.MercatorCoordinate.fromLngLat(this.center), l2 = Math.pow(2, a3), c5 = [l2 * r2.x, l2 * r2.y, 0], h2 = [l2 * n3.x, l2 * n3.y, 0], u2 = as.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a3);
              let d3 = e3.minzoom || 0;
              !e3.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d3 = a3);
              const _2 = e3.terrain ? 2 / Math.min(this.tileSize, e3.tileSize) * this.tileSize : 3, m4 = (t3) => ({ aabb: new os([t3 * l2, 0, 0], [(t3 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), p3 = [], g3 = [], v2 = a3, x2 = e3.reparseOverscaled ? o2 : a3;
              if (this._renderWorldCopies)
                for (let t3 = 1; t3 <= 3; t3++)
                  p3.push(m4(-t3)), p3.push(m4(t3));
              for (p3.push(m4(0)); p3.length > 0; ) {
                const a4 = p3.pop(), o3 = a4.x, r3 = a4.y;
                let n4 = a4.fullyVisible;
                if (!n4) {
                  const t3 = a4.aabb.intersects(u2);
                  if (0 === t3)
                    continue;
                  n4 = 2 === t3;
                }
                const l3 = e3.terrain ? c5 : h2, m5 = a4.aabb.distanceX(l3), y2 = a4.aabb.distanceY(l3), b3 = Math.max(Math.abs(m5), Math.abs(y2));
                if (a4.zoom === v2 || b3 > _2 + (1 << v2 - a4.zoom) - 2 && a4.zoom >= d3) {
                  const e4 = v2 - a4.zoom, i4 = c5[0] - 0.5 - (o3 << e4), s3 = c5[1] - 0.5 - (r3 << e4);
                  g3.push({ tileID: new t2.OverscaledTileID(a4.zoom === v2 ? x2 : a4.zoom, a4.wrap, a4.zoom, o3, r3), distanceSq: f([h2[0] - 0.5 - o3, h2[1] - 0.5 - r3]), tileDistanceToCamera: Math.sqrt(i4 * i4 + s3 * s3) });
                } else
                  for (let l4 = 0; l4 < 4; l4++) {
                    const c6 = (o3 << 1) + l4 % 2, h3 = (r3 << 1) + (l4 >> 1), u3 = a4.zoom + 1;
                    let d4 = a4.aabb.quadrant(l4);
                    if (e3.terrain) {
                      const o4 = new t2.OverscaledTileID(u3, a4.wrap, u3, c6, h3), r4 = e3.terrain.getMinMaxElevation(o4), n5 = null !== (i3 = r4.minElevation) && void 0 !== i3 ? i3 : this.elevation, l5 = null !== (s2 = r4.maxElevation) && void 0 !== s2 ? s2 : this.elevation;
                      d4 = new os([d4.min[0], d4.min[1], n5], [d4.max[0], d4.max[1], l5]);
                    }
                    p3.push({ aabb: d4, zoom: u3, x: c6, y: h3, wrap: a4.wrap, fullyVisible: n4 });
                  }
              }
              return g3.sort((t3, e4) => t3.distanceSq - e4.distanceSq).map((t3) => t3.tileID);
            }
            resize(t3, e3) {
              this.width = t3, this.height = e3, this.pixelsToGLUnits = [2 / t3, -2 / e3], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(t3) {
              return Math.pow(2, t3);
            }
            scaleZoom(t3) {
              return Math.log(t3) / Math.LN2;
            }
            project(e3) {
              const i3 = t2.clamp(e3.lat, -this.maxValidLatitude, this.maxValidLatitude);
              return new t2.Point(t2.mercatorXfromLng(e3.lng) * this.worldSize, t2.mercatorYfromLat(i3) * this.worldSize);
            }
            unproject(e3) {
              return new t2.MercatorCoordinate(e3.x / this.worldSize, e3.y / this.worldSize).toLngLat();
            }
            get point() {
              return this.project(this.center);
            }
            updateElevation(t3) {
              this.freezeElevation || (this.elevation = t3 ? this.getElevation(this._center, t3) : 0);
            }
            getElevation(e3, i3) {
              const s2 = t2.MercatorCoordinate.fromLngLat(e3.wrap()), a3 = (1 << this.tileZoom) * t2.EXTENT, o2 = s2.x * a3, r2 = s2.y * a3, n3 = Math.floor(o2 / t2.EXTENT), l2 = Math.floor(r2 / t2.EXTENT), c5 = new t2.OverscaledTileID(this.tileZoom, 0, this.tileZoom, n3, l2);
              return i3.getElevation(c5, o2 % t2.EXTENT, r2 % t2.EXTENT, t2.EXTENT);
            }
            getCameraPosition() {
              return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
            }
            recalculateZoom(e3) {
              const i3 = this.pointLocation(this.centerPoint, e3), s2 = this.getElevation(i3, e3);
              if (!(this.elevation - s2))
                return;
              const a3 = this.getCameraPosition(), o2 = t2.MercatorCoordinate.fromLngLat(a3.lngLat, a3.altitude), r2 = t2.MercatorCoordinate.fromLngLat(i3, s2), n3 = o2.x - r2.x, l2 = o2.y - r2.y, c5 = o2.z - r2.z, h2 = Math.sqrt(n3 * n3 + l2 * l2 + c5 * c5), u2 = this.scaleZoom(this.cameraToCenterDistance / h2 / this.tileSize);
              this._elevation = s2, this._center = i3, this.zoom = u2;
            }
            setLocationAtPoint(e3, i3) {
              const s2 = this.pointCoordinate(i3), a3 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(e3), r2 = new t2.MercatorCoordinate(o2.x - (s2.x - a3.x), o2.y - (s2.y - a3.y));
              this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t3, e3) {
              return e3 ? this.coordinatePoint(this.locationCoordinate(t3), this.getElevation(t3, e3), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t3));
            }
            pointLocation(t3, e3) {
              return this.coordinateLocation(this.pointCoordinate(t3, e3));
            }
            locationCoordinate(e3) {
              return t2.MercatorCoordinate.fromLngLat(e3);
            }
            coordinateLocation(t3) {
              return t3 && t3.toLngLat();
            }
            pointCoordinate(e3, i3) {
              if (i3) {
                const t3 = i3.pointCoordinate(e3);
                if (null != t3)
                  return t3;
              }
              const s2 = [e3.x, e3.y, 0, 1], a3 = [e3.x, e3.y, 1, 1];
              t2.transformMat4(s2, s2, this.pixelMatrixInverse), t2.transformMat4(a3, a3, this.pixelMatrixInverse);
              const o2 = s2[3], r2 = a3[3], n3 = s2[1] / o2, l2 = a3[1] / r2, c5 = s2[2] / o2, h2 = a3[2] / r2, u2 = c5 === h2 ? 0 : (0 - c5) / (h2 - c5);
              return new t2.MercatorCoordinate(t2.interpolate.number(s2[0] / o2, a3[0] / r2, u2) / this.worldSize, t2.interpolate.number(n3, l2, u2) / this.worldSize);
            }
            coordinatePoint(e3, i3 = 0, s2 = this.pixelMatrix) {
              const a3 = [e3.x * this.worldSize, e3.y * this.worldSize, i3, 1];
              return t2.transformMat4(a3, a3, s2), new t2.Point(a3[0] / a3[3], a3[1] / a3[3]);
            }
            getBounds() {
              const e3 = Math.max(0, this.height / 2 - this.getHorizon());
              return new L().extend(this.pointLocation(new t2.Point(0, e3))).extend(this.pointLocation(new t2.Point(this.width, e3))).extend(this.pointLocation(new t2.Point(this.width, this.height))).extend(this.pointLocation(new t2.Point(0, this.height)));
            }
            getMaxBounds() {
              return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new L([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
            }
            getHorizon() {
              return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
            }
            setMaxBounds(t3) {
              t3 ? (this.lngRange = [t3.getWest(), t3.getEast()], this.latRange = [t3.getSouth(), t3.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
            }
            calculatePosMatrix(e3, i3 = false) {
              const s2 = e3.key, a3 = i3 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (a3[s2])
                return a3[s2];
              const o2 = e3.canonical, r2 = this.worldSize / this.zoomScale(o2.z), n3 = o2.x + Math.pow(2, o2.z) * e3.wrap, l2 = t2.identity(new Float64Array(16));
              return t2.translate(l2, l2, [n3 * r2, o2.y * r2, 0]), t2.scale(l2, l2, [r2 / t2.EXTENT, r2 / t2.EXTENT, 1]), t2.multiply(l2, i3 ? this.alignedProjMatrix : this.projMatrix, l2), a3[s2] = new Float32Array(l2), a3[s2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              let e3, i3, s2, a3, o2 = -90, r2 = 90, n3 = -180, l2 = 180;
              const c5 = this.size, h2 = this._unmodified;
              if (this.latRange) {
                const i4 = this.latRange;
                o2 = t2.mercatorYfromLat(i4[1]) * this.worldSize, r2 = t2.mercatorYfromLat(i4[0]) * this.worldSize, e3 = r2 - o2 < c5.y ? c5.y / (r2 - o2) : 0;
              }
              if (this.lngRange) {
                const e4 = this.lngRange;
                n3 = t2.wrap(t2.mercatorXfromLng(e4[0]) * this.worldSize, 0, this.worldSize), l2 = t2.wrap(t2.mercatorXfromLng(e4[1]) * this.worldSize, 0, this.worldSize), l2 < n3 && (l2 += this.worldSize), i3 = l2 - n3 < c5.x ? c5.x / (l2 - n3) : 0;
              }
              const u2 = this.point, d3 = Math.max(i3 || 0, e3 || 0);
              if (d3)
                return this.center = this.unproject(new t2.Point(i3 ? (l2 + n3) / 2 : u2.x, e3 ? (r2 + o2) / 2 : u2.y)), this.zoom += this.scaleZoom(d3), this._unmodified = h2, void (this._constraining = false);
              if (this.latRange) {
                const t3 = u2.y, e4 = c5.y / 2;
                t3 - e4 < o2 && (a3 = o2 + e4), t3 + e4 > r2 && (a3 = r2 - e4);
              }
              if (this.lngRange) {
                const e4 = (n3 + l2) / 2, i4 = t2.wrap(u2.x, e4 - this.worldSize / 2, e4 + this.worldSize / 2), a4 = c5.x / 2;
                i4 - a4 < n3 && (s2 = n3 + a4), i4 + a4 > l2 && (s2 = l2 - a4);
              }
              void 0 === s2 && void 0 === a3 || (this.center = this.unproject(new t2.Point(void 0 !== s2 ? s2 : u2.x, void 0 !== a3 ? a3 : u2.y)).wrap()), this._unmodified = h2, this._constraining = false;
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const e3 = this.centerOffset, i3 = this.point.x, s2 = this.point.y;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t2.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
              let a3 = t2.identity(new Float64Array(16));
              t2.scale(a3, a3, [this.width / 2, -this.height / 2, 1]), t2.translate(a3, a3, [1, -1, 0]), this.labelPlaneMatrix = a3, a3 = t2.identity(new Float64Array(16)), t2.scale(a3, a3, [1, -1, 1]), t2.translate(a3, a3, [-1, -1, 0]), t2.scale(a3, a3, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a3, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
              const o2 = this._elevation < 0 ? this.cameraToCenterDistance : this.cameraToSeaLevelDistance, r2 = Math.PI / 2 + this._pitch, n3 = this._fov * (0.5 + e3.y / this.height), l2 = Math.sin(n3) * o2 / Math.sin(t2.clamp(Math.PI - r2 - n3, 0.01, Math.PI - 0.01)), c5 = this.getHorizon(), h2 = 2 * Math.atan(c5 / this.cameraToCenterDistance) * (0.5 + e3.y / (2 * c5)), u2 = Math.sin(h2) * o2 / Math.sin(t2.clamp(Math.PI - r2 - h2, 0.01, Math.PI - 0.01)), d3 = Math.min(l2, u2), _2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * d3 + o2), m4 = this.height / 50;
              a3 = new Float64Array(16), t2.perspective(a3, this._fov, this.width / this.height, m4, _2), a3[8] = 2 * -e3.x / this.width, a3[9] = 2 * e3.y / this.height, t2.scale(a3, a3, [1, -1, 1]), t2.translate(a3, a3, [0, 0, -this.cameraToCenterDistance]), t2.rotateX(a3, a3, this._pitch), t2.rotateZ(a3, a3, this.angle), t2.translate(a3, a3, [-i3, -s2, 0]), this.mercatorMatrix = t2.scale([], a3, [this.worldSize, this.worldSize, this.worldSize]), t2.scale(a3, a3, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t2.multiply(new Float64Array(16), this.labelPlaneMatrix, a3), t2.translate(a3, a3, [0, 0, -this.elevation]), this.projMatrix = a3, this.invProjMatrix = t2.invert([], a3), this.pixelMatrix3D = t2.multiply(new Float64Array(16), this.labelPlaneMatrix, a3);
              const p3 = this.width % 2 / 2, f2 = this.height % 2 / 2, g3 = Math.cos(this.angle), v2 = Math.sin(this.angle), x2 = i3 - Math.round(i3) + g3 * p3 + v2 * f2, y2 = s2 - Math.round(s2) + g3 * f2 + v2 * p3, b3 = new Float64Array(a3);
              if (t2.translate(b3, b3, [x2 > 0.5 ? x2 - 1 : x2, y2 > 0.5 ? y2 - 1 : y2, 0]), this.alignedProjMatrix = b3, a3 = t2.invert(new Float64Array(16), this.pixelMatrix), !a3)
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = a3, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            maxPitchScaleFactor() {
              if (!this.pixelMatrixInverse)
                return 1;
              const e3 = this.pointCoordinate(new t2.Point(0, 0)), i3 = [e3.x * this.worldSize, e3.y * this.worldSize, 0, 1];
              return t2.transformMat4(i3, i3, this.pixelMatrix)[3] / this.cameraToCenterDistance;
            }
            getCameraPoint() {
              const e3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t2.Point(0, e3));
            }
            getCameraQueryGeometry(e3) {
              const i3 = this.getCameraPoint();
              if (1 === e3.length)
                return [e3[0], i3];
              {
                let s2 = i3.x, a3 = i3.y, o2 = i3.x, r2 = i3.y;
                for (const t3 of e3)
                  s2 = Math.min(s2, t3.x), a3 = Math.min(a3, t3.y), o2 = Math.max(o2, t3.x), r2 = Math.max(r2, t3.y);
                return [new t2.Point(s2, a3), new t2.Point(o2, a3), new t2.Point(o2, r2), new t2.Point(s2, r2), new t2.Point(s2, a3)];
              }
            }
          }
          class ls {
            constructor(t3) {
              this._getCurrentHash = () => {
                const t4 = window.location.hash.replace("#", "");
                if (this._hashName) {
                  let e3;
                  return t4.split("&").map((t5) => t5.split("=")).forEach((t5) => {
                    t5[0] === this._hashName && (e3 = t5);
                  }), (e3 && e3[1] || "").split("/");
                }
                return t4.split("/");
              }, this._onHashChange = () => {
                const t4 = this._getCurrentHash();
                if (t4.length >= 3 && !t4.some((t5) => isNaN(t5))) {
                  const e3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t4[3] || 0) : this._map.getBearing();
                  return this._map.jumpTo({ center: [+t4[2], +t4[1]], zoom: +t4[0], bearing: e3, pitch: +(t4[4] || 0) }), true;
                }
                return false;
              }, this._updateHashUnthrottled = () => {
                const t4 = window.location.href.replace(/(#.+)?$/, this.getHashString());
                try {
                  window.history.replaceState(window.history.state, null, t4);
                } catch (t5) {
                }
              }, this._updateHash = function(t4, e3) {
                let i3 = false, s2 = null;
                const a3 = () => {
                  s2 = null, i3 && (t4(), s2 = setTimeout(a3, 300), i3 = false);
                };
                return () => (i3 = true, s2 || a3(), s2);
              }(this._updateHashUnthrottled), this._hashName = t3 && encodeURIComponent(t3);
            }
            addTo(t3) {
              return this._map = t3, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(t3) {
              const e3 = this._map.getCenter(), i3 = Math.round(100 * this._map.getZoom()) / 100, s2 = Math.ceil((i3 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a3 = Math.pow(10, s2), o2 = Math.round(e3.lng * a3) / a3, r2 = Math.round(e3.lat * a3) / a3, n3 = this._map.getBearing(), l2 = this._map.getPitch();
              let c5 = "";
              if (c5 += t3 ? `/${o2}/${r2}/${i3}` : `${i3}/${r2}/${o2}`, (n3 || l2) && (c5 += "/" + Math.round(10 * n3) / 10), l2 && (c5 += `/${Math.round(l2)}`), this._hashName) {
                const t4 = this._hashName;
                let e4 = false;
                const i4 = window.location.hash.slice(1).split("&").map((i5) => {
                  const s3 = i5.split("=")[0];
                  return s3 === t4 ? (e4 = true, `${s3}=${c5}`) : i5;
                }).filter((t5) => t5);
                return e4 || i4.push(`${t4}=${c5}`), `#${i4.join("&")}`;
              }
              return `#${c5}`;
            }
          }
          const cs = { linearity: 0.3, easing: t2.bezier(0, 0, 0.3, 1) }, hs = t2.extend({ deceleration: 2500, maxSpeed: 1400 }, cs), us = t2.extend({ deceleration: 20, maxSpeed: 1400 }, cs), ds = t2.extend({ deceleration: 1e3, maxSpeed: 360 }, cs), _s = t2.extend({ deceleration: 1e3, maxSpeed: 90 }, cs);
          class ms {
            constructor(t3) {
              this._map = t3, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e3) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t2.browser.now(), settings: e3 });
            }
            _drainInertiaBuffer() {
              const e3 = this._inertiaBuffer, i3 = t2.browser.now();
              for (; e3.length > 0 && i3 - e3[0].time > 160; )
                e3.shift();
            }
            _onMoveEnd(e3) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i3 = { zoom: 0, bearing: 0, pitch: 0, pan: new t2.Point(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: t3 } of this._inertiaBuffer)
                i3.zoom += t3.zoomDelta || 0, i3.bearing += t3.bearingDelta || 0, i3.pitch += t3.pitchDelta || 0, t3.panDelta && i3.pan._add(t3.panDelta), t3.around && (i3.around = t3.around), t3.pinchAround && (i3.pinchAround = t3.pinchAround);
              const s2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a3 = {};
              if (i3.pan.mag()) {
                const o2 = fs(i3.pan.mag(), s2, t2.extend({}, hs, e3 || {}));
                a3.offset = i3.pan.mult(o2.amount / i3.pan.mag()), a3.center = this._map.transform.center, ps(a3, o2);
              }
              if (i3.zoom) {
                const t3 = fs(i3.zoom, s2, us);
                a3.zoom = this._map.transform.zoom + t3.amount, ps(a3, t3);
              }
              if (i3.bearing) {
                const e4 = fs(i3.bearing, s2, ds);
                a3.bearing = this._map.transform.bearing + t2.clamp(e4.amount, -179, 179), ps(a3, e4);
              }
              if (i3.pitch) {
                const t3 = fs(i3.pitch, s2, _s);
                a3.pitch = this._map.transform.pitch + t3.amount, ps(a3, t3);
              }
              if (a3.zoom || a3.bearing) {
                const t3 = void 0 === i3.pinchAround ? i3.around : i3.pinchAround;
                a3.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
              }
              return this.clear(), t2.extend(a3, { noMoveStart: true });
            }
          }
          function ps(t3, e3) {
            (!t3.duration || t3.duration < e3.duration) && (t3.duration = e3.duration, t3.easing = e3.easing);
          }
          function fs(e3, i3, s2) {
            const { maxSpeed: a3, linearity: o2, deceleration: r2 } = s2, n3 = t2.clamp(e3 * o2 / (i3 / 1e3), -a3, a3), l2 = Math.abs(n3) / (r2 * o2);
            return { easing: s2.easing, duration: 1e3 * l2, amount: n3 * (l2 / 2) };
          }
          class gs extends t2.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e3, s2, a3, o2 = {}) {
              const r2 = i2.mousePos(s2.getCanvasContainer(), a3), n3 = s2.unproject(r2);
              super(e3, t2.extend({ point: r2, lngLat: n3, originalEvent: a3 }, o2)), this._defaultPrevented = false, this.target = s2;
            }
          }
          class vs extends t2.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e3, s2, a3) {
              const o2 = "touchend" === e3 ? a3.changedTouches : a3.touches, r2 = i2.touchPos(s2.getCanvasContainer(), o2), n3 = r2.map((t3) => s2.unproject(t3)), l2 = r2.reduce((t3, e4, i3, s3) => t3.add(e4.div(s3.length)), new t2.Point(0, 0));
              super(e3, { points: r2, point: l2, lngLats: n3, lngLat: s2.unproject(l2), originalEvent: a3 }), this._defaultPrevented = false;
            }
          }
          class xs extends t2.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t3, e3, i3) {
              super(t3, { originalEvent: i3 }), this._defaultPrevented = false;
            }
          }
          class ys {
            constructor(t3, e3) {
              this._map = t3, this._clickTolerance = e3.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(t3) {
              return this._firePreventable(new xs(t3.type, this._map, t3));
            }
            mousedown(t3, e3) {
              return this._mousedownPos = e3, this._firePreventable(new gs(t3.type, this._map, t3));
            }
            mouseup(t3) {
              this._map.fire(new gs(t3.type, this._map, t3));
            }
            click(t3, e3) {
              this._mousedownPos && this._mousedownPos.dist(e3) >= this._clickTolerance || this._map.fire(new gs(t3.type, this._map, t3));
            }
            dblclick(t3) {
              return this._firePreventable(new gs(t3.type, this._map, t3));
            }
            mouseover(t3) {
              this._map.fire(new gs(t3.type, this._map, t3));
            }
            mouseout(t3) {
              this._map.fire(new gs(t3.type, this._map, t3));
            }
            touchstart(t3) {
              return this._firePreventable(new vs(t3.type, this._map, t3));
            }
            touchmove(t3) {
              this._map.fire(new vs(t3.type, this._map, t3));
            }
            touchend(t3) {
              this._map.fire(new vs(t3.type, this._map, t3));
            }
            touchcancel(t3) {
              this._map.fire(new vs(t3.type, this._map, t3));
            }
            _firePreventable(t3) {
              if (this._map.fire(t3), t3.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class bs {
            constructor(t3) {
              this._map = t3;
            }
            reset() {
              this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
            }
            mousemove(t3) {
              this._map.fire(new gs(t3.type, this._map, t3));
            }
            mousedown() {
              this._delayContextMenu = true, this._ignoreContextMenu = false;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t3) {
              this._delayContextMenu ? this._contextMenuEvent = t3 : this._ignoreContextMenu || this._map.fire(new gs(t3.type, this._map, t3)), this._map.listens("contextmenu") && t3.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class ws {
            constructor(t3) {
              this._map = t3;
            }
            get transform() {
              return this._map._requestedCameraState || this._map.transform;
            }
            get center() {
              return { lng: this.transform.center.lng, lat: this.transform.center.lat };
            }
            get zoom() {
              return this.transform.zoom;
            }
            get pitch() {
              return this.transform.pitch;
            }
            get bearing() {
              return this.transform.bearing;
            }
            unproject(e3) {
              return this.transform.pointLocation(t2.Point.convert(e3), this._map.terrain);
            }
          }
          class Ts {
            constructor(t3, e3) {
              this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._container = t3.getContainer(), this._clickTolerance = e3.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(t3, e3) {
              this.isEnabled() && t3.shiftKey && 0 === t3.button && (i2.disableDrag(), this._startPos = this._lastPos = e3, this._active = true);
            }
            mousemoveWindow(t3, e3) {
              if (!this._active)
                return;
              const s2 = e3;
              if (this._lastPos.equals(s2) || !this._box && s2.dist(this._startPos) < this._clickTolerance)
                return;
              const a3 = this._startPos;
              this._lastPos = s2, this._box || (this._box = i2.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t3));
              const o2 = Math.min(a3.x, s2.x), r2 = Math.max(a3.x, s2.x), n3 = Math.min(a3.y, s2.y), l2 = Math.max(a3.y, s2.y);
              i2.setTransform(this._box, `translate(${o2}px,${n3}px)`), this._box.style.width = r2 - o2 + "px", this._box.style.height = l2 - n3 + "px";
            }
            mouseupWindow(e3, s2) {
              if (!this._active)
                return;
              if (0 !== e3.button)
                return;
              const a3 = this._startPos, o2 = s2;
              if (this.reset(), i2.suppressClick(), a3.x !== o2.x || a3.y !== o2.y)
                return this._map.fire(new t2.Event("boxzoomend", { originalEvent: e3 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(a3, o2, this._tr.bearing, { linear: true }) };
              this._fireEvent("boxzoomcancel", e3);
            }
            keydown(t3) {
              this._active && 27 === t3.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t3));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (i2.remove(this._box), this._box = null), i2.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e3, i3) {
              return this._map.fire(new t2.Event(e3, { originalEvent: i3 }));
            }
          }
          function Es(t3, e3) {
            if (t3.length !== e3.length)
              throw new Error(`The number of touches and points are not equal - touches ${t3.length}, points ${e3.length}`);
            const i3 = {};
            for (let s2 = 0; s2 < t3.length; s2++)
              i3[t3[s2].identifier] = e3[s2];
            return i3;
          }
          class Is {
            constructor(t3) {
              this.reset(), this.numTouches = t3.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e3, i3, s2) {
              (this.centroid || s2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e3.timeStamp), s2.length === this.numTouches && (this.centroid = function(e4) {
                const i4 = new t2.Point(0, 0);
                for (const t3 of e4)
                  i4._add(t3);
                return i4.div(e4.length);
              }(i3), this.touches = Es(s2, i3)));
            }
            touchmove(t3, e3, i3) {
              if (this.aborted || !this.centroid)
                return;
              const s2 = Es(i3, e3);
              for (const t4 in this.touches) {
                const e4 = s2[t4];
                (!e4 || e4.dist(this.touches[t4]) > 30) && (this.aborted = true);
              }
            }
            touchend(t3, e3, i3) {
              if ((!this.centroid || t3.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i3.length) {
                const t4 = !this.aborted && this.centroid;
                if (this.reset(), t4)
                  return t4;
              }
            }
          }
          class Ss {
            constructor(t3) {
              this.singleTap = new Is(t3), this.numTaps = t3.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t3, e3, i3) {
              this.singleTap.touchstart(t3, e3, i3);
            }
            touchmove(t3, e3, i3) {
              this.singleTap.touchmove(t3, e3, i3);
            }
            touchend(t3, e3, i3) {
              const s2 = this.singleTap.touchend(t3, e3, i3);
              if (s2) {
                const e4 = t3.timeStamp - this.lastTime < 500, i4 = !this.lastTap || this.lastTap.dist(s2) < 30;
                if (e4 && i4 || this.reset(), this.count++, this.lastTime = t3.timeStamp, this.lastTap = s2, this.count === this.numTaps)
                  return this.reset(), s2;
              }
            }
          }
          class Cs {
            constructor(t3) {
              this._tr = new ws(t3), this._zoomIn = new Ss({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ss({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t3, e3, i3) {
              this._zoomIn.touchstart(t3, e3, i3), this._zoomOut.touchstart(t3, e3, i3);
            }
            touchmove(t3, e3, i3) {
              this._zoomIn.touchmove(t3, e3, i3), this._zoomOut.touchmove(t3, e3, i3);
            }
            touchend(t3, e3, i3) {
              const s2 = this._zoomIn.touchend(t3, e3, i3), a3 = this._zoomOut.touchend(t3, e3, i3), o2 = this._tr;
              return s2 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(s2) }, { originalEvent: t3 }) }) : a3 ? (this._active = true, t3.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(a3) }, { originalEvent: t3 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ps {
            constructor(t3) {
              this._enabled = !!t3.enable, this._moveStateManager = t3.moveStateManager, this._clickTolerance = t3.clickTolerance || 1, this._moveFunction = t3.move, this._activateOnStart = !!t3.activateOnStart, t3.assignEvents(this), this.reset();
            }
            reset(t3) {
              this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t3);
            }
            _move(...t3) {
              const e3 = this._moveFunction(...t3);
              if (e3.bearingDelta || e3.pitchDelta || e3.around || e3.panDelta)
                return this._active = true, e3;
            }
            dragStart(t3, e3) {
              this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t3) && (this._moveStateManager.startMove(t3), this._lastPoint = e3.length ? e3[0] : e3, this._activateOnStart && this._lastPoint && (this._active = true));
            }
            dragMove(t3, e3) {
              if (!this.isEnabled())
                return;
              const i3 = this._lastPoint;
              if (!i3)
                return;
              if (t3.preventDefault(), !this._moveStateManager.isValidMoveEvent(t3))
                return void this.reset(t3);
              const s2 = e3.length ? e3[0] : e3;
              return !this._moved && s2.dist(i3) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s2, this._move(i3, s2));
            }
            dragEnd(t3) {
              this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t3) && (this._moved && i2.suppressClick(), this.reset(t3));
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            getClickTolerance() {
              return this._clickTolerance;
            }
          }
          const Ds = { 0: 1, 2: 2 };
          class zs {
            constructor(t3) {
              this._correctEvent = t3.checkCorrectEvent;
            }
            startMove(t3) {
              const e3 = i2.mouseButton(t3);
              this._eventButton = e3;
            }
            endMove(t3) {
              delete this._eventButton;
            }
            isValidStartEvent(t3) {
              return this._correctEvent(t3);
            }
            isValidMoveEvent(t3) {
              return !function(t4, e3) {
                const i3 = Ds[e3];
                return void 0 === t4.buttons || (t4.buttons & i3) !== i3;
              }(t3, this._eventButton);
            }
            isValidEndEvent(t3) {
              return i2.mouseButton(t3) === this._eventButton;
            }
          }
          class Ms {
            constructor() {
              this._firstTouch = void 0;
            }
            _isOneFingerTouch(t3) {
              return 1 === t3.targetTouches.length;
            }
            _isSameTouchEvent(t3) {
              return t3.targetTouches[0].identifier === this._firstTouch;
            }
            startMove(t3) {
              this._firstTouch = t3.targetTouches[0].identifier;
            }
            endMove(t3) {
              delete this._firstTouch;
            }
            isValidStartEvent(t3) {
              return this._isOneFingerTouch(t3);
            }
            isValidMoveEvent(t3) {
              return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
            }
            isValidEndEvent(t3) {
              return this._isOneFingerTouch(t3) && this._isSameTouchEvent(t3);
            }
          }
          const As = (t3) => {
            t3.mousedown = t3.dragStart, t3.mousemoveWindow = t3.dragMove, t3.mouseup = t3.dragEnd, t3.contextmenu = function(t4) {
              t4.preventDefault();
            };
          }, Ls = ({ enable: t3, clickTolerance: e3, bearingDegreesPerPixelMoved: s2 = 0.8 }) => {
            const a3 = new zs({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
            return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ bearingDelta: (e4.x - t4.x) * s2 }), moveStateManager: a3, enable: t3, assignEvents: As });
          }, Rs = ({ enable: t3, clickTolerance: e3, pitchDegreesPerPixelMoved: s2 = -0.5 }) => {
            const a3 = new zs({ checkCorrectEvent: (t4) => 0 === i2.mouseButton(t4) && t4.ctrlKey || 2 === i2.mouseButton(t4) });
            return new Ps({ clickTolerance: e3, move: (t4, e4) => ({ pitchDelta: (e4.y - t4.y) * s2 }), moveStateManager: a3, enable: t3, assignEvents: As });
          };
          class ks {
            constructor(t3, e3) {
              this._minTouches = t3.cooperativeGestures ? 2 : 1, this._clickTolerance = t3.clickTolerance || 1, this._map = e3, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t2.Point(0, 0), setTimeout(() => {
                this._cancelCooperativeMessage = false;
              }, 200);
            }
            touchstart(t3, e3, i3) {
              return this._calculateTransform(t3, e3, i3);
            }
            touchmove(t3, e3, i3) {
              if (this._map._cooperativeGestures && (2 === this._minTouches && i3.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t3, false, i3.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i3.length < this._minTouches))
                return t3.preventDefault(), this._calculateTransform(t3, e3, i3);
            }
            touchend(t3, e3, i3) {
              this._calculateTransform(t3, e3, i3), this._active && i3.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e3, i3, s2) {
              s2.length > 0 && (this._active = true);
              const a3 = Es(s2, i3), o2 = new t2.Point(0, 0), r2 = new t2.Point(0, 0);
              let n3 = 0;
              for (const t3 in a3) {
                const e4 = a3[t3], i4 = this._touches[t3];
                i4 && (o2._add(e4), r2._add(e4.sub(i4)), n3++, a3[t3] = e4);
              }
              if (this._touches = a3, n3 < this._minTouches || !r2.mag())
                return;
              const l2 = r2.div(n3);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: o2.div(n3), panDelta: l2 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Bs {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            touchstart(t3, e3, i3) {
              this._firstTwoTouches || i3.length < 2 || (this._firstTwoTouches = [i3[0].identifier, i3[1].identifier], this._start([e3[0], e3[1]]));
            }
            touchmove(t3, e3, i3) {
              if (!this._firstTwoTouches)
                return;
              t3.preventDefault();
              const [s2, a3] = this._firstTwoTouches, o2 = Fs(i3, e3, s2), r2 = Fs(i3, e3, a3);
              if (!o2 || !r2)
                return;
              const n3 = this._aroundCenter ? null : o2.add(r2).div(2);
              return this._move([o2, r2], n3, t3);
            }
            touchend(t3, e3, s2) {
              if (!this._firstTwoTouches)
                return;
              const [a3, o2] = this._firstTwoTouches, r2 = Fs(s2, e3, a3), n3 = Fs(s2, e3, o2);
              r2 && n3 || (this._active && i2.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(t3) {
              this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Fs(t3, e3, i3) {
            for (let s2 = 0; s2 < t3.length; s2++)
              if (t3[s2].identifier === i3)
                return e3[s2];
          }
          function Us(t3, e3) {
            return Math.log(t3 / e3) / Math.LN2;
          }
          class Os extends Bs {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t3) {
              this._startDistance = this._distance = t3[0].dist(t3[1]);
            }
            _move(t3, e3) {
              const i3 = this._distance;
              if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(Us(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Us(this._distance, i3), pinchAround: e3 };
            }
          }
          function Ns(t3, e3) {
            return 180 * t3.angleWith(e3) / Math.PI;
          }
          class Gs extends Bs {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t3) {
              this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
            }
            _move(t3, e3) {
              const i3 = this._vector;
              if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: Ns(this._vector, i3), pinchAround: e3 };
            }
            _isBelowThreshold(t3) {
              this._minDiameter = Math.min(this._minDiameter, t3.mag());
              const e3 = 25 / (Math.PI * this._minDiameter) * 360, i3 = Ns(t3, this._startVector);
              return Math.abs(i3) < e3;
            }
          }
          function Zs(t3) {
            return Math.abs(t3.y) > Math.abs(t3.x);
          }
          class Vs extends Bs {
            constructor(t3) {
              super(), this._map = t3;
            }
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(t3, e3, i3) {
              super.touchstart(t3, e3, i3), this._currentTouchCount = i3.length;
            }
            _start(t3) {
              this._lastPoints = t3, Zs(t3[0].sub(t3[1])) && (this._valid = false);
            }
            _move(t3, e3, i3) {
              if (this._map._cooperativeGestures && this._currentTouchCount < 3)
                return;
              const s2 = t3[0].sub(this._lastPoints[0]), a3 = t3[1].sub(this._lastPoints[1]);
              return this._valid = this.gestureBeginsVertically(s2, a3, i3.timeStamp), this._valid ? (this._lastPoints = t3, this._active = true, { pitchDelta: (s2.y + a3.y) / 2 * -0.5 }) : void 0;
            }
            gestureBeginsVertically(t3, e3, i3) {
              if (void 0 !== this._valid)
                return this._valid;
              const s2 = t3.mag() >= 2, a3 = e3.mag() >= 2;
              if (!s2 && !a3)
                return;
              if (!s2 || !a3)
                return void 0 === this._firstMove && (this._firstMove = i3), i3 - this._firstMove < 100 && void 0;
              const o2 = t3.y > 0 == e3.y > 0;
              return Zs(t3) && Zs(e3) && o2;
            }
          }
          const qs = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class js {
            constructor(t3) {
              this._tr = new ws(t3);
              const e3 = qs;
              this._panStep = e3.panStep, this._bearingStep = e3.bearingStep, this._pitchStep = e3.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(t3) {
              if (t3.altKey || t3.ctrlKey || t3.metaKey)
                return;
              let e3 = 0, i3 = 0, s2 = 0, a3 = 0, o2 = 0;
              switch (t3.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  e3 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  e3 = -1;
                  break;
                case 37:
                  t3.shiftKey ? i3 = -1 : (t3.preventDefault(), a3 = -1);
                  break;
                case 39:
                  t3.shiftKey ? i3 = 1 : (t3.preventDefault(), a3 = 1);
                  break;
                case 38:
                  t3.shiftKey ? s2 = 1 : (t3.preventDefault(), o2 = -1);
                  break;
                case 40:
                  t3.shiftKey ? s2 = -1 : (t3.preventDefault(), o2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i3 = 0, s2 = 0), { cameraAnimation: (r2) => {
                const n3 = this._tr;
                r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $s, zoom: e3 ? Math.round(n3.zoom) + e3 * (t3.shiftKey ? 2 : 1) : n3.zoom, bearing: n3.bearing + i3 * this._bearingStep, pitch: n3.pitch + s2 * this._pitchStep, offset: [-a3 * this._panStep, -o2 * this._panStep], center: n3.center }, { originalEvent: t3 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function $s(t3) {
            return t3 * (2 - t3);
          }
          const Xs = 4.000244140625;
          class Ws {
            constructor(t3, e3) {
              this._onTimeout = (t4) => {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t4);
              }, this._map = t3, this._tr = new ws(t3), this._el = t3.getCanvasContainer(), this._triggerRenderFrame = e3, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
            }
            setZoomRate(t3) {
              this._defaultZoomRate = t3;
            }
            setWheelZoomRate(t3) {
              this._wheelZoomRate = t3;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(t3) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t3 && "center" === t3.around);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            wheel(e3) {
              if (!this.isEnabled())
                return;
              if (this._map._cooperativeGestures) {
                if (!e3[this._map._metaKey])
                  return;
                e3.preventDefault();
              }
              let i3 = e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e3.deltaY : e3.deltaY;
              const s2 = t2.browser.now(), a3 = s2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = s2, 0 !== i3 && i3 % Xs == 0 ? this._type = "wheel" : 0 !== i3 && Math.abs(i3) < 4 ? this._type = "trackpad" : a3 > 400 ? (this._type = null, this._lastValue = i3, this._timeout = setTimeout(this._onTimeout, 40, e3)) : this._type || (this._type = Math.abs(a3 * i3) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i3 += this._lastValue)), e3.shiftKey && i3 && (i3 /= 4), this._type && (this._lastWheelEvent = e3, this._delta -= i3, this._active || this._start(e3)), e3.preventDefault();
            }
            _start(e3) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const s2 = i2.mousePos(this._el, e3), a3 = this._tr;
              this._around = t2.LngLat.convert(this._aroundCenter ? a3.center : a3.unproject(s2)), this._aroundPoint = a3.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const e3 = this._tr.transform;
              if (0 !== this._delta) {
                const t3 = "wheel" === this._type && Math.abs(this._delta) > Xs ? this._wheelZoomRate : this._defaultZoomRate;
                let i4 = 2 / (1 + Math.exp(-Math.abs(this._delta * t3)));
                this._delta < 0 && 0 !== i4 && (i4 = 1 / i4);
                const s3 = "number" == typeof this._targetZoom ? e3.zoomScale(this._targetZoom) : e3.scale;
                this._targetZoom = Math.min(e3.maxZoom, Math.max(e3.minZoom, e3.scaleZoom(s3 * i4))), "wheel" === this._type && (this._startZoom = e3.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i3 = "number" == typeof this._targetZoom ? this._targetZoom : e3.zoom, s2 = this._startZoom, a3 = this._easing;
              let o2, r2 = false;
              if ("wheel" === this._type && s2 && a3) {
                const e4 = Math.min((t2.browser.now() - this._lastWheelEventTime) / 200, 1), n3 = a3(e4);
                o2 = t2.interpolate.number(s2, i3, n3), e4 < 1 ? this._frameId || (this._frameId = true) : r2 = true;
              } else
                o2 = i3, r2 = true;
              return this._active = true, r2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !r2, zoomDelta: o2 - e3.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e3) {
              let i3 = t2.defaultEasing;
              if (this._prevEase) {
                const e4 = this._prevEase, s2 = (t2.browser.now() - e4.start) / e4.duration, a3 = e4.easing(s2 + 0.01) - e4.easing(s2), o2 = 0.27 / Math.sqrt(a3 * a3 + 1e-4) * 0.01, r2 = Math.sqrt(0.0729 - o2 * o2);
                i3 = t2.bezier(o2, r2, 0.25, 1);
              }
              return this._prevEase = { start: t2.browser.now(), duration: e3, easing: i3 }, i3;
            }
            reset() {
              this._active = false;
            }
          }
          class Hs {
            constructor(t3, e3) {
              this._clickZoom = t3, this._tapZoom = e3;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class Ks {
            constructor(t3) {
              this._tr = new ws(t3), this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(t3, e3) {
              return t3.preventDefault(), { cameraAnimation: (i3) => {
                i3.easeTo({ duration: 300, zoom: this._tr.zoom + (t3.shiftKey ? -1 : 1), around: this._tr.unproject(e3) }, { originalEvent: t3 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ys {
            constructor() {
              this._tap = new Ss({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
            }
            touchstart(t3, e3, i3) {
              if (!this._swipePoint)
                if (this._tapTime) {
                  const s2 = e3[0], a3 = t3.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(s2) < 30;
                  a3 && o2 ? i3.length > 0 && (this._swipePoint = s2, this._swipeTouch = i3[0].identifier) : this.reset();
                } else
                  this._tap.touchstart(t3, e3, i3);
            }
            touchmove(t3, e3, i3) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i3[0].identifier !== this._swipeTouch)
                    return;
                  const s2 = e3[0], a3 = s2.y - this._swipePoint.y;
                  return this._swipePoint = s2, t3.preventDefault(), this._active = true, { zoomDelta: a3 / 128 };
                }
              } else
                this._tap.touchmove(t3, e3, i3);
            }
            touchend(t3, e3, i3) {
              if (this._tapTime)
                this._swipePoint && 0 === i3.length && this.reset();
              else {
                const s2 = this._tap.touchend(t3, e3, i3);
                s2 && (this._tapTime = t3.timeStamp, this._tapPoint = s2);
              }
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Js {
            constructor(t3, e3, i3) {
              this._el = t3, this._mousePan = e3, this._touchPan = i3;
            }
            enable(t3) {
              this._inertiaOptions = t3 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class Qs {
            constructor(t3, e3, i3) {
              this._pitchWithRotate = t3.pitchWithRotate, this._mouseRotate = e3, this._mousePitch = i3;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class ta {
            constructor(t3, e3, i3, s2) {
              this._el = t3, this._touchZoom = e3, this._touchRotate = i3, this._tapDragZoom = s2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(t3) {
              this._touchZoom.enable(t3), this._rotationDisabled || this._touchRotate.enable(t3), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const ea = (t3) => t3.zoom || t3.drag || t3.pitch || t3.rotate;
          class ia extends t2.Event {
          }
          function sa(t3) {
            return t3.panDelta && t3.panDelta.mag() || t3.zoomDelta || t3.bearingDelta || t3.pitchDelta;
          }
          class aa {
            constructor(t3, e3) {
              this.handleWindowEvent = (t4) => {
                this.handleEvent(t4, `${t4.type}Window`);
              }, this.handleEvent = (t4, e4) => {
                if ("blur" === t4.type)
                  return void this.stop(true);
                this._updatingCamera = true;
                const s3 = "renderFrame" === t4.type ? void 0 : t4, a3 = { needsRenderFrame: false }, o2 = {}, r2 = {}, n3 = t4.touches, l2 = n3 ? this._getMapTouches(n3) : void 0, c5 = l2 ? i2.touchPos(this._el, l2) : i2.mousePos(this._el, t4);
                for (const { handlerName: i3, handler: n4, allowed: h3 } of this._handlers) {
                  if (!n4.isEnabled())
                    continue;
                  let u3;
                  this._blockedByActive(r2, h3, i3) ? n4.reset() : n4[e4 || t4.type] && (u3 = n4[e4 || t4.type](t4, c5, l2), this.mergeHandlerResult(a3, o2, u3, i3, s3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n4.isActive()) && (r2[i3] = n4);
                }
                const h2 = {};
                for (const t5 in this._previousActiveHandlers)
                  r2[t5] || (h2[t5] = s3);
                this._previousActiveHandlers = r2, (Object.keys(h2).length || sa(a3)) && (this._changes.push([a3, o2, h2]), this._triggerRenderFrame()), (Object.keys(r2).length || sa(a3)) && this._map._stop(true), this._updatingCamera = false;
                const { cameraAnimation: u2 } = a3;
                u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
              }, this._map = t3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ms(t3), this._bearingSnap = e3.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e3);
              const s2 = this._el;
              this._listeners = [[s2, "touchstart", { passive: true }], [s2, "touchmove", { passive: false }], [s2, "touchend", void 0], [s2, "touchcancel", void 0], [s2, "mousedown", void 0], [s2, "mousemove", void 0], [s2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [s2, "mouseover", void 0], [s2, "mouseout", void 0], [s2, "dblclick", void 0], [s2, "click", void 0], [s2, "keydown", { capture: false }], [s2, "keyup", void 0], [s2, "wheel", { passive: false }], [s2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [t4, e4, s3] of this._listeners)
                i2.addEventListener(t4, e4, t4 === document ? this.handleWindowEvent : this.handleEvent, s3);
            }
            destroy() {
              for (const [t3, e3, s2] of this._listeners)
                i2.removeEventListener(t3, e3, t3 === document ? this.handleWindowEvent : this.handleEvent, s2);
            }
            _addDefaultHandlers(t3) {
              const e3 = this._map, s2 = e3.getCanvasContainer();
              this._add("mapEvent", new ys(e3, t3));
              const a3 = e3.boxZoom = new Ts(e3, t3);
              this._add("boxZoom", a3), t3.interactive && t3.boxZoom && a3.enable();
              const o2 = new Cs(e3), r2 = new Ks(e3);
              e3.doubleClickZoom = new Hs(r2, o2), this._add("tapZoom", o2), this._add("clickZoom", r2), t3.interactive && t3.doubleClickZoom && e3.doubleClickZoom.enable();
              const n3 = new Ys();
              this._add("tapDragZoom", n3);
              const l2 = e3.touchPitch = new Vs(e3);
              this._add("touchPitch", l2), t3.interactive && t3.touchPitch && e3.touchPitch.enable(t3.touchPitch);
              const c5 = Ls(t3), h2 = Rs(t3);
              e3.dragRotate = new Qs(t3, c5, h2), this._add("mouseRotate", c5, ["mousePitch"]), this._add("mousePitch", h2, ["mouseRotate"]), t3.interactive && t3.dragRotate && e3.dragRotate.enable();
              const u2 = (({ enable: t4, clickTolerance: e4 }) => {
                const s3 = new zs({ checkCorrectEvent: (t5) => 0 === i2.mouseButton(t5) && !t5.ctrlKey });
                return new Ps({ clickTolerance: e4, move: (t5, e5) => ({ around: e5, panDelta: e5.sub(t5) }), activateOnStart: true, moveStateManager: s3, enable: t4, assignEvents: As });
              })(t3), d3 = new ks(t3, e3);
              e3.dragPan = new Js(s2, u2, d3), this._add("mousePan", u2), this._add("touchPan", d3, ["touchZoom", "touchRotate"]), t3.interactive && t3.dragPan && e3.dragPan.enable(t3.dragPan);
              const _2 = new Gs(), m4 = new Os();
              e3.touchZoomRotate = new ta(s2, m4, _2, n3), this._add("touchRotate", _2, ["touchPan", "touchZoom"]), this._add("touchZoom", m4, ["touchPan", "touchRotate"]), t3.interactive && t3.touchZoomRotate && e3.touchZoomRotate.enable(t3.touchZoomRotate);
              const p3 = e3.scrollZoom = new Ws(e3, () => this._triggerRenderFrame());
              this._add("scrollZoom", p3, ["mousePan"]), t3.interactive && t3.scrollZoom && e3.scrollZoom.enable(t3.scrollZoom);
              const f2 = e3.keyboard = new js(e3);
              this._add("keyboard", f2), t3.interactive && t3.keyboard && e3.keyboard.enable(), this._add("blockableMapEvent", new bs(e3));
            }
            _add(t3, e3, i3) {
              this._handlers.push({ handlerName: t3, handler: e3, allowed: i3 }), this._handlersById[t3] = e3;
            }
            stop(t3) {
              if (!this._updatingCamera) {
                for (const { handler: t4 } of this._handlers)
                  t4.reset();
                this._inertia.clear(), this._fireEvents({}, {}, t3), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: t3 } of this._handlers)
                if (t3.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(ea(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t3, e3, i3) {
              for (const s2 in t3)
                if (s2 !== i3 && (!e3 || e3.indexOf(s2) < 0))
                  return true;
              return false;
            }
            _getMapTouches(t3) {
              const e3 = [];
              for (const i3 of t3)
                this._el.contains(i3.target) && e3.push(i3);
              return e3;
            }
            mergeHandlerResult(e3, i3, s2, a3, o2) {
              if (!s2)
                return;
              t2.extend(e3, s2);
              const r2 = { handlerName: a3, originalEvent: s2.originalEvent || o2 };
              void 0 !== s2.zoomDelta && (i3.zoom = r2), void 0 !== s2.panDelta && (i3.drag = r2), void 0 !== s2.pitchDelta && (i3.pitch = r2), void 0 !== s2.bearingDelta && (i3.rotate = r2);
            }
            _applyChanges() {
              const e3 = {}, i3 = {}, s2 = {};
              for (const [a3, o2, r2] of this._changes)
                a3.panDelta && (e3.panDelta = (e3.panDelta || new t2.Point(0, 0))._add(a3.panDelta)), a3.zoomDelta && (e3.zoomDelta = (e3.zoomDelta || 0) + a3.zoomDelta), a3.bearingDelta && (e3.bearingDelta = (e3.bearingDelta || 0) + a3.bearingDelta), a3.pitchDelta && (e3.pitchDelta = (e3.pitchDelta || 0) + a3.pitchDelta), void 0 !== a3.around && (e3.around = a3.around), void 0 !== a3.pinchAround && (e3.pinchAround = a3.pinchAround), a3.noInertia && (e3.noInertia = a3.noInertia), t2.extend(i3, o2), t2.extend(s2, r2);
              this._updateMapTransform(e3, i3, s2), this._changes = [];
            }
            _updateMapTransform(t3, e3, i3) {
              const s2 = this._map, a3 = s2._getTransformForUpdate(), o2 = s2.terrain;
              if (!(sa(t3) || o2 && this._terrainMovement))
                return this._fireEvents(e3, i3, true);
              let { panDelta: r2, zoomDelta: n3, bearingDelta: l2, pitchDelta: c5, around: h2, pinchAround: u2 } = t3;
              void 0 !== u2 && (h2 = u2), s2._stop(true), h2 = h2 || s2.transform.centerPoint;
              const d3 = a3.pointLocation(r2 ? h2.sub(r2) : h2);
              l2 && (a3.bearing += l2), c5 && (a3.pitch += c5), n3 && (a3.zoom += n3), o2 ? this._terrainMovement || !e3.drag && !e3.zoom ? e3.drag && this._terrainMovement ? a3.center = a3.pointLocation(a3.centerPoint.sub(r2)) : a3.setLocationAtPoint(d3, h2) : (this._terrainMovement = true, a3.freezeElevation = true, a3.setLocationAtPoint(d3, h2), this._map.once("moveend", () => {
                a3.freezeElevation = false, this._terrainMovement = false, a3.recalculateZoom(s2.terrain);
              })) : a3.setLocationAtPoint(d3, h2), s2._applyUpdatedTransform(a3), this._map._update(), t3.noInertia || this._inertia.record(t3), this._fireEvents(e3, i3, true);
            }
            _fireEvents(e3, i3, s2) {
              const a3 = ea(this._eventsInProgress), o2 = ea(e3), r2 = {};
              for (const t3 in e3) {
                const { originalEvent: i4 } = e3[t3];
                this._eventsInProgress[t3] || (r2[`${t3}start`] = i4), this._eventsInProgress[t3] = e3[t3];
              }
              !a3 && o2 && this._fireEvent("movestart", o2.originalEvent);
              for (const t3 in r2)
                this._fireEvent(t3, r2[t3]);
              o2 && this._fireEvent("move", o2.originalEvent);
              for (const t3 in e3) {
                const { originalEvent: i4 } = e3[t3];
                this._fireEvent(t3, i4);
              }
              const n3 = {};
              let l2;
              for (const t3 in this._eventsInProgress) {
                const { handlerName: e4, originalEvent: s3 } = this._eventsInProgress[t3];
                this._handlersById[e4].isActive() || (delete this._eventsInProgress[t3], l2 = i3[e4] || s3, n3[`${t3}end`] = l2);
              }
              for (const t3 in n3)
                this._fireEvent(t3, n3[t3]);
              const c5 = ea(this._eventsInProgress);
              if (s2 && (a3 || o2) && !c5) {
                this._updatingCamera = true;
                const e4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i4 = (t3) => 0 !== t3 && -this._bearingSnap < t3 && t3 < this._bearingSnap;
                e4 ? (i4(e4.bearing || this._map.getBearing()) && (e4.bearing = 0), e4.freezeElevation = true, this._map.easeTo(e4, { originalEvent: l2 })) : (this._map.fire(new t2.Event("moveend", { originalEvent: l2 })), i4(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(e3, i3) {
              this._map.fire(new t2.Event(e3, i3 ? { originalEvent: i3 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t3) => {
                delete this._frameId, this.handleEvent(new ia("renderFrame", { timeStamp: t3 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          class oa extends t2.Evented {
            constructor(e3, i3) {
              super(), this._renderFrameCallback = () => {
                const e4 = Math.min((t2.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
                this._onEaseFrame(this._easeOptions.easing(e4)), e4 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
              }, this._moving = false, this._zooming = false, this.transform = e3, this._bearingSnap = i3.bearingSnap, this.on("moveend", () => {
                delete this._requestedCameraState;
              });
            }
            getCenter() {
              return new t2.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t3, e3) {
              return this.jumpTo({ center: t3 }, e3);
            }
            panBy(e3, i3, s2) {
              return e3 = t2.Point.convert(e3).mult(-1), this.panTo(this.transform.center, t2.extend({ offset: e3 }, i3), s2);
            }
            panTo(e3, i3, s2) {
              return this.easeTo(t2.extend({ center: e3 }, i3), s2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(t3, e3) {
              return this.jumpTo({ zoom: t3 }, e3), this;
            }
            zoomTo(e3, i3, s2) {
              return this.easeTo(t2.extend({ zoom: e3 }, i3), s2);
            }
            zoomIn(t3, e3) {
              return this.zoomTo(this.getZoom() + 1, t3, e3), this;
            }
            zoomOut(t3, e3) {
              return this.zoomTo(this.getZoom() - 1, t3, e3), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(t3, e3) {
              return this.jumpTo({ bearing: t3 }, e3), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(t3, e3) {
              return this.jumpTo({ padding: t3 }, e3), this;
            }
            rotateTo(e3, i3, s2) {
              return this.easeTo(t2.extend({ bearing: e3 }, i3), s2);
            }
            resetNorth(e3, i3) {
              return this.rotateTo(0, t2.extend({ duration: 1e3 }, e3), i3), this;
            }
            resetNorthPitch(e3, i3) {
              return this.easeTo(t2.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i3), this;
            }
            snapToNorth(t3, e3) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t3, e3) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(t3, e3) {
              return this.jumpTo({ pitch: t3 }, e3), this;
            }
            cameraForBounds(t3, e3) {
              t3 = L.convert(t3);
              const i3 = e3 && e3.bearing || 0;
              return this._cameraForBoxAndBearing(t3.getNorthWest(), t3.getSouthEast(), i3, e3);
            }
            _cameraForBoxAndBearing(e3, i3, s2, a3) {
              const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (a3 = t2.extend({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a3)).padding) {
                const t3 = a3.padding;
                a3.padding = { top: t3, bottom: t3, right: t3, left: t3 };
              }
              a3.padding = t2.extend(o2, a3.padding);
              const r2 = this.transform, n3 = r2.padding, l2 = r2.project(t2.LngLat.convert(e3)), c5 = r2.project(t2.LngLat.convert(i3)), h2 = l2.rotate(-s2 * Math.PI / 180), u2 = c5.rotate(-s2 * Math.PI / 180), d3 = new t2.Point(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), _2 = new t2.Point(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), m4 = d3.sub(_2), p3 = (r2.width - (n3.left + n3.right + a3.padding.left + a3.padding.right)) / m4.x, f2 = (r2.height - (n3.top + n3.bottom + a3.padding.top + a3.padding.bottom)) / m4.y;
              if (f2 < 0 || p3 < 0)
                return void t2.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              const g3 = Math.min(r2.scaleZoom(r2.scale * Math.min(p3, f2)), a3.maxZoom), v2 = t2.Point.convert(a3.offset), x2 = new t2.Point((a3.padding.left - a3.padding.right) / 2, (a3.padding.top - a3.padding.bottom) / 2).rotate(s2 * Math.PI / 180), y2 = v2.add(x2).mult(r2.scale / r2.zoomScale(g3));
              return { center: r2.unproject(l2.add(c5).div(2).sub(y2)), zoom: g3, bearing: s2 };
            }
            fitBounds(t3, e3, i3) {
              return this._fitInternal(this.cameraForBounds(t3, e3), e3, i3);
            }
            fitScreenCoordinates(e3, i3, s2, a3, o2) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t2.Point.convert(e3)), this.transform.pointLocation(t2.Point.convert(i3)), s2, a3), a3, o2);
            }
            _fitInternal(e3, i3, s2) {
              return e3 ? (delete (i3 = t2.extend(e3, i3)).padding, i3.linear ? this.easeTo(i3, s2) : this.flyTo(i3, s2)) : this;
            }
            jumpTo(e3, i3) {
              this.stop();
              const s2 = this._getTransformForUpdate();
              let a3 = false, o2 = false, r2 = false;
              return "zoom" in e3 && s2.zoom !== +e3.zoom && (a3 = true, s2.zoom = +e3.zoom), void 0 !== e3.center && (s2.center = t2.LngLat.convert(e3.center)), "bearing" in e3 && s2.bearing !== +e3.bearing && (o2 = true, s2.bearing = +e3.bearing), "pitch" in e3 && s2.pitch !== +e3.pitch && (r2 = true, s2.pitch = +e3.pitch), null == e3.padding || s2.isPaddingEqual(e3.padding) || (s2.padding = e3.padding), this._applyUpdatedTransform(s2), this.fire(new t2.Event("movestart", i3)).fire(new t2.Event("move", i3)), a3 && this.fire(new t2.Event("zoomstart", i3)).fire(new t2.Event("zoom", i3)).fire(new t2.Event("zoomend", i3)), o2 && this.fire(new t2.Event("rotatestart", i3)).fire(new t2.Event("rotate", i3)).fire(new t2.Event("rotateend", i3)), r2 && this.fire(new t2.Event("pitchstart", i3)).fire(new t2.Event("pitch", i3)).fire(new t2.Event("pitchend", i3)), this.fire(new t2.Event("moveend", i3));
            }
            calculateCameraOptionsFromTo(e3, i3, s2, a3 = 0) {
              const o2 = t2.MercatorCoordinate.fromLngLat(e3, i3), r2 = t2.MercatorCoordinate.fromLngLat(s2, a3), n3 = r2.x - o2.x, l2 = r2.y - o2.y, c5 = r2.z - o2.z, h2 = Math.hypot(n3, l2, c5);
              if (0 === h2)
                throw new Error("Can't calculate camera options with same From and To");
              const u2 = Math.hypot(n3, l2), d3 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), _2 = 180 * Math.atan2(n3, -l2) / Math.PI;
              let m4 = 180 * Math.acos(u2 / h2) / Math.PI;
              return m4 = c5 < 0 ? 90 - m4 : 90 + m4, { center: r2.toLngLat(), zoom: d3, pitch: m4, bearing: _2 };
            }
            easeTo(e3, i3) {
              this._stop(false, e3.easeId), (false === (e3 = t2.extend({ offset: [0, 0], duration: 500, easing: t2.defaultEasing }, e3)).animate || !e3.essential && t2.browser.prefersReducedMotion) && (e3.duration = 0);
              const s2 = this._getTransformForUpdate(), a3 = this.getZoom(), o2 = this.getBearing(), r2 = this.getPitch(), n3 = this.getPadding(), l2 = "zoom" in e3 ? +e3.zoom : a3, c5 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, o2) : o2, h2 = "pitch" in e3 ? +e3.pitch : r2, u2 = "padding" in e3 ? e3.padding : s2.padding, d3 = t2.Point.convert(e3.offset);
              let _2 = s2.centerPoint.add(d3);
              const m4 = s2.pointLocation(_2), p3 = t2.LngLat.convert(e3.center || m4);
              this._normalizeCenter(p3);
              const f2 = s2.project(m4), g3 = s2.project(p3).sub(f2), v2 = s2.zoomScale(l2 - a3);
              let x2, y2;
              e3.around && (x2 = t2.LngLat.convert(e3.around), y2 = s2.locationPoint(x2));
              const b3 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || l2 !== a3, this._rotating = this._rotating || o2 !== c5, this._pitching = this._pitching || h2 !== r2, this._padding = !s2.isPaddingEqual(u2), this._easeId = e3.easeId, this._prepareEase(i3, e3.noMoveStart, b3), this.terrain && this._prepareElevation(p3), this._ease((m5) => {
                if (this._zooming && (s2.zoom = t2.interpolate.number(a3, l2, m5)), this._rotating && (s2.bearing = t2.interpolate.number(o2, c5, m5)), this._pitching && (s2.pitch = t2.interpolate.number(r2, h2, m5)), this._padding && (s2.interpolatePadding(n3, u2, m5), _2 = s2.centerPoint.add(d3)), this.terrain && !e3.freezeElevation && this._updateElevation(m5), x2)
                  s2.setLocationAtPoint(x2, y2);
                else {
                  const t3 = s2.zoomScale(s2.zoom - a3), e4 = l2 > a3 ? Math.min(2, v2) : Math.max(0.5, v2), i4 = Math.pow(e4, 1 - m5), o3 = s2.unproject(f2.add(g3.mult(m5 * i4)).mult(t3));
                  s2.setLocationAtPoint(s2.renderWorldCopies ? o3.wrap() : o3, _2);
                }
                this._applyUpdatedTransform(s2), this._fireMoveEvents(i3);
              }, (t3) => {
                this.terrain && this._finalizeElevation(), this._afterEase(i3, t3);
              }, e3), this;
            }
            _prepareEase(e3, i3, s2 = {}) {
              this._moving = true, i3 || s2.moving || this.fire(new t2.Event("movestart", e3)), this._zooming && !s2.zooming && this.fire(new t2.Event("zoomstart", e3)), this._rotating && !s2.rotating && this.fire(new t2.Event("rotatestart", e3)), this._pitching && !s2.pitching && this.fire(new t2.Event("pitchstart", e3));
            }
            _prepareElevation(t3) {
              this._elevationCenter = t3, this._elevationStart = this.transform.elevation, this._elevationTarget = this.transform.getElevation(t3, this.terrain), this.transform.freezeElevation = true;
            }
            _updateElevation(e3) {
              const i3 = this.transform.getElevation(this._elevationCenter, this.terrain);
              if (e3 < 1 && i3 !== this._elevationTarget) {
                const t3 = this._elevationTarget - this._elevationStart;
                this._elevationStart += e3 * (t3 - (i3 - (t3 * e3 + this._elevationStart)) / (1 - e3)), this._elevationTarget = i3;
              }
              this.transform.elevation = t2.interpolate.number(this._elevationStart, this._elevationTarget, e3);
            }
            _finalizeElevation() {
              this.transform.freezeElevation = false, this.transform.recalculateZoom(this.terrain);
            }
            _getTransformForUpdate() {
              return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
            }
            _applyUpdatedTransform(t3) {
              if (!this.transformCameraUpdate)
                return;
              const e3 = t3.clone(), { center: i3, zoom: s2, pitch: a3, bearing: o2, elevation: r2 } = this.transformCameraUpdate(e3);
              i3 && (e3.center = i3), void 0 !== s2 && (e3.zoom = s2), void 0 !== a3 && (e3.pitch = a3), void 0 !== o2 && (e3.bearing = o2), void 0 !== r2 && (e3.elevation = r2), this.transform.apply(e3);
            }
            _fireMoveEvents(e3) {
              this.fire(new t2.Event("move", e3)), this._zooming && this.fire(new t2.Event("zoom", e3)), this._rotating && this.fire(new t2.Event("rotate", e3)), this._pitching && this.fire(new t2.Event("pitch", e3));
            }
            _afterEase(e3, i3) {
              if (this._easeId && i3 && this._easeId === i3)
                return;
              delete this._easeId;
              const s2 = this._zooming, a3 = this._rotating, o2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s2 && this.fire(new t2.Event("zoomend", e3)), a3 && this.fire(new t2.Event("rotateend", e3)), o2 && this.fire(new t2.Event("pitchend", e3)), this.fire(new t2.Event("moveend", e3));
            }
            flyTo(e3, i3) {
              if (!e3.essential && t2.browser.prefersReducedMotion) {
                const s3 = t2.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(s3, i3);
              }
              this.stop(), e3 = t2.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t2.defaultEasing }, e3);
              const s2 = this._getTransformForUpdate(), a3 = this.getZoom(), o2 = this.getBearing(), r2 = this.getPitch(), n3 = this.getPadding(), l2 = "zoom" in e3 ? t2.clamp(+e3.zoom, s2.minZoom, s2.maxZoom) : a3, c5 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, o2) : o2, h2 = "pitch" in e3 ? +e3.pitch : r2, u2 = "padding" in e3 ? e3.padding : s2.padding, d3 = s2.zoomScale(l2 - a3), _2 = t2.Point.convert(e3.offset);
              let m4 = s2.centerPoint.add(_2);
              const p3 = s2.pointLocation(m4), f2 = t2.LngLat.convert(e3.center || p3);
              this._normalizeCenter(f2);
              const g3 = s2.project(p3), v2 = s2.project(f2).sub(g3);
              let x2 = e3.curve;
              const y2 = Math.max(s2.width, s2.height), b3 = y2 / d3, w2 = v2.mag();
              if ("minZoom" in e3) {
                const i4 = t2.clamp(Math.min(e3.minZoom, a3, l2), s2.minZoom, s2.maxZoom), o3 = y2 / s2.zoomScale(i4 - a3);
                x2 = Math.sqrt(o3 / w2 * 2);
              }
              const T2 = x2 * x2;
              function E2(t3) {
                const e4 = (b3 * b3 - y2 * y2 + (t3 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (t3 ? b3 : y2) * T2 * w2);
                return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
              }
              function I2(t3) {
                return (Math.exp(t3) - Math.exp(-t3)) / 2;
              }
              function S2(t3) {
                return (Math.exp(t3) + Math.exp(-t3)) / 2;
              }
              const C3 = E2(false);
              let P2 = function(t3) {
                return S2(C3) / S2(C3 + x2 * t3);
              }, D2 = function(t3) {
                return y2 * ((S2(C3) * (I2(e4 = C3 + x2 * t3) / S2(e4)) - I2(C3)) / T2) / w2;
                var e4;
              }, z2 = (E2(true) - C3) / x2;
              if (Math.abs(w2) < 1e-6 || !isFinite(z2)) {
                if (Math.abs(y2 - b3) < 1e-6)
                  return this.easeTo(e3, i3);
                const t3 = b3 < y2 ? -1 : 1;
                z2 = Math.abs(Math.log(b3 / y2)) / x2, D2 = function() {
                  return 0;
                }, P2 = function(e4) {
                  return Math.exp(t3 * x2 * e4);
                };
              }
              return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * z2 / ("screenSpeed" in e3 ? +e3.screenSpeed / x2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = o2 !== c5, this._pitching = h2 !== r2, this._padding = !s2.isPaddingEqual(u2), this._prepareEase(i3, false), this.terrain && this._prepareElevation(f2), this._ease((d4) => {
                const p4 = d4 * z2, x3 = 1 / P2(p4);
                s2.zoom = 1 === d4 ? l2 : a3 + s2.scaleZoom(x3), this._rotating && (s2.bearing = t2.interpolate.number(o2, c5, d4)), this._pitching && (s2.pitch = t2.interpolate.number(r2, h2, d4)), this._padding && (s2.interpolatePadding(n3, u2, d4), m4 = s2.centerPoint.add(_2)), this.terrain && !e3.freezeElevation && this._updateElevation(d4);
                const y3 = 1 === d4 ? f2 : s2.unproject(g3.add(v2.mult(D2(p4))).mult(x3));
                s2.setLocationAtPoint(s2.renderWorldCopies ? y3.wrap() : y3, m4), this._applyUpdatedTransform(s2), this._fireMoveEvents(i3);
              }, () => {
                this.terrain && this._finalizeElevation(), this._afterEase(i3);
              }, e3), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(t3, e3) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const t4 = this._onEaseEnd;
                delete this._onEaseEnd, t4.call(this, e3);
              }
              if (!t3) {
                const t4 = this.handlers;
                t4 && t4.stop(false);
              }
              return this;
            }
            _ease(e3, i3, s2) {
              false === s2.animate || 0 === s2.duration ? (e3(1), i3()) : (this._easeStart = t2.browser.now(), this._easeOptions = s2, this._onEaseFrame = e3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _normalizeBearing(e3, i3) {
              e3 = t2.wrap(e3, -180, 180);
              const s2 = Math.abs(e3 - i3);
              return Math.abs(e3 - 360 - i3) < s2 && (e3 -= 360), Math.abs(e3 + 360 - i3) < s2 && (e3 += 360), e3;
            }
            _normalizeCenter(t3) {
              const e3 = this.transform;
              if (!e3.renderWorldCopies || e3.lngRange)
                return;
              const i3 = t3.lng - e3.center.lng;
              t3.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
            }
            queryTerrainElevation(e3) {
              return this.terrain ? this.transform.getElevation(t2.LngLat.convert(e3), this.terrain) - this.transform.elevation : null;
            }
          }
          class ra {
            constructor(t3 = {}) {
              this._toggleAttribution = () => {
                this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
              }, this._updateData = (t4) => {
                !t4 || "metadata" !== t4.sourceDataType && "visibility" !== t4.sourceDataType && "style" !== t4.dataType && "terrain" !== t4.type || this._updateAttributions();
              }, this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
              }, this._updateCompactMinimize = () => {
                this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
              }, this.options = t3;
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(t3) {
              return this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i2.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i2.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              i2.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t3, e3) {
              const i3 = this._map._getUIString(`AttributionControl.${e3}`);
              t3.title = i3, t3.setAttribute("aria-label", i3);
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let t3 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t3 = t3.concat(this.options.customAttribution.map((t4) => "string" != typeof t4 ? "" : t4)) : "string" == typeof this.options.customAttribution && t3.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const t4 = this._map.style.stylesheet;
                this.styleOwner = t4.owner, this.styleId = t4.id;
              }
              const e3 = this._map.style.sourceCaches;
              for (const i4 in e3) {
                const s2 = e3[i4];
                if (s2.used || s2.usedForTerrain) {
                  const e4 = s2.getSource();
                  e4.attribution && t3.indexOf(e4.attribution) < 0 && t3.push(e4.attribution);
                }
              }
              t3 = t3.filter((t4) => String(t4).trim()), t3.sort((t4, e4) => t4.length - e4.length), t3 = t3.filter((e4, i4) => {
                for (let s2 = i4 + 1; s2 < t3.length; s2++)
                  if (t3[s2].indexOf(e4) >= 0)
                    return false;
                return true;
              });
              const i3 = t3.join(" | ");
              i3 !== this._attribHTML && (this._attribHTML = i3, t3.length ? (this._innerContainer.innerHTML = i3, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
          }
          class na {
            constructor(t3 = {}) {
              this._updateCompact = () => {
                const t4 = this._container.children;
                if (t4.length) {
                  const e3 = t4[0];
                  this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e3.classList.add("maplibregl-compact") : e3.classList.remove("maplibregl-compact");
                }
              }, this.options = t3;
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t3) {
              this._map = t3, this._compact = this.options && this.options.compact, this._container = i2.create("div", "maplibregl-ctrl");
              const e3 = i2.create("a", "maplibregl-ctrl-logo");
              return e3.target = "_blank", e3.rel = "noopener nofollow", e3.href = "https://maplibre.org/", e3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              i2.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
          }
          class la {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(t3) {
              const e3 = ++this._id;
              return this._queue.push({ callback: t3, id: e3, cancelled: false }), e3;
            }
            remove(t3) {
              const e3 = this._currentlyRunning, i3 = e3 ? this._queue.concat(e3) : this._queue;
              for (const e4 of i3)
                if (e4.id === t3)
                  return void (e4.cancelled = true);
            }
            run(t3 = 0) {
              if (this._currentlyRunning)
                throw new Error("Attempting to run(), but is already running.");
              const e3 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i3 of e3)
                if (!i3.cancelled && (i3.callback(t3), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          const ca = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
          var ha = t2.createLayout([{ name: "a_pos3d", type: "Int16", components: 3 }]);
          class ua extends t2.Evented {
            constructor(t3) {
              super(), this.sourceCache = t3, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t3.usedForTerrain = true, t3.tileSize = this.tileSize * 2 ** this.deltaZoom;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
            }
            update(e3, i3) {
              this.sourceCache.update(e3, i3), this._renderableTilesKeys = [];
              const s2 = {};
              for (const a3 of e3.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i3 }))
                s2[a3.key] = true, this._renderableTilesKeys.push(a3.key), this._tiles[a3.key] || (a3.posMatrix = new Float64Array(16), t2.ortho(a3.posMatrix, 0, t2.EXTENT, 0, t2.EXTENT, 0, 1), this._tiles[a3.key] = new W(a3, this.tileSize));
              for (const t3 in this._tiles)
                s2[t3] || delete this._tiles[t3];
            }
            freeRtt(t3) {
              for (const e3 in this._tiles) {
                const i3 = this._tiles[e3];
                (!t3 || i3.tileID.equals(t3) || i3.tileID.isChildOf(t3) || t3.isChildOf(i3.tileID)) && (i3.rtt = []);
              }
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((t3) => this.getTileByID(t3));
            }
            getTileByID(t3) {
              return this._tiles[t3];
            }
            getTerrainCoords(e3) {
              const i3 = {};
              for (const s2 of this._renderableTilesKeys) {
                const a3 = this._tiles[s2].tileID;
                if (a3.canonical.equals(e3.canonical)) {
                  const a4 = e3.clone();
                  a4.posMatrix = new Float64Array(16), t2.ortho(a4.posMatrix, 0, t2.EXTENT, 0, t2.EXTENT, 0, 1), i3[s2] = a4;
                } else if (a3.canonical.isChildOf(e3.canonical)) {
                  const o2 = e3.clone();
                  o2.posMatrix = new Float64Array(16);
                  const r2 = a3.canonical.z - e3.canonical.z, n3 = a3.canonical.x - (a3.canonical.x >> r2 << r2), l2 = a3.canonical.y - (a3.canonical.y >> r2 << r2), c5 = t2.EXTENT >> r2;
                  t2.ortho(o2.posMatrix, 0, c5, 0, c5, 0, 1), t2.translate(o2.posMatrix, o2.posMatrix, [-n3 * c5, -l2 * c5, 0]), i3[s2] = o2;
                } else if (e3.canonical.isChildOf(a3.canonical)) {
                  const o2 = e3.clone();
                  o2.posMatrix = new Float64Array(16);
                  const r2 = e3.canonical.z - a3.canonical.z, n3 = e3.canonical.x - (e3.canonical.x >> r2 << r2), l2 = e3.canonical.y - (e3.canonical.y >> r2 << r2), c5 = t2.EXTENT >> r2;
                  t2.ortho(o2.posMatrix, 0, t2.EXTENT, 0, t2.EXTENT, 0, 1), t2.translate(o2.posMatrix, o2.posMatrix, [n3 * c5, l2 * c5, 0]), t2.scale(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i3[s2] = o2;
                }
              }
              return i3;
            }
            getSourceTile(t3, e3) {
              const i3 = this.sourceCache._source;
              let s2 = t3.overscaledZ - this.deltaZoom;
              if (s2 > i3.maxzoom && (s2 = i3.maxzoom), s2 < i3.minzoom)
                return null;
              this._sourceTileCache[t3.key] || (this._sourceTileCache[t3.key] = t3.scaledTo(s2).key);
              let a3 = this.sourceCache.getTileByID(this._sourceTileCache[t3.key]);
              if ((!a3 || !a3.dem) && e3)
                for (; s2 >= i3.minzoom && (!a3 || !a3.dem); )
                  a3 = this.sourceCache.getTileByID(t3.scaledTo(s2--).key);
              return a3;
            }
            tilesAfterTime(t3 = Date.now()) {
              return Object.values(this._tiles).filter((e3) => e3.timeAdded >= t3);
            }
          }
          class da {
            constructor(t3, e3, i3) {
              this.painter = t3, this.sourceCache = new ua(e3), this.options = i3, this.exaggeration = "number" == typeof i3.exaggeration ? i3.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
            }
            getDEMElevation(e3, i3, s2, a3 = t2.EXTENT) {
              var o2;
              if (!(i3 >= 0 && i3 < a3 && s2 >= 0 && s2 < a3))
                return 0;
              const r2 = this.getTerrainData(e3), n3 = null === (o2 = r2.tile) || void 0 === o2 ? void 0 : o2.dem;
              if (!n3)
                return 0;
              const l2 = function(t3, e4, i4) {
                var s3 = e4[0], a4 = e4[1];
                return t3[0] = i4[0] * s3 + i4[4] * a4 + i4[12], t3[1] = i4[1] * s3 + i4[5] * a4 + i4[13], t3;
              }([], [i3 / a3 * t2.EXTENT, s2 / a3 * t2.EXTENT], r2.u_terrain_matrix), c5 = [l2[0] * n3.dim, l2[1] * n3.dim], h2 = Math.floor(c5[0]), u2 = Math.floor(c5[1]), d3 = c5[0] - h2, _2 = c5[1] - u2;
              return n3.get(h2, u2) * (1 - d3) * (1 - _2) + n3.get(h2 + 1, u2) * d3 * (1 - _2) + n3.get(h2, u2 + 1) * (1 - d3) * _2 + n3.get(h2 + 1, u2 + 1) * d3 * _2;
            }
            getElevation(e3, i3, s2, a3 = t2.EXTENT) {
              return this.getDEMElevation(e3, i3, s2, a3) * this.exaggeration;
            }
            getTerrainData(e3) {
              if (!this._emptyDemTexture) {
                const e4 = this.painter.context, i4 = new t2.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new x(e4, i4, e4.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new x(e4, new t2.RGBAImage({ width: 1, height: 1 }), e4.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e4.gl.NEAREST, e4.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t2.identity([]);
              }
              const i3 = this.sourceCache.getSourceTile(e3, true);
              if (i3 && i3.dem && (!i3.demTexture || i3.needsTerrainPrepare)) {
                const t3 = this.painter.context;
                i3.demTexture = this.painter.getTileTexture(i3.dem.stride), i3.demTexture ? i3.demTexture.update(i3.dem.getPixels(), { premultiply: false }) : i3.demTexture = new x(t3, i3.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i3.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i3.needsTerrainPrepare = false;
              }
              const s2 = i3 && i3 + i3.tileID.key + e3.key;
              if (s2 && !this._demMatrixCache[s2]) {
                const s3 = this.sourceCache.sourceCache._source.maxzoom;
                let a3 = e3.canonical.z - i3.tileID.canonical.z;
                e3.overscaledZ > e3.canonical.z && (e3.canonical.z >= s3 ? a3 = e3.canonical.z - s3 : t2.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const o2 = e3.canonical.x - (e3.canonical.x >> a3 << a3), r2 = e3.canonical.y - (e3.canonical.y >> a3 << a3), n3 = t2.fromScaling(new Float64Array(16), [1 / (t2.EXTENT << a3), 1 / (t2.EXTENT << a3), 0]);
                t2.translate(n3, n3, [o2 * t2.EXTENT, r2 * t2.EXTENT, 0]), this._demMatrixCache[e3.key] = { matrix: n3, coord: e3 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i3 && i3.dem && i3.dem.dim || 1, u_terrain_matrix: s2 ? this._demMatrixCache[e3.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i3 && i3.dem && i3.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i3 && i3.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i3 };
            }
            getFramebuffer(t3) {
              const e3 = this.painter, i3 = e3.width / devicePixelRatio, s2 = e3.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i3 && this._fbo.height === s2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new x(e3.context, { width: i3, height: s2, data: null }, e3.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e3.context.gl.NEAREST, e3.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new x(e3.context, { width: i3, height: s2, data: null }, e3.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e3.context.gl.NEAREST, e3.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e3.context.createFramebuffer(i3, s2, true, false), this._fbo.depthAttachment.set(e3.context.createRenderbuffer(e3.context.gl.DEPTH_COMPONENT16, i3, s2))), this._fbo.colorAttachment.set("coords" === t3 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e3 = this.painter.context;
              if (this._coordsTexture)
                return this._coordsTexture;
              const i3 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let t3 = 0, e4 = 0; t3 < this._coordsTextureSize; t3++)
                for (let s3 = 0; s3 < this._coordsTextureSize; s3++, e4 += 4)
                  i3[e4 + 0] = 255 & s3, i3[e4 + 1] = 255 & t3, i3[e4 + 2] = s3 >> 8 << 4 | t3 >> 8, i3[e4 + 3] = 0;
              const s2 = new t2.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i3.buffer)), a3 = new x(e3, s2, e3.gl.RGBA, { premultiply: false });
              return a3.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._coordsTexture = a3, a3;
            }
            pointCoordinate(e3) {
              const i3 = new Uint8Array(4), s2 = this.painter.context, a3 = s2.gl;
              s2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a3.readPixels(e3.x, this.painter.height / devicePixelRatio - e3.y - 1, 1, 1, a3.RGBA, a3.UNSIGNED_BYTE, i3), s2.bindFramebuffer.set(null);
              const o2 = i3[0] + (i3[2] >> 4 << 8), r2 = i3[1] + ((15 & i3[2]) << 8), n3 = this.coordsIndex[255 - i3[3]], l2 = n3 && this.sourceCache.getTileByID(n3);
              if (!l2)
                return null;
              const c5 = this._coordsTextureSize, h2 = (1 << l2.tileID.canonical.z) * c5;
              return new t2.MercatorCoordinate((l2.tileID.canonical.x * c5 + o2) / h2, (l2.tileID.canonical.y * c5 + r2) / h2, this.getElevation(l2.tileID, o2, r2, c5));
            }
            getTerrainMesh() {
              if (this._mesh)
                return this._mesh;
              const e3 = this.painter.context, i3 = new t2.Pos3dArray(), s2 = new t2.TriangleIndexArray(), a3 = this.meshSize, o2 = t2.EXTENT / a3, r2 = a3 * a3;
              for (let t3 = 0; t3 <= a3; t3++)
                for (let e4 = 0; e4 <= a3; e4++)
                  i3.emplaceBack(e4 * o2, t3 * o2, 0);
              for (let t3 = 0; t3 < r2; t3 += a3 + 1)
                for (let e4 = 0; e4 < a3; e4++)
                  s2.emplaceBack(e4 + t3, a3 + e4 + t3 + 1, a3 + e4 + t3 + 2), s2.emplaceBack(e4 + t3, a3 + e4 + t3 + 2, e4 + t3 + 1);
              const n3 = i3.length, l2 = n3 + 2 * (a3 + 1);
              for (const e4 of [0, 1])
                for (let s3 = 0; s3 <= a3; s3++)
                  for (const a4 of [0, 1])
                    i3.emplaceBack(s3 * o2, e4 * t2.EXTENT, a4);
              for (let t3 = 0; t3 < 2 * a3; t3 += 2)
                s2.emplaceBack(l2 + t3, l2 + t3 + 1, l2 + t3 + 3), s2.emplaceBack(l2 + t3, l2 + t3 + 3, l2 + t3 + 2), s2.emplaceBack(n3 + t3, n3 + t3 + 3, n3 + t3 + 1), s2.emplaceBack(n3 + t3, n3 + t3 + 2, n3 + t3 + 3);
              const c5 = i3.length, h2 = c5 + 2 * (a3 + 1);
              for (const e4 of [0, 1])
                for (let s3 = 0; s3 <= a3; s3++)
                  for (const a4 of [0, 1])
                    i3.emplaceBack(e4 * t2.EXTENT, s3 * o2, a4);
              for (let t3 = 0; t3 < 2 * a3; t3 += 2)
                s2.emplaceBack(c5 + t3, c5 + t3 + 1, c5 + t3 + 3), s2.emplaceBack(c5 + t3, c5 + t3 + 3, c5 + t3 + 2), s2.emplaceBack(h2 + t3, h2 + t3 + 3, h2 + t3 + 1), s2.emplaceBack(h2 + t3, h2 + t3 + 2, h2 + t3 + 3);
              return this._mesh = { indexBuffer: e3.createIndexBuffer(s2), vertexBuffer: e3.createVertexBuffer(i3, ha.members), segments: t2.SegmentVector.simpleSegment(0, 0, i3.length, s2.length) }, this._mesh;
            }
            getMeshFrameDelta(e3) {
              return 2 * Math.PI * t2.earthRadius / Math.pow(2, e3) / 5;
            }
            getMinMaxElevation(t3) {
              const e3 = this.getTerrainData(t3).tile, i3 = { minElevation: null, maxElevation: null };
              return e3 && e3.dem && (i3.minElevation = e3.dem.min * this.exaggeration, i3.maxElevation = e3.dem.max * this.exaggeration), i3;
            }
          }
          class _a2 {
            constructor(t3, e3, i3) {
              this._context = t3, this._size = e3, this._tileSize = i3, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
            }
            destruct() {
              for (const t3 of this._objects)
                t3.texture.destroy(), t3.fbo.destroy();
            }
            _createObject(t3) {
              const e3 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i3 = new x(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
              return i3.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e3.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e3.colorAttachment.set(i3.texture), { id: t3, fbo: e3, texture: i3, stamp: -1, inUse: false };
            }
            getObjectForId(t3) {
              return this._objects[t3];
            }
            useObject(t3) {
              t3.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e3) => t3.id !== e3), this._recentlyUsed.push(t3.id);
            }
            stampObject(t3) {
              t3.stamp = ++this._stamp;
            }
            getOrCreateFreeObject() {
              for (const t4 of this._recentlyUsed)
                if (!this._objects[t4].inUse)
                  return this._objects[t4];
              if (this._objects.length >= this._size)
                throw new Error("No free RenderPool available, call freeAllObjects() required!");
              const t3 = this._createObject(this._objects.length);
              return this._objects.push(t3), t3;
            }
            freeObject(t3) {
              t3.inUse = false;
            }
            freeAllObjects() {
              for (const t3 of this._objects)
                this.freeObject(t3);
            }
            isFull() {
              return !(this._objects.length < this._size) && false === this._objects.some((t3) => !t3.inUse);
            }
          }
          const ma = { background: true, fill: true, line: true, raster: true, hillshade: true };
          class pa {
            constructor(t3, e3) {
              this.painter = t3, this.terrain = e3, this.pool = new _a2(t3.context, 30, e3.sourceCache.tileSize * e3.qualityFactor);
            }
            destruct() {
              this.pool.destruct();
            }
            getTexture(t3) {
              return this.pool.getObjectForId(t3.rtt[this._stacks.length - 1].id).texture;
            }
            prepareForRender(t3, e3) {
              this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t3._order.filter((i3) => !t3._layers[i3].isHidden(e3)), this._coordsDescendingInv = {};
              for (const e4 in t3.sourceCaches) {
                this._coordsDescendingInv[e4] = {};
                const i3 = t3.sourceCaches[e4].getVisibleCoordinates();
                for (const t4 of i3) {
                  const i4 = this.terrain.sourceCache.getTerrainCoords(t4);
                  for (const t5 in i4)
                    this._coordsDescendingInv[e4][t5] || (this._coordsDescendingInv[e4][t5] = []), this._coordsDescendingInv[e4][t5].push(i4[t5]);
                }
              }
              this._coordsDescendingInvStr = {};
              for (const e4 of t3._order) {
                const i3 = t3._layers[e4], s2 = i3.source;
                if (ma[i3.type] && !this._coordsDescendingInvStr[s2]) {
                  this._coordsDescendingInvStr[s2] = {};
                  for (const t4 in this._coordsDescendingInv[s2])
                    this._coordsDescendingInvStr[s2][t4] = this._coordsDescendingInv[s2][t4].map((t5) => t5.key).sort().join();
                }
              }
              for (const t4 of this._renderableTiles)
                for (const e4 in this._coordsDescendingInvStr) {
                  const i3 = this._coordsDescendingInvStr[e4][t4.tileID.key];
                  i3 && i3 !== t4.rttCoords[e4] && (t4.rtt = []);
                }
            }
            renderLayer(e3) {
              if (e3.isHidden(this.painter.transform.zoom))
                return false;
              const i3 = e3.type, s2 = this.painter, a3 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e3.id;
              if (ma[i3] && (this._prevType && ma[this._prevType] || this._stacks.push([]), this._prevType = i3, this._stacks[this._stacks.length - 1].push(e3.id), !a3))
                return true;
              if (ma[this._prevType] || ma[i3] && a3) {
                this._prevType = i3;
                const e4 = this._stacks.length - 1, a4 = this._stacks[e4] || [];
                for (const i4 of this._renderableTiles) {
                  if (this.pool.isFull() && (is(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i4), i4.rtt[e4]) {
                    const t3 = this.pool.getObjectForId(i4.rtt[e4].id);
                    if (t3.stamp === i4.rtt[e4].stamp) {
                      this.pool.useObject(t3);
                      continue;
                    }
                  }
                  const o2 = this.pool.getOrCreateFreeObject();
                  this.pool.useObject(o2), this.pool.stampObject(o2), i4.rtt[e4] = { id: o2.id, stamp: o2.stamp }, s2.context.bindFramebuffer.set(o2.fbo.framebuffer), s2.context.clear({ color: t2.Color.transparent, stencil: 0 }), s2.currentStencilSource = void 0;
                  for (let t3 = 0; t3 < a4.length; t3++) {
                    const e5 = s2.style._layers[a4[t3]], r2 = e5.source ? this._coordsDescendingInv[e5.source][i4.tileID.key] : [i4.tileID];
                    s2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), s2._renderTileClippingMasks(e5, r2), s2.renderLayer(s2, s2.style.sourceCaches[e5.source], e5, r2), e5.source && (i4.rttCoords[e5.source] = this._coordsDescendingInvStr[e5.source][i4.tileID.key]);
                  }
                }
                return is(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), ma[i3];
              }
              return false;
            }
          }
          const fa = e2, ga = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t2.config.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, va = (t3) => {
            t3.touchstart = t3.dragStart, t3.touchmoveWindow = t3.dragMove, t3.touchend = t3.dragEnd;
          }, xa = { showCompass: true, showZoom: true, visualizePitch: false };
          class ya {
            constructor(e3, s2, a3 = false) {
              this.mousedown = (e4) => {
                this.startMouse(t2.extend({}, e4, { ctrlKey: true, preventDefault: () => e4.preventDefault() }), i2.mousePos(this.element, e4)), i2.addEventListener(window, "mousemove", this.mousemove), i2.addEventListener(window, "mouseup", this.mouseup);
              }, this.mousemove = (t3) => {
                this.moveMouse(t3, i2.mousePos(this.element, t3));
              }, this.mouseup = (t3) => {
                this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
              }, this.touchstart = (t3) => {
                1 !== t3.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), i2.addEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.addEventListener(window, "touchend", this.touchend));
              }, this.touchmove = (t3) => {
                1 !== t3.targetTouches.length ? this.reset() : (this._lastPos = i2.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
              }, this.touchend = (t3) => {
                0 === t3.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this.reset = () => {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this._clickTolerance = 10;
              const o2 = e3.dragRotate._mouseRotate.getClickTolerance(), r2 = e3.dragRotate._mousePitch.getClickTolerance();
              this.element = s2, this.mouseRotate = Ls({ clickTolerance: o2, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e4, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
                const s3 = new Ms();
                return new Ps({ clickTolerance: e4, move: (t4, e5) => ({ bearingDelta: (e5.x - t4.x) * i3 }), moveStateManager: s3, enable: t3, assignEvents: va });
              })({ clickTolerance: o2, enable: true }), this.map = e3, a3 && (this.mousePitch = Rs({ clickTolerance: r2, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e4, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
                const s3 = new Ms();
                return new Ps({ clickTolerance: e4, move: (t4, e5) => ({ pitchDelta: (e5.y - t4.y) * i3 }), moveStateManager: s3, enable: t3, assignEvents: va });
              })({ clickTolerance: r2, enable: true })), i2.addEventListener(s2, "mousedown", this.mousedown), i2.addEventListener(s2, "touchstart", this.touchstart, { passive: false }), i2.addEventListener(s2, "touchcancel", this.reset);
            }
            startMouse(t3, e3) {
              this.mouseRotate.dragStart(t3, e3), this.mousePitch && this.mousePitch.dragStart(t3, e3), i2.disableDrag();
            }
            startTouch(t3, e3) {
              this.touchRotate.dragStart(t3, e3), this.touchPitch && this.touchPitch.dragStart(t3, e3), i2.disableDrag();
            }
            moveMouse(t3, e3) {
              const i3 = this.map, { bearingDelta: s2 } = this.mouseRotate.dragMove(t3, e3) || {};
              if (s2 && i3.setBearing(i3.getBearing() + s2), this.mousePitch) {
                const { pitchDelta: s3 } = this.mousePitch.dragMove(t3, e3) || {};
                s3 && i3.setPitch(i3.getPitch() + s3);
              }
            }
            moveTouch(t3, e3) {
              const i3 = this.map, { bearingDelta: s2 } = this.touchRotate.dragMove(t3, e3) || {};
              if (s2 && i3.setBearing(i3.getBearing() + s2), this.touchPitch) {
                const { pitchDelta: s3 } = this.touchPitch.dragMove(t3, e3) || {};
                s3 && i3.setPitch(i3.getPitch() + s3);
              }
            }
            off() {
              const t3 = this.element;
              i2.removeEventListener(t3, "mousedown", this.mousedown), i2.removeEventListener(t3, "touchstart", this.touchstart, { passive: false }), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend), i2.removeEventListener(t3, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              i2.enableDrag(), i2.removeEventListener(window, "mousemove", this.mousemove), i2.removeEventListener(window, "mouseup", this.mouseup), i2.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i2.removeEventListener(window, "touchend", this.touchend);
            }
          }
          let ba;
          function wa(e3, i3, s2) {
            if (e3 = new t2.LngLat(e3.lng, e3.lat), i3) {
              const a3 = new t2.LngLat(e3.lng - 360, e3.lat), o2 = new t2.LngLat(e3.lng + 360, e3.lat), r2 = s2.locationPoint(e3).distSqr(i3);
              s2.locationPoint(a3).distSqr(i3) < r2 ? e3 = a3 : s2.locationPoint(o2).distSqr(i3) < r2 && (e3 = o2);
            }
            for (; Math.abs(e3.lng - s2.center.lng) > 180; ) {
              const t3 = s2.locationPoint(e3);
              if (t3.x >= 0 && t3.y >= 0 && t3.x <= s2.width && t3.y <= s2.height)
                break;
              e3.lng > s2.center.lng ? e3.lng -= 360 : e3.lng += 360;
            }
            return e3;
          }
          const Ta = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function Ea(t3, e3, i3) {
            const s2 = t3.classList;
            for (const t4 in Ta)
              s2.remove(`maplibregl-${i3}-anchor-${t4}`);
            s2.add(`maplibregl-${i3}-anchor-${e3}`);
          }
          class Ia extends t2.Evented {
            constructor(e3) {
              if (super(), this._onKeyPress = (t3) => {
                const e4 = t3.code, i3 = t3.charCode || t3.keyCode;
                "Space" !== e4 && "Enter" !== e4 && 32 !== i3 && 13 !== i3 || this.togglePopup();
              }, this._onMapClick = (t3) => {
                const e4 = t3.originalEvent.target, i3 = this._element;
                this._popup && (e4 === i3 || i3.contains(e4)) && this.togglePopup();
              }, this._update = (t3) => {
                if (!this._map)
                  return;
                this._map.transform.renderWorldCopies && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
                let e4 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e4 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (e4 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let s2 = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? s2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (s2 = `rotateX(${this._map.getPitch()}deg)`), t3 && "moveend" !== t3.type || (this._pos = this._pos.round()), i2.setTransform(this._element, `${Ta[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${s2} ${e4}`), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                  const t4 = this._map.unproject(this._pos), e5 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                  this._element.style.opacity = t4.distanceTo(this._lngLat) > 20 * e5 ? "0.2" : "1.0", this._opacityTimeout = null;
                }, 100));
              }, this._onMove = (e4) => {
                if (!this._isDragging) {
                  const t3 = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = e4.point.dist(this._pointerdownPos) >= t3;
                }
                this._isDragging && (this._pos = e4.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t2.Event("dragstart"))), this.fire(new t2.Event("drag")));
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t2.Event("dragend")), this._state = "inactive";
              }, this._addDragHandler = (t3) => {
                this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
              }, this._anchor = e3 && e3.anchor || "center", this._color = e3 && e3.color || "#3FB1CE", this._scale = e3 && e3.scale || 1, this._draggable = e3 && e3.draggable || false, this._clickTolerance = e3 && e3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e3 && e3.rotation || 0, this._rotationAlignment = e3 && e3.rotationAlignment || "auto", this._pitchAlignment = e3 && e3.pitchAlignment && "auto" !== e3.pitchAlignment ? e3.pitchAlignment : this._rotationAlignment, e3 && e3.element)
                this._element = e3.element, this._offset = t2.Point.convert(e3 && e3.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = i2.create("div"), this._element.setAttribute("aria-label", "Map marker");
                const s2 = i2.createNS("http://www.w3.org/2000/svg", "svg"), a3 = 41, o2 = 27;
                s2.setAttributeNS(null, "display", "block"), s2.setAttributeNS(null, "height", `${a3}px`), s2.setAttributeNS(null, "width", `${o2}px`), s2.setAttributeNS(null, "viewBox", `0 0 ${o2} ${a3}`);
                const r2 = i2.createNS("http://www.w3.org/2000/svg", "g");
                r2.setAttributeNS(null, "stroke", "none"), r2.setAttributeNS(null, "stroke-width", "1"), r2.setAttributeNS(null, "fill", "none"), r2.setAttributeNS(null, "fill-rule", "evenodd");
                const n3 = i2.createNS("http://www.w3.org/2000/svg", "g");
                n3.setAttributeNS(null, "fill-rule", "nonzero");
                const l2 = i2.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                const c5 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const t3 of c5) {
                  const e4 = i2.createNS("http://www.w3.org/2000/svg", "ellipse");
                  e4.setAttributeNS(null, "opacity", "0.04"), e4.setAttributeNS(null, "cx", "10.5"), e4.setAttributeNS(null, "cy", "5.80029008"), e4.setAttributeNS(null, "rx", t3.rx), e4.setAttributeNS(null, "ry", t3.ry), l2.appendChild(e4);
                }
                const h2 = i2.createNS("http://www.w3.org/2000/svg", "g");
                h2.setAttributeNS(null, "fill", this._color);
                const u2 = i2.createNS("http://www.w3.org/2000/svg", "path");
                u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
                const d3 = i2.createNS("http://www.w3.org/2000/svg", "g");
                d3.setAttributeNS(null, "opacity", "0.25"), d3.setAttributeNS(null, "fill", "#000000");
                const _2 = i2.createNS("http://www.w3.org/2000/svg", "path");
                _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d3.appendChild(_2);
                const m4 = i2.createNS("http://www.w3.org/2000/svg", "g");
                m4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), m4.setAttributeNS(null, "fill", "#FFFFFF");
                const p3 = i2.createNS("http://www.w3.org/2000/svg", "g");
                p3.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f2 = i2.createNS("http://www.w3.org/2000/svg", "circle");
                f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
                const g3 = i2.createNS("http://www.w3.org/2000/svg", "circle");
                g3.setAttributeNS(null, "fill", "#FFFFFF"), g3.setAttributeNS(null, "cx", "5.5"), g3.setAttributeNS(null, "cy", "5.5"), g3.setAttributeNS(null, "r", "5.4999962"), p3.appendChild(f2), p3.appendChild(g3), n3.appendChild(l2), n3.appendChild(h2), n3.appendChild(d3), n3.appendChild(m4), n3.appendChild(p3), s2.appendChild(n3), s2.setAttributeNS(null, "height", a3 * this._scale + "px"), s2.setAttributeNS(null, "width", o2 * this._scale + "px"), this._element.appendChild(s2), this._offset = t2.Point.convert(e3 && e3.offset || [0, -14]);
              }
              if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
                t3.preventDefault();
              }), this._element.addEventListener("mousedown", (t3) => {
                t3.preventDefault();
              }), Ea(this._element, this._anchor, "marker"), e3 && e3.className)
                for (const t3 of e3.className.split(" "))
                  this._element.classList.add(t3);
              this._popup = null;
            }
            addTo(t3) {
              return this.remove(), this._map = t3, t3.getCanvasContainer().appendChild(this._element), t3.on("move", this._update), t3.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i2.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e3) {
              return this._lngLat = t2.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(t3) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t3) {
                if (!("offset" in t3.options)) {
                  const e3 = 38.1, i3 = 13.5, s2 = Math.sqrt(Math.pow(i3, 2) / 2);
                  t3.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e3], "bottom-left": [s2, -1 * (e3 - i3 + s2)], "bottom-right": [-s2, -1 * (e3 - i3 + s2)], left: [i3, -1 * (e3 - i3)], right: [-i3, -1 * (e3 - i3)] } : this._offset;
                }
                this._popup = t3, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const t3 = this._popup;
              return t3 ? (t3.isOpen() ? t3.remove() : t3.addTo(this._map), this) : this;
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e3) {
              return this._offset = t2.Point.convert(e3), this._update(), this;
            }
            addClassName(t3) {
              this._element.classList.add(t3);
            }
            removeClassName(t3) {
              this._element.classList.remove(t3);
            }
            toggleClassName(t3) {
              return this._element.classList.toggle(t3);
            }
            setDraggable(t3) {
              return this._draggable = !!t3, this._map && (t3 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(t3) {
              return this._rotation = t3 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(t3) {
              return this._rotationAlignment = t3 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(t3) {
              return this._pitchAlignment = t3 && "auto" !== t3 ? t3 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
          }
          const Sa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let Ca = 0, Pa = false;
          const Da = { maxWidth: 100, unit: "metric" };
          function za(t3, e3, i3) {
            const s2 = i3 && i3.maxWidth || 100, a3 = t3._container.clientHeight / 2, o2 = t3.unproject([0, a3]), r2 = t3.unproject([s2, a3]), n3 = o2.distanceTo(r2);
            if (i3 && "imperial" === i3.unit) {
              const i4 = 3.2808 * n3;
              i4 > 5280 ? Ma(e3, s2, i4 / 5280, t3._getUIString("ScaleControl.Miles")) : Ma(e3, s2, i4, t3._getUIString("ScaleControl.Feet"));
            } else
              i3 && "nautical" === i3.unit ? Ma(e3, s2, n3 / 1852, t3._getUIString("ScaleControl.NauticalMiles")) : n3 >= 1e3 ? Ma(e3, s2, n3 / 1e3, t3._getUIString("ScaleControl.Kilometers")) : Ma(e3, s2, n3, t3._getUIString("ScaleControl.Meters"));
          }
          function Ma(t3, e3, i3, s2) {
            const a3 = function(t4) {
              const e4 = Math.pow(10, `${Math.floor(t4)}`.length - 1);
              let i4 = t4 / e4;
              return i4 = i4 >= 10 ? 10 : i4 >= 5 ? 5 : i4 >= 3 ? 3 : i4 >= 2 ? 2 : i4 >= 1 ? 1 : function(t5) {
                const e5 = Math.pow(10, Math.ceil(-Math.log(t5) / Math.LN10));
                return Math.round(t5 * e5) / e5;
              }(i4), e4 * i4;
            }(i3);
            t3.style.width = e3 * (a3 / i3) + "px", t3.innerHTML = `${a3}&nbsp;${s2}`;
          }
          const Aa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, La = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Ra(e3) {
            if (e3) {
              if ("number" == typeof e3) {
                const i3 = Math.round(Math.sqrt(0.5 * Math.pow(e3, 2)));
                return { center: new t2.Point(0, 0), top: new t2.Point(0, e3), "top-left": new t2.Point(i3, i3), "top-right": new t2.Point(-i3, i3), bottom: new t2.Point(0, -e3), "bottom-left": new t2.Point(i3, -i3), "bottom-right": new t2.Point(-i3, -i3), left: new t2.Point(e3, 0), right: new t2.Point(-e3, 0) };
              }
              if (e3 instanceof t2.Point || Array.isArray(e3)) {
                const i3 = t2.Point.convert(e3);
                return { center: i3, top: i3, "top-left": i3, "top-right": i3, bottom: i3, "bottom-left": i3, "bottom-right": i3, left: i3, right: i3 };
              }
              return { center: t2.Point.convert(e3.center || [0, 0]), top: t2.Point.convert(e3.top || [0, 0]), "top-left": t2.Point.convert(e3["top-left"] || [0, 0]), "top-right": t2.Point.convert(e3["top-right"] || [0, 0]), bottom: t2.Point.convert(e3.bottom || [0, 0]), "bottom-left": t2.Point.convert(e3["bottom-left"] || [0, 0]), "bottom-right": t2.Point.convert(e3["bottom-right"] || [0, 0]), left: t2.Point.convert(e3.left || [0, 0]), right: t2.Point.convert(e3.right || [0, 0]) };
            }
            return Ra(new t2.Point(0, 0));
          }
          const ka = { extend: (e3, ...i3) => t2.extend(e3, ...i3), run(t3) {
            t3();
          }, logToElement(t3, e3 = false, i3 = "log") {
            const s2 = window.document.getElementById(i3);
            s2 && (e3 && (s2.innerHTML = ""), s2.innerHTML += `<br>${t3}`);
          } }, Ba = e2;
          class Fa {
            static get version() {
              return Ba;
            }
            static get workerCount() {
              return et.workerCount;
            }
            static set workerCount(t3) {
              et.workerCount = t3;
            }
            static get maxParallelImageRequests() {
              return t2.config.MAX_PARALLEL_IMAGE_REQUESTS;
            }
            static set maxParallelImageRequests(e3) {
              t2.config.MAX_PARALLEL_IMAGE_REQUESTS = e3;
            }
            static get workerUrl() {
              return t2.config.WORKER_URL;
            }
            static set workerUrl(e3) {
              t2.config.WORKER_URL = e3;
            }
            static addProtocol(e3, i3) {
              t2.config.REGISTERED_PROTOCOLS[e3] = i3;
            }
            static removeProtocol(e3) {
              delete t2.config.REGISTERED_PROTOCOLS[e3];
            }
          }
          return Fa.Map = class extends oa {
            constructor(e3) {
              if (t2.PerformanceUtils.mark(t2.PerformanceMarkers.create), null != (e3 = t2.extend({}, ga, e3)).minZoom && null != e3.maxZoom && e3.minZoom > e3.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != e3.minPitch && null != e3.maxPitch && e3.minPitch > e3.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != e3.minPitch && e3.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != e3.maxPitch && e3.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (super(new ns(e3.minZoom, e3.maxZoom, e3.minPitch, e3.maxPitch, e3.renderWorldCopies), { bearingSnap: e3.bearingSnap }), this._cooperativeGesturesOnWheel = (t3) => {
                this._onCooperativeGesture(t3, t3[this._metaKey], 1);
              }, this._contextLost = (e4) => {
                e4.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t2.Event("webglcontextlost", { originalEvent: e4 }));
              }, this._contextRestored = (e4) => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new t2.Event("webglcontextrestored", { originalEvent: e4 }));
              }, this._onMapScroll = (t3) => {
                if (t3.target === this._container)
                  return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
              }, this._onWindowOnline = () => {
                this._update();
              }, this._interactive = e3.interactive, this._cooperativeGestures = e3.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e3.maxTileCacheSize, this._maxTileCacheZoomLevels = e3.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e3.preserveDrawingBuffer, this._antialias = e3.antialias, this._trackResize = e3.trackResize, this._bearingSnap = e3.bearingSnap, this._refreshExpiredTiles = e3.refreshExpiredTiles, this._fadeDuration = e3.fadeDuration, this._crossSourceCollisions = e3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e3.collectResourceTiming, this._renderTaskQueue = new la(), this._controls = [], this._mapId = t2.uniqueId(), this._locale = t2.extend({}, ca, e3.locale), this._clickTolerance = e3.clickTolerance, this._overridePixelRatio = e3.pixelRatio, this._maxCanvasSize = e3.maxCanvasSize, this.transformCameraUpdate = e3.transformCameraUpdate, this._imageQueueHandle = c4.addThrottleControl(() => this.isMoving()), this._requestManager = new u(e3.transformRequest), "string" == typeof e3.container) {
                if (this._container = document.getElementById(e3.container), !this._container)
                  throw new Error(`Container '${e3.container}' not found.`);
              } else {
                if (!(e3.container instanceof HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e3.container;
              }
              if (e3.maxBounds && this.setMaxBounds(e3.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), this.once("idle", () => {
                this._idleTriggered = true;
              }), "undefined" != typeof window) {
                addEventListener("online", this._onWindowOnline, false);
                let t3 = false;
                this._resizeObserver = new ResizeObserver((e4) => {
                  t3 ? this._trackResize && this.resize(e4)._update() : t3 = true;
                }), this._resizeObserver.observe(this._container);
              }
              this.handlers = new aa(this, e3), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e3.hash && new ls("string" == typeof e3.hash && e3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e3.center, zoom: e3.zoom, bearing: e3.bearing, pitch: e3.pitch }), e3.bounds && (this.resize(), this.fitBounds(e3.bounds, t2.extend({}, e3.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e3.localIdeographFontFamily, this._validateStyle = e3.validateStyle, e3.style && this.setStyle(e3.style, { localIdeographFontFamily: e3.localIdeographFontFamily }), e3.attributionControl && this.addControl(new ra({ customAttribution: e3.customAttribution })), e3.maplibreLogo && this.addControl(new na(), e3.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (e4) => {
                this._update("style" === e4.dataType), this.fire(new t2.Event(`${e4.dataType}data`, e4));
              }), this.on("dataloading", (e4) => {
                this.fire(new t2.Event(`${e4.dataType}dataloading`, e4));
              }), this.on("dataabort", (e4) => {
                this.fire(new t2.Event("sourcedataabort", e4));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e3, i3) {
              if (void 0 === i3 && (i3 = e3.getDefaultPosition ? e3.getDefaultPosition() : "top-right"), !e3 || !e3.onAdd)
                return this.fire(new t2.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const s2 = e3.onAdd(this);
              this._controls.push(e3);
              const a3 = this._controlPositions[i3];
              return -1 !== i3.indexOf("bottom") ? a3.insertBefore(s2, a3.firstChild) : a3.appendChild(s2), this;
            }
            removeControl(e3) {
              if (!e3 || !e3.onRemove)
                return this.fire(new t2.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i3 = this._controls.indexOf(e3);
              return i3 > -1 && this._controls.splice(i3, 1), e3.onRemove(this), this;
            }
            hasControl(t3) {
              return this._controls.indexOf(t3) > -1;
            }
            calculateCameraOptionsFromTo(t3, e3, i3, s2) {
              return null == s2 && this.terrain && (s2 = this.transform.getElevation(i3, this.terrain)), super.calculateCameraOptionsFromTo(t3, e3, i3, s2);
            }
            resize(e3) {
              var i3;
              const s2 = this._containerDimensions(), a3 = s2[0], o2 = s2[1], r2 = this._getClampedPixelRatio(a3, o2);
              if (this._resizeCanvas(a3, o2, r2), this.painter.resize(a3, o2, r2), this.painter.overLimit()) {
                const t3 = this.painter.context.gl;
                this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
                const e4 = this._getClampedPixelRatio(a3, o2);
                this._resizeCanvas(a3, o2, e4), this.painter.resize(a3, o2, e4);
              }
              this.transform.resize(a3, o2), null === (i3 = this._requestedCameraState) || void 0 === i3 || i3.resize(a3, o2);
              const n3 = !this._moving;
              return n3 && (this.stop(), this.fire(new t2.Event("movestart", e3)).fire(new t2.Event("move", e3))), this.fire(new t2.Event("resize", e3)), n3 && this.fire(new t2.Event("moveend", e3)), this;
            }
            _getClampedPixelRatio(t3, e3) {
              const { 0: i3, 1: s2 } = this._maxCanvasSize, a3 = this.getPixelRatio(), o2 = t3 * a3, r2 = e3 * a3;
              return Math.min(o2 > i3 ? i3 / o2 : 1, r2 > s2 ? s2 / r2 : 1) * a3;
            }
            getPixelRatio() {
              var t3;
              return null !== (t3 = this._overridePixelRatio) && void 0 !== t3 ? t3 : devicePixelRatio;
            }
            setPixelRatio(t3) {
              this._overridePixelRatio = t3, this.resize();
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(t3) {
              return this.transform.setMaxBounds(L.convert(t3)), this._update();
            }
            setMinZoom(t3) {
              if ((t3 = null == t3 ? -2 : t3) >= -2 && t3 <= this.transform.maxZoom)
                return this.transform.minZoom = t3, this._update(), this.getZoom() < t3 && this.setZoom(t3), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t3) {
              if ((t3 = null == t3 ? 22 : t3) >= this.transform.minZoom)
                return this.transform.maxZoom = t3, this._update(), this.getZoom() > t3 && this.setZoom(t3), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t3) {
              if ((t3 = null == t3 ? 0 : t3) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t3 >= 0 && t3 <= this.transform.maxPitch)
                return this.transform.minPitch = t3, this._update(), this.getPitch() < t3 && this.setPitch(t3), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t3) {
              if ((t3 = null == t3 ? 60 : t3) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t3 >= this.transform.minPitch)
                return this.transform.maxPitch = t3, this._update(), this.getPitch() > t3 && this.setPitch(t3), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t3) {
              return this.transform.renderWorldCopies = t3, this._update();
            }
            getCooperativeGestures() {
              return this._cooperativeGestures;
            }
            setCooperativeGestures(t3) {
              return this._cooperativeGestures = t3, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
            }
            project(e3) {
              return this.transform.locationPoint(t2.LngLat.convert(e3), this.style && this.terrain);
            }
            unproject(e3) {
              return this.transform.pointLocation(t2.Point.convert(e3), this.terrain);
            }
            isMoving() {
              var t3;
              return this._moving || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isMoving());
            }
            isZooming() {
              var t3;
              return this._zooming || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isZooming());
            }
            isRotating() {
              var t3;
              return this._rotating || (null === (t3 = this.handlers) || void 0 === t3 ? void 0 : t3.isRotating());
            }
            _createDelegatedListener(t3, e3, i3) {
              if ("mouseenter" === t3 || "mouseover" === t3) {
                let s2 = false;
                const a3 = (a4) => {
                  const o2 = this.getLayer(e3) ? this.queryRenderedFeatures(a4.point, { layers: [e3] }) : [];
                  o2.length ? s2 || (s2 = true, i3.call(this, new gs(t3, this, a4.originalEvent, { features: o2 }))) : s2 = false;
                };
                return { layer: e3, listener: i3, delegates: { mousemove: a3, mouseout: () => {
                  s2 = false;
                } } };
              }
              if ("mouseleave" === t3 || "mouseout" === t3) {
                let s2 = false;
                const a3 = (a4) => {
                  (this.getLayer(e3) ? this.queryRenderedFeatures(a4.point, { layers: [e3] }) : []).length ? s2 = true : s2 && (s2 = false, i3.call(this, new gs(t3, this, a4.originalEvent)));
                }, o2 = (e4) => {
                  s2 && (s2 = false, i3.call(this, new gs(t3, this, e4.originalEvent)));
                };
                return { layer: e3, listener: i3, delegates: { mousemove: a3, mouseout: o2 } };
              }
              {
                const s2 = (t4) => {
                  const s3 = this.getLayer(e3) ? this.queryRenderedFeatures(t4.point, { layers: [e3] }) : [];
                  s3.length && (t4.features = s3, i3.call(this, t4), delete t4.features);
                };
                return { layer: e3, listener: i3, delegates: { [t3]: s2 } };
              }
            }
            on(t3, e3, i3) {
              if (void 0 === i3)
                return super.on(t3, e3);
              const s2 = this._createDelegatedListener(t3, e3, i3);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t3] = this._delegatedListeners[t3] || [], this._delegatedListeners[t3].push(s2);
              for (const t4 in s2.delegates)
                this.on(t4, s2.delegates[t4]);
              return this;
            }
            once(t3, e3, i3) {
              if (void 0 === i3)
                return super.once(t3, e3);
              const s2 = this._createDelegatedListener(t3, e3, i3);
              for (const t4 in s2.delegates)
                this.once(t4, s2.delegates[t4]);
              return this;
            }
            off(t3, e3, i3) {
              return void 0 === i3 ? super.off(t3, e3) : (this._delegatedListeners && this._delegatedListeners[t3] && ((s2) => {
                const a3 = this._delegatedListeners[t3];
                for (let t4 = 0; t4 < a3.length; t4++) {
                  const s3 = a3[t4];
                  if (s3.layer === e3 && s3.listener === i3) {
                    for (const t5 in s3.delegates)
                      this.off(t5, s3.delegates[t5]);
                    return a3.splice(t4, 1), this;
                  }
                }
              })(), this);
            }
            queryRenderedFeatures(e3, i3) {
              if (!this.style)
                return [];
              let s2;
              const a3 = e3 instanceof t2.Point || Array.isArray(e3), o2 = a3 ? e3 : [[0, 0], [this.transform.width, this.transform.height]];
              if (i3 = i3 || (a3 ? {} : e3) || {}, o2 instanceof t2.Point || "number" == typeof o2[0])
                s2 = [t2.Point.convert(o2)];
              else {
                const e4 = t2.Point.convert(o2[0]), i4 = t2.Point.convert(o2[1]);
                s2 = [e4, new t2.Point(i4.x, e4.y), i4, new t2.Point(e4.x, i4.y), e4];
              }
              return this.style.queryRenderedFeatures(s2, i3, this.transform);
            }
            querySourceFeatures(t3, e3) {
              return this.style.querySourceFeatures(t3, e3);
            }
            setStyle(e3, i3) {
              return false !== (i3 = t2.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i3)).diff && i3.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e3 ? (this._diffStyle(e3, i3), this) : (this._localIdeographFontFamily = i3.localIdeographFontFamily, this._updateStyle(e3, i3));
            }
            setTransformRequest(t3) {
              return this._requestManager.setTransformRequest(t3), this;
            }
            _getUIString(t3) {
              const e3 = this._locale[t3];
              if (null == e3)
                throw new Error(`Missing UI string '${t3}'`);
              return e3;
            }
            _updateStyle(t3, e3) {
              if (e3.transformStyle && this.style && !this.style._loaded)
                return void this.style.once("style.load", () => this._updateStyle(t3, e3));
              const i3 = this.style && e3.transformStyle ? this.style.serialize() : void 0;
              return this.style && (this.style.setEventedParent(null), this.style._remove(!t3)), t3 ? (this.style = new ae(this, e3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t3 ? this.style.loadURL(t3, e3, i3) : this.style.loadJSON(t3, e3, i3), this) : (delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new ae(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e3, i3) {
              if ("string" == typeof e3) {
                const s2 = this._requestManager.transformRequest(e3, h.Style);
                t2.getJSON(s2, (e4, s3) => {
                  e4 ? this.fire(new t2.ErrorEvent(e4)) : s3 && this._updateDiff(s3, i3);
                });
              } else
                "object" == typeof e3 && this._updateDiff(e3, i3);
            }
            _updateDiff(e3, i3) {
              try {
                this.style.setState(e3, i3) && this._update(true);
              } catch (s2) {
                t2.warnOnce(`Unable to perform style diff: ${s2.message || s2.error || s2}.  Rebuilding the style from scratch.`), this._updateStyle(e3, i3);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t2.warnOnce("There is no style added to the map.");
            }
            addSource(t3, e3) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t3, e3), this._update(true);
            }
            isSourceLoaded(e3) {
              const i3 = this.style && this.style.sourceCaches[e3];
              if (void 0 !== i3)
                return i3.loaded();
              this.fire(new t2.ErrorEvent(new Error(`There is no source with ID '${e3}'`)));
            }
            setTerrain(e3) {
              if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e3) {
                const i3 = this.style.sourceCaches[e3.source];
                if (!i3)
                  throw new Error(`cannot load terrain, because there exists no source with ID: ${e3.source}`);
                for (const i4 in this.style._layers) {
                  const s2 = this.style._layers[i4];
                  "hillshade" === s2.type && s2.source === e3.source && t2.warnOnce("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
                }
                this.terrain = new da(this.painter, i3, e3), this.painter.renderToTexture = new pa(this.painter, this.terrain), this.transform.updateElevation(this.terrain), this._terrainDataCallback = (t3) => {
                  "style" === t3.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t3.dataType && t3.tile && (t3.sourceId === e3.source && this.transform.updateElevation(this.terrain), this.terrain.sourceCache.freeRtt(t3.tile.tileID));
                }, this.style.on("data", this._terrainDataCallback);
              } else
                this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.updateElevation(this.terrain);
              return this.fire(new t2.Event("terrain", { terrain: e3 })), this;
            }
            getTerrain() {
              return this.terrain && this.terrain.options;
            }
            areTilesLoaded() {
              const t3 = this.style && this.style.sourceCaches;
              for (const e3 in t3) {
                const i3 = t3[e3]._tiles;
                for (const t4 in i3) {
                  const e4 = i3[t4];
                  if ("loaded" !== e4.state && "errored" !== e4.state)
                    return false;
                }
              }
              return true;
            }
            addSourceType(t3, e3, i3) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t3, e3, i3);
            }
            removeSource(t3) {
              return this.style.removeSource(t3), this._update(true);
            }
            getSource(t3) {
              return this.style.getSource(t3);
            }
            addImage(e3, i3, s2 = {}) {
              const { pixelRatio: a3 = 1, sdf: o2 = false, stretchX: r2, stretchY: n3, content: l2 } = s2;
              if (this._lazyInitEmptyStyle(), !(i3 instanceof HTMLImageElement || t2.isImageBitmap(i3))) {
                if (void 0 === i3.width || void 0 === i3.height)
                  return this.fire(new t2.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: s3, height: c5, data: h2 } = i3, u2 = i3;
                  return this.style.addImage(e3, { data: new t2.RGBAImage({ width: s3, height: c5 }, new Uint8Array(h2)), pixelRatio: a3, stretchX: r2, stretchY: n3, content: l2, sdf: o2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e3), this;
                }
              }
              {
                const { width: s3, height: c5, data: h2 } = t2.browser.getImageData(i3);
                this.style.addImage(e3, { data: new t2.RGBAImage({ width: s3, height: c5 }, h2), pixelRatio: a3, stretchX: r2, stretchY: n3, content: l2, sdf: o2, version: 0 });
              }
            }
            updateImage(e3, i3) {
              const s2 = this.style.getImage(e3);
              if (!s2)
                return this.fire(new t2.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const a3 = i3 instanceof HTMLImageElement || t2.isImageBitmap(i3) ? t2.browser.getImageData(i3) : i3, { width: o2, height: r2, data: n3 } = a3;
              if (void 0 === o2 || void 0 === r2)
                return this.fire(new t2.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (o2 !== s2.data.width || r2 !== s2.data.height)
                return this.fire(new t2.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const l2 = !(i3 instanceof HTMLImageElement || t2.isImageBitmap(i3));
              return s2.data.replace(n3, l2), this.style.updateImage(e3, s2), this;
            }
            getImage(t3) {
              return this.style.getImage(t3);
            }
            hasImage(e3) {
              return e3 ? !!this.style.getImage(e3) : (this.fire(new t2.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(t3) {
              this.style.removeImage(t3);
            }
            loadImage(t3, e3) {
              c4.getImage(this._requestManager.transformRequest(t3, h.Image), e3);
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t3, e3) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t3, e3), this._update(true);
            }
            moveLayer(t3, e3) {
              return this.style.moveLayer(t3, e3), this._update(true);
            }
            removeLayer(t3) {
              return this.style.removeLayer(t3), this._update(true);
            }
            getLayer(t3) {
              return this.style.getLayer(t3);
            }
            setLayerZoomRange(t3, e3, i3) {
              return this.style.setLayerZoomRange(t3, e3, i3), this._update(true);
            }
            setFilter(t3, e3, i3 = {}) {
              return this.style.setFilter(t3, e3, i3), this._update(true);
            }
            getFilter(t3) {
              return this.style.getFilter(t3);
            }
            setPaintProperty(t3, e3, i3, s2 = {}) {
              return this.style.setPaintProperty(t3, e3, i3, s2), this._update(true);
            }
            getPaintProperty(t3, e3) {
              return this.style.getPaintProperty(t3, e3);
            }
            setLayoutProperty(t3, e3, i3, s2 = {}) {
              return this.style.setLayoutProperty(t3, e3, i3, s2), this._update(true);
            }
            getLayoutProperty(t3, e3) {
              return this.style.getLayoutProperty(t3, e3);
            }
            setGlyphs(t3, e3 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setGlyphs(t3, e3), this._update(true);
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(t3, e3, i3 = {}) {
              return this._lazyInitEmptyStyle(), this.style.addSprite(t3, e3, i3, (t4) => {
                t4 || this._update(true);
              }), this;
            }
            removeSprite(t3) {
              return this._lazyInitEmptyStyle(), this.style.removeSprite(t3), this._update(true);
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(t3, e3 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSprite(t3, e3, (t4) => {
                t4 || this._update(true);
              }), this;
            }
            setLight(t3, e3 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(t3, e3), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setFeatureState(t3, e3) {
              return this.style.setFeatureState(t3, e3), this._update();
            }
            removeFeatureState(t3, e3) {
              return this.style.removeFeatureState(t3, e3), this._update();
            }
            getFeatureState(t3) {
              return this.style.getFeatureState(t3);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let t3 = 0, e3 = 0;
              return this._container && (t3 = this._container.clientWidth || 400, e3 = this._container.clientHeight || 300), [t3, e3];
            }
            _setupContainer() {
              const t3 = this._container;
              t3.classList.add("maplibregl-map");
              const e3 = this._canvasContainer = i2.create("div", "maplibregl-canvas-container", t3);
              this._interactive && e3.classList.add("maplibregl-interactive"), this._canvas = i2.create("canvas", "maplibregl-canvas", e3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              const s2 = this._containerDimensions(), a3 = this._getClampedPixelRatio(s2[0], s2[1]);
              this._resizeCanvas(s2[0], s2[1], a3);
              const o2 = this._controlContainer = i2.create("div", "maplibregl-control-container", t3), r2 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t4) => {
                r2[t4] = i2.create("div", `maplibregl-ctrl-${t4} `, o2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _setupCooperativeGestures() {
              this._cooperativeGesturesScreen = i2.create("div", "maplibregl-cooperative-gesture-screen", this._container);
              let t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
              0 === navigator.platform.indexOf("Mac") && (t3 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t3}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
            }
            _destroyCooperativeGestures() {
              i2.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
            }
            _resizeCanvas(t3, e3, i3) {
              this._canvas.width = Math.floor(i3 * t3), this._canvas.height = Math.floor(i3 * e3), this._canvas.style.width = `${t3}px`, this._canvas.style.height = `${e3}px`;
            }
            _setupPainter() {
              const t3 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
              let e3 = null;
              this._canvas.addEventListener("webglcontextcreationerror", (i4) => {
                e3 = { requestedAttributes: t3 }, i4 && (e3.statusMessage = i4.statusMessage, e3.type = i4.type);
              }, { once: true });
              const i3 = this._canvas.getContext("webgl2", t3) || this._canvas.getContext("webgl", t3);
              if (!i3) {
                const t4 = "Failed to initialize WebGL";
                throw e3 ? (e3.message = t4, new Error(JSON.stringify(e3))) : new Error(t4);
              }
              this.painter = new ss(i3, this.transform), s.testSupport(i3);
            }
            _onCooperativeGesture(t3, e3, i3) {
              return !e3 && i3 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
                this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
              }, 100)), false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(t3) {
              return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t3, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(t3) {
              return this._update(), this._renderTaskQueue.add(t3);
            }
            _cancelRenderFrame(t3) {
              this._renderTaskQueue.remove(t3);
            }
            _render(e3) {
              const i3 = this._idleTriggered ? this._fadeDuration : 0;
              if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e3), this._removed)
                return;
              let s2 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e4 = this.transform.zoom, a4 = t2.browser.now();
                this.style.zoomHistory.update(e4, a4);
                const o2 = new t2.EvaluationParameters(e4, { now: a4, fadeDuration: i3, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r2 = o2.crossFadingFactor();
                1 === r2 && r2 === this._crossFadingFactor || (s2 = true, this._crossFadingFactor = r2), this.style.update(o2);
              }
              this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain && this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.updateElevation(this.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i3, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i3, showPadding: this.showPadding }), this.fire(new t2.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, t2.PerformanceUtils.mark(t2.PerformanceMarkers.load), this.fire(new t2.Event("load"))), this.style && (this.style.hasTransitions() || s2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
              const a3 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return a3 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t2.Event("idle")), !this._loaded || this._fullyLoaded || a3 || (this._fullyLoaded = true, t2.PerformanceUtils.mark(t2.PerformanceMarkers.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
            }
            remove() {
              var e3;
              this._hash && this._hash.remove();
              for (const t3 of this._controls)
                t3.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), c4.removeThrottleControl(this._imageQueueHandle), null === (e3 = this._resizeObserver) || void 0 === e3 || e3.disconnect();
              const s2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              s2 && s2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), i2.remove(this._canvasContainer), i2.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), t2.PerformanceUtils.clearMetrics(), this._removed = true, this.fire(new t2.Event("remove"));
            }
            triggerRepaint() {
              this.style && !this._frame && (this._frame = t2.browser.frame((e3) => {
                t2.PerformanceUtils.frame(e3), this._frame = null, this._render(e3);
              }));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t3) {
              this._showTileBoundaries !== t3 && (this._showTileBoundaries = t3, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t3) {
              this._showPadding !== t3 && (this._showPadding = t3, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t3) {
              this._showCollisionBoxes !== t3 && (this._showCollisionBoxes = t3, t3 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t3) {
              this._showOverdrawInspector !== t3 && (this._showOverdrawInspector = t3, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t3) {
              this._repaint !== t3 && (this._repaint = t3, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t3) {
              this._vertices = t3, this._update();
            }
            get version() {
              return fa;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
          }, Fa.NavigationControl = class {
            constructor(e3) {
              this._updateZoomButtons = () => {
                const t3 = this._map.getZoom(), e4 = t3 === this._map.getMaxZoom(), i3 = t3 === this._map.getMinZoom();
                this._zoomInButton.disabled = e4, this._zoomOutButton.disabled = i3, this._zoomInButton.setAttribute("aria-disabled", e4.toString()), this._zoomOutButton.setAttribute("aria-disabled", i3.toString());
              }, this._rotateCompassArrow = () => {
                const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
                this._compassIcon.style.transform = t3;
              }, this._setButtonTitle = (t3, e4) => {
                const i3 = this._map._getUIString(`NavigationControl.${e4}`);
                t3.title = i3, t3.setAttribute("aria-label", i3);
              }, this.options = t2.extend({}, xa, e3), this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), i2.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
              }), this._compassIcon = i2.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            onAdd(t3) {
              return this._map = t3, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ya(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              i2.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(t3, e3) {
              const s2 = i2.create("button", t3, this._container);
              return s2.type = "button", s2.addEventListener("click", e3), s2;
            }
          }, Fa.GeolocateControl = class extends t2.Evented {
            constructor(e3) {
              super(), this._onSuccess = (e4) => {
                if (this._map) {
                  if (this._isOutOfMapMaxBounds(e4))
                    return this._setErrorState(), this.fire(new t2.Event("outofmaxbounds", e4)), this._updateMarker(), void this._finish();
                  if (this.options.trackUserLocation)
                    switch (this._lastKnownPosition = e4, this._watchState) {
                      case "WAITING_ACTIVE":
                      case "ACTIVE_LOCK":
                      case "ACTIVE_ERROR":
                        this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                        break;
                      case "BACKGROUND":
                      case "BACKGROUND_ERROR":
                        this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                        break;
                      default:
                        throw new Error(`Unexpected watchState ${this._watchState}`);
                    }
                  this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e4), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e4), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t2.Event("geolocate", e4)), this._finish();
                }
              }, this._updateCamera = (e4) => {
                const i3 = new t2.LngLat(e4.coords.longitude, e4.coords.latitude), s2 = e4.coords.accuracy, a3 = this._map.getBearing(), o2 = t2.extend({ bearing: a3 }, this.options.fitBoundsOptions), r2 = L.fromLngLat(i3, s2);
                this._map.fitBounds(r2, o2, { geolocateSource: true });
              }, this._updateMarker = (e4) => {
                if (e4) {
                  const i3 = new t2.LngLat(e4.coords.longitude, e4.coords.latitude);
                  this._accuracyCircleMarker.setLngLat(i3).addTo(this._map), this._userLocationDotMarker.setLngLat(i3).addTo(this._map), this._accuracy = e4.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                } else
                  this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
              }, this._onZoom = () => {
                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              }, this._onError = (e4) => {
                if (this._map) {
                  if (this.options.trackUserLocation)
                    if (1 === e4.code) {
                      this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                      const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                      this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3), void 0 !== this._geolocationWatchID && this._clearWatch();
                    } else {
                      if (3 === e4.code && Pa)
                        return;
                      this._setErrorState();
                    }
                  "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t2.Event("error", e4)), this._finish();
                }
              }, this._finish = () => {
                this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
              }, this._setupUI = (e4) => {
                if (this._map) {
                  if (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = i2.create("button", "maplibregl-ctrl-geolocate", this._container), i2.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e4) {
                    t2.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                    const e5 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.disabled = true, this._geolocateButton.title = e5, this._geolocateButton.setAttribute("aria-label", e5);
                  } else {
                    const t3 = this._map._getUIString("GeolocateControl.FindMyLocation");
                    this._geolocateButton.title = t3, this._geolocateButton.setAttribute("aria-label", t3);
                  }
                  this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i2.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ia({ element: this._dotElement }), this._circleElement = i2.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ia({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e5) => {
                    e5.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e5.originalEvent && "resize" === e5.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t2.Event("trackuserlocationend")));
                  });
                }
              }, this.options = t2.extend({}, Sa, e3);
            }
            onAdd(t3) {
              return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t4, e3 = false) {
                void 0 === ba || e3 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((e4) => {
                  ba = "denied" !== e4.state, t4(ba);
                }).catch(() => {
                  ba = !!window.navigator.geolocation, t4(ba);
                }) : (ba = !!window.navigator.geolocation, t4(ba)) : t4(ba);
              }(this._setupUI), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i2.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ca = 0, Pa = false;
            }
            _isOutOfMapMaxBounds(t3) {
              const e3 = this._map.getMaxBounds(), i3 = t3.coords;
              return e3 && (i3.longitude < e3.getWest() || i3.longitude > e3.getEast() || i3.latitude < e3.getSouth() || i3.latitude > e3.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadius() {
              const t3 = this._map.getBounds(), e3 = t3.getSouthEast(), i3 = t3.getNorthEast(), s2 = e3.distanceTo(i3), a3 = Math.ceil(this._accuracy / (s2 / this._map._container.clientHeight) * 2);
              this._circleElement.style.width = `${a3}px`, this._circleElement.style.height = `${a3}px`;
            }
            trigger() {
              if (!this._setup)
                return t2.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t2.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    Ca--, Pa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t2.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t2.Event("trackuserlocationstart"));
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let t3;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ca++, Ca > 1 ? (t3 = { maximumAge: 6e5, timeout: 0 }, Pa = true) : (t3 = this.options.positionOptions, Pa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t3);
                }
              } else
                window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, Fa.AttributionControl = ra, Fa.LogoControl = na, Fa.ScaleControl = class {
            constructor(e3) {
              this._onMove = () => {
                za(this._map, this._container, this.options);
              }, this.setUnit = (t3) => {
                this.options.unit = t3, za(this._map, this._container, this.options);
              }, this.options = t2.extend({}, Da, e3);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t3) {
              return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t3.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              i2.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
          }, Fa.FullscreenControl = class extends t2.Evented {
            constructor(e3 = {}) {
              super(), this._onFullscreenChange = () => {
                (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
              }, this._onClickFullscreen = () => {
                this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
              }, this._fullscreen = false, e3 && e3.container && (e3.container instanceof HTMLElement ? this._container = e3.container : t2.warnOnce("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(t3) {
              return this._map = t3, this._container || (this._container = this._map.getContainer()), this._controlContainer = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
            }
            onRemove() {
              i2.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _setupUI() {
              const t3 = this._fullscreenButton = i2.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
              i2.create("span", "maplibregl-ctrl-icon", t3).setAttribute("aria-hidden", "true"), t3.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _updateTitle() {
              const t3 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", t3), this._fullscreenButton.title = t3;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t2.Event("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new t2.Event("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
            }
            _exitFullscreen() {
              window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
            }
          }, Fa.TerrainControl = class {
            constructor(t3) {
              this._toggleTerrain = () => {
                this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
              }, this._updateTerrainIcon = () => {
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
              }, this.options = t3;
            }
            onAdd(t3) {
              return this._map = t3, this._container = i2.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = i2.create("button", "maplibregl-ctrl-terrain", this._container), i2.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              i2.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
          }, Fa.Popup = class extends t2.Evented {
            constructor(e3) {
              super(), this.remove = () => (this._content && i2.remove(this._content), this._container && (i2.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t2.Event("close")), this), this._onMouseUp = (t3) => {
                this._update(t3.point);
              }, this._onMouseMove = (t3) => {
                this._update(t3.point);
              }, this._onDrag = (t3) => {
                this._update(t3.point);
              }, this._update = (t3) => {
                if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                  return;
                if (!this._container) {
                  if (this._container = i2.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i2.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                    for (const t4 of this.options.className.split(" "))
                      this._container.classList.add(t4);
                  this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                }
                if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t3)
                  return;
                const e4 = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
                let s2 = this.options.anchor;
                const a3 = Ra(this.options.offset);
                if (!s2) {
                  const t4 = this._container.offsetWidth, i3 = this._container.offsetHeight;
                  let o3;
                  o3 = e4.y + a3.bottom.y < i3 ? ["top"] : e4.y > this._map.transform.height - i3 ? ["bottom"] : [], e4.x < t4 / 2 ? o3.push("left") : e4.x > this._map.transform.width - t4 / 2 && o3.push("right"), s2 = 0 === o3.length ? "bottom" : o3.join("-");
                }
                const o2 = e4.add(a3[s2]).round();
                i2.setTransform(this._container, `${Ta[s2]} translate(${o2.x}px,${o2.y}px)`), Ea(this._container, s2, "popup");
              }, this._onClose = () => {
                this.remove();
              }, this.options = t2.extend(Object.create(Aa), e3);
            }
            addTo(e3) {
              return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t2.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e3) {
              return this._lngLat = t2.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(t3) {
              return this.setDOMContent(document.createTextNode(t3));
            }
            setHTML(t3) {
              const e3 = document.createDocumentFragment(), i3 = document.createElement("body");
              let s2;
              for (i3.innerHTML = t3; s2 = i3.firstChild, s2; )
                e3.appendChild(s2);
              return this.setDOMContent(e3);
            }
            getMaxWidth() {
              var t3;
              return null === (t3 = this._container) || void 0 === t3 ? void 0 : t3.style.maxWidth;
            }
            setMaxWidth(t3) {
              return this.options.maxWidth = t3, this._update(), this;
            }
            setDOMContent(t3) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = i2.create("div", "maplibregl-popup-content", this._container);
              return this._content.appendChild(t3), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(t3) {
              this._container && this._container.classList.add(t3);
            }
            removeClassName(t3) {
              this._container && this._container.classList.remove(t3);
            }
            setOffset(t3) {
              return this.options.offset = t3, this._update(), this;
            }
            toggleClassName(t3) {
              if (this._container)
                return this._container.classList.toggle(t3);
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = i2.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const t3 = this._container.querySelector(La);
              t3 && t3.focus();
            }
          }, Fa.Marker = Ia, Fa.Style = ae, Fa.LngLat = t2.LngLat, Fa.LngLatBounds = L, Fa.Point = t2.Point, Fa.MercatorCoordinate = t2.MercatorCoordinate, Fa.Evented = t2.Evented, Fa.AJAXError = t2.AJAXError, Fa.config = t2.config, Fa.CanvasSource = Z, Fa.GeoJSONSource = U, Fa.ImageSource = N, Fa.RasterDEMTileSource = F, Fa.RasterTileSource = B, Fa.VectorTileSource = k, Fa.VideoSource = G, Fa.setRTLTextPlugin = t2.setRTLTextPlugin, Fa.getRTLTextPluginStatus = t2.getRTLTextPluginStatus, Fa.prewarm = function() {
            at().acquire(tt);
          }, Fa.clearPrewarmedResources = function() {
            const t3 = st;
            t3 && (t3.isPreloaded() && 1 === t3.numActive() ? (t3.release(tt), st = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, ka.extend(Fa, { isSafari: t2.isSafari, getPerformanceMetrics: t2.PerformanceUtils.getPerformanceMetrics }), Fa;
        });
        var maplibregl$1 = maplibregl2;
        return maplibregl$1;
      });
    }
  });

  // public/module.js
  var import_statebus = __toESM(require_statebus());
  var import_client_library = __toESM(require_client_library());
  var import_braidify_client = __toESM(require_braidify_client());

  // node_modules/diffhtml/dist/es/util/types.js
  var NODE_TYPE = { ELEMENT: 1, ATTR: 2, TEXT: 3, COMMENT: 8, FRAGMENT: 11 };
  var EMPTY = { STR: "", NUM: 1, OBJ: {}, ARR: [], MAP: /* @__PURE__ */ new Map(), SET: /* @__PURE__ */ new Set(), DOM: {}, FUN: () => {
  } };
  var PATCH_TYPE = { SET_ATTRIBUTE: 0, REMOVE_ATTRIBUTE: 1, NODE_VALUE: 2, INSERT_BEFORE: 3, REPLACE_CHILD: 4, REMOVE_CHILD: 5 };
  var TransitionStateNames = ["attached", "detached", "replaced", "attributeChanged", "textChanged"];
  var TransitionCache = /* @__PURE__ */ new Map([["attached", /* @__PURE__ */ new Set()], ["detached", /* @__PURE__ */ new Set()], ["replaced", /* @__PURE__ */ new Set()], ["attributeChanged", /* @__PURE__ */ new Set()], ["textChanged", /* @__PURE__ */ new Set()]]);
  var StateCache = /* @__PURE__ */ new Map();
  var NodeCache = /* @__PURE__ */ new Map();
  var MiddlewareCache = /* @__PURE__ */ new Set();
  var CreateTreeHookCache = /* @__PURE__ */ new Set();
  var CreateNodeHookCache = /* @__PURE__ */ new Set();
  var SyncTreeHookCache = /* @__PURE__ */ new Set();
  var ReleaseHookCache = /* @__PURE__ */ new Set();
  var ParseHookCache = /* @__PURE__ */ new Set();
  var TransitionStateName = EMPTY.OBJ;
  var VTreeAttributes = EMPTY.OBJ;
  var VTree = EMPTY.OBJ;
  var VTreeLike = EMPTY.OBJ;
  var ValidInput = EMPTY.OBJ;
  var ValidNode = EMPTY.OBJ;
  var Mount = EMPTY.OBJ;
  var Middleware = EMPTY.OBJ;
  var ParserConfig = EMPTY.OBJ;
  var TransactionConfig = EMPTY.OBJ;
  var GlobalConfig = EMPTY.OBJ;
  var Supplemental = EMPTY.OBJ;
  var TransactionState = EMPTY.OBJ;
  var Internals = EMPTY.OBJ;

  // node_modules/diffhtml/dist/es/util/process.js
  var process_default = typeof process !== "undefined" ? process : { env: { NODE_ENV: "development" }, argv: [] };

  // node_modules/diffhtml/dist/es/util/global.js
  var global_default = typeof global === "object" ? global : (typeof window === "object" ? window : self) || {};

  // node_modules/diffhtml/dist/es/util/config.js
  var { parseInt: parseInt2 } = Number;
  var { parse: parse2 } = JSON;
  var globalConfig = { collectMetrics: true, executeScripts: true };
  function formatValue(value, type2) {
    const valueAsString = String(value);
    switch (type2) {
      case "boolean": {
        return valueAsString !== "false";
      }
      case "string": {
        return valueAsString;
      }
      case "number": {
        return parseInt2(valueAsString, 10);
      }
      case "object": {
        return parse2(valueAsString);
      }
    }
  }
  function getConfig(name3, defaultValue, type2 = typeof defaultValue, overrides) {
    const { location: location2, URLSearchParams } = global_default;
    const hasSearchParams = typeof URLSearchParams !== "undefined";
    const hasLocation = typeof location2 !== "undefined";
    const useSearchParams = hasSearchParams && hasLocation;
    const useEnv = process_default.env;
    if (overrides && name3 in overrides) {
      return overrides[name3];
    }
    const keyName2 = `DIFF_${name3.replace(/[^a-zA-Z0-9]/, "")}`;
    if (useSearchParams) {
      const searchParams = new URLSearchParams(location2.search);
      const lowerKey = keyName2.toLowerCase();
      if (searchParams.has(lowerKey)) {
        return formatValue(decodeURIComponent(String(searchParams.get(lowerKey))), type2);
      }
    }
    const upperKey = keyName2.toUpperCase();
    if (useEnv && upperKey in process_default.env) {
      return formatValue(process_default.env[upperKey.toUpperCase()], type2);
    }
    return defaultValue;
  }

  // node_modules/diffhtml/dist/es/util/pool.js
  var size = getConfig("initialPoolSize", 5e3);
  var free = /* @__PURE__ */ new Set();
  var allocate = /* @__PURE__ */ new Set();
  var protect = /* @__PURE__ */ new Set();
  var shape = () => ({ rawNodeName: EMPTY.STR, nodeName: EMPTY.STR, nodeValue: EMPTY.STR, nodeType: NODE_TYPE.ELEMENT, key: EMPTY.STR, childNodes: [], attributes: {} });
  var memory = { free, allocated: allocate, protected: protect };
  var freeValues = free.values();
  var Pool = {
    size,
    memory,
    fill() {
      for (let i2 = free.size; i2 < this.size; i2++) {
        free.add(shape());
      }
      if (this.size < free.size) {
        free.forEach((value) => {
          if (free.size !== this.size) {
            free.delete(value);
          }
        });
      }
    },
    get() {
      const { value = shape(), done } = freeValues.next();
      if (done) {
        freeValues = free.values();
      }
      free.delete(value);
      allocate.add(value);
      return value;
    },
    protect(vTree) {
      allocate.delete(vTree);
      protect.add(vTree);
    },
    unprotect(vTree) {
      if (protect.has(vTree) || allocate.has(vTree)) {
        protect.delete(vTree);
        allocate.delete(vTree);
        free.add(vTree);
      }
    }
  };
  Pool.fill();
  var pool_default = Pool;

  // node_modules/diffhtml/dist/es/tree/create.js
  function ownKeys(object, enumerableOnly) {
    var keys4 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys4.push.apply(keys4, symbols2);
    }
    return keys4;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var { isArray } = Array;
  var { memory: memory2 } = pool_default;
  var fragmentName = "#document-fragment";
  var textName = "#text";
  function flatten(vTrees, retVal = []) {
    for (let i2 = 0; i2 < vTrees.length; i2++) {
      const vTree = vTrees[i2];
      if (vTree && vTree.rawNodeName === fragmentName) {
        flatten(vTree.childNodes, retVal);
      } else if (vTree) {
        retVal.push(vTree);
      }
    }
    return retVal;
  }
  function createTree(input, attributes2, childNodes, ...rest) {
    let entry = null;
    if (memory2.protected.has(input) || memory2.allocated.has(input)) {
      entry = input;
    } else if (!input || isArray(input)) {
      const length = input ? input.length : 0;
      childNodes = [];
      for (let i2 = 0; i2 < length; i2++) {
        const hasInput = input && !input[i2];
        if (hasInput)
          continue;
        input && childNodes.push(input[i2]);
      }
      entry = createTree(fragmentName, null, childNodes);
    }
    if (entry) {
      return entry;
    }
    const isObject = typeof input === "object";
    const inputAsHTMLEl = input;
    if (input && isObject && "ownerDocument" in inputAsHTMLEl) {
      const { nodeType } = inputAsHTMLEl;
      if (nodeType === NODE_TYPE.TEXT) {
        const vTree = createTree(textName, inputAsHTMLEl.nodeValue);
        NodeCache.set(vTree, inputAsHTMLEl);
        return vTree;
      }
      attributes2 = {};
      childNodes = [];
      const inputAttrs = inputAsHTMLEl.attributes;
      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT && inputAttrs && inputAttrs.length) {
        for (let i2 = 0; i2 < inputAttrs.length; i2++) {
          const { name: name3, value } = inputAttrs[i2];
          if (value === EMPTY.STR && name3 in inputAsHTMLEl) {
            attributes2[name3] = input[name3];
            continue;
          }
          attributes2[name3] = value;
        }
      }
      if (inputAsHTMLEl.nodeType === NODE_TYPE.ELEMENT || inputAsHTMLEl.nodeType === NODE_TYPE.FRAGMENT) {
        childNodes = [];
        for (let i2 = 0; i2 < inputAsHTMLEl.childNodes.length; i2++) {
          const childNodeElement = inputAsHTMLEl.childNodes[i2];
          childNodes.push(createTree(childNodeElement));
        }
      }
      NodeCache.forEach((domNode, vTree) => {
        if (domNode === input) {
          entry = vTree;
        }
      });
      entry = entry || createTree(inputAsHTMLEl.nodeName, attributes2, childNodes);
      entry.attributes = _objectSpread(_objectSpread({}, entry.attributes), attributes2);
      entry.childNodes = childNodes;
      NodeCache.set(entry, inputAsHTMLEl);
      return entry;
    }
    if (isObject) {
      const { rawNodeName, nodeName, nodeValue, attributes: attributes3, childNodes: childNodes2, children } = input;
      const treeName = rawNodeName || nodeName;
      const vTree = createTree(treeName, attributes3 || null, children || childNodes2);
      if (nodeValue) {
        vTree.nodeValue = nodeValue;
      }
      return vTree;
    }
    if (rest.length) {
      childNodes = [childNodes, ...rest];
    }
    entry = pool_default.get();
    const isTextNode = input === textName;
    const isString2 = typeof input === "string";
    if (isString2) {
      entry.rawNodeName = input;
      entry.nodeName = entry.rawNodeName.toLowerCase();
    } else {
      entry.rawNodeName = input;
      entry.nodeName = fragmentName;
    }
    entry.nodeValue = EMPTY.STR;
    entry.key = EMPTY.STR;
    entry.childNodes.length = 0;
    entry.attributes = {};
    const useAttributes = isArray(attributes2) || typeof attributes2 !== "object";
    const useNodes = useAttributes ? attributes2 : childNodes;
    const allNodes = flatten(isArray(useNodes) ? useNodes : [useNodes]);
    if (isTextNode) {
      const nodeValue = allNodes.join(EMPTY.STR);
      entry.nodeType = NODE_TYPE.TEXT;
      entry.nodeValue = String(nodeValue);
      return entry;
    } else if (entry.nodeName === fragmentName) {
      entry.nodeType = NODE_TYPE.FRAGMENT;
    } else if (input === "#comment") {
      entry.nodeType = NODE_TYPE.COMMENT;
    } else {
      entry.nodeType = NODE_TYPE.ELEMENT;
    }
    if (useNodes && allNodes.length && (!attributes2 || !attributes2.childNodes)) {
      for (let i2 = 0; i2 < allNodes.length; i2++) {
        const newNode = allNodes[i2];
        if (isArray(newNode)) {
          entry.childNodes.push(...newNode);
        } else if (!newNode) {
          continue;
        } else if (newNode.nodeType === NODE_TYPE.FRAGMENT && typeof newNode.rawNodeName === "string") {
          entry.childNodes.push(...newNode.childNodes);
        } else if (newNode && typeof newNode === "object") {
          entry.childNodes.push(createTree(newNode));
        } else {
          entry.childNodes.push(createTree(textName, null, newNode));
        }
      }
    }
    if (attributes2 && typeof attributes2 === "object" && !isArray(attributes2)) {
      entry.attributes = _objectSpread({}, attributes2);
      if (attributes2.childNodes) {
        const isObject2 = typeof attributes2.childNodes === "object";
        entry.childNodes.push(isObject2 ? createTree(attributes2.childNodes) : createTree("#text", attributes2.childNodes));
      }
    }
    if (entry.nodeName === "script" && entry.attributes.src) {
      entry.key = String(entry.attributes.src);
    }
    if (entry.attributes && "key" in entry.attributes) {
      entry.key = String(entry.attributes.key);
    }
    if (CreateTreeHookCache.size) {
      CreateTreeHookCache.forEach((fn, retVal) => {
        if (retVal = fn(entry)) {
          entry = createTree(retVal);
        }
      });
    }
    return entry;
  }

  // node_modules/diffhtml/dist/es/util/parse.js
  var TOKEN = "__DIFFHTML__";
  var doctypeEx = /<!DOCTYPE.*>/i;
  var spaceEx = /[^ ]/;
  var tokenEx = new RegExp(`${TOKEN}([^_]*)__`);
  var defaultSupplemental = { tags: [], attributes: {}, children: {} };
  var { assign } = Object;
  var { isArray: isArray2 } = Array;
  var rawElementsDefaults = ["script", "noscript", "style", "template"];
  var selfClosingElementsDefaults = ["source", "embed", "param", "track", "input", "meta", "link", "area", "base", "col", "wbr", "img", "br", "hr"];
  var kElementsClosedByOpening = { li: { li: true }, p: { p: true, div: true }, td: { td: true, th: true }, th: { td: true, th: true } };
  var kElementsClosedByClosing = { li: { ul: true, ol: true }, a: { div: true }, b: { div: true }, i: { div: true }, p: { div: true }, td: { tr: true, table: true }, th: { tr: true, table: true } };
  var interpolateChildNodes = (currentParent, markup, supplemental) => {
    if ("childNodes" in currentParent.attributes) {
      return;
    }
    if (markup && !doctypeEx.test(markup) && !tokenEx.test(markup)) {
      return currentParent.childNodes.push(createTree("#text", markup));
    }
    const childNodes = [];
    const parts = markup.split(tokenEx);
    for (let i2 = 0; i2 < parts.length; i2++) {
      const value = parts[i2];
      if (!value) {
        continue;
      }
      if (i2 % 2 === 1) {
        const supValue = supplemental.children[value];
        const innerTree = value in supplemental.children ? supValue : createTree("#text", `${TOKEN}${value}__`);
        if (!innerTree)
          continue;
        const isFragment = innerTree.nodeType === NODE_TYPE.FRAGMENT;
        if (typeof innerTree.rawNodeName === "string" && isFragment) {
          childNodes.push(...innerTree.childNodes);
        } else {
          childNodes.push(innerTree);
        }
      } else if (!doctypeEx.test(value)) {
        childNodes.push(createTree("#text", value));
      }
    }
    currentParent.childNodes.push(...childNodes);
  };
  var HTMLElement2 = (nodeName, rawAttrs, supplemental, options2) => {
    let match = null;
    const attrEx = /([_@$#a-z][^\s\x00-\x1F"'>\/=\uFDD0-\uFDEF\uFFFE\uFFFF]*)\s*(=\s*("([^"]+)"|'([^']+)'|(\S+)))?/ig;
    if (match = tokenEx.exec(nodeName)) {
      return HTMLElement2(supplemental.tags[match[1]], rawAttrs, supplemental, options2);
    }
    const attributes2 = {};
    for (let match2; match2 = attrEx.exec(rawAttrs || EMPTY.STR); ) {
      const isHTML = typeof nodeName === "string";
      const name3 = match2[1];
      let tokenValue;
      if (name3 === "") {
        const match3 = rawAttrs.match(tokenEx);
        tokenValue = match3 ? match3[0] : "";
      }
      const testValue = match2[6] || match2[5] || match2[4];
      const rawValue = tokenValue || testValue || (isHTML ? match2[1] : testValue || true);
      const value = rawValue === `''` || rawValue === `""` ? EMPTY.STR : rawValue;
      let valueMatchesToken = String(value).match(tokenEx);
      if (valueMatchesToken && valueMatchesToken.length) {
        const parts = String(value).split(tokenEx);
        const hasToken = tokenEx.exec(name3);
        const newName = hasToken ? supplemental.attributes[hasToken[1]] : name3;
        for (let i2 = 0; i2 < parts.length; i2++) {
          const value2 = parts[i2];
          if (!value2) {
            continue;
          }
          if (i2 % 2 === 1) {
            const isObject = typeof newName === "object";
            const hasSupValue = value2 in supplemental.attributes;
            const supValue = supplemental.attributes[value2];
            const fallback = `${TOKEN}${value2}__`;
            if (attributes2[newName]) {
              attributes2[newName] += hasSupValue ? supValue : fallback;
            } else if (isObject) {
              if (newName && !isArray2(newName)) {
                assign(attributes2, newName);
              } else {
                if (process_default.env.NODE_ENV !== "production") {
                  throw new Error("Arrays cannot be spread as attributes");
                }
              }
            } else if (newName) {
              const defaultValue = hasSupValue ? supValue : fallback;
              attributes2[newName] = testValue ? defaultValue : true;
            }
          } else if (attributes2[newName]) {
            attributes2[newName] += value2;
          } else {
            attributes2[newName] = value2;
          }
        }
      } else if (valueMatchesToken = tokenEx.exec(name3)) {
        const nameAndValue = supplemental.attributes[valueMatchesToken[1]];
        if (typeof nameAndValue === "object" && !isArray2(nameAndValue)) {
          assign(attributes2, nameAndValue);
        } else {
          attributes2[nameAndValue] = value;
        }
      } else {
        attributes2[name3] = testValue !== void 0 ? value : true;
      }
    }
    return createTree(nodeName, attributes2, attributes2.childNodes || []);
  };
  function parse3(html, supplemental, options2 = {}) {
    if (!options2.parser) {
      options2.parser = {};
    }
    if (!supplemental) {
      supplemental = defaultSupplemental;
    }
    const blockText = new Set(getConfig("rawElements", rawElementsDefaults, "array", options2.parser));
    const selfClosing = new Set(getConfig("selfClosingElements", selfClosingElementsDefaults, "array", options2.parser));
    const tagEx = /<!--[^]*?(?=-->)-->|<(\/?)([a-z\-\_][a-z0-9\-\_]*)\s*([^>]*?)(".*?"|'.*?')?(\/?)>/ig;
    const root = createTree("#document-fragment", null, []);
    const stack = [root];
    let currentParent = root;
    let lastTextPos = -1;
    if (process_default.env.NODE_ENV !== "production") {
      const markup = [html];
      if (!html.includes("<") && options2.parser.strict) {
        markup.splice(1, 0, `
Possibly invalid markup. Opening tag was not properly opened.
      `);
        throw new Error(`

${markup.join("\n")}`);
      }
      if (!html.includes(">") && options2.parser.strict) {
        markup.splice(1, 0, `
Possibly invalid markup. Opening tag was not properly closed.
      `);
        throw new Error(`

${markup.join("\n")}`);
      }
    }
    if (!html.includes("<") && html) {
      interpolateChildNodes(currentParent, html, supplemental);
      return root;
    }
    for (let match, text, i2 = 0; match = tagEx.exec(html); i2++) {
      const [fullMatch, isClosingMatch, tagMatch, attributeMatch, extraMatch, selfClosingMatch] = match;
      if (lastTextPos > -1) {
        if (lastTextPos + fullMatch.length < tagEx.lastIndex) {
          text = html.slice(lastTextPos, tagEx.lastIndex - fullMatch.length);
          if (text) {
            interpolateChildNodes(currentParent, text, supplemental);
          }
        }
      }
      const matchOffset = tagEx.lastIndex - fullMatch.length;
      if (lastTextPos === -1 && matchOffset > 0) {
        const string2 = html.slice(0, matchOffset);
        if (string2 && !doctypeEx.exec(string2)) {
          interpolateChildNodes(currentParent, string2, supplemental);
        }
      }
      lastTextPos = tagEx.lastIndex;
      if (match[0][1] === "!") {
        continue;
      }
      const tokenMatch = tokenEx.exec(tagMatch);
      const supTag = tokenMatch && supplemental.tags[tokenMatch[1]];
      const name3 = supTag ? supTag.name || supTag : tagMatch;
      let bypassMatch;
      if (!isClosingMatch) {
        if (!match[4] && kElementsClosedByOpening[currentParent.rawNodeName]) {
          if (kElementsClosedByOpening[currentParent.rawNodeName][name3]) {
            stack.pop();
            currentParent = stack[stack.length - 1];
          }
        }
        const attrs = attributeMatch + (extraMatch || "");
        currentParent = currentParent.childNodes[currentParent.childNodes.push(HTMLElement2(tagMatch, attrs, supplemental, options2)) - 1];
        stack.push(currentParent);
        if (options2.parser.strict || blockText.has(name3)) {
          const closeMarkup = `</${name3}>`;
          const index = html.indexOf(closeMarkup, tagEx.lastIndex);
          if (process_default.env.NODE_ENV !== "production") {
            if (index === -1 && options2.parser.strict && !selfClosing.has(name3)) {
              const markup = html.slice(tagEx.lastIndex - fullMatch.length).split("\n").map((line) => line.replace(tokenEx, (value, index2) => {
                if (!supplemental) {
                  return value;
                }
                const { tags: tags2, children, attributes: attributes2 } = supplemental;
                return tags2[index2] || children[index2] || attributes2[index2];
              })).slice(0, 3);
              const lookup = spaceEx.exec(markup[0]);
              const caret = Array((lookup ? lookup.index - 1 : 0) + closeMarkup.length - 1).join(" ") + "^";
              markup.splice(1, 0, `${caret}
    Possibly invalid markup. <${name3}> must be closed in strict mode.
            `);
              throw new Error(`

${markup.join("\n")}`);
            }
          }
          if (blockText.has(name3)) {
            if (index === -1) {
              lastTextPos = tagEx.lastIndex = html.length + 1;
            } else {
              lastTextPos = index + closeMarkup.length;
              tagEx.lastIndex = lastTextPos;
              bypassMatch = true;
            }
            const newText = html.slice(match.index + fullMatch.length, index);
            interpolateChildNodes(currentParent, newText, supplemental);
          }
        }
      }
      if (bypassMatch || isClosingMatch || selfClosingMatch || selfClosing.has(name3)) {
        if (process_default.env.NODE_ENV !== "production") {
          if (currentParent && name3 !== currentParent.rawNodeName && options2.parser.strict) {
            const nodeName = currentParent.rawNodeName;
            const markup = html.slice(tagEx.lastIndex - fullMatch.length).split("\n").map((line) => line.replace(tokenEx, (value, index) => {
              if (!supplemental) {
                return value;
              }
              const { tags: tags2, children, attributes: attributes2 } = supplemental;
              return tags2[index] || children[index] || attributes2[index];
            })).slice(0, 3);
            const lookup = spaceEx.exec(markup[0]);
            const caret = Array(lookup ? lookup.index : 0).join(" ") + "^";
            markup.splice(1, 0, `${caret}
  Possibly invalid markup. Saw ${name3}, expected ${nodeName}...
          `);
            throw new Error(`

${markup.join("\n")}`);
          }
        }
        while (currentParent) {
          if (selfClosingMatch === "/" && tokenMatch) {
            stack.pop();
            currentParent = stack[stack.length - 1];
            break;
          } else if (supTag) {
            if (currentParent.rawNodeName === name3) {
              stack.pop();
              currentParent = stack[stack.length - 1];
              break;
            }
          }
          if (currentParent.rawNodeName === name3) {
            stack.pop();
            currentParent = stack[stack.length - 1];
            break;
          } else {
            const tag = kElementsClosedByClosing[currentParent.rawNodeName];
            if (tag) {
              if (tag[name3]) {
                stack.pop();
                currentParent = stack[stack.length - 1];
                continue;
              }
            }
            break;
          }
        }
      }
    }
    const remainingText = html.slice(lastTextPos === -1 ? 0 : lastTextPos);
    if (process_default.env.NODE_ENV !== "production") {
      if ((remainingText.includes(">") || remainingText.includes("<")) && options2.parser.strict) {
        const markup = [remainingText];
        const lookup = spaceEx.exec(markup[0]);
        const caret = Array(lookup ? lookup.index : 0).join(" ") + "^";
        if (remainingText.includes(">")) {
          markup.splice(1, 0, `${caret}
  Possibly invalid markup. Opening tag was not properly opened.
        `);
        } else {
          markup.splice(1, 0, `${caret}
  Possibly invalid markup. Opening tag was not properly closed.
        `);
        }
        throw new Error(`

${markup.join("\n")}`);
      }
    }
    if (remainingText) {
      interpolateChildNodes(currentParent, remainingText, supplemental);
    }
    if (root.childNodes.length && root.childNodes[0].nodeName === "html") {
      const head = { before: [], after: [] };
      const body = { after: [] };
      const HTML = root.childNodes[0];
      let beforeHead = true;
      let beforeBody = true;
      HTML.childNodes = HTML.childNodes.filter((el) => {
        if (el.nodeName === "body" || el.nodeName === "head") {
          if (el.nodeName === "head")
            beforeHead = false;
          if (el.nodeName === "body")
            beforeBody = false;
          return true;
        } else if (el.nodeType === NODE_TYPE.ELEMENT) {
          if (beforeHead && beforeBody)
            head.before.push(el);
          else if (!beforeHead && beforeBody)
            head.after.push(el);
          else if (!beforeBody)
            body.after.push(el);
        }
      });
      if (!HTML.childNodes[0] || HTML.childNodes[0].nodeName !== "head") {
        const headInstance = createTree("head", null, []);
        if (headInstance) {
          const existing = headInstance.childNodes;
          existing.unshift.apply(existing, head.before);
          existing.push.apply(existing, head.after);
          HTML.childNodes.unshift(headInstance);
        }
      } else {
        const existing = HTML.childNodes[0].childNodes;
        existing.unshift.apply(existing, head.before);
        existing.push.apply(existing, head.after);
      }
      if (!HTML.childNodes[1] || HTML.childNodes[1].nodeName !== "body") {
        const bodyInstance = createTree("body", null, []);
        if (bodyInstance) {
          const existing = bodyInstance.childNodes;
          existing.push.apply(existing, body.after);
          HTML.childNodes.push(bodyInstance);
        }
      } else {
        const existing = HTML.childNodes[1].childNodes;
        existing.push.apply(existing, body.after);
      }
    }
    return root;
  }

  // node_modules/diffhtml/dist/es/util/make-measure.js
  var prefix = "diffHTML";
  var marks = /* @__PURE__ */ new Map();
  var count = 0;
  function makeMeasure(transaction) {
    const { mount, input } = transaction;
    const inputAsVTree = input;
    const id2 = count++;
    if (!getConfig("collectMetrics", false)) {
      return EMPTY.FUN;
    }
    return (name3) => {
      name3 = `[${id2}] ${name3}`;
      const { host } = mount;
      if (mount && host) {
        name3 = `${host.constructor.name} ${name3}`;
      } else if (inputAsVTree && typeof inputAsVTree.rawNodeName === "function") {
        name3 = `${inputAsVTree.rawNodeName.name} ${name3}`;
      }
      const endName = `${name3}-end`;
      if (marks.has(name3)) {
        const prevMark = marks.get(name3) || 0;
        const totalMs = (performance.now() - prevMark).toFixed(3);
        marks.delete(name3);
        performance.mark(endName);
        performance.measure(`${prefix} ${name3} (${totalMs}ms)`, name3, endName);
      } else {
        marks.set(name3, performance.now());
        performance.mark(name3);
      }
    };
  }

  // node_modules/diffhtml/dist/es/util/memory.js
  var memory_exports = {};
  __export(memory_exports, {
    gc: () => gc,
    protectVTree: () => protectVTree,
    unprotectVTree: () => unprotectVTree
  });
  var { protect: protect2, unprotect, memory: memory3 } = pool_default;
  function protectVTree(vTree) {
    protect2(vTree);
    if (vTree.childNodes.length) {
      for (let i2 = 0; i2 < vTree.childNodes.length; i2++) {
        protectVTree(vTree.childNodes[i2]);
      }
    }
  }
  function unprotectVTree(vTree) {
    if (vTree.childNodes.length) {
      for (let i2 = 0; i2 < vTree.childNodes.length; i2++) {
        unprotectVTree(vTree.childNodes[i2]);
      }
    }
    NodeCache.delete(vTree);
    unprotect(vTree);
  }
  function gc() {
    memory3.allocated.forEach((vTree) => {
      vTree.attributes = {};
      vTree.childNodes.length = 0;
      memory3.free.add(vTree);
      memory3.allocated.delete(vTree);
      NodeCache.delete(vTree);
    });
  }

  // node_modules/diffhtml/dist/es/tasks/schedule.js
  function schedule(transaction) {
    let { state: state3, state: { isRendering } } = transaction;
    state3.measure("schedule");
    StateCache.forEach((val) => {
      const oldMount = val.activeTransaction && val.activeTransaction.mount;
      const newMount = transaction.mount;
      if (!oldMount || !newMount || !val.isRendering) {
        return;
      } else if (oldMount.contains && oldMount.contains(newMount) || newMount.contains && newMount.contains(oldMount)) {
        state3 = val;
        isRendering = true;
      } else if (oldMount === newMount) {
        state3 = val;
        isRendering = true;
      }
    });
    const { activeTransaction, nextTransaction } = state3;
    if (isRendering) {
      const { tasks: tasks2 } = transaction;
      state3.nextTransaction = transaction;
      transaction.abort();
      const promise = nextTransaction && nextTransaction.promise || activeTransaction.promise || Promise.resolve();
      return transaction.promise = promise.then(() => {
        transaction.aborted = false;
        transaction.state.isRendering = true;
        transaction.state.activeTransaction = transaction;
        state3.measure("schedule");
        return Transaction.flow(transaction, tasks2.slice(1));
      });
    }
    state3.isRendering = true;
    state3.activeTransaction = transaction;
    state3.measure("schedule");
  }

  // node_modules/diffhtml/dist/es/tasks/should-update.js
  function shouldUpdate(transaction) {
    const { mount, input, state: { measure }, config: options2 } = transaction;
    const prop = options2.inner ? "innerHTML" : "outerHTML";
    measure("should update");
    const mountAsHTMLEl = mount;
    if (typeof input === "string" && mountAsHTMLEl[prop] === input) {
      return transaction.abort(true);
    }
    measure("should update");
  }

  // node_modules/diffhtml/dist/es/release.js
  var hasIdle = typeof requestIdleCallback !== "undefined";
  var gcTimerId = -1;
  var scheduleTimeout = (fn) => (hasIdle ? requestIdleCallback : setTimeout)(fn);
  var cancelTimeout = (id2) => (hasIdle ? cancelIdleCallback : clearTimeout)(id2);
  function release(mount) {
    if (StateCache.has(mount)) {
      const { mutationObserver, oldTree } = StateCache.get(mount);
      mutationObserver && mutationObserver.disconnect();
      if (oldTree && !NodeCache.has(oldTree)) {
        ReleaseHookCache.forEach((fn) => fn(oldTree));
        unprotectVTree(oldTree);
      }
      StateCache.delete(mount);
    }
    if (!mount) {
      return;
    }
    const asHTMLElement = mount;
    if (asHTMLElement.childNodes && asHTMLElement.childNodes.length) {
      for (let i2 = 0; i2 < asHTMLElement.childNodes.length; i2++) {
        release(asHTMLElement.childNodes[i2]);
      }
    }
    if (asHTMLElement.shadowRoot) {
      release(asHTMLElement.shadowRoot);
    }
    NodeCache.forEach((domNode, vTree) => {
      if (domNode === asHTMLElement) {
        ReleaseHookCache.forEach((fn) => fn(vTree));
        unprotectVTree(vTree);
      }
    });
    cancelTimeout(gcTimerId);
    gcTimerId = scheduleTimeout(gc);
  }

  // node_modules/diffhtml/dist/es/tasks/reconcile-trees.js
  function reconcileTrees(transaction) {
    const { state: state3, mount, input, config: options2 } = transaction;
    const { inner } = options2;
    const mountAsHTMLEl = mount;
    if (state3.mutationObserver && !state3.isDirty) {
      state3.isDirty = Boolean(state3.mutationObserver.takeRecords().length);
    } else if (!state3.mutationObserver) {
      state3.isDirty = false;
    }
    if (state3.isDirty || !state3.oldTree) {
      release(mountAsHTMLEl);
      if (mountAsHTMLEl.ownerDocument && state3.mutationObserver) {
        state3.mutationObserver.observe(mountAsHTMLEl, { subtree: true, childList: true, attributes: true, characterData: true });
      }
      state3.oldTree = createTree(mountAsHTMLEl);
      protectVTree(state3.oldTree);
      StateCache.set(mount, state3);
    }
    const { nodeName, attributes: attributes2 } = state3.oldTree;
    if (!transaction.newTree) {
      transaction.newTree = createTree(input);
    }
    const inputAsVTree = transaction.newTree;
    if (!inner && inputAsVTree.nodeType === NODE_TYPE.FRAGMENT && state3.oldTree.nodeType !== NODE_TYPE.FRAGMENT) {
      let foundElements = [];
      for (let i2 = 0; i2 < inputAsVTree.childNodes.length; i2++) {
        const value = inputAsVTree.childNodes[i2];
        const isText = value.nodeType === NODE_TYPE.TEXT;
        if (!isText || value.nodeValue.trim()) {
          foundElements.push(value);
        }
      }
      if (foundElements.length === 1) {
        transaction.newTree = foundElements[0];
      } else if (foundElements.length > 1) {
        transaction.newTree = createTree(inputAsVTree.childNodes);
      }
    }
    transaction.oldTree = state3.oldTree;
    const { oldTree, newTree } = transaction;
    if (inner && oldTree && newTree) {
      const isUnknown = typeof newTree.rawNodeName !== "string";
      const isFragment = newTree.nodeType === NODE_TYPE.FRAGMENT;
      const children = isFragment && !isUnknown ? newTree.childNodes : newTree;
      transaction.newTree = createTree(nodeName, attributes2, children);
    }
  }

  // node_modules/diffhtml/dist/es/tree/sync.js
  var { max } = Math;
  var keyNames = ["old", "new"];
  var textName2 = "#text";
  function syncTree(oldTree, newTree, patches = [], state3 = {}, transaction = EMPTY.OBJ, attributesOnly) {
    if (!oldTree)
      oldTree = EMPTY.OBJ;
    if (!newTree)
      newTree = EMPTY.OBJ;
    const { svgElements = /* @__PURE__ */ new Set() } = state3;
    const oldNodeName = oldTree.nodeName;
    const newNodeName = newTree.nodeName;
    const isEmpty = oldTree === EMPTY.OBJ || attributesOnly;
    const isSVG = newNodeName === "svg" || svgElements.has(newTree);
    let shortCircuit = null;
    if (SyncTreeHookCache.size) {
      SyncTreeHookCache.forEach((fn) => {
        const entry = fn(oldTree, newTree, transaction);
        if (entry && entry === oldTree) {
          shortCircuit = patches;
        } else if (entry === false) {
          shortCircuit = false;
        } else if (entry) {
          newTree = entry;
        }
      });
    }
    if (shortCircuit !== null || !newTree) {
      return shortCircuit;
    }
    if (newNodeName === textName2) {
      if (oldNodeName === textName2 && oldTree.nodeValue !== newTree.nodeValue) {
        patches.push(PATCH_TYPE.NODE_VALUE, oldTree, newTree.nodeValue, oldTree.nodeValue);
        oldTree.nodeValue = newTree.nodeValue;
        return patches;
      } else if (isEmpty) {
        patches.push(PATCH_TYPE.NODE_VALUE, newTree, newTree.nodeValue, null);
        return patches;
      }
    }
    const newChildNodes = newTree.childNodes || [];
    if (newTree.nodeType === NODE_TYPE.ELEMENT) {
      const oldAttributes = isEmpty ? EMPTY.OBJ : oldTree.attributes;
      const newAttributes = newTree.attributes || {};
      for (let key2 in newAttributes) {
        const value = newAttributes[key2];
        if (key2 in oldAttributes && oldAttributes[key2] === newAttributes[key2]) {
          continue;
        }
        if (!isEmpty) {
          oldAttributes[key2] = value;
        }
        if ((!oldTree || oldTree.nodeName !== "script") && newTree.nodeName === "script" && key2 === "type") {
          continue;
        }
        patches.push(PATCH_TYPE.SET_ATTRIBUTE, isEmpty ? newTree : oldTree, key2, value);
      }
      if (!isEmpty) {
        for (let key2 in oldAttributes) {
          if (key2 in newAttributes) {
            continue;
          }
          patches.push(PATCH_TYPE.REMOVE_ATTRIBUTE, oldTree, key2);
          delete oldAttributes[key2];
        }
      }
    }
    if (attributesOnly) {
      for (let i2 = 0; i2 < newChildNodes.length; i2++) {
        isSVG && svgElements.add(newChildNodes[i2]);
        syncTree(null, newChildNodes[i2], patches, state3, transaction, true);
      }
      return patches;
    }
    const keysLookup = { old: /* @__PURE__ */ new Map(), new: /* @__PURE__ */ new Map() };
    for (let i2 = 0; i2 < keyNames.length; i2++) {
      const keyName2 = keyNames[i2];
      const map = keysLookup[keyName2];
      const vTree = arguments[i2];
      const nodes = vTree && vTree.childNodes;
      if (nodes && nodes.length) {
        for (let i3 = 0; i3 < nodes.length; i3++) {
          const vTree2 = nodes[i3];
          if (vTree2.key) {
            if (process_default.env.NODE_ENV !== "production") {
              if (map.has(vTree2.key)) {
                throw new Error(`Key: ${vTree2.key} cannot be duplicated`);
              }
            }
            map.set(vTree2.key, vTree2);
          }
        }
      }
    }
    const oldChildNodes = oldTree.childNodes || [];
    let maxLength = max(newChildNodes.length, oldChildNodes.length);
    for (let i2 = 0; i2 < maxLength; i2++) {
      const oldChildNode = oldChildNodes && oldChildNodes[i2];
      const newChildNode = newChildNodes[i2];
      if (isSVG || newChildNode && newChildNode.nodeName === "svg") {
        svgElements.add(newChildNode);
      }
      if (!newChildNode) {
        if (syncTree(oldChildNode, null, patches, state3, transaction, true) === false) {
          newChildNodes.splice(i2, 0, oldChildNode);
        }
        continue;
      }
      if (!oldChildNode) {
        oldChildNodes.push(newChildNode);
        syncTree(null, newChildNode, patches, state3, transaction, true);
        patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, newChildNode, null);
        continue;
      }
      const newKey = newChildNode.key;
      const oldKey = oldChildNode.key;
      const oldInNew = keysLookup.new.has(oldKey);
      const newInOld = keysLookup.old.has(newKey);
      if (oldKey || newKey) {
        if (!oldInNew && !newInOld) {
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1, newChildNode);
          syncTree(null, newChildNode, patches, state3, transaction, true);
          patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
          i2 = i2 - 1;
          continue;
        } else if (!oldInNew) {
          patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNode);
          oldChildNodes.splice(oldChildNodes.indexOf(oldChildNode), 1);
          i2 = i2 - 1;
          continue;
        }
        if (newKey !== oldKey) {
          let optimalNewNode = newChildNode;
          if (newKey && newInOld) {
            optimalNewNode = keysLookup.old.get(newKey);
            oldChildNodes.splice(oldChildNodes.indexOf(optimalNewNode), 1);
          } else {
            optimalNewNode = newChildNode;
          }
          syncTree(null, optimalNewNode, patches, state3, transaction, true);
          patches.push(PATCH_TYPE.INSERT_BEFORE, oldTree, optimalNewNode, oldChildNode);
          oldChildNodes.splice(i2, 0, optimalNewNode);
          continue;
        }
      }
      const sameType = oldChildNode.nodeName === newChildNode.nodeName;
      const retVal = syncTree(oldChildNode, newChildNode, patches, state3, transaction, !sameType);
      if (retVal === false) {
        newChildNodes.splice(i2, 0, oldChildNode);
        maxLength += 1;
        continue;
      }
      if (!sameType) {
        oldChildNodes[i2] = newChildNode;
        const lookupIndex = oldChildNodes.lastIndexOf(newChildNode);
        if (lookupIndex > i2) {
          oldChildNodes.splice(lookupIndex, 1);
        }
        patches.push(PATCH_TYPE.REPLACE_CHILD, newChildNode, oldChildNode);
      }
    }
    if (oldChildNodes.length !== newChildNodes.length) {
      for (let i2 = newChildNodes.length; i2 < oldChildNodes.length; i2++) {
        patches.push(PATCH_TYPE.REMOVE_CHILD, oldChildNodes[i2]);
      }
      oldChildNodes.length = newChildNodes.length;
    }
    return patches;
  }

  // node_modules/diffhtml/dist/es/node/create.js
  var namespace = "http://www.w3.org/2000/svg";
  function createNode(vTreeLike, ownerDocument = global_default.document, isSVG) {
    if (process_default.env.NODE_ENV !== "production") {
      if (!vTreeLike) {
        throw new Error("Missing VTree when trying to create DOM Node");
      }
    }
    const vTree = createTree(vTreeLike);
    const existingNode = NodeCache.get(vTree);
    if (existingNode) {
      return existingNode;
    }
    const { nodeName, rawNodeName = nodeName, childNodes = [] } = vTree;
    isSVG = isSVG || nodeName === "svg";
    let domNodeCheck = null;
    let retVal = null;
    CreateNodeHookCache.forEach((fn) => {
      if (retVal = fn(vTree)) {
        domNodeCheck = retVal;
      }
    });
    if (!ownerDocument) {
      return domNodeCheck;
    }
    let domNode = domNodeCheck;
    if (!domNode) {
      if (nodeName === "#text") {
        domNode = ownerDocument.createTextNode(vTree.nodeValue || EMPTY.STR);
      } else if (nodeName === "#document-fragment") {
        domNode = ownerDocument.createDocumentFragment();
      } else if (isSVG) {
        domNode = ownerDocument.createElementNS(namespace, rawNodeName);
      } else {
        domNode = ownerDocument.createElement(rawNodeName);
      }
      if (nodeName === "script") {
        domNode.type = "no-execute";
      }
    }
    NodeCache.set(vTree, domNode);
    for (let i2 = 0; i2 < childNodes.length; i2++) {
      const validChildNode = createNode(childNodes[i2], ownerDocument, isSVG);
      if (domNode && validChildNode) {
        domNode.appendChild(validChildNode);
      }
    }
    return domNode;
  }

  // node_modules/diffhtml/dist/es/tasks/sync-trees.js
  function syncTrees(transaction) {
    const { state: state3, state: { measure }, oldTree, newTree, mount } = transaction;
    measure("sync trees");
    if (process_default.env.NODE_ENV !== "production") {
      if (!oldTree) {
        throw new Error("Missing old tree during synchronization");
      }
      if (!newTree) {
        throw new Error("Missing new tree during synchronization");
      }
    }
    if (oldTree && newTree && oldTree.nodeName !== newTree.nodeName && newTree.nodeType !== NODE_TYPE.FRAGMENT) {
      if (process_default.env.NODE_ENV !== "production") {
        if (!mount.parentNode) {
          throw new Error("Unable to replace top level node without a parent");
        }
      }
      transaction.patches = [PATCH_TYPE.REPLACE_CHILD, newTree, oldTree];
      transaction.oldTree = state3.oldTree = newTree;
      const newNode = createNode(newTree);
      StateCache.delete(mount);
      StateCache.set(newNode, state3);
      transaction.mount = newNode;
      if (newTree.nodeName === "script") {
        state3.scriptsToExecute.set(newTree, newTree.attributes.type || EMPTY.STR);
      }
    } else {
      transaction.patches = syncTree(oldTree || null, newTree || null, [], state3, transaction);
    }
    measure("sync trees");
  }

  // node_modules/diffhtml/dist/es/transition.js
  function addTransitionState(stateName, callback) {
    if (process_default.env.NODE_ENV !== "production") {
      if (!TransitionStateNames.includes(stateName)) {
        throw new Error(`Invalid state name '${stateName}'`);
      }
      if (!callback) {
        throw new Error("Missing transition state callback");
      }
    }
    TransitionCache.get(stateName)?.add(callback);
  }
  function removeTransitionState(stateName, callback) {
    if (process_default.env.NODE_ENV !== "production") {
      if (stateName && !TransitionStateNames.includes(stateName)) {
        throw new Error(`Invalid state name '${stateName}'`);
      }
    }
    if (!callback && stateName) {
      TransitionCache.get(stateName)?.clear();
    } else if (stateName && callback) {
      TransitionCache.get(stateName)?.delete(callback);
    } else {
      for (let i2 = 0; i2 < TransitionStateNames.length; i2++) {
        TransitionCache.get(TransitionStateNames[i2])?.clear();
      }
    }
  }
  function runTransitions(setName, ...args) {
    const set3 = TransitionCache.get(setName);
    const promises = [];
    if (!set3) {
      return promises;
    }
    const vTree = args[0];
    const isElement = vTree.nodeType === NODE_TYPE.ELEMENT;
    if (!set3.size || setName !== "textChanged" && !isElement) {
      return promises;
    }
    set3.forEach((callback) => {
      const nodes = args.map((x) => NodeCache.get(x) || x);
      const retVal = callback(...nodes);
      if (typeof retVal === "object" && retVal.then) {
        promises.push(retVal);
      }
    });
    if (setName === "attached" || setName === "detached") {
      vTree.childNodes.forEach((childTree) => {
        promises.push(...runTransitions(setName, childTree, ...args.slice(1)));
      });
    }
    return promises;
  }

  // node_modules/diffhtml/dist/es/util/decode-entities.js
  var element = global_default.document ? document.createElement("div") : null;
  function decodeEntities(string2) {
    if (!element || !string2 || !string2.indexOf || !string2.includes("&")) {
      return string2;
    }
    element.innerHTML = string2;
    return element.textContent || EMPTY.STR;
  }

  // node_modules/diffhtml/dist/es/util/symbols.js
  var $$strict = Symbol.for("diff.strict");
  var $$insertAfter = Symbol.for("diff.after");
  var $$diffHTML = Symbol.for("diffHTML");

  // node_modules/diffhtml/dist/es/node/patch.js
  var { keys } = Object;
  var blocklist = /* @__PURE__ */ new Set();
  var allowlist = /* @__PURE__ */ new Set();
  var setAttribute = (vTree, domNode, name3, value) => {
    const isObject = typeof value === "object" && value;
    const isFunction = typeof value === "function";
    const isSymbol = typeof value === "symbol";
    const isEvent = name3.indexOf("on") === 0;
    const anyNode = domNode;
    const lowerName = isEvent ? name3.toLowerCase() : name3;
    const blocklistName = "s-" + vTree.nodeName + "-" + lowerName;
    const htmlElement = domNode;
    if (allowlist.has(blocklistName)) {
      anyNode[lowerName] = value;
    } else if (!blocklist.has(blocklistName)) {
      try {
        anyNode[lowerName] = value;
        allowlist.add(blocklistName);
      } catch {
        blocklist.add(blocklistName);
      }
    }
    if (!isObject && !isFunction && !isSymbol) {
      const emptyValue = value === null || value === void 0 || value === true;
      htmlElement.setAttribute(lowerName, emptyValue ? EMPTY.STR : value);
    } else if (isObject && lowerName === "style") {
      const valueKeys = keys(value);
      for (let i2 = 0; i2 < valueKeys.length; i2++) {
        htmlElement.style[valueKeys[i2]] = value[valueKeys[i2]];
      }
    }
  };
  var removeAttribute = (vTree, domNode, name3) => {
    const blocklistName = "r-" + vTree.nodeName + "-" + name3;
    const anyNode = domNode;
    if (allowlist.has(blocklistName)) {
      anyNode[name3] = void 0;
      delete anyNode[name3];
    } else if (!blocklist.has(blocklistName)) {
      try {
        anyNode[name3] = void 0;
        delete anyNode[name3];
        allowlist.add(blocklistName);
      } catch {
        blocklist.add(blocklistName);
      }
    }
    domNode.removeAttribute(name3);
  };
  var changeNodeValue = (domNode, nodeValue) => {
    const htmlElement = domNode;
    if (nodeValue.includes("&")) {
      htmlElement.nodeValue = decodeEntities(nodeValue);
    } else {
      htmlElement.nodeValue = nodeValue;
    }
  };
  function patchNode(patches, state3 = EMPTY.OBJ) {
    const promises = [];
    const { ownerDocument, svgElements = /* @__PURE__ */ new Set() } = state3;
    const { length } = patches;
    let i2 = 0;
    while (true) {
      const patchType = patches[i2];
      if (i2 === length) {
        break;
      }
      switch (patchType) {
        case PATCH_TYPE.REMOVE_ATTRIBUTE:
        case PATCH_TYPE.SET_ATTRIBUTE: {
          const isSet = patchType === PATCH_TYPE.SET_ATTRIBUTE;
          const vTree = patches[i2 + 1];
          const name3 = patches[i2 + 2];
          const value = isSet ? decodeEntities(patches[i2 + 3]) : null;
          i2 += isSet ? 4 : 3;
          const isSVG = svgElements.has(vTree);
          const domNode = createNode(vTree, ownerDocument, isSVG);
          const oldValue = domNode.getAttribute(name3);
          const attributeChangedPromises = runTransitions("attributeChanged", vTree, name3, oldValue, value);
          protectVTree(vTree);
          const setOrRemove = isSet ? setAttribute : removeAttribute;
          if (attributeChangedPromises.length) {
            Promise.all(attributeChangedPromises).then(() => setOrRemove(vTree, domNode, name3, value));
            promises.push(...attributeChangedPromises);
          } else {
            setOrRemove(vTree, domNode, name3, value);
          }
          break;
        }
        case PATCH_TYPE.NODE_VALUE: {
          const vTree = patches[i2 + 1];
          const nodeValue = patches[i2 + 2];
          const oldValue = patches[i2 + 3];
          const isSVG = svgElements.has(vTree);
          i2 += 4;
          const domNode = createNode(vTree, ownerDocument, isSVG);
          protectVTree(vTree);
          const textChangedPromises = runTransitions("textChanged", vTree, oldValue, nodeValue);
          if (textChangedPromises.length) {
            Promise.all(textChangedPromises).then(() => changeNodeValue(domNode, nodeValue));
            promises.push(...textChangedPromises);
          } else {
            changeNodeValue(domNode, nodeValue);
          }
          break;
        }
        case PATCH_TYPE.INSERT_BEFORE: {
          const vTree = patches[i2 + 1];
          const newTree = patches[i2 + 2];
          let refTree = patches[i2 + 3];
          i2 += 4;
          if (!NodeCache.has(vTree) && vTree !== $$insertAfter) {
            continue;
          }
          let domNode = NodeCache.get(vTree);
          if (vTree === $$insertAfter) {
            const refNode2 = NodeCache.get(refTree);
            if (refNode2) {
              domNode = refNode2.parentNode;
              refTree = refNode2.nextSibling ? refNode2.nextSibling : null;
            }
          }
          const isSVG = svgElements.has(newTree);
          protectVTree(newTree);
          const refNode = refTree && createNode(refTree, ownerDocument, isSVG);
          const newNode = createNode(newTree, ownerDocument, isSVG);
          domNode.insertBefore(newNode, refNode || null);
          promises.push(...runTransitions("attached", newTree));
          break;
        }
        case PATCH_TYPE.REPLACE_CHILD: {
          const newTree = patches[i2 + 1];
          const oldTree = patches[i2 + 2];
          i2 += 3;
          const isSVG = svgElements.has(newTree);
          const oldDomNode = NodeCache.get(oldTree);
          const newDomNode = createNode(newTree, ownerDocument, isSVG);
          if (!oldDomNode || !oldDomNode.parentNode) {
            break;
          }
          protectVTree(newTree);
          const hasAttached = TransitionCache.get("attached")?.size;
          const hasDetached = TransitionCache.get("detached")?.size;
          const hasReplaced = TransitionCache.get("replaced")?.size;
          if (!hasAttached && !hasDetached && !hasReplaced) {
            oldDomNode.parentNode.replaceChild(newDomNode, oldDomNode);
            unprotectVTree(oldTree);
            break;
          }
          oldDomNode.parentNode.insertBefore(newDomNode, oldDomNode);
          const allPromises = [...hasAttached && runTransitions("attached", newTree) || EMPTY.ARR, ...hasDetached && runTransitions("detached", oldTree) || EMPTY.ARR, ...hasReplaced && runTransitions("replaced", oldTree, newTree) || EMPTY.ARR];
          if (allPromises.length) {
            Promise.all(allPromises).then(() => {
              if (oldDomNode.parentNode) {
                oldDomNode.parentNode.removeChild(oldDomNode);
              }
              unprotectVTree(oldTree);
            });
            promises.push(...allPromises);
          } else {
            oldDomNode.parentNode.removeChild(oldDomNode);
            unprotectVTree(oldTree);
          }
          break;
        }
        case PATCH_TYPE.REMOVE_CHILD: {
          const vTree = patches[i2 + 1];
          i2 += 2;
          const domNode = NodeCache.get(vTree);
          if (!domNode || !domNode.parentNode) {
            break;
          }
          const detachedPromises = runTransitions("detached", vTree);
          if (detachedPromises.length) {
            Promise.all(detachedPromises).then(() => {
              if (domNode.parentNode) {
                domNode.parentNode.removeChild(domNode);
              }
              unprotectVTree(vTree);
            });
            promises.push(...detachedPromises);
          } else {
            domNode.parentNode.removeChild(domNode);
            unprotectVTree(vTree);
          }
          break;
        }
      }
    }
    return promises;
  }

  // node_modules/diffhtml/dist/es/tasks/patch-node.js
  function patchNode2(transaction) {
    const { mount, state: state3, patches } = transaction;
    const { mutationObserver, measure, scriptsToExecute } = state3;
    measure("patch node");
    const { ownerDocument } = mount;
    const promises = transaction.promises || [];
    state3.ownerDocument = ownerDocument || global_default.document;
    if (mutationObserver) {
      mutationObserver.disconnect();
    }
    const collectScripts = (vTree) => {
      if (vTree.nodeName === "script") {
        scriptsToExecute.set(vTree, vTree.attributes.type);
      }
    };
    CreateNodeHookCache.add(collectScripts);
    if (state3.ownerDocument) {
      promises.push(...patchNode(patches, state3));
    }
    CreateNodeHookCache.delete(collectScripts);
    transaction.promises = promises;
    measure("patch node");
  }

  // node_modules/diffhtml/dist/es/tasks/end-as-promise.js
  function endAsPromise(transaction) {
    const { promises } = transaction;
    if (promises && promises.length) {
      return transaction.promise = Promise.all(promises).then(() => transaction.end());
    }
    return transaction.promise = Promise.resolve(transaction.end());
  }

  // node_modules/diffhtml/dist/es/util/has-module.js
  var element2 = global_default.document ? document.createElement("script") : null;
  function hasModule() {
    return Boolean(element2 && "noModule" in element2);
  }

  // node_modules/diffhtml/dist/es/transaction.js
  function _defineProperty2(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var { assign: assign2 } = Object;
  var defaultTasks = [schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode2, endAsPromise];
  var tasks = { schedule, shouldUpdate, reconcileTrees, syncTrees, patchNode: patchNode2, endAsPromise };
  var Transaction = class {
    static create(mount, input, options2) {
      return new Transaction(mount, input, options2);
    }
    static flow(transaction, tasks2) {
      let retVal = transaction;
      for (let i2 = 0; i2 < tasks2.length; i2++) {
        if (transaction.aborted) {
          return retVal;
        }
        retVal = tasks2[i2](transaction);
        if (retVal !== void 0 && retVal !== transaction) {
          return retVal;
        }
      }
      return retVal;
    }
    static assert(transaction) {
      if (process_default.env.NODE_ENV !== "production") {
        if (typeof transaction.mount !== "object" || !transaction.mount) {
          throw new Error("Transaction requires a DOM Node mount point");
        }
        if (transaction.aborted && transaction.completed) {
          throw new Error("Transaction was previously aborted");
        }
        if (transaction.completed) {
          throw new Error("Transaction was previously completed");
        }
      }
    }
    static invokeMiddleware(transaction) {
      const { state: { measure }, tasks: tasks2 } = transaction;
      MiddlewareCache.forEach((fn) => {
        const label = `invoke ${fn.name || "anon"}`;
        measure(label);
        const result = fn(transaction);
        if (result) {
          tasks2.push(result);
        }
        measure(label);
      });
    }
    constructor(mount, input, config2) {
      _defineProperty2(this, "state", EMPTY.OBJ);
      _defineProperty2(this, "mount", EMPTY.OBJ);
      _defineProperty2(this, "input", EMPTY.OBJ);
      _defineProperty2(this, "oldTree", void 0);
      _defineProperty2(this, "newTree", void 0);
      _defineProperty2(this, "promise", void 0);
      _defineProperty2(this, "promises", void 0);
      _defineProperty2(this, "tasks", []);
      _defineProperty2(this, "patches", []);
      this.mount = mount;
      this.input = input;
      this.config = config2;
      const useObserver = !config2.disableMutationObserver && "MutationObserver" in (global_default.window || EMPTY.OBJ);
      this.state = StateCache.get(mount) || { measure: makeMeasure(this), svgElements: /* @__PURE__ */ new Set(), scriptsToExecute: /* @__PURE__ */ new Map(), activeTransaction: this, mutationObserver: useObserver && new global_default.window.MutationObserver(EMPTY.FUN) };
      this.tasks = getConfig("tasks", defaultTasks, void 0, config2).slice();
      this.endedCallbacks = /* @__PURE__ */ new Set();
      StateCache.set(mount, this.state);
    }
    start() {
      if (process_default.env.NODE_ENV !== "production") {
        Transaction.assert(this);
      }
      const { state: { measure }, tasks: tasks2 } = this;
      const takeLastTask = tasks2.pop();
      measure("render");
      this.aborted = false;
      Transaction.invokeMiddleware(this);
      takeLastTask && tasks2.push(takeLastTask);
      return Transaction.flow(this, tasks2);
    }
    abort(isReturn) {
      this.aborted = true;
      if (isReturn) {
        return this.tasks[this.tasks.length - 1](this);
      }
    }
    end() {
      const { state: state3, config: config2, mount } = this;
      const { mutationObserver, measure, svgElements, scriptsToExecute } = state3;
      const mountAsHTMLEl = mount;
      measure("finalize");
      this.completed = true;
      svgElements.clear();
      state3.isRendering = false;
      state3.isDirty = false;
      if (mountAsHTMLEl.ownerDocument && mutationObserver) {
        mutationObserver.observe(mountAsHTMLEl, { subtree: true, childList: true, attributes: true, characterData: true });
      } else {
        state3.isDirty = true;
      }
      scriptsToExecute.forEach((type2, vTree) => {
        const oldNode = NodeCache.get(vTree);
        oldNode.type = type2;
        if (!config2.executeScripts || hasModule() && type2 === "nomodule") {
          return;
        }
        const newNode = assign2(oldNode.ownerDocument.createElement("script"), oldNode);
        for (let key2 in vTree.attributes) {
          const value = vTree.attributes[key2];
          newNode.setAttribute(key2, value);
        }
        newNode.textContent = oldNode.textContent;
        if (StateCache.has(oldNode)) {
          release(oldNode);
          StateCache.set(newNode, state3);
        }
        NodeCache.set(vTree, newNode);
        oldNode.parentNode && oldNode.parentNode.replaceChild(newNode, oldNode);
      });
      scriptsToExecute.clear();
      this.endedCallbacks.forEach((callback) => callback(this));
      this.endedCallbacks.clear();
      measure("finalize");
      measure("render");
      if (state3.oldTree)
        protectVTree(state3.oldTree);
      return this;
    }
    onceEnded(callback) {
      this.endedCallbacks.add(callback);
    }
  };

  // node_modules/diffhtml/dist/es/tasks/parse-new-tree.js
  function parseNewTree(transaction) {
    const { state: state3, input, config: options2 } = transaction;
    const { measure } = state3;
    if (typeof input === "string") {
      measure("parsing input for new tree");
      const { childNodes } = parse3(input, void 0, options2);
      const vTree = createTree(childNodes);
      if (vTree) {
        transaction.newTree = vTree;
      }
      measure("parsing input for new tree");
    }
  }

  // node_modules/diffhtml/dist/es/util/escape.js
  function escape2(unescaped) {
    return unescaped.replace(/[&<>]/g, (match) => `&#${match.charCodeAt(0)};`);
  }

  // node_modules/diffhtml/dist/es/util/internals.js
  function ownKeys2(object, enumerableOnly) {
    var keys4 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys4.push.apply(keys4, symbols2);
    }
    return keys4;
  }
  function _objectSpread2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key2) {
        _defineProperty3(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty3(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var caches = { StateCache, NodeCache, TransitionCache, MiddlewareCache, CreateTreeHookCache, CreateNodeHookCache, SyncTreeHookCache, ReleaseHookCache, ParseHookCache };
  var internals_default = _objectSpread2({
    decodeEntities,
    escape: escape2,
    makeMeasure,
    memory: memory_exports,
    Pool: pool_default,
    process: process_default,
    PATCH_TYPE,
    globalConfig,
    createNode,
    syncTree,
    Transaction,
    defaultTasks,
    tasks
  }, caches);

  // node_modules/diffhtml/dist/es/inner-html.js
  function innerHTML(mount, input = EMPTY.STR, config2 = {}) {
    config2.inner = true;
    config2.executeScripts = "executeScripts" in config2 ? config2.executeScripts : true;
    config2.tasks = config2.tasks || defaultTasks;
    return Transaction.create(mount, input, config2).start();
  }

  // node_modules/diffhtml/dist/es/outer-html.js
  function outerHTML(mount, input = EMPTY.STR, config2 = {}) {
    config2.inner = false;
    config2.executeScripts = "executeScripts" in config2 ? config2.executeScripts : true;
    config2.tasks = config2.tasks || defaultTasks;
    return Transaction.create(mount, input, config2).start();
  }

  // node_modules/diffhtml/dist/es/to-string.js
  var { keys: keys2 } = Object;
  function toString(input, config2 = {}) {
    const oldTree = createTree();
    const activeTasks = new Set(config2.tasks || defaultTasks);
    activeTasks.delete(tasks.patchNode);
    activeTasks.delete(tasks.endAsPromise);
    activeTasks.add(function endAsString(transaction) {
      return serializeVTree(transaction.oldTree);
    });
    config2.tasks = [...activeTasks];
    config2.inner = true;
    let markup = "";
    try {
      markup = Transaction.create(oldTree, input, config2).start();
    } catch (e2) {
      release(oldTree);
      throw e2;
    }
    release(oldTree);
    return markup;
  }
  function serializeAttributes(attributes2) {
    const attrs = keys2(attributes2);
    return attrs.length ? " " + attrs.map((keyName2) => {
      const value = attributes2[keyName2];
      const isFalsy = !value;
      const isDynamic = typeof value === "object" || typeof value === "function";
      if (value === true) {
        return keyName2;
      }
      return `${keyName2}${!isFalsy && !isDynamic ? `="${String(value)}"` : ""}`;
    }).join(" ") : "";
  }
  function serializeVTree(vTree) {
    let output = "";
    if (!vTree) {
      return output;
    }
    const { childNodes, nodeType, nodeName: tag, nodeValue, attributes: attributes2 } = vTree;
    if (nodeType === 11) {
      for (let i2 = 0; i2 < childNodes.length; i2++) {
        output += serializeVTree(childNodes[i2]);
      }
    } else if (!childNodes.length && nodeType === 1) {
      output += `<${tag}${serializeAttributes(attributes2)}></${tag}>`;
    } else if (nodeType === 3) {
      output += nodeValue;
    } else if (childNodes.length) {
      const children = childNodes.map((childNode) => `${serializeVTree(childNode)}`).join("");
      output += `<${tag}${serializeAttributes(attributes2)}>${children}</${tag}>`;
    }
    return output;
  }

  // node_modules/diffhtml/dist/es/html.js
  var { isArray: isArray3 } = Array;
  var isTagEx = /(<|\/)/;
  var nextValue = (values) => {
    const value = values.shift();
    return typeof value === "string" ? escape2(decodeEntities(value)) : value;
  };
  function handleTaggedTemplate(strings, ...values) {
    const empty2 = createTree("#text", EMPTY.STR);
    if (!strings) {
      return empty2;
    } else if (typeof strings === "string") {
      strings = [strings];
    }
    if (strings.length === 1 && !values.length) {
      if (!strings[0]) {
        return empty2;
      }
      const strict2 = getConfig("strict", false, "boolean", { strict: handleTaggedTemplate[$$strict] });
      delete handleTaggedTemplate[$$strict];
      const { childNodes: childNodes2 } = parse3(strings[0], void 0, { parser: { strict: strict2 } });
      return createTree(childNodes2.length === 1 ? childNodes2[0] : childNodes2);
    }
    let HTML = EMPTY.STR;
    const supplemental = { attributes: {}, children: {}, tags: {} };
    strings.forEach((string2, i2) => {
      HTML += string2;
      if (values.length) {
        const value = nextValue(values);
        const lastCharacter = HTML.trim().slice(-1);
        const isAttribute = HTML.lastIndexOf(">") < HTML.lastIndexOf("<");
        const isTag = Boolean(lastCharacter.match(isTagEx));
        const isObject = typeof value === "object";
        const token = `${TOKEN}${i2}__`;
        if (isTag) {
          supplemental.tags[i2] = value;
          HTML += token;
        } else if (isAttribute) {
          supplemental.attributes[i2] = value;
          HTML += token;
        } else if (isArray3(value) || isObject) {
          supplemental.children[i2] = createTree(value);
          HTML += token;
        } else if (value) {
          HTML += value;
        }
      }
    });
    const strict = getConfig("strict", false, "boolean", { strict: handleTaggedTemplate[$$strict] });
    const { childNodes } = parse3(HTML, supplemental, { parser: { strict } });
    return createTree(childNodes.length === 1 ? childNodes[0] : childNodes);
  }
  delete handleTaggedTemplate[$$strict];
  function setStrictMode(markup, ...args) {
    handleTaggedTemplate[$$strict] = true;
    try {
      return handleTaggedTemplate(markup, ...args);
    } catch (e2) {
      handleTaggedTemplate[$$strict] = false;
      throw e2;
    }
  }
  handleTaggedTemplate.strict = setStrictMode;

  // node_modules/diffhtml/dist/es/use.js
  var { isArray: isArray4 } = Array;
  function use(middleware) {
    const isFunction = typeof middleware === "function";
    const isObject = typeof middleware === "object";
    if (process_default.env.NODE_ENV !== "production") {
      if (!middleware || !isFunction && !isObject || isArray4(middleware)) {
        throw new Error("Middleware must be a function or plain object");
      }
    }
    const { subscribe, unsubscribe, createTreeHook, createNodeHook, syncTreeHook, releaseHook, parseHook } = middleware;
    isFunction && MiddlewareCache.add(middleware);
    subscribe && subscribe(internals_default);
    createTreeHook && CreateTreeHookCache.add(createTreeHook);
    createNodeHook && CreateNodeHookCache.add(createNodeHook);
    syncTreeHook && SyncTreeHookCache.add(syncTreeHook);
    releaseHook && ReleaseHookCache.add(releaseHook);
    parseHook && ParseHookCache.add(parseHook);
    return () => {
      isFunction && MiddlewareCache.delete(middleware);
      unsubscribe && unsubscribe(internals_default);
      createTreeHook && CreateTreeHookCache.delete(createTreeHook);
      createNodeHook && CreateNodeHookCache.delete(createNodeHook);
      syncTreeHook && SyncTreeHookCache.delete(syncTreeHook);
      releaseHook && ReleaseHookCache.delete(releaseHook);
      parseHook && ParseHookCache.delete(parseHook);
    };
  }

  // node_modules/diffhtml/dist/es/version.js
  var __VERSION__ = "1.0.0-beta.29";

  // node_modules/diffhtml/dist/es/index.js
  defaultTasks.splice(defaultTasks.indexOf(reconcileTrees), 0, parseNewTree);
  internals_default.parse = parse3;
  internals_default.VERSION = __VERSION__;
  var api2 = {};
  api2.VERSION = __VERSION__;
  api2.addTransitionState = addTransitionState;
  api2.removeTransitionState = removeTransitionState;
  api2.release = release;
  api2.createTree = createTree;
  api2.use = use;
  api2.outerHTML = outerHTML;
  api2.innerHTML = innerHTML;
  api2.toString = toString;
  api2.html = handleTaggedTemplate;
  api2.Internals = internals_default;
  var global2 = global_default;
  if ($$diffHTML in global_default) {
    const existingApi = global2[$$diffHTML];
    if (__VERSION__ !== existingApi.VERSION) {
      console.log(`Loaded ${__VERSION__} after ${existingApi.VERSION}`);
    }
  }
  global2[$$diffHTML] = api2;
  if (global2.devTools) {
    global2.unsubscribeDevTools = use(global2.devTools(internals_default));
  }

  // public/module.js
  var bus2 = window.bus;
  var state2 = bus2.state;
  bus2.libs.localstorage("ls/*");
  bus2.libs.http_out("/*", "/");
  window.braid_fetch = window.fetch;
  window.module = module2;
  window.state = state2;
  var CREATE_EVENT = "create";
  var observableEvents = [CREATE_EVENT];
  function update(target, compositor) {
    const html = compositor(target);
    if (html)
      innerHTML(target, html);
  }
  function draw(link2, compositor) {
    listen(CREATE_EVENT, link2, (event) => {
      bus2.reactive(
        update.bind(null, event.target, compositor)
      )();
    });
  }
  function flair(link2, stylesheet) {
    const styles = `
    <style type="text/css" data-tag=${link2}>
      ${stylesheet.replaceAll("&", link2)}
    </style>
  `;
    document.body.insertAdjacentHTML("beforeend", styles);
  }
  function learn(link2) {
    return state2[link2] || {};
  }
  function teach(link2, knowledge, nuance = (s, p2) => ({ ...s, ...p2 })) {
    const current = bus2.cache[link2] || {};
    state2[link2] = nuance(current.val || {}, knowledge);
  }
  function when(link1, eventName, link2, callback) {
    listen(eventName, `${link1} ${link2}`, callback);
  }
  function module2(link2, initialState3 = {}) {
    teach(link2, initialState3);
    return {
      link: link2,
      learn: learn.bind(null, link2),
      draw: draw.bind(null, link2),
      flair: flair.bind(null, link2),
      when: when.bind(null, link2),
      teach: teach.bind(null, link2)
    };
  }
  function listen(type2, link2, handler = () => null) {
    const callback = (event) => {
      if (event.target && event.target.matches && event.target.matches(link2)) {
        handler.call(null, event);
      }
    };
    document.addEventListener(type2, callback, true);
    if (observableEvents.includes(type2)) {
      observe(link2);
    }
    return function unlisten() {
      if (type2 === CREATE_EVENT) {
        disregard(link2);
      }
      document.removeEventListener(type2, callback, true);
    };
  }
  var links = [];
  function observe(link2) {
    links = [.../* @__PURE__ */ new Set([...links, link2])];
    maybeCreateReactive([...document.querySelectorAll(link2)]);
  }
  function disregard(link2) {
    const index = links.indexOf(link2);
    if (index >= 0) {
      links = [
        ...links.slice(0, index),
        ...links.slice(index + 1)
      ];
    }
  }
  function maybeCreateReactive(targets) {
    targets.filter((x) => !x.reactive).forEach(dispatchCreate);
  }
  function getSubscribers({ target }) {
    if (links.length > 0)
      return [...target.querySelectorAll(links.join(", "))];
    else
      return [];
  }
  function dispatchCreate(target) {
    if (!target.id)
      target.id = sufficientlyUniqueId();
    target.dispatchEvent(new Event(CREATE_EVENT));
    target.reactive = true;
  }
  new MutationObserver((mutationsList) => {
    const targets = [...mutationsList].map(getSubscribers).flatMap((x) => x);
    maybeCreateReactive(targets);
  }).observe(document.body, { childList: true, subtree: true });
  function sufficientlyUniqueId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c4) {
      const r = Math.random() * 16 | 0, v = c4 == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }

  // public/packages/smugoogle.js
  var import_maplibre_gl = __toESM(require_maplibre_gl());
  var $ = module2("smugoogle");
  var modes = {
    welcome: "welcome",
    planting: "planting",
    jamming: "jamming"
  };
  var actions = {
    goto: "goto",
    next: "next",
    back: "back"
  };
  var emptyLauncher = {
    mode: "welcome",
    nextMode: null,
    backMode: null,
    companionActive: true
  };
  var unregisterRandom = () => null;
  function launcherById(id2) {
    return $.learn()[id2] || emptyLauncher;
  }
  var paginationActions = [actions.back, actions.next];
  $.when("click", "[data-action]", action);
  $.when("click", "[data-goto]", goTo);
  var actionHandlers = {
    [modes.welcome]: (id2) => [
      `
			<button data-id="${id2}" data-goto="planting">
				Please continue
			</button>
			<button data-id="${id2}" data-goto="jamming">
				Skip the narrative
			</button>
		`
    ],
    [modes.planting]: (id2) => [
      `
			<button data-id="${id2}" data-goto="jamming">
				Begin Adeventure
			</button>
		`,
      `
			<button data-id="${id2}" data-action="back">
				Go Back
			</button>
		`
    ],
    [modes.jamming]: (id2) => [
      `
			<button data-id="${id2}" data-goto="welcome">
				Restart
			</button>
		`
    ],
    "default": (id2) => [
      `
			<button data-id="${id2}" data-goto="welcome">
				Restart
			</button>
		`
    ]
  };
  function actionItems(id2, mode) {
    const buttons = (actionHandlers[mode] || actionHandlers["default"])(id2).join("");
    return `
		<actions>
			${buttons}
		</actions>	
	`;
  }
  $.draw((target) => {
    const { id: id2 } = target;
    const launcher = launcherById(id2);
    const renderers = {
      [modes.welcome]: () => `
				<div class="card">
					<h2>Story Scout</h2>
					<p>Real stories happen in real places with real people.</p>
					${actionItems(id2, modes.welcome)}
				</div>
			`,
      [modes.planting]: () => `
				<div class="card">
					<h2>Mapping Time and Space</h2>
					<p>Scouts adventure adventure the planet, take photos, and geotag them.</p>
					${actionItems(id2, modes.planting)}
				</div>
			`,
      [modes.jamming]: () => `
				<div class="card">
					<h2>Map Layers</h2>
					<p>Drag and Drop to create a new map layer, then toggle existinglayers.</p>
          <google-maps></google-maps>
          <smug-mug></smug-mug>
				</div>
			`,
      "default": () => `
				<div class="card">
					<h2>Error...</h2>
					${actionItems(id2)}
				</div>
			`
    };
    const { mode, nextMode, companionActive } = launcher;
    const view = (renderers[mode] || renderers["default"])();
    const fadeOut = nextMode && mode !== nextMode;
    const companionClass = companionActive ? `mode-${mode} active` : `mode-${mode}`;
    return `
		<button aria-label="Companion" class="switcher" data-id="${id2}"></button>
		<companion class="${companionClass}">
			<transition class="${fadeOut ? "out" : ""}" data-id="${id2}">
				${view}
			</transition>
		</companion>
		<music-earth></music-earth>			
		`;
  });
  $.when("click", "button.switcher", switcher);
  function switcher({ target }) {
    const { id: id2 } = target.dataset;
    const { companionActive } = launcherById(id2);
    $.teach({ companionActive: !companionActive }, merge(id2));
  }
  function transition({ target }) {
    const { id: id2 } = target.dataset;
    const { mode, nextMode, backMode } = launcherById(id2);
    const currentMode = nextMode ? nextMode : mode;
    const previousMode = mode !== backMode ? backMode : mode;
    $.teach({ mode: currentMode, backMode: previousMode }, merge(id2));
    target.scrollTop = "0";
    document.activeElement.blur();
  }
  $.when("animationend", "transition", transition);
  $.flair(`
		& {
			background: white;
			display: block;
			position: absolute;
			overflow: hidden;
			height: 100%;
			width: 100%;
			inset: 0;
		}

		& .switcher {
      border-radius: 0 0 0 100%;
			display: block;
			position: fixed;
			height: 72px;
			padding: 0;
			margin: 0;
			background: orange;
			right: 0;
			z-index: 10;
			border: 0;
			top: 0;
			width: 72px;
		}

		& actions {
			position: absolute;
			right: 1rem;
			bottom: 1rem;
			border: 1px solid orange;
			border-radius: 2px;
		}

		& companion {
      background: rgba(0,0,0,.1);
			display: grid;
			place-items: center;
			position: fixed;
			top: 0;
      bottom: 0;
      right: 0;
			min-height: 1rem;
      max-width: 320px;
			z-index: 5;
			transition: transform 100ms ease-in-out;
			transform: translate(100%, -100%);
			border-bottom: 1px solid orange;
		}

		& companion.active {
			transform: translate(0, 0);
		}

		& companion:not(.active) button {
			animation: &-fade-out ease-in-out 0ms;
			display: none;
		}

		& companion button {
			animation: &-fade-in ease-in-out 1000ms;
			background: white;
			color: blue;
			text-decoration: underline;
			border: none;
			border-bottom: 1px solid cyan;
			width: 100%;
			padding: .5rem;
			text-align: left;
		}

		& companion button:last-child {
			border-bottom: none;	
		}

		& button {
			display: block;
			margin: 0;
		}

		& transition {
			animation: &-fade-in ease-in-out 250ms;
			display: grid;
			height: 100%;
			place-items: center;
			width: 100%;
		}

		& transition.out {
			animation: &-fade-out ease-in-out 100ms;
		}

		& .icons {
			display: grid;
			height: 100%;
			gap: 1rem;
			grid-template-columns: repeat(auto-fill, 4rem);
			grid-template-rows: repeat(auto-fill, 4rem);
			padding: 1rem;
			width: 100%;
		}

		& .icons button {
			margin: 0;
		}

		& .card {
			background: rgba(0,0,0,.85);
			color: rgba(255,255,255,.85);
			width: 100%;
      overflow: auto;
      height: 100%;
			padding: 1rem;
		}

		& .card h2 {
			margin: 0;
		}

		& .card p {
			margin: 0;
		}

		@keyframes &-fade-in {
			0% {
				opacity: 0;
			}
			100% {
				opacity: 1;
			}
		}

		@keyframes &-fade-out {
			0% {
				opacity: 1;
			}
			100% {
				opacity: 0;
			}
		}

		@keyframes &-zoom-in {
			0% {
				transform: scale(.9);
			}
			100% {
				transform: scale(1);
			}
		}

		@keyframes &-zoom-out {
			0% {
				transform: scale(1);
			}
			100% {
				transform: scale(.9);
			}
		}
	`);
  var welcomePath = [
    modes.welcome,
    modes.planting,
    modes.jamming
  ];
  function goTo({ target }) {
    const mode = target.dataset.goto;
    return messageStateMachine(target, { action: actions.goto, mode });
  }
  function action({ target }) {
    const { action: action2 } = target.dataset;
    return messageStateMachine(target, { action: action2 });
  }
  function dispatch(target, type2, mode) {
    const states = {
      "welcome": {
        "leaving": unregisterRandom,
        "entering": registerRandom
      }
    };
    if (states[mode]) {
      const change = states[mode][type2] || (() => null);
      change(target);
    }
  }
  function messageStateMachine(target, message) {
    const { id: id2 } = target.dataset;
    const { mode, backMode } = launcherById(id2);
    const { action: action2 } = message;
    function setMode(nextMode) {
      dispatch(target, "leaving", mode);
      $.teach({ nextMode }, merge(id2));
      dispatch(target, "entering", nextMode);
    }
    if (action2 === actions.goto) {
      setMode(message.mode);
      return;
    }
    if (action2 === actions.back && backMode) {
      setMode(backMode);
      return;
    }
    const onTheWelcomePath = welcomePath.includes(mode) && paginationActions.includes(action2);
    if (onTheWelcomePath) {
      const order = action2 === actions.next ? welcomePath : [...welcomePath].reverse();
      const nextIndex = order.indexOf(mode) + 1;
      setMode(order[nextIndex]);
      return;
    }
  }
  function merge(id2) {
    return function middleware(state3, payload) {
      return {
        ...state3,
        [id2]: {
          ...emptyLauncher,
          ...state3[id2],
          ...payload
        }
      };
    };
  }
  var $earth = module2("music-earth", { center: [0, 0] });
  function initialize(target) {
    const { center } = $earth.learn();
    const container = document.createElement("div");
    container.classList.add("map");
    target.appendChild(container);
    target.map = new import_maplibre_gl.default.Map({
      container,
      style: "https://demotiles.maplibre.org/style.json",
      center,
      zoom: 4,
      bearing: 0,
      pitch: 0
    });
    target.map.on("load", () => start(target));
  }
  function start(target) {
    target.map.resize();
    target.classList.add("ready");
    registerRandom();
    var deltaDistance = 100;
    var deltaDegrees = 25;
    function easing(t2) {
      return t2 * (2 - t2);
    }
    target.map.getCanvas().focus();
    target.map.getCanvas().addEventListener(
      "keydown",
      function(e2) {
        e2.preventDefault();
        if (e2.which === 38) {
          target.map.panBy([0, -deltaDistance], {
            easing
          });
        } else if (e2.which === 40) {
          target.map.panBy([0, deltaDistance], {
            easing
          });
        } else if (e2.which === 37) {
          target.map.easeTo({
            bearing: target.map.getBearing() - deltaDegrees,
            easing
          });
        } else if (e2.which === 39) {
          target.map.easeTo({
            bearing: target.map.getBearing() + deltaDegrees,
            easing
          });
        }
      },
      true
    );
  }
  function registerRandom() {
    unregisterRandom();
    const random = setInterval(() => jump(), 5e3);
    unregisterRandom = () => {
      clearInterval(random);
    };
  }
  function jump() {
    const center = [
      getRandomInRange(-90, 90, 3),
      getRandomInRange(-90, 90, 3)
    ];
    $earth.teach({
      center
    });
  }
  function getRandomInRange(from, to2, fixed) {
    return (Math.random() * (to2 - from) + from).toFixed(fixed);
  }
  $earth.draw(function drawPlanet(target) {
    if (!target.map)
      initialize(target);
    if (!!target.map.getSource) {
      const { center } = $earth.learn();
      target.map.flyTo({
        center,
        speed: 0.5
      });
    }
  });
  $earth.flair(`
	& {
		display: block;
	}

	& .map {
		position: absolute;
		inset: 0;
		width: 100%;
		height: 100%;
    opacity: 0;
    transform: scale(.9);
	}

	&.ready .map {
    transform: scale(1);
    opacity: 1;
    transition: all 250ms ease-in-out;
  }
`);

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element3) {
    return element3.getRootNode();
  } : function(element3) {
    return element3.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options2) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element3 = elementsToCheck.shift();
      if (element3.tagName === "SLOT") {
        var assigned = element3.assignedElements();
        var content2 = assigned.length ? assigned : element3.children;
        var nestedCandidates = getCandidatesIteratively2(content2, true, options2);
        if (options2.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element3,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element3, candidateSelector);
        if (validCandidate && options2.filter(element3) && (includeContainer || !elements.includes(element3))) {
          candidates.push(element3);
        }
        var shadowRoot = element3.shadowRoot || typeof options2.getShadowRoot === "function" && options2.getShadowRoot(element3);
        var validShadowRoot = !options2.shadowRootFilter || options2.shadowRootFilter(element3);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element3.children : shadowRoot.children, true, options2);
          if (options2.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scopeParent: element3,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element3.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
    return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2].checked && nodes[i2].form === form) {
        return nodes[i2];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name3) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name3 + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isNodeAttached = function isNodeAttached2(node) {
    var _nodeRootHost;
    var nodeRootHost = getRootNode(node).host;
    var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRootHost2;
      nodeRootHost = getRootNode(nodeRootHost).host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
    }
    return attached;
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (isNodeAttached(node)) {
        return !node.getClientRects().length;
      }
      if (displayCheck !== "legacy-full") {
        return true;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i2 = 0; i2 < parentNode.children.length; i2++) {
            var child = parentNode.children.item(i2);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options2, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options2) || isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options2, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options2, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i2) {
      var isScope = !!item.scopeParent;
      var element3 = isScope ? item.scopeParent : item;
      var candidateTabindex = getTabindex(element3, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element3;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element3);
      } else {
        orderedTabbables.push({
          documentOrder: i2,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options2) {
    options2 = options2 || {};
    var candidates;
    if (options2.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options2.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options2),
        flatten: false,
        getShadowRoot: options2.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options2.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options2));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options2) {
    options2 = options2 || {};
    var candidates;
    if (options2.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options2.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options2),
        flatten: true,
        getShadowRoot: options2.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options2.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options2));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options2) {
    options2 = options2 || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options2, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options2) {
    options2 = options2 || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options2, node);
  };

  // node_modules/focus-trap/dist/focus-trap.esm.js
  function ownKeys3(object, enumerableOnly) {
    var keys4 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols2 = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols2 = symbols2.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys4.push.apply(keys4, symbols2);
    }
    return keys4;
  }
  function _objectSpread22(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys3(Object(source), true).forEach(function(key2) {
        _defineProperty4(target, key2, source[key2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
    return target;
  }
  function _defineProperty4(obj, key2, value) {
    if (key2 in obj) {
      Object.defineProperty(obj, key2, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key2] = value;
    }
    return obj;
  }
  var activeFocusTraps = function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e2) {
    return e2.key === "Escape" || e2.key === "Esc" || e2.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e2) {
    return e2.key === "Tab" || e2.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i2) {
      if (fn(value)) {
        idx = i2;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event) {
    return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc2 = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config2 = _objectSpread22({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state3 = {
      containers: [],
      containerGroups: [],
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config2[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element3) {
      return state3.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element3) || tabbableNodes.find(function(node) {
          return node === element3;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config2[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc2.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc2.activeElement) >= 0) {
          node = doc2.activeElement;
        } else {
          var firstTabbableGroup = state3.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state3.containerGroups = state3.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config2.tabbableOptions);
        var focusableNodes = focusable(container, config2.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n2) {
              return n2 === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n2) {
                return isTabbable(n2, config2.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n2) {
              return isTabbable(n2, config2.tabbableOptions);
            });
          }
        };
      });
      state3.tabbableGroups = state3.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state3.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc2.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config2.preventScroll
      });
      state3.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
        trap.deactivate({
          returnFocus: config2.returnFocusOnDeactivate && !isFocusable(target, config2.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config2.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e2) {
      var target = getActualTarget(e2);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state3.mostRecentlyFocusedNode = target;
        }
      } else {
        e2.stopImmediatePropagation();
        tryFocus(state3.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e2) {
      var target = getActualTarget(e2);
      updateTabbableNodes();
      var destinationNode = null;
      if (state3.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state3.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e2.shiftKey) {
            destinationNode = state3.tabbableGroups[state3.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state3.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e2.shiftKey) {
          var startOfGroupIndex = findIndex(state3.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state3.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state3.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state3.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config2.tabbableOptions) && !isTabbable(target, config2.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state3.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state3.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e2.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e2) {
      if (isEscapeEvent(e2) && valueOrHandler(config2.escapeDeactivates, e2) !== false) {
        e2.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e2)) {
        checkTab(e2);
        return;
      }
    };
    var checkClick = function checkClick2(e2) {
      var target = getActualTarget(e2);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config2.clickOutsideDeactivates, e2)) {
        return;
      }
      if (valueOrHandler(config2.allowOutsideClick, e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state3.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state3.delayInitialFocusTimer = config2.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc2.addEventListener("focusin", checkFocusIn, true);
      doc2.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc2.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state3.active) {
        return;
      }
      doc2.removeEventListener("focusin", checkFocusIn, true);
      doc2.removeEventListener("mousedown", checkPointerDown, true);
      doc2.removeEventListener("touchstart", checkPointerDown, true);
      doc2.removeEventListener("click", checkClick, true);
      doc2.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state3.active;
      },
      get paused() {
        return state3.paused;
      },
      activate: function activate(activateOptions) {
        if (state3.active) {
          return this;
        }
        var onActivate2 = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state3.active = true;
        state3.paused = false;
        state3.nodeFocusedBeforeActivation = doc2.activeElement;
        if (onActivate2) {
          onActivate2();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state3.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state3.active) {
          return this;
        }
        var options2 = _objectSpread22({
          onDeactivate: config2.onDeactivate,
          onPostDeactivate: config2.onPostDeactivate,
          checkCanReturnFocus: config2.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state3.delayInitialFocusTimer);
        state3.delayInitialFocusTimer = void 0;
        removeListeners();
        state3.active = false;
        state3.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate2 = getOption(options2, "onDeactivate");
        var onPostDeactivate = getOption(options2, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options2, "checkCanReturnFocus");
        var returnFocus = getOption(options2, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate2) {
          onDeactivate2();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state3.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state3.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state3.paused || !state3.active) {
          return this;
        }
        state3.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state3.paused || !state3.active) {
          return this;
        }
        state3.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state3.containers = elementsAsArray.map(function(element3) {
          return typeof element3 === "string" ? doc2.querySelector(element3) : element3;
        });
        if (state3.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };

  // public/packages/console-module.js
  var ENUMS = [
    { command: "escape" },
    { command: "download" },
    { command: "upload" }
  ];
  function execute(command2) {
    alert(`executed ${command2}`);
  }
  var $2 = module2("console-module", {
    filter: ""
  });
  $2.when("click", ".item", function update2(event) {
    event.preventDefault();
    const args = attributes(event.target, $2);
    const { command: command2 } = event.target.dataset;
    execute(command2);
    args.root.trap.deactivate();
  });
  $2.when("click", ".bar", toggleActive);
  $2.when("keyup", '[name="filter"]', setFilter);
  $2.draw((target) => {
    if (!target.trap) {
      target.trap = createFocusTrap(target, {
        onActivate: onActivate(target),
        onDeactivate: onDeactivate(target),
        clickOutsideDeactivates: true
      });
    }
    const { filter } = $2.learn();
    const choices = [];
    const list = ENUMS.filter((x) => x.command.toLowerCase().indexOf(filter.toLowerCase()) > -1).map((x) => `
      <button class="item" data-command="${x.command}">
        ${x.command}
      </button>
    `).join("");
    const customOption = `
    <button class="item" data-id="${filter}">
      ${filter}
    </button>
  `;
    return `
    <button class="bar">
      'run: ' ${choices.map((x) => x.command).join(", ")}
    </button>

    <div class="filterable-list">
      <div class="filter-area">
        <input type="text" name="filter" placeholder="Search" value="${filter}" />
      </div>
      <div class="list">
        ${list}
        ${customOption}
      </div>
    </div>
  `;
  });
  function attributes(node, $11) {
    const root = node.closest($11.selector);
    return { root };
  }
  function toggleActive(event) {
    const args = attributes(event.target, $2);
    if (isActive(args.root)) {
      args.root.trap.deactivate();
    } else {
      args.root.trap.activate();
    }
  }
  function setFilter(event) {
    const { value } = event.target;
    $2.teach({ filter: value });
  }
  function onActivate(target) {
    return () => {
      target.classList.add("is-active");
      target.querySelector('[name="filter"]').focus();
    };
  }
  function onDeactivate(target) {
    return () => {
      target.classList.remove("is-active");
      $2.teach({ filter: "" });
    };
  }
  function isActive(target) {
    return target.matches(".is-active");
  }
  $2.flair(`
	& {
		display: block;
		position: relative;
		z-index: 3;
    width: 100%;
	}

	& .filter-area {
    margin: .5rem;
	}

	& .bar {
		white-space: nowrap;
		background: rgba(255,255,255,.85);
    width: 100%;
	}

	&.is-active .bar {
	}
	& .bar:hover,
	& .bar:focus {
	}

	& [name="filter"] {
		background: white;
		border: none;
		width: 100%;
    display: block;
	}

	& .filterable-list {
    background: white;
		display: none;
		position: absolute;
    width: 100%;
	}

	&.is-active .filterable-list {
		display: flex;
    flex-direction: column;
	}

  & .filterable-list.above {
    top: 0;
    transform: translateY(-100%);
    flex-direction: column-reverse;
  }

	& .item {
		background: transparent;
		border: none;
		display: grid;
		grid-template-columns: auto 1fr;
		align-items: center;
		min-height: 40px;
		margin: 0;
		text-align: left;
		width: 100%;
	}

	& .item * {
		pointer-events: none;
	}

	& .list {
		max-height: 80vh;
		overflow-y: auto;
	}

	& .item:hover,
	& .item:focus {
		background: linear-gradient(rgba(0,0,0,0) 75%, rgba(0,0,0,.25));
	}
`);

  // node_modules/@codemirror/state/dist/index.js
  var Text = class {
    constructor() {
    }
    lineAt(pos) {
      if (pos < 0 || pos > this.length)
        throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
      return this.lineInner(pos, false, 1, 0);
    }
    line(n2) {
      if (n2 < 1 || n2 > this.lines)
        throw new RangeError(`Invalid line number ${n2} in ${this.lines}-line document`);
      return this.lineInner(n2, true, 1, 0);
    }
    replace(from, to2, text) {
      let parts = [];
      this.decompose(0, from, parts, 2);
      if (text.length)
        text.decompose(0, text.length, parts, 1 | 2);
      this.decompose(to2, this.length, parts, 1);
      return TextNode.from(parts, this.length - (to2 - from) + text.length);
    }
    append(other) {
      return this.replace(this.length, this.length, other);
    }
    slice(from, to2 = this.length) {
      let parts = [];
      this.decompose(from, to2, parts, 0);
      return TextNode.from(parts, to2 - from);
    }
    eq(other) {
      if (other == this)
        return true;
      if (other.length != this.length || other.lines != this.lines)
        return false;
      let start2 = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
      let a2 = new RawTextCursor(this), b2 = new RawTextCursor(other);
      for (let skip = start2, pos = start2; ; ) {
        a2.next(skip);
        b2.next(skip);
        skip = 0;
        if (a2.lineBreak != b2.lineBreak || a2.done != b2.done || a2.value != b2.value)
          return false;
        pos += a2.value.length;
        if (a2.done || pos >= end)
          return true;
      }
    }
    iter(dir = 1) {
      return new RawTextCursor(this, dir);
    }
    iterRange(from, to2 = this.length) {
      return new PartialTextCursor(this, from, to2);
    }
    iterLines(from, to2) {
      let inner;
      if (from == null) {
        inner = this.iter();
      } else {
        if (to2 == null)
          to2 = this.lines + 1;
        let start2 = this.line(from).from;
        inner = this.iterRange(start2, Math.max(start2, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
      }
      return new LineCursor(inner);
    }
    toString() {
      return this.sliceString(0);
    }
    toJSON() {
      let lines = [];
      this.flatten(lines);
      return lines;
    }
    static of(text) {
      if (text.length == 0)
        throw new RangeError("A document must have at least one line");
      if (text.length == 1 && !text[0])
        return Text.empty;
      return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
  };
  var TextLeaf = class extends Text {
    constructor(text, length = textLength(text)) {
      super();
      this.text = text;
      this.length = length;
    }
    get lines() {
      return this.text.length;
    }
    get children() {
      return null;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let string2 = this.text[i2], end = offset + string2.length;
        if ((isLine ? line : end) >= target)
          return new Line(offset, end, line, string2);
        offset = end + 1;
        line++;
      }
    }
    decompose(from, to2, target, open) {
      let text = from <= 0 && to2 >= this.length ? this : new TextLeaf(sliceText(this.text, from, to2), Math.min(to2, this.length) - Math.max(0, from));
      if (open & 1) {
        let prev = target.pop();
        let joined = appendText(text.text, prev.text.slice(), 0, text.length);
        if (joined.length <= 32) {
          target.push(new TextLeaf(joined, prev.length + text.length));
        } else {
          let mid = joined.length >> 1;
          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
        }
      } else {
        target.push(text);
      }
    }
    replace(from, to2, text) {
      if (!(text instanceof TextLeaf))
        return super.replace(from, to2, text);
      let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to2);
      let newLen = this.length + text.length - (to2 - from);
      if (lines.length <= 32)
        return new TextLeaf(lines, newLen);
      return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to2 = this.length, lineSep = "\n") {
      let result = "";
      for (let pos = 0, i2 = 0; pos <= to2 && i2 < this.text.length; i2++) {
        let line = this.text[i2], end = pos + line.length;
        if (pos > from && i2)
          result += lineSep;
        if (from < end && to2 > pos)
          result += line.slice(Math.max(0, from - pos), to2 - pos);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let line of this.text)
        target.push(line);
    }
    scanIdentical() {
      return 0;
    }
    static split(text, target) {
      let part = [], len = -1;
      for (let line of text) {
        part.push(line);
        len += line.length + 1;
        if (part.length == 32) {
          target.push(new TextLeaf(part, len));
          part = [];
          len = -1;
        }
      }
      if (len > -1)
        target.push(new TextLeaf(part, len));
      return target;
    }
  };
  var TextNode = class extends Text {
    constructor(children, length) {
      super();
      this.children = children;
      this.length = length;
      this.lines = 0;
      for (let child of children)
        this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
      for (let i2 = 0; ; i2++) {
        let child = this.children[i2], end = offset + child.length, endLine = line + child.lines - 1;
        if ((isLine ? endLine : end) >= target)
          return child.lineInner(target, isLine, line, offset);
        offset = end + 1;
        line = endLine + 1;
      }
    }
    decompose(from, to2, target, open) {
      for (let i2 = 0, pos = 0; pos <= to2 && i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (from <= end && to2 >= pos) {
          let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to2 ? 2 : 0));
          if (pos >= from && end <= to2 && !childOpen)
            target.push(child);
          else
            child.decompose(from - pos, to2 - pos, target, childOpen);
        }
        pos = end + 1;
      }
    }
    replace(from, to2, text) {
      if (text.lines < this.lines)
        for (let i2 = 0, pos = 0; i2 < this.children.length; i2++) {
          let child = this.children[i2], end = pos + child.length;
          if (from >= pos && to2 <= end) {
            let updated = child.replace(from - pos, to2 - pos, text);
            let totalLines = this.lines - child.lines + updated.lines;
            if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
              let copy = this.children.slice();
              copy[i2] = updated;
              return new TextNode(copy, this.length - (to2 - from) + text.length);
            }
            return super.replace(pos, end, updated);
          }
          pos = end + 1;
        }
      return super.replace(from, to2, text);
    }
    sliceString(from, to2 = this.length, lineSep = "\n") {
      let result = "";
      for (let i2 = 0, pos = 0; i2 < this.children.length && pos <= to2; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos > from && i2)
          result += lineSep;
        if (from < end && to2 > pos)
          result += child.sliceString(from - pos, to2 - pos, lineSep);
        pos = end + 1;
      }
      return result;
    }
    flatten(target) {
      for (let child of this.children)
        child.flatten(target);
    }
    scanIdentical(other, dir) {
      if (!(other instanceof TextNode))
        return 0;
      let length = 0;
      let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
      for (; ; iA += dir, iB += dir) {
        if (iA == eA || iB == eB)
          return length;
        let chA = this.children[iA], chB = other.children[iB];
        if (chA != chB)
          return length + chA.scanIdentical(chB, dir);
        length += chA.length + 1;
      }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
      let lines = 0;
      for (let ch of children)
        lines += ch.lines;
      if (lines < 32) {
        let flat = [];
        for (let ch of children)
          ch.flatten(flat);
        return new TextLeaf(flat, length);
      }
      let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
      let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
      function add2(child) {
        let last2;
        if (child.lines > maxChunk && child instanceof TextNode) {
          for (let node of child.children)
            add2(node);
        } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
          flush();
          chunked.push(child);
        } else if (child instanceof TextLeaf && currentLines && (last2 = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last2.lines <= 32) {
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk[currentChunk.length - 1] = new TextLeaf(last2.text.concat(child.text), last2.length + 1 + child.length);
        } else {
          if (currentLines + child.lines > chunk)
            flush();
          currentLines += child.lines;
          currentLen += child.length + 1;
          currentChunk.push(child);
        }
      }
      function flush() {
        if (currentLines == 0)
          return;
        chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
        currentLen = -1;
        currentLines = currentChunk.length = 0;
      }
      for (let child of children)
        add2(child);
      flush();
      return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
  };
  Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
  function textLength(text) {
    let length = -1;
    for (let line of text)
      length += line.length + 1;
    return length;
  }
  function appendText(text, target, from = 0, to2 = 1e9) {
    for (let pos = 0, i2 = 0, first = true; i2 < text.length && pos <= to2; i2++) {
      let line = text[i2], end = pos + line.length;
      if (end >= from) {
        if (end > to2)
          line = line.slice(0, to2 - pos);
        if (pos < from)
          line = line.slice(from - pos);
        if (first) {
          target[target.length - 1] += line;
          first = false;
        } else
          target.push(line);
      }
      pos = end + 1;
    }
    return target;
  }
  function sliceText(text, from, to2) {
    return appendText(text, [""], from, to2);
  }
  var RawTextCursor = class {
    constructor(text, dir = 1) {
      this.dir = dir;
      this.done = false;
      this.lineBreak = false;
      this.value = "";
      this.nodes = [text];
      this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
      this.done = this.lineBreak = false;
      for (; ; ) {
        let last2 = this.nodes.length - 1;
        let top2 = this.nodes[last2], offsetValue = this.offsets[last2], offset = offsetValue >> 1;
        let size2 = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
        if (offset == (dir > 0 ? size2 : 0)) {
          if (last2 == 0) {
            this.done = true;
            this.value = "";
            return this;
          }
          if (dir > 0)
            this.offsets[last2 - 1]++;
          this.nodes.pop();
          this.offsets.pop();
        } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
          this.offsets[last2] += dir;
          if (skip == 0) {
            this.lineBreak = true;
            this.value = "\n";
            return this;
          }
          skip--;
        } else if (top2 instanceof TextLeaf) {
          let next = top2.text[offset + (dir < 0 ? -1 : 0)];
          this.offsets[last2] += dir;
          if (next.length > Math.max(0, skip)) {
            this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
            return this;
          }
          skip -= next.length;
        } else {
          let next = top2.children[offset + (dir < 0 ? -1 : 0)];
          if (skip > next.length) {
            skip -= next.length;
            this.offsets[last2] += dir;
          } else {
            if (dir < 0)
              this.offsets[last2]--;
            this.nodes.push(next);
            this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
          }
        }
      }
    }
    next(skip = 0) {
      if (skip < 0) {
        this.nextInner(-skip, -this.dir);
        skip = this.value.length;
      }
      return this.nextInner(skip, this.dir);
    }
  };
  var PartialTextCursor = class {
    constructor(text, start2, end) {
      this.value = "";
      this.done = false;
      this.cursor = new RawTextCursor(text, start2 > end ? -1 : 1);
      this.pos = start2 > end ? text.length : 0;
      this.from = Math.min(start2, end);
      this.to = Math.max(start2, end);
    }
    nextInner(skip, dir) {
      if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
        this.value = "";
        this.done = true;
        return this;
      }
      skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
      let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
      if (skip > limit)
        skip = limit;
      limit -= skip;
      let { value } = this.cursor.next(skip);
      this.pos += (value.length + skip) * dir;
      this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
      this.done = !this.value;
      return this;
    }
    next(skip = 0) {
      if (skip < 0)
        skip = Math.max(skip, this.from - this.pos);
      else if (skip > 0)
        skip = Math.min(skip, this.to - this.pos);
      return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() {
      return this.cursor.lineBreak && this.value != "";
    }
  };
  var LineCursor = class {
    constructor(inner) {
      this.inner = inner;
      this.afterBreak = true;
      this.value = "";
      this.done = false;
    }
    next(skip = 0) {
      let { done, lineBreak, value } = this.inner.next(skip);
      if (done) {
        this.done = true;
        this.value = "";
      } else if (lineBreak) {
        if (this.afterBreak) {
          this.value = "";
        } else {
          this.afterBreak = true;
          this.next();
        }
      } else {
        this.value = value;
        this.afterBreak = false;
      }
      return this;
    }
    get lineBreak() {
      return false;
    }
  };
  if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function() {
      return this.iter();
    };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  var Line = class {
    constructor(from, to2, number2, text) {
      this.from = from;
      this.to = to2;
      this.number = number2;
      this.text = text;
    }
    get length() {
      return this.to - this.from;
    }
  };
  var extend2 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
  for (let i2 = 1; i2 < extend2.length; i2++)
    extend2[i2] += extend2[i2 - 1];
  function isExtendingChar(code2) {
    for (let i2 = 1; i2 < extend2.length; i2 += 2)
      if (extend2[i2] > code2)
        return extend2[i2 - 1] <= code2;
    return false;
  }
  function isRegionalIndicator(code2) {
    return code2 >= 127462 && code2 <= 127487;
  }
  var ZWJ = 8205;
  function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
  }
  function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
      return pos;
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
      pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
      let next = codePointAt(str, pos);
      if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
        pos += codePointSize(next);
        prev = next;
      } else if (isRegionalIndicator(next)) {
        let countBefore = 0, i2 = pos - 2;
        while (i2 >= 0 && isRegionalIndicator(codePointAt(str, i2))) {
          countBefore++;
          i2 -= 2;
        }
        if (countBefore % 2 == 0)
          break;
        else
          pos += 2;
      } else {
        break;
      }
    }
    return pos;
  }
  function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
      let found = nextClusterBreak(str, pos - 2, includeExtending);
      if (found < pos)
        return found;
      pos--;
    }
    return 0;
  }
  function surrogateLow(ch) {
    return ch >= 56320 && ch < 57344;
  }
  function surrogateHigh(ch) {
    return ch >= 55296 && ch < 56320;
  }
  function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
      return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
      return code0;
    return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
  }
  function fromCodePoint(code2) {
    if (code2 <= 65535)
      return String.fromCharCode(code2);
    code2 -= 65536;
    return String.fromCharCode((code2 >> 10) + 55296, (code2 & 1023) + 56320);
  }
  function codePointSize(code2) {
    return code2 < 65536 ? 1 : 2;
  }
  var DefaultSplit = /\r\n?|\n/;
  var MapMode = /* @__PURE__ */ function(MapMode2) {
    MapMode2[MapMode2["Simple"] = 0] = "Simple";
    MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
    MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
    MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
    return MapMode2;
  }(MapMode || (MapMode = {}));
  var ChangeDesc = class {
    constructor(sections) {
      this.sections = sections;
    }
    get length() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2)
        result += this.sections[i2];
      return result;
    }
    get newLength() {
      let result = 0;
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let ins = this.sections[i2 + 1];
        result += ins < 0 ? this.sections[i2] : ins;
      }
      return result;
    }
    get empty() {
      return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
    }
    iterGaps(f) {
      for (let i2 = 0, posA = 0, posB = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0) {
          f(posA, posB, len);
          posB += len;
        } else {
          posB += ins;
        }
        posA += len;
      }
    }
    iterChangedRanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get invertedDesc() {
      let sections = [];
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        if (ins < 0)
          sections.push(len, ins);
        else
          sections.push(ins, len);
      }
      return new ChangeDesc(sections);
    }
    composeDesc(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other);
    }
    mapDesc(other, before = false) {
      return other.empty ? this : mapSet(this, other, before);
    }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
      let posA = 0, posB = 0;
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], endA = posA + len;
        if (ins < 0) {
          if (endA > pos)
            return posB + (pos - posA);
          posB += len;
        } else {
          if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
            return null;
          if (endA > pos || endA == pos && assoc < 0 && !len)
            return pos == posA || assoc < 0 ? posB : posB + ins;
          posB += ins;
        }
        posA = endA;
      }
      if (pos > posA)
        throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
      return posB;
    }
    touchesRange(from, to2 = from) {
      for (let i2 = 0, pos = 0; i2 < this.sections.length && pos <= to2; ) {
        let len = this.sections[i2++], ins = this.sections[i2++], end = pos + len;
        if (ins >= 0 && pos <= to2 && end >= from)
          return pos < from && end > to2 ? "cover" : true;
        pos = end;
      }
      return false;
    }
    toString() {
      let result = "";
      for (let i2 = 0; i2 < this.sections.length; ) {
        let len = this.sections[i2++], ins = this.sections[i2++];
        result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
      }
      return result;
    }
    toJSON() {
      return this.sections;
    }
    static fromJSON(json) {
      if (!Array.isArray(json) || json.length % 2 || json.some((a2) => typeof a2 != "number"))
        throw new RangeError("Invalid JSON representation of ChangeDesc");
      return new ChangeDesc(json);
    }
    static create(sections) {
      return new ChangeDesc(sections);
    }
  };
  var ChangeSet = class extends ChangeDesc {
    constructor(sections, inserted) {
      super(sections);
      this.inserted = inserted;
    }
    apply(doc2) {
      if (this.length != doc2.length)
        throw new RangeError("Applying change set to a document with the wrong length");
      iterChanges(this, (fromA, toA, fromB, _toB, text) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text), false);
      return doc2;
    }
    mapDesc(other, before = false) {
      return mapSet(this, other, before, true);
    }
    invert(doc2) {
      let sections = this.sections.slice(), inserted = [];
      for (let i2 = 0, pos = 0; i2 < sections.length; i2 += 2) {
        let len = sections[i2], ins = sections[i2 + 1];
        if (ins >= 0) {
          sections[i2] = ins;
          sections[i2 + 1] = len;
          let index = i2 >> 1;
          while (inserted.length < index)
            inserted.push(Text.empty);
          inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
        }
        pos += len;
      }
      return new ChangeSet(sections, inserted);
    }
    compose(other) {
      return this.empty ? other : other.empty ? this : composeSets(this, other, true);
    }
    map(other, before = false) {
      return other.empty ? this : mapSet(this, other, before, true);
    }
    iterChanges(f, individual = false) {
      iterChanges(this, f, individual);
    }
    get desc() {
      return ChangeDesc.create(this.sections);
    }
    filter(ranges) {
      let resultSections = [], resultInserted = [], filteredSections = [];
      let iter = new SectionIter(this);
      done:
        for (let i2 = 0, pos = 0; ; ) {
          let next = i2 == ranges.length ? 1e9 : ranges[i2++];
          while (pos < next || pos == next && iter.len == 0) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, next - pos);
            addSection(filteredSections, len, -1);
            let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
            addSection(resultSections, len, ins);
            if (ins > 0)
              addInsert(resultInserted, resultSections, iter.text);
            iter.forward(len);
            pos += len;
          }
          let end = ranges[i2++];
          while (pos < end) {
            if (iter.done)
              break done;
            let len = Math.min(iter.len, end - pos);
            addSection(resultSections, len, -1);
            addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
            iter.forward(len);
            pos += len;
          }
        }
      return {
        changes: new ChangeSet(resultSections, resultInserted),
        filtered: ChangeDesc.create(filteredSections)
      };
    }
    toJSON() {
      let parts = [];
      for (let i2 = 0; i2 < this.sections.length; i2 += 2) {
        let len = this.sections[i2], ins = this.sections[i2 + 1];
        if (ins < 0)
          parts.push(len);
        else if (ins == 0)
          parts.push([len]);
        else
          parts.push([len].concat(this.inserted[i2 >> 1].toJSON()));
      }
      return parts;
    }
    static of(changes, length, lineSep) {
      let sections = [], inserted = [], pos = 0;
      let total = null;
      function flush(force = false) {
        if (!force && !sections.length)
          return;
        if (pos < length)
          addSection(sections, length - pos, -1);
        let set3 = new ChangeSet(sections, inserted);
        total = total ? total.compose(set3.map(total)) : set3;
        sections = [];
        inserted = [];
        pos = 0;
      }
      function process2(spec) {
        if (Array.isArray(spec)) {
          for (let sub of spec)
            process2(sub);
        } else if (spec instanceof ChangeSet) {
          if (spec.length != length)
            throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
          flush();
          total = total ? total.compose(spec.map(total)) : spec;
        } else {
          let { from, to: to2 = from, insert: insert2 } = spec;
          if (from > to2 || from < 0 || to2 > length)
            throw new RangeError(`Invalid change range ${from} to ${to2} (in doc of length ${length})`);
          let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
          let insLen = insText.length;
          if (from == to2 && insLen == 0)
            return;
          if (from < pos)
            flush();
          if (from > pos)
            addSection(sections, from - pos, -1);
          addSection(sections, to2 - from, insLen);
          addInsert(inserted, sections, insText);
          pos = to2;
        }
      }
      process2(changes);
      flush(!total);
      return total;
    }
    static empty(length) {
      return new ChangeSet(length ? [length, -1] : [], []);
    }
    static fromJSON(json) {
      if (!Array.isArray(json))
        throw new RangeError("Invalid JSON representation of ChangeSet");
      let sections = [], inserted = [];
      for (let i2 = 0; i2 < json.length; i2++) {
        let part = json[i2];
        if (typeof part == "number") {
          sections.push(part, -1);
        } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e2, i3) => i3 && typeof e2 != "string")) {
          throw new RangeError("Invalid JSON representation of ChangeSet");
        } else if (part.length == 1) {
          sections.push(part[0], 0);
        } else {
          while (inserted.length < i2)
            inserted.push(Text.empty);
          inserted[i2] = Text.of(part.slice(1));
          sections.push(part[0], inserted[i2].length);
        }
      }
      return new ChangeSet(sections, inserted);
    }
    static createSet(sections, inserted) {
      return new ChangeSet(sections, inserted);
    }
  };
  function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
      return;
    let last2 = sections.length - 2;
    if (last2 >= 0 && ins <= 0 && ins == sections[last2 + 1])
      sections[last2] += len;
    else if (len == 0 && sections[last2] == 0)
      sections[last2 + 1] += ins;
    else if (forceJoin) {
      sections[last2] += len;
      sections[last2 + 1] += ins;
    } else
      sections.push(len, ins);
  }
  function addInsert(values, sections, value) {
    if (value.length == 0)
      return;
    let index = sections.length - 2 >> 1;
    if (index < values.length) {
      values[values.length - 1] = values[values.length - 1].append(value);
    } else {
      while (values.length < index)
        values.push(Text.empty);
      values.push(value);
    }
  }
  function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i2 = 0; i2 < desc.sections.length; ) {
      let len = desc.sections[i2++], ins = desc.sections[i2++];
      if (ins < 0) {
        posA += len;
        posB += len;
      } else {
        let endA = posA, endB = posB, text = Text.empty;
        for (; ; ) {
          endA += len;
          endB += ins;
          if (ins && inserted)
            text = text.append(inserted[i2 - 2 >> 1]);
          if (individual || i2 == desc.sections.length || desc.sections[i2 + 1] < 0)
            break;
          len = desc.sections[i2++];
          ins = desc.sections[i2++];
        }
        f(posA, endA, posB, endB, text);
        posA = endA;
        posB = endB;
      }
    }
  }
  function mapSet(setA, setB, before, mkSet = false) {
    let sections = [], insert2 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let posA = 0, posB = 0; ; ) {
      if (a2.ins == -1) {
        posA += a2.len;
        a2.next();
      } else if (b2.ins == -1 && posB < posA) {
        let skip = Math.min(b2.len, posA - posB);
        b2.forward(skip);
        addSection(sections, skip, -1);
        posB += skip;
      } else if (b2.ins >= 0 && (a2.done || posB < posA || posB == posA && (b2.len < a2.len || b2.len == a2.len && !before))) {
        addSection(sections, b2.ins, -1);
        while (posA > posB && !a2.done && posA + a2.len < posB + b2.len) {
          posA += a2.len;
          a2.next();
        }
        posB += b2.len;
        b2.next();
      } else if (a2.ins >= 0) {
        let len = 0, end = posA + a2.len;
        for (; ; ) {
          if (b2.ins >= 0 && posB > posA && posB + b2.len < end) {
            len += b2.ins;
            posB += b2.len;
            b2.next();
          } else if (b2.ins == -1 && posB < end) {
            let skip = Math.min(b2.len, end - posB);
            len += skip;
            b2.forward(skip);
            posB += skip;
          } else {
            break;
          }
        }
        addSection(sections, len, a2.ins);
        if (insert2)
          addInsert(insert2, sections, a2.text);
        posA = end;
        a2.next();
      } else if (a2.done && b2.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else {
        throw new Error("Mismatched change set lengths");
      }
    }
  }
  function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert2 = mkSet ? [] : null;
    let a2 = new SectionIter(setA), b2 = new SectionIter(setB);
    for (let open = false; ; ) {
      if (a2.done && b2.done) {
        return insert2 ? ChangeSet.createSet(sections, insert2) : ChangeDesc.create(sections);
      } else if (a2.ins == 0) {
        addSection(sections, a2.len, 0, open);
        a2.next();
      } else if (b2.len == 0 && !b2.done) {
        addSection(sections, 0, b2.ins, open);
        if (insert2)
          addInsert(insert2, sections, b2.text);
        b2.next();
      } else if (a2.done || b2.done) {
        throw new Error("Mismatched change set lengths");
      } else {
        let len = Math.min(a2.len2, b2.len), sectionLen = sections.length;
        if (a2.ins == -1) {
          let insB = b2.ins == -1 ? -1 : b2.off ? 0 : b2.ins;
          addSection(sections, len, insB, open);
          if (insert2 && insB)
            addInsert(insert2, sections, b2.text);
        } else if (b2.ins == -1) {
          addSection(sections, a2.off ? 0 : a2.len, len, open);
          if (insert2)
            addInsert(insert2, sections, a2.textBit(len));
        } else {
          addSection(sections, a2.off ? 0 : a2.len, b2.off ? 0 : b2.ins, open);
          if (insert2 && !b2.off)
            addInsert(insert2, sections, b2.text);
        }
        open = (a2.ins > len || b2.ins >= 0 && b2.len > len) && (open || sections.length > sectionLen);
        a2.forward2(len);
        b2.forward(len);
      }
    }
  }
  var SectionIter = class {
    constructor(set3) {
      this.set = set3;
      this.i = 0;
      this.next();
    }
    next() {
      let { sections } = this.set;
      if (this.i < sections.length) {
        this.len = sections[this.i++];
        this.ins = sections[this.i++];
      } else {
        this.len = 0;
        this.ins = -2;
      }
      this.off = 0;
    }
    get done() {
      return this.ins == -2;
    }
    get len2() {
      return this.ins < 0 ? this.len : this.ins;
    }
    get text() {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
      let { inserted } = this.set, index = this.i - 2 >> 1;
      return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? void 0 : this.off + len);
    }
    forward(len) {
      if (len == this.len)
        this.next();
      else {
        this.len -= len;
        this.off += len;
      }
    }
    forward2(len) {
      if (this.ins == -1)
        this.forward(len);
      else if (len == this.ins)
        this.next();
      else {
        this.ins -= len;
        this.off += len;
      }
    }
  };
  var SelectionRange = class {
    constructor(from, to2, flags) {
      this.from = from;
      this.to = to2;
      this.flags = flags;
    }
    get anchor() {
      return this.flags & 16 ? this.to : this.from;
    }
    get head() {
      return this.flags & 16 ? this.from : this.to;
    }
    get empty() {
      return this.from == this.to;
    }
    get assoc() {
      return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
    }
    get bidiLevel() {
      let level = this.flags & 3;
      return level == 3 ? null : level;
    }
    get goalColumn() {
      let value = this.flags >> 5;
      return value == 33554431 ? void 0 : value;
    }
    map(change, assoc = -1) {
      let from, to2;
      if (this.empty) {
        from = to2 = change.mapPos(this.from, assoc);
      } else {
        from = change.mapPos(this.from, 1);
        to2 = change.mapPos(this.to, -1);
      }
      return from == this.from && to2 == this.to ? this : new SelectionRange(from, to2, this.flags);
    }
    extend(from, to2 = from) {
      if (from <= this.anchor && to2 >= this.anchor)
        return EditorSelection.range(from, to2);
      let head = Math.abs(from - this.anchor) > Math.abs(to2 - this.anchor) ? from : to2;
      return EditorSelection.range(this.anchor, head);
    }
    eq(other) {
      return this.anchor == other.anchor && this.head == other.head;
    }
    toJSON() {
      return { anchor: this.anchor, head: this.head };
    }
    static fromJSON(json) {
      if (!json || typeof json.anchor != "number" || typeof json.head != "number")
        throw new RangeError("Invalid JSON representation for SelectionRange");
      return EditorSelection.range(json.anchor, json.head);
    }
    static create(from, to2, flags) {
      return new SelectionRange(from, to2, flags);
    }
  };
  var EditorSelection = class {
    constructor(ranges, mainIndex) {
      this.ranges = ranges;
      this.mainIndex = mainIndex;
    }
    map(change, assoc = -1) {
      if (change.empty)
        return this;
      return EditorSelection.create(this.ranges.map((r) => r.map(change, assoc)), this.mainIndex);
    }
    eq(other) {
      if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
        return false;
      for (let i2 = 0; i2 < this.ranges.length; i2++)
        if (!this.ranges[i2].eq(other.ranges[i2]))
          return false;
      return true;
    }
    get main() {
      return this.ranges[this.mainIndex];
    }
    asSingle() {
      return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
    }
    addRange(range2, main = true) {
      return EditorSelection.create([range2].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    replaceRange(range2, which = this.mainIndex) {
      let ranges = this.ranges.slice();
      ranges[which] = range2;
      return EditorSelection.create(ranges, this.mainIndex);
    }
    toJSON() {
      return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
    }
    static fromJSON(json) {
      if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
        throw new RangeError("Invalid JSON representation for EditorSelection");
      return new EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    static single(anchor, head = anchor) {
      return new EditorSelection([EditorSelection.range(anchor, head)], 0);
    }
    static create(ranges, mainIndex = 0) {
      if (ranges.length == 0)
        throw new RangeError("A selection needs at least one range");
      for (let pos = 0, i2 = 0; i2 < ranges.length; i2++) {
        let range2 = ranges[i2];
        if (range2.empty ? range2.from <= pos : range2.from < pos)
          return EditorSelection.normalized(ranges.slice(), mainIndex);
        pos = range2.to;
      }
      return new EditorSelection(ranges, mainIndex);
    }
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
      return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
    }
    static range(anchor, head, goalColumn) {
      let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
      return head < anchor ? SelectionRange.create(head, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head, goal | (head > anchor ? 4 : 0));
    }
    static normalized(ranges, mainIndex = 0) {
      let main = ranges[mainIndex];
      ranges.sort((a2, b2) => a2.from - b2.from);
      mainIndex = ranges.indexOf(main);
      for (let i2 = 1; i2 < ranges.length; i2++) {
        let range2 = ranges[i2], prev = ranges[i2 - 1];
        if (range2.empty ? range2.from <= prev.to : range2.from < prev.to) {
          let from = prev.from, to2 = Math.max(range2.to, prev.to);
          if (i2 <= mainIndex)
            mainIndex--;
          ranges.splice(--i2, 2, range2.anchor > range2.head ? EditorSelection.range(to2, from) : EditorSelection.range(from, to2));
        }
      }
      return new EditorSelection(ranges, mainIndex);
    }
  };
  function checkSelection(selection, docLength) {
    for (let range2 of selection.ranges)
      if (range2.to > docLength)
        throw new RangeError("Selection points outside of document");
  }
  var nextID = 0;
  var Facet = class {
    constructor(combine, compareInput, compare2, isStatic, extensions) {
      this.combine = combine;
      this.compareInput = compareInput;
      this.compare = compare2;
      this.isStatic = isStatic;
      this.extensions = extensions;
      this.id = nextID++;
      this.default = combine([]);
    }
    static define(config2 = {}) {
      return new Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b2) => a2 === b2), config2.compare || (!config2.combine ? sameArray : (a2, b2) => a2 === b2), !!config2.static, config2.enables);
    }
    of(value) {
      return new FacetProvider([], this, 0, value);
    }
    compute(deps2, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps2, this, 1, get3);
    }
    computeN(deps2, get3) {
      if (this.isStatic)
        throw new Error("Can't compute a static facet");
      return new FacetProvider(deps2, this, 2, get3);
    }
    from(field, get3) {
      if (!get3)
        get3 = (x) => x;
      return this.compute([field], (state3) => get3(state3.field(field)));
    }
  };
  function sameArray(a2, b2) {
    return a2 == b2 || a2.length == b2.length && a2.every((e2, i2) => e2 === b2[i2]);
  }
  var FacetProvider = class {
    constructor(dependencies, facet, type2, value) {
      this.dependencies = dependencies;
      this.facet = facet;
      this.type = type2;
      this.value = value;
      this.id = nextID++;
    }
    dynamicSlot(addresses) {
      var _a2;
      let getter = this.value;
      let compare2 = this.facet.compareInput;
      let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
      let depDoc = false, depSel = false, depAddrs = [];
      for (let dep of this.dependencies) {
        if (dep == "doc")
          depDoc = true;
        else if (dep == "selection")
          depSel = true;
        else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
          depAddrs.push(addresses[dep.id]);
      }
      return {
        create(state3) {
          state3.values[idx] = getter(state3);
          return 1;
        },
        update(state3, tr) {
          if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state3, depAddrs)) {
            let newVal = getter(state3);
            if (multi ? !compareArray(newVal, state3.values[idx], compare2) : !compare2(newVal, state3.values[idx])) {
              state3.values[idx] = newVal;
              return 1;
            }
          }
          return 0;
        },
        reconfigure: (state3, oldState) => {
          let newVal = getter(state3);
          let oldAddr = oldState.config.address[id2];
          if (oldAddr != null) {
            let oldVal = getAddr(oldState, oldAddr);
            if (this.dependencies.every((dep) => {
              return dep instanceof Facet ? oldState.facet(dep) === state3.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state3.field(dep, false) : true;
            }) || (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))) {
              state3.values[idx] = oldVal;
              return 0;
            }
          }
          state3.values[idx] = newVal;
          return 1;
        }
      };
    }
  };
  function compareArray(a2, b2, compare2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!compare2(a2[i2], b2[i2]))
        return false;
    return true;
  }
  function ensureAll(state3, addrs) {
    let changed2 = false;
    for (let addr of addrs)
      if (ensureAddr(state3, addr) & 1)
        changed2 = true;
    return changed2;
  }
  function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map((p2) => addresses[p2.id]);
    let providerTypes = providers.map((p2) => p2.type);
    let dynamic = providerAddrs.filter((p2) => !(p2 & 1));
    let idx = addresses[facet.id] >> 1;
    function get3(state3) {
      let values = [];
      for (let i2 = 0; i2 < providerAddrs.length; i2++) {
        let value = getAddr(state3, providerAddrs[i2]);
        if (providerTypes[i2] == 2)
          for (let val of value)
            values.push(val);
        else
          values.push(value);
      }
      return facet.combine(values);
    }
    return {
      create(state3) {
        for (let addr of providerAddrs)
          ensureAddr(state3, addr);
        state3.values[idx] = get3(state3);
        return 1;
      },
      update(state3, tr) {
        if (!ensureAll(state3, dynamic))
          return 0;
        let value = get3(state3);
        if (facet.compare(value, state3.values[idx]))
          return 0;
        state3.values[idx] = value;
        return 1;
      },
      reconfigure(state3, oldState) {
        let depChanged = ensureAll(state3, providerAddrs);
        let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
        if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
          state3.values[idx] = oldValue;
          return 0;
        }
        let value = get3(state3);
        if (facet.compare(value, oldValue)) {
          state3.values[idx] = oldValue;
          return 0;
        }
        state3.values[idx] = value;
        return 1;
      }
    };
  }
  var initField = /* @__PURE__ */ Facet.define({ static: true });
  var StateField = class {
    constructor(id2, createF, updateF, compareF, spec) {
      this.id = id2;
      this.createF = createF;
      this.updateF = updateF;
      this.compareF = compareF;
      this.spec = spec;
      this.provides = void 0;
    }
    static define(config2) {
      let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b2) => a2 === b2), config2);
      if (config2.provide)
        field.provides = config2.provide(field);
      return field;
    }
    create(state3) {
      let init = state3.facet(initField).find((i2) => i2.field == this);
      return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state3);
    }
    slot(addresses) {
      let idx = addresses[this.id] >> 1;
      return {
        create: (state3) => {
          state3.values[idx] = this.create(state3);
          return 1;
        },
        update: (state3, tr) => {
          let oldVal = state3.values[idx];
          let value = this.updateF(oldVal, tr);
          if (this.compareF(oldVal, value))
            return 0;
          state3.values[idx] = value;
          return 1;
        },
        reconfigure: (state3, oldState) => {
          if (oldState.config.address[this.id] != null) {
            state3.values[idx] = oldState.field(this);
            return 0;
          }
          state3.values[idx] = this.create(state3);
          return 1;
        }
      };
    }
    init(create) {
      return [this, initField.of({ field: this, create })];
    }
    get extension() {
      return this;
    }
  };
  var Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
  function prec(value) {
    return (ext) => new PrecExtension(ext, value);
  }
  var Prec = {
    highest: /* @__PURE__ */ prec(Prec_.highest),
    high: /* @__PURE__ */ prec(Prec_.high),
    default: /* @__PURE__ */ prec(Prec_.default),
    low: /* @__PURE__ */ prec(Prec_.low),
    lowest: /* @__PURE__ */ prec(Prec_.lowest)
  };
  var PrecExtension = class {
    constructor(inner, prec2) {
      this.inner = inner;
      this.prec = prec2;
    }
  };
  var Compartment = class {
    of(ext) {
      return new CompartmentInstance(this, ext);
    }
    reconfigure(content2) {
      return Compartment.reconfigure.of({ compartment: this, extension: content2 });
    }
    get(state3) {
      return state3.config.compartments.get(this);
    }
  };
  var CompartmentInstance = class {
    constructor(compartment, inner) {
      this.compartment = compartment;
      this.inner = inner;
    }
  };
  var Configuration = class {
    constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
      this.base = base2;
      this.compartments = compartments;
      this.dynamicSlots = dynamicSlots;
      this.address = address;
      this.staticValues = staticValues;
      this.facets = facets;
      this.statusTemplate = [];
      while (this.statusTemplate.length < dynamicSlots.length)
        this.statusTemplate.push(0);
    }
    staticFacet(facet) {
      let addr = this.address[facet.id];
      return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base2, compartments, oldState) {
      let fields = [];
      let facets = /* @__PURE__ */ Object.create(null);
      let newCompartments = /* @__PURE__ */ new Map();
      for (let ext of flatten2(base2, compartments, newCompartments)) {
        if (ext instanceof StateField)
          fields.push(ext);
        else
          (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
      }
      let address = /* @__PURE__ */ Object.create(null);
      let staticValues = [];
      let dynamicSlots = [];
      for (let field of fields) {
        address[field.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => field.slot(a2));
      }
      let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
      for (let id2 in facets) {
        let providers = facets[id2], facet = providers[0].facet;
        let oldProviders = oldFacets && oldFacets[id2] || [];
        if (providers.every((p2) => p2.type == 0)) {
          address[facet.id] = staticValues.length << 1 | 1;
          if (sameArray(oldProviders, providers)) {
            staticValues.push(oldState.facet(facet));
          } else {
            let value = facet.combine(providers.map((p2) => p2.value));
            staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
          }
        } else {
          for (let p2 of providers) {
            if (p2.type == 0) {
              address[p2.id] = staticValues.length << 1 | 1;
              staticValues.push(p2.value);
            } else {
              address[p2.id] = dynamicSlots.length << 1;
              dynamicSlots.push((a2) => p2.dynamicSlot(a2));
            }
          }
          address[facet.id] = dynamicSlots.length << 1;
          dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
        }
      }
      let dynamic = dynamicSlots.map((f) => f(address));
      return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
    }
  };
  function flatten2(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = /* @__PURE__ */ new Map();
    function inner(ext, prec2) {
      let known = seen.get(ext);
      if (known != null) {
        if (known <= prec2)
          return;
        let found = result[known].indexOf(ext);
        if (found > -1)
          result[known].splice(found, 1);
        if (ext instanceof CompartmentInstance)
          newCompartments.delete(ext.compartment);
      }
      seen.set(ext, prec2);
      if (Array.isArray(ext)) {
        for (let e2 of ext)
          inner(e2, prec2);
      } else if (ext instanceof CompartmentInstance) {
        if (newCompartments.has(ext.compartment))
          throw new RangeError(`Duplicate use of compartment in extensions`);
        let content2 = compartments.get(ext.compartment) || ext.inner;
        newCompartments.set(ext.compartment, content2);
        inner(content2, prec2);
      } else if (ext instanceof PrecExtension) {
        inner(ext.inner, ext.prec);
      } else if (ext instanceof StateField) {
        result[prec2].push(ext);
        if (ext.provides)
          inner(ext.provides, prec2);
      } else if (ext instanceof FacetProvider) {
        result[prec2].push(ext);
        if (ext.facet.extensions)
          inner(ext.facet.extensions, prec2);
      } else {
        let content2 = ext.extension;
        if (!content2)
          throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
        inner(content2, prec2);
      }
    }
    inner(extension, Prec_.default);
    return result.reduce((a2, b2) => a2.concat(b2));
  }
  function ensureAddr(state3, addr) {
    if (addr & 1)
      return 2;
    let idx = addr >> 1;
    let status = state3.status[idx];
    if (status == 4)
      throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2)
      return status;
    state3.status[idx] = 4;
    let changed2 = state3.computeSlot(state3, state3.config.dynamicSlots[idx]);
    return state3.status[idx] = 2 | changed2;
  }
  function getAddr(state3, addr) {
    return addr & 1 ? state3.config.staticValues[addr >> 1] : state3.values[addr >> 1];
  }
  var languageData = /* @__PURE__ */ Facet.define();
  var allowMultipleSelections = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((v) => v),
    static: true
  });
  var lineSeparator = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : void 0,
    static: true
  });
  var changeFilter = /* @__PURE__ */ Facet.define();
  var transactionFilter = /* @__PURE__ */ Facet.define();
  var transactionExtender = /* @__PURE__ */ Facet.define();
  var readOnly = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : false
  });
  var Annotation = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    static define() {
      return new AnnotationType();
    }
  };
  var AnnotationType = class {
    of(value) {
      return new Annotation(this, value);
    }
  };
  var StateEffectType = class {
    constructor(map) {
      this.map = map;
    }
    of(value) {
      return new StateEffect(this, value);
    }
  };
  var StateEffect = class {
    constructor(type2, value) {
      this.type = type2;
      this.value = value;
    }
    map(mapping) {
      let mapped = this.type.map(this.value, mapping);
      return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    is(type2) {
      return this.type == type2;
    }
    static define(spec = {}) {
      return new StateEffectType(spec.map || ((v) => v));
    }
    static mapEffects(effects, mapping) {
      if (!effects.length)
        return effects;
      let result = [];
      for (let effect of effects) {
        let mapped = effect.map(mapping);
        if (mapped)
          result.push(mapped);
      }
      return result;
    }
  };
  StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
  StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
  var Transaction2 = class {
    constructor(startState, changes, selection, effects, annotations, scrollIntoView3) {
      this.startState = startState;
      this.changes = changes;
      this.selection = selection;
      this.effects = effects;
      this.annotations = annotations;
      this.scrollIntoView = scrollIntoView3;
      this._doc = null;
      this._state = null;
      if (selection)
        checkSelection(selection, changes.newLength);
      if (!annotations.some((a2) => a2.type == Transaction2.time))
        this.annotations = annotations.concat(Transaction2.time.of(Date.now()));
    }
    static create(startState, changes, selection, effects, annotations, scrollIntoView3) {
      return new Transaction2(startState, changes, selection, effects, annotations, scrollIntoView3);
    }
    get newDoc() {
      return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    get newSelection() {
      return this.selection || this.startState.selection.map(this.changes);
    }
    get state() {
      if (!this._state)
        this.startState.applyTransaction(this);
      return this._state;
    }
    annotation(type2) {
      for (let ann of this.annotations)
        if (ann.type == type2)
          return ann.value;
      return void 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get reconfigured() {
      return this.startState.config != this.state.config;
    }
    isUserEvent(event) {
      let e2 = this.annotation(Transaction2.userEvent);
      return !!(e2 && (e2 == event || e2.length > event.length && e2.slice(0, event.length) == event && e2[event.length] == "."));
    }
  };
  Transaction2.time = /* @__PURE__ */ Annotation.define();
  Transaction2.userEvent = /* @__PURE__ */ Annotation.define();
  Transaction2.addToHistory = /* @__PURE__ */ Annotation.define();
  Transaction2.remote = /* @__PURE__ */ Annotation.define();
  function joinRanges(a2, b2) {
    let result = [];
    for (let iA = 0, iB = 0; ; ) {
      let from, to2;
      if (iA < a2.length && (iB == b2.length || b2[iB] >= a2[iA])) {
        from = a2[iA++];
        to2 = a2[iA++];
      } else if (iB < b2.length) {
        from = b2[iB++];
        to2 = b2[iB++];
      } else
        return result;
      if (!result.length || result[result.length - 1] < from)
        result.push(from, to2);
      else if (result[result.length - 1] < to2)
        result[result.length - 1] = to2;
    }
  }
  function mergeTransaction(a2, b2, sequential) {
    var _a2;
    let mapForA, mapForB, changes;
    if (sequential) {
      mapForA = b2.changes;
      mapForB = ChangeSet.empty(b2.changes.length);
      changes = a2.changes.compose(b2.changes);
    } else {
      mapForA = b2.changes.map(a2.changes);
      mapForB = a2.changes.mapDesc(b2.changes, true);
      changes = a2.changes.compose(mapForA);
    }
    return {
      changes,
      selection: b2.selection ? b2.selection.map(mapForB) : (_a2 = a2.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
      effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b2.effects, mapForB)),
      annotations: a2.annotations.length ? a2.annotations.concat(b2.annotations) : b2.annotations,
      scrollIntoView: a2.scrollIntoView || b2.scrollIntoView
    };
  }
  function resolveTransactionInner(state3, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
      annotations = annotations.concat(Transaction2.userEvent.of(spec.userEvent));
    return {
      changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state3.facet(lineSeparator)),
      selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
      effects: asArray(spec.effects),
      annotations,
      scrollIntoView: !!spec.scrollIntoView
    };
  }
  function resolveTransaction(state3, specs, filter) {
    let s = resolveTransactionInner(state3, specs.length ? specs[0] : {}, state3.doc.length);
    if (specs.length && specs[0].filter === false)
      filter = false;
    for (let i2 = 1; i2 < specs.length; i2++) {
      if (specs[i2].filter === false)
        filter = false;
      let seq = !!specs[i2].sequential;
      s = mergeTransaction(s, resolveTransactionInner(state3, specs[i2], seq ? s.changes.newLength : state3.doc.length), seq);
    }
    let tr = Transaction2.create(state3, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
  }
  function filterTransaction(tr) {
    let state3 = tr.startState;
    let result = true;
    for (let filter of state3.facet(changeFilter)) {
      let value = filter(tr);
      if (value === false) {
        result = false;
        break;
      }
      if (Array.isArray(value))
        result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
      let changes, back;
      if (result === false) {
        back = tr.changes.invertedDesc;
        changes = ChangeSet.empty(state3.doc.length);
      } else {
        let filtered = tr.changes.filter(result);
        changes = filtered.changes;
        back = filtered.filtered.invertedDesc;
      }
      tr = Transaction2.create(state3, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    let filters = state3.facet(transactionFilter);
    for (let i2 = filters.length - 1; i2 >= 0; i2--) {
      let filtered = filters[i2](tr);
      if (filtered instanceof Transaction2)
        tr = filtered;
      else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction2)
        tr = filtered[0];
      else
        tr = resolveTransaction(state3, asArray(filtered), false);
    }
    return tr;
  }
  function extendTransaction(tr) {
    let state3 = tr.startState, extenders = state3.facet(transactionExtender), spec = tr;
    for (let i2 = extenders.length - 1; i2 >= 0; i2--) {
      let extension = extenders[i2](tr);
      if (extension && Object.keys(extension).length)
        spec = mergeTransaction(tr, resolveTransactionInner(state3, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction2.create(state3, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
  }
  var none = [];
  function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
  }
  var CharCategory = /* @__PURE__ */ function(CharCategory2) {
    CharCategory2[CharCategory2["Word"] = 0] = "Word";
    CharCategory2[CharCategory2["Space"] = 1] = "Space";
    CharCategory2[CharCategory2["Other"] = 2] = "Other";
    return CharCategory2;
  }(CharCategory || (CharCategory = {}));
  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var wordChar;
  try {
    wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
  } catch (_) {
  }
  function hasWordChar(str) {
    if (wordChar)
      return wordChar.test(str);
    for (let i2 = 0; i2 < str.length; i2++) {
      let ch = str[i2];
      if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
        return true;
    }
    return false;
  }
  function makeCategorizer(wordChars) {
    return (char) => {
      if (!/\S/.test(char))
        return CharCategory.Space;
      if (hasWordChar(char))
        return CharCategory.Word;
      for (let i2 = 0; i2 < wordChars.length; i2++)
        if (char.indexOf(wordChars[i2]) > -1)
          return CharCategory.Word;
      return CharCategory.Other;
    };
  }
  var EditorState = class {
    constructor(config2, doc2, selection, values, computeSlot, tr) {
      this.config = config2;
      this.doc = doc2;
      this.selection = selection;
      this.values = values;
      this.status = config2.statusTemplate.slice();
      this.computeSlot = computeSlot;
      if (tr)
        tr._state = this;
      for (let i2 = 0; i2 < this.config.dynamicSlots.length; i2++)
        ensureAddr(this, i2 << 1);
      this.computeSlot = null;
    }
    field(field, require2 = true) {
      let addr = this.config.address[field.id];
      if (addr == null) {
        if (require2)
          throw new RangeError("Field is not present in this state");
        return void 0;
      }
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    update(...specs) {
      return resolveTransaction(this, specs, true);
    }
    applyTransaction(tr) {
      let conf = this.config, { base: base2, compartments } = conf;
      for (let effect of tr.effects) {
        if (effect.is(Compartment.reconfigure)) {
          if (conf) {
            compartments = /* @__PURE__ */ new Map();
            conf.compartments.forEach((val, key2) => compartments.set(key2, val));
            conf = null;
          }
          compartments.set(effect.value.compartment, effect.value.extension);
        } else if (effect.is(StateEffect.reconfigure)) {
          conf = null;
          base2 = effect.value;
        } else if (effect.is(StateEffect.appendConfig)) {
          conf = null;
          base2 = asArray(base2).concat(effect.value);
        }
      }
      let startValues;
      if (!conf) {
        conf = Configuration.resolve(base2, compartments, this);
        let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state3, slot) => slot.reconfigure(state3, this), null);
        startValues = intermediateState.values;
      } else {
        startValues = tr.startState.values.slice();
      }
      new EditorState(conf, tr.newDoc, tr.newSelection, startValues, (state3, slot) => slot.update(state3, tr), tr);
    }
    replaceSelection(text) {
      if (typeof text == "string")
        text = this.toText(text);
      return this.changeByRange((range2) => ({
        changes: { from: range2.from, to: range2.to, insert: text },
        range: EditorSelection.cursor(range2.from + text.length)
      }));
    }
    changeByRange(f) {
      let sel = this.selection;
      let result1 = f(sel.ranges[0]);
      let changes = this.changes(result1.changes), ranges = [result1.range];
      let effects = asArray(result1.effects);
      for (let i2 = 1; i2 < sel.ranges.length; i2++) {
        let result = f(sel.ranges[i2]);
        let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
        for (let j = 0; j < i2; j++)
          ranges[j] = ranges[j].map(newMapped);
        let mapBy = changes.mapDesc(newChanges, true);
        ranges.push(result.range.map(mapBy));
        changes = changes.compose(newMapped);
        effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
      }
      return {
        changes,
        selection: EditorSelection.create(ranges, sel.mainIndex),
        effects
      };
    }
    changes(spec = []) {
      if (spec instanceof ChangeSet)
        return spec;
      return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    toText(string2) {
      return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    sliceDoc(from = 0, to2 = this.doc.length) {
      return this.doc.sliceString(from, to2, this.lineBreak);
    }
    facet(facet) {
      let addr = this.config.address[facet.id];
      if (addr == null)
        return facet.default;
      ensureAddr(this, addr);
      return getAddr(this, addr);
    }
    toJSON(fields) {
      let result = {
        doc: this.sliceDoc(),
        selection: this.selection.toJSON()
      };
      if (fields)
        for (let prop in fields) {
          let value = fields[prop];
          if (value instanceof StateField)
            result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
        }
      return result;
    }
    static fromJSON(json, config2 = {}, fields) {
      if (!json || typeof json.doc != "string")
        throw new RangeError("Invalid JSON representation for EditorState");
      let fieldInit = [];
      if (fields)
        for (let prop in fields) {
          let field = fields[prop], value = json[prop];
          fieldInit.push(field.init((state3) => field.spec.fromJSON(value, state3)));
        }
      return EditorState.create({
        doc: json.doc,
        selection: EditorSelection.fromJSON(json.selection),
        extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
      });
    }
    static create(config2 = {}) {
      let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
      let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
      let selection = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
      checkSelection(selection, doc2.length);
      if (!configuration.staticFacet(allowMultipleSelections))
        selection = selection.asSingle();
      return new EditorState(configuration, doc2, selection, configuration.dynamicSlots.map(() => null), (state3, slot) => slot.create(state3), null);
    }
    get tabSize() {
      return this.facet(EditorState.tabSize);
    }
    get lineBreak() {
      return this.facet(EditorState.lineSeparator) || "\n";
    }
    get readOnly() {
      return this.facet(readOnly);
    }
    phrase(phrase2, ...insert2) {
      for (let map of this.facet(EditorState.phrases))
        if (Object.prototype.hasOwnProperty.call(map, phrase2)) {
          phrase2 = map[phrase2];
          break;
        }
      if (insert2.length)
        phrase2 = phrase2.replace(/\$(\$|\d*)/g, (m3, i2) => {
          if (i2 == "$")
            return "$";
          let n2 = +(i2 || 1);
          return n2 > insert2.length ? m3 : insert2[n2 - 1];
        });
      return phrase2;
    }
    languageDataAt(name3, pos, side = -1) {
      let values = [];
      for (let provider of this.facet(languageData)) {
        for (let result of provider(this, pos, side)) {
          if (Object.prototype.hasOwnProperty.call(result, name3))
            values.push(result[name3]);
        }
      }
      return values;
    }
    charCategorizer(at) {
      return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    wordAt(pos) {
      let { text, from, length } = this.doc.lineAt(pos);
      let cat = this.charCategorizer(pos);
      let start2 = pos - from, end = pos - from;
      while (start2 > 0) {
        let prev = findClusterBreak(text, start2, false);
        if (cat(text.slice(prev, start2)) != CharCategory.Word)
          break;
        start2 = prev;
      }
      while (end < length) {
        let next = findClusterBreak(text, end);
        if (cat(text.slice(end, next)) != CharCategory.Word)
          break;
        end = next;
      }
      return start2 == end ? null : EditorSelection.range(start2 + from, end + from);
    }
  };
  EditorState.allowMultipleSelections = allowMultipleSelections;
  EditorState.tabSize = /* @__PURE__ */ Facet.define({
    combine: (values) => values.length ? values[0] : 4
  });
  EditorState.lineSeparator = lineSeparator;
  EditorState.readOnly = readOnly;
  EditorState.phrases = /* @__PURE__ */ Facet.define({
    compare(a2, b2) {
      let kA = Object.keys(a2), kB = Object.keys(b2);
      return kA.length == kB.length && kA.every((k) => a2[k] == b2[k]);
    }
  });
  EditorState.languageData = languageData;
  EditorState.changeFilter = changeFilter;
  EditorState.transactionFilter = transactionFilter;
  EditorState.transactionExtender = transactionExtender;
  Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
  function combineConfig(configs, defaults4, combine = {}) {
    let result = {};
    for (let config2 of configs)
      for (let key2 of Object.keys(config2)) {
        let value = config2[key2], current = result[key2];
        if (current === void 0)
          result[key2] = value;
        else if (current === value || value === void 0)
          ;
        else if (Object.hasOwnProperty.call(combine, key2))
          result[key2] = combine[key2](current, value);
        else
          throw new Error("Config merge conflict for field " + key2);
      }
    for (let key2 in defaults4)
      if (result[key2] === void 0)
        result[key2] = defaults4[key2];
    return result;
  }
  var RangeValue = class {
    eq(other) {
      return this == other;
    }
    range(from, to2 = from) {
      return Range.create(from, to2, this);
    }
  };
  RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
  RangeValue.prototype.point = false;
  RangeValue.prototype.mapMode = MapMode.TrackDel;
  var Range = class {
    constructor(from, to2, value) {
      this.from = from;
      this.to = to2;
      this.value = value;
    }
    static create(from, to2, value) {
      return new Range(from, to2, value);
    }
  };
  function cmpRange(a2, b2) {
    return a2.from - b2.from || a2.value.startSide - b2.value.startSide;
  }
  var Chunk = class {
    constructor(from, to2, value, maxPoint) {
      this.from = from;
      this.to = to2;
      this.value = value;
      this.maxPoint = maxPoint;
    }
    get length() {
      return this.to[this.to.length - 1];
    }
    findIndex(pos, side, end, startAt = 0) {
      let arr = end ? this.to : this.from;
      for (let lo = startAt, hi = arr.length; ; ) {
        if (lo == hi)
          return lo;
        let mid = lo + hi >> 1;
        let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
        if (mid == lo)
          return diff >= 0 ? lo : hi;
        if (diff >= 0)
          hi = mid;
        else
          lo = mid + 1;
      }
    }
    between(offset, from, to2, f) {
      for (let i2 = this.findIndex(from, -1e9, true), e2 = this.findIndex(to2, 1e9, false, i2); i2 < e2; i2++)
        if (f(this.from[i2] + offset, this.to[i2] + offset, this.value[i2]) === false)
          return false;
    }
    map(offset, changes) {
      let value = [], from = [], to2 = [], newPos = -1, maxPoint = -1;
      for (let i2 = 0; i2 < this.value.length; i2++) {
        let val = this.value[i2], curFrom = this.from[i2] + offset, curTo = this.to[i2] + offset, newFrom, newTo;
        if (curFrom == curTo) {
          let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
          if (mapped == null)
            continue;
          newFrom = newTo = mapped;
          if (val.startSide != val.endSide) {
            newTo = changes.mapPos(curFrom, val.endSide);
            if (newTo < newFrom)
              continue;
          }
        } else {
          newFrom = changes.mapPos(curFrom, val.startSide);
          newTo = changes.mapPos(curTo, val.endSide);
          if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
            continue;
        }
        if ((newTo - newFrom || val.endSide - val.startSide) < 0)
          continue;
        if (newPos < 0)
          newPos = newFrom;
        if (val.point)
          maxPoint = Math.max(maxPoint, newTo - newFrom);
        value.push(val);
        from.push(newFrom - newPos);
        to2.push(newTo - newPos);
      }
      return { mapped: value.length ? new Chunk(from, to2, value, maxPoint) : null, pos: newPos };
    }
  };
  var RangeSet = class {
    constructor(chunkPos, chunk, nextLayer, maxPoint) {
      this.chunkPos = chunkPos;
      this.chunk = chunk;
      this.nextLayer = nextLayer;
      this.maxPoint = maxPoint;
    }
    static create(chunkPos, chunk, nextLayer, maxPoint) {
      return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    get length() {
      let last2 = this.chunk.length - 1;
      return last2 < 0 ? 0 : Math.max(this.chunkEnd(last2), this.nextLayer.length);
    }
    get size() {
      if (this.isEmpty)
        return 0;
      let size2 = this.nextLayer.size;
      for (let chunk of this.chunk)
        size2 += chunk.value.length;
      return size2;
    }
    chunkEnd(index) {
      return this.chunkPos[index] + this.chunk[index].length;
    }
    update(updateSpec) {
      let { add: add2 = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
      let filter = updateSpec.filter;
      if (add2.length == 0 && !filter)
        return this;
      if (sort)
        add2 = add2.slice().sort(cmpRange);
      if (this.isEmpty)
        return add2.length ? RangeSet.of(add2) : this;
      let cur2 = new LayerCursor(this, null, -1).goto(0), i2 = 0, spill = [];
      let builder = new RangeSetBuilder();
      while (cur2.value || i2 < add2.length) {
        if (i2 < add2.length && (cur2.from - add2[i2].from || cur2.startSide - add2[i2].value.startSide) >= 0) {
          let range2 = add2[i2++];
          if (!builder.addInner(range2.from, range2.to, range2.value))
            spill.push(range2);
        } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i2 == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i2].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
          cur2.nextChunk();
        } else {
          if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
            if (!builder.addInner(cur2.from, cur2.to, cur2.value))
              spill.push(Range.create(cur2.from, cur2.to, cur2.value));
          }
          cur2.next();
        }
      }
      return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    map(changes) {
      if (changes.empty || this.isEmpty)
        return this;
      let chunks = [], chunkPos = [], maxPoint = -1;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start2 = this.chunkPos[i2], chunk = this.chunk[i2];
        let touch = changes.touchesRange(start2, start2 + chunk.length);
        if (touch === false) {
          maxPoint = Math.max(maxPoint, chunk.maxPoint);
          chunks.push(chunk);
          chunkPos.push(changes.mapPos(start2));
        } else if (touch === true) {
          let { mapped, pos } = chunk.map(start2, changes);
          if (mapped) {
            maxPoint = Math.max(maxPoint, mapped.maxPoint);
            chunks.push(mapped);
            chunkPos.push(pos);
          }
        }
      }
      let next = this.nextLayer.map(changes);
      return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
    }
    between(from, to2, f) {
      if (this.isEmpty)
        return;
      for (let i2 = 0; i2 < this.chunk.length; i2++) {
        let start2 = this.chunkPos[i2], chunk = this.chunk[i2];
        if (to2 >= start2 && from <= start2 + chunk.length && chunk.between(start2, from - start2, to2 - start2, f) === false)
          return;
      }
      this.nextLayer.between(from, to2, f);
    }
    iter(from = 0) {
      return HeapCursor.from([this]).goto(from);
    }
    get isEmpty() {
      return this.nextLayer == this;
    }
    static iter(sets, from = 0) {
      return HeapCursor.from(sets).goto(from);
    }
    static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
      let a2 = oldSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let b2 = newSets.filter((set3) => set3.maxPoint > 0 || !set3.isEmpty && set3.maxPoint >= minPointSize);
      let sharedChunks = findSharedChunks(a2, b2, textDiff);
      let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
      let sideB = new SpanCursor(b2, sharedChunks, minPointSize);
      textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
      if (textDiff.empty && textDiff.length == 0)
        compare(sideA, 0, sideB, 0, 0, comparator);
    }
    static eq(oldSets, newSets, from = 0, to2) {
      if (to2 == null)
        to2 = 1e9;
      let a2 = oldSets.filter((set3) => !set3.isEmpty && newSets.indexOf(set3) < 0);
      let b2 = newSets.filter((set3) => !set3.isEmpty && oldSets.indexOf(set3) < 0);
      if (a2.length != b2.length)
        return false;
      if (!a2.length)
        return true;
      let sharedChunks = findSharedChunks(a2, b2);
      let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from), sideB = new SpanCursor(b2, sharedChunks, 0).goto(from);
      for (; ; ) {
        if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
          return false;
        if (sideA.to > to2)
          return true;
        sideA.next();
        sideB.next();
      }
    }
    static spans(sets, from, to2, iterator, minPointSize = -1) {
      let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
      let open = cursor.openStart;
      for (; ; ) {
        let curTo = Math.min(cursor.to, to2);
        if (cursor.point) {
          iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open, cursor.pointRank);
          open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
        } else if (curTo > pos) {
          iterator.span(pos, curTo, cursor.active, open);
          open = cursor.openEnd(curTo);
        }
        if (cursor.to > to2)
          break;
        pos = cursor.to;
        cursor.next();
      }
      return open;
    }
    static of(ranges, sort = false) {
      let build = new RangeSetBuilder();
      for (let range2 of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
        build.add(range2.from, range2.to, range2.value);
      return build.finish();
    }
  };
  RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
  function lazySort(ranges) {
    if (ranges.length > 1)
      for (let prev = ranges[0], i2 = 1; i2 < ranges.length; i2++) {
        let cur2 = ranges[i2];
        if (cmpRange(prev, cur2) > 0)
          return ranges.slice().sort(cmpRange);
        prev = cur2;
      }
    return ranges;
  }
  RangeSet.empty.nextLayer = RangeSet.empty;
  var RangeSetBuilder = class {
    constructor() {
      this.chunks = [];
      this.chunkPos = [];
      this.chunkStart = -1;
      this.last = null;
      this.lastFrom = -1e9;
      this.lastTo = -1e9;
      this.from = [];
      this.to = [];
      this.value = [];
      this.maxPoint = -1;
      this.setMaxPoint = -1;
      this.nextLayer = null;
    }
    finishChunk(newArrays) {
      this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
      this.chunkPos.push(this.chunkStart);
      this.chunkStart = -1;
      this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
      this.maxPoint = -1;
      if (newArrays) {
        this.from = [];
        this.to = [];
        this.value = [];
      }
    }
    add(from, to2, value) {
      if (!this.addInner(from, to2, value))
        (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to2, value);
    }
    addInner(from, to2, value) {
      let diff = from - this.lastTo || value.startSide - this.last.endSide;
      if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
        throw new Error("Ranges must be added sorted by `from` position and `startSide`");
      if (diff < 0)
        return false;
      if (this.from.length == 250)
        this.finishChunk(true);
      if (this.chunkStart < 0)
        this.chunkStart = from;
      this.from.push(from - this.chunkStart);
      this.to.push(to2 - this.chunkStart);
      this.last = value;
      this.lastFrom = from;
      this.lastTo = to2;
      this.value.push(value);
      if (value.point)
        this.maxPoint = Math.max(this.maxPoint, to2 - from);
      return true;
    }
    addChunk(from, chunk) {
      if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
        return false;
      if (this.from.length)
        this.finishChunk(true);
      this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
      this.chunks.push(chunk);
      this.chunkPos.push(from);
      let last2 = chunk.value.length - 1;
      this.last = chunk.value[last2];
      this.lastFrom = chunk.from[last2] + from;
      this.lastTo = chunk.to[last2] + from;
      return true;
    }
    finish() {
      return this.finishInner(RangeSet.empty);
    }
    finishInner(next) {
      if (this.from.length)
        this.finishChunk(false);
      if (this.chunks.length == 0)
        return next;
      let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
      this.from = null;
      return result;
    }
  };
  function findSharedChunks(a2, b2, textDiff) {
    let inA = /* @__PURE__ */ new Map();
    for (let set3 of a2)
      for (let i2 = 0; i2 < set3.chunk.length; i2++)
        if (set3.chunk[i2].maxPoint <= 0)
          inA.set(set3.chunk[i2], set3.chunkPos[i2]);
    let shared = /* @__PURE__ */ new Set();
    for (let set3 of b2)
      for (let i2 = 0; i2 < set3.chunk.length; i2++) {
        let known = inA.get(set3.chunk[i2]);
        if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set3.chunkPos[i2] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set3.chunk[i2].length)))
          shared.add(set3.chunk[i2]);
      }
    return shared;
  }
  var LayerCursor = class {
    constructor(layer, skip, minPoint, rank = 0) {
      this.layer = layer;
      this.skip = skip;
      this.minPoint = minPoint;
      this.rank = rank;
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    get endSide() {
      return this.value ? this.value.endSide : 0;
    }
    goto(pos, side = -1e9) {
      this.chunkIndex = this.rangeIndex = 0;
      this.gotoInner(pos, side, false);
      return this;
    }
    gotoInner(pos, side, forward) {
      while (this.chunkIndex < this.layer.chunk.length) {
        let next = this.layer.chunk[this.chunkIndex];
        if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint))
          break;
        this.chunkIndex++;
        forward = false;
      }
      if (this.chunkIndex < this.layer.chunk.length) {
        let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
        if (!forward || this.rangeIndex < rangeIndex)
          this.setRangeIndex(rangeIndex);
      }
      this.next();
    }
    forward(pos, side) {
      if ((this.to - pos || this.endSide - side) < 0)
        this.gotoInner(pos, side, true);
    }
    next() {
      for (; ; ) {
        if (this.chunkIndex == this.layer.chunk.length) {
          this.from = this.to = 1e9;
          this.value = null;
          break;
        } else {
          let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
          let from = chunkPos + chunk.from[this.rangeIndex];
          this.from = from;
          this.to = chunkPos + chunk.to[this.rangeIndex];
          this.value = chunk.value[this.rangeIndex];
          this.setRangeIndex(this.rangeIndex + 1);
          if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
            break;
        }
      }
    }
    setRangeIndex(index) {
      if (index == this.layer.chunk[this.chunkIndex].value.length) {
        this.chunkIndex++;
        if (this.skip) {
          while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
            this.chunkIndex++;
        }
        this.rangeIndex = 0;
      } else {
        this.rangeIndex = index;
      }
    }
    nextChunk() {
      this.chunkIndex++;
      this.rangeIndex = 0;
      this.next();
    }
    compare(other) {
      return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
    }
  };
  var HeapCursor = class {
    constructor(heap) {
      this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
      let heap = [];
      for (let i2 = 0; i2 < sets.length; i2++) {
        for (let cur2 = sets[i2]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
          if (cur2.maxPoint >= minPoint)
            heap.push(new LayerCursor(cur2, skip, minPoint, i2));
        }
      }
      return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() {
      return this.value ? this.value.startSide : 0;
    }
    goto(pos, side = -1e9) {
      for (let cur2 of this.heap)
        cur2.goto(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      this.next();
      return this;
    }
    forward(pos, side) {
      for (let cur2 of this.heap)
        cur2.forward(pos, side);
      for (let i2 = this.heap.length >> 1; i2 >= 0; i2--)
        heapBubble(this.heap, i2);
      if ((this.to - pos || this.value.endSide - side) < 0)
        this.next();
    }
    next() {
      if (this.heap.length == 0) {
        this.from = this.to = 1e9;
        this.value = null;
        this.rank = -1;
      } else {
        let top2 = this.heap[0];
        this.from = top2.from;
        this.to = top2.to;
        this.value = top2.value;
        this.rank = top2.rank;
        if (top2.value)
          top2.next();
        heapBubble(this.heap, 0);
      }
    }
  };
  function heapBubble(heap, index) {
    for (let cur2 = heap[index]; ; ) {
      let childIndex = (index << 1) + 1;
      if (childIndex >= heap.length)
        break;
      let child = heap[childIndex];
      if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
        child = heap[childIndex + 1];
        childIndex++;
      }
      if (cur2.compare(child) < 0)
        break;
      heap[childIndex] = cur2;
      heap[index] = child;
      index = childIndex;
    }
  }
  var SpanCursor = class {
    constructor(sets, skip, minPoint) {
      this.minPoint = minPoint;
      this.active = [];
      this.activeTo = [];
      this.activeRank = [];
      this.minActive = -1;
      this.point = null;
      this.pointFrom = 0;
      this.pointRank = 0;
      this.to = -1e9;
      this.endSide = 0;
      this.openStart = -1;
      this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1e9) {
      this.cursor.goto(pos, side);
      this.active.length = this.activeTo.length = this.activeRank.length = 0;
      this.minActive = -1;
      this.to = pos;
      this.endSide = side;
      this.openStart = -1;
      this.next();
      return this;
    }
    forward(pos, side) {
      while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
        this.removeActive(this.minActive);
      this.cursor.forward(pos, side);
    }
    removeActive(index) {
      remove(this.active, index);
      remove(this.activeTo, index);
      remove(this.activeRank, index);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
      let i2 = 0, { value, to: to2, rank } = this.cursor;
      while (i2 < this.activeRank.length && this.activeRank[i2] <= rank)
        i2++;
      insert(this.active, i2, value);
      insert(this.activeTo, i2, to2);
      insert(this.activeRank, i2, rank);
      if (trackOpen)
        insert(trackOpen, i2, this.cursor.from);
      this.minActive = findMinIndex(this.active, this.activeTo);
    }
    next() {
      let from = this.to, wasPoint = this.point;
      this.point = null;
      let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
      for (; ; ) {
        let a2 = this.minActive;
        if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
          if (this.activeTo[a2] > from) {
            this.to = this.activeTo[a2];
            this.endSide = this.active[a2].endSide;
            break;
          }
          this.removeActive(a2);
          if (trackOpen)
            remove(trackOpen, a2);
        } else if (!this.cursor.value) {
          this.to = this.endSide = 1e9;
          break;
        } else if (this.cursor.from > from) {
          this.to = this.cursor.from;
          this.endSide = this.cursor.startSide;
          break;
        } else {
          let nextVal = this.cursor.value;
          if (!nextVal.point) {
            this.addActive(trackOpen);
            this.cursor.next();
          } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
            this.cursor.next();
          } else {
            this.point = nextVal;
            this.pointFrom = this.cursor.from;
            this.pointRank = this.cursor.rank;
            this.to = this.cursor.to;
            this.endSide = nextVal.endSide;
            if (this.cursor.from < from)
              trackExtra = 1;
            this.cursor.next();
            this.forward(this.to, this.endSide);
            break;
          }
        }
      }
      if (trackOpen) {
        let openStart = 0;
        while (openStart < trackOpen.length && trackOpen[openStart] < from)
          openStart++;
        this.openStart = openStart + trackExtra;
      }
    }
    activeForPoint(to2) {
      if (!this.active.length)
        return this.active;
      let active = [];
      for (let i2 = this.active.length - 1; i2 >= 0; i2--) {
        if (this.activeRank[i2] < this.pointRank)
          break;
        if (this.activeTo[i2] > to2 || this.activeTo[i2] == to2 && this.active[i2].endSide >= this.point.endSide)
          active.push(this.active[i2]);
      }
      return active.reverse();
    }
    openEnd(to2) {
      let open = 0;
      for (let i2 = this.activeTo.length - 1; i2 >= 0 && this.activeTo[i2] > to2; i2--)
        open++;
      return open;
    }
  };
  function compare(a2, startA, b2, startB, length, comparator) {
    a2.goto(startA);
    b2.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (; ; ) {
      let diff = a2.to + dPos - b2.to || a2.endSide - b2.endSide;
      let end = diff < 0 ? a2.to + dPos : b2.to, clipEnd = Math.min(end, endB);
      if (a2.point || b2.point) {
        if (!(a2.point && b2.point && (a2.point == b2.point || a2.point.eq(b2.point)) && sameValues(a2.activeForPoint(a2.to + dPos), b2.activeForPoint(b2.to))))
          comparator.comparePoint(pos, clipEnd, a2.point, b2.point);
      } else {
        if (clipEnd > pos && !sameValues(a2.active, b2.active))
          comparator.compareRange(pos, clipEnd, a2.active, b2.active);
      }
      if (end > endB)
        break;
      pos = end;
      if (diff <= 0)
        a2.next();
      if (diff >= 0)
        b2.next();
    }
  }
  function sameValues(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (a2[i2] != b2[i2] && !a2[i2].eq(b2[i2]))
        return false;
    return true;
  }
  function remove(array, index) {
    for (let i2 = index, e2 = array.length - 1; i2 < e2; i2++)
      array[i2] = array[i2 + 1];
    array.pop();
  }
  function insert(array, index, value) {
    for (let i2 = array.length - 1; i2 >= index; i2--)
      array[i2 + 1] = array[i2];
    array[index] = value;
  }
  function findMinIndex(value, array) {
    let found = -1, foundPos = 1e9;
    for (let i2 = 0; i2 < array.length; i2++)
      if ((array[i2] - foundPos || value[i2].endSide - value[found].endSide) < 0) {
        found = i2;
        foundPos = array[i2];
      }
    return found;
  }
  function countColumn(string2, tabSize, to2 = string2.length) {
    let n2 = 0;
    for (let i2 = 0; i2 < to2; ) {
      if (string2.charCodeAt(i2) == 9) {
        n2 += tabSize - n2 % tabSize;
        i2++;
      } else {
        n2++;
        i2 = findClusterBreak(string2, i2);
      }
    }
    return n2;
  }
  function findColumn(string2, col, tabSize, strict) {
    for (let i2 = 0, n2 = 0; ; ) {
      if (n2 >= col)
        return i2;
      if (i2 == string2.length)
        break;
      n2 += string2.charCodeAt(i2) == 9 ? tabSize - n2 % tabSize : 1;
      i2 = findClusterBreak(string2, i2);
    }
    return strict === true ? -1 : string2.length;
  }

  // node_modules/style-mod/src/style-mod.js
  var C = "\u037C";
  var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
  var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
  var top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
  var StyleModule = class {
    constructor(spec, options2) {
      this.rules = [];
      let { finish } = options2 || {};
      function splitSelector(selector) {
        return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
      }
      function render(selectors, spec2, target, isKeyframes) {
        let local = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
        if (isAt && spec2 == null)
          return target.push(selectors[0] + ";");
        for (let prop in spec2) {
          let value = spec2[prop];
          if (/&/.test(prop)) {
            render(
              prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b2) => a2.concat(b2)),
              value,
              target
            );
          } else if (value && typeof value == "object") {
            if (!isAt)
              throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
            render(splitSelector(prop), value, local, keyframes);
          } else if (value != null) {
            local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l) => "-" + l.toLowerCase()) + ": " + value + ";");
          }
        }
        if (local.length || keyframes) {
          target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
        }
      }
      for (let prop in spec)
        render(splitSelector(prop), spec[prop], this.rules);
    }
    getRules() {
      return this.rules.join("\n");
    }
    static newName() {
      let id2 = top[COUNT] || 1;
      top[COUNT] = id2 + 1;
      return C + id2.toString(36);
    }
    static mount(root, modules) {
      (root[SET] || new StyleSet(root)).mount(Array.isArray(modules) ? modules : [modules]);
    }
  };
  var adoptedSet = null;
  var StyleSet = class {
    constructor(root) {
      if (!root.head && root.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
        if (adoptedSet) {
          root.adoptedStyleSheets = [adoptedSet.sheet].concat(root.adoptedStyleSheets);
          return root[SET] = adoptedSet;
        }
        this.sheet = new CSSStyleSheet();
        root.adoptedStyleSheets = [this.sheet].concat(root.adoptedStyleSheets);
        adoptedSet = this;
      } else {
        this.styleTag = (root.ownerDocument || root).createElement("style");
        let target = root.head || root;
        target.insertBefore(this.styleTag, target.firstChild);
      }
      this.modules = [];
      root[SET] = this;
    }
    mount(modules) {
      let sheet = this.sheet;
      let pos = 0, j = 0;
      for (let i2 = 0; i2 < modules.length; i2++) {
        let mod2 = modules[i2], index = this.modules.indexOf(mod2);
        if (index < j && index > -1) {
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod2);
          if (sheet)
            for (let k = 0; k < mod2.rules.length; k++)
              sheet.insertRule(mod2.rules[k], pos++);
        } else {
          while (j < index)
            pos += this.modules[j++].rules.length;
          pos += mod2.rules.length;
          j++;
        }
      }
      if (!sheet) {
        let text = "";
        for (let i2 = 0; i2 < this.modules.length; i2++)
          text += this.modules[i2].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  };

  // node_modules/w3c-keyname/index.es.js
  var base = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  };
  var shift = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  };
  var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
  var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
  var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
  var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
  var brokenModifierNames = mac || chrome && +chrome[1] < 57;
  for (i2 = 0; i2 < 10; i2++)
    base[48 + i2] = base[96 + i2] = String(i2);
  var i2;
  for (i2 = 1; i2 <= 24; i2++)
    base[i2 + 111] = "F" + i2;
  var i2;
  for (i2 = 65; i2 <= 90; i2++) {
    base[i2] = String.fromCharCode(i2 + 32);
    shift[i2] = String.fromCharCode(i2);
  }
  var i2;
  for (code2 in base)
    if (!shift.hasOwnProperty(code2))
      shift[code2] = base[code2];
  var code2;
  function keyName(event) {
    var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
    var name3 = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
    if (name3 == "Esc")
      name3 = "Escape";
    if (name3 == "Del")
      name3 = "Delete";
    if (name3 == "Left")
      name3 = "ArrowLeft";
    if (name3 == "Up")
      name3 = "ArrowUp";
    if (name3 == "Right")
      name3 = "ArrowRight";
    if (name3 == "Down")
      name3 = "ArrowDown";
    return name3;
  }

  // node_modules/@codemirror/view/dist/index.js
  function getSelection(root) {
    let target;
    if (root.nodeType == 11) {
      target = root.getSelection ? root : root.ownerDocument;
    } else {
      target = root;
    }
    return target.getSelection();
  }
  function contains(dom2, node) {
    return node ? dom2 == node || dom2.contains(node.nodeType != 1 ? node.parentNode : node) : false;
  }
  function deepActiveElement() {
    let elt = document.activeElement;
    while (elt && elt.shadowRoot)
      elt = elt.shadowRoot.activeElement;
    return elt;
  }
  function hasSelection(dom2, selection) {
    if (!selection.anchorNode)
      return false;
    try {
      return contains(dom2, selection.anchorNode);
    } catch (_) {
      return false;
    }
  }
  function clientRectsFor(dom2) {
    if (dom2.nodeType == 3)
      return textRange(dom2, 0, dom2.nodeValue.length).getClientRects();
    else if (dom2.nodeType == 1)
      return dom2.getClientRects();
    else
      return [];
  }
  function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
  }
  function domIndex(node) {
    for (var index = 0; ; index++) {
      node = node.previousSibling;
      if (!node)
        return index;
    }
  }
  function scanFor(node, off, targetNode, targetOff, dir) {
    for (; ; ) {
      if (node == targetNode && off == targetOff)
        return true;
      if (off == (dir < 0 ? 0 : maxOffset(node))) {
        if (node.nodeName == "DIV")
          return false;
        let parent = node.parentNode;
        if (!parent || parent.nodeType != 1)
          return false;
        off = domIndex(node) + (dir < 0 ? 0 : 1);
        node = parent;
      } else if (node.nodeType == 1) {
        node = node.childNodes[off + (dir < 0 ? -1 : 0)];
        if (node.nodeType == 1 && node.contentEditable == "false")
          return false;
        off = dir < 0 ? maxOffset(node) : 0;
      } else {
        return false;
      }
    }
  }
  function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
  }
  var Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
  function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
  }
  function windowRect(win) {
    return {
      left: 0,
      right: win.innerWidth,
      top: 0,
      bottom: win.innerHeight
    };
  }
  function scrollRectIntoView(dom2, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc2 = dom2.ownerDocument, win = doc2.defaultView;
    for (let cur2 = dom2; cur2; ) {
      if (cur2.nodeType == 1) {
        let bounding, top2 = cur2 == doc2.body;
        if (top2) {
          bounding = windowRect(win);
        } else {
          if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
            cur2 = cur2.parentNode;
            continue;
          }
          let rect2 = cur2.getBoundingClientRect();
          bounding = {
            left: rect2.left,
            right: rect2.left + cur2.clientWidth,
            top: rect2.top,
            bottom: rect2.top + cur2.clientHeight
          };
        }
        let moveX = 0, moveY = 0;
        if (y == "nearest") {
          if (rect.top < bounding.top) {
            moveY = -(bounding.top - rect.top + yMargin);
            if (side > 0 && rect.bottom > bounding.bottom + moveY)
              moveY = rect.bottom - bounding.bottom + moveY + yMargin;
          } else if (rect.bottom > bounding.bottom) {
            moveY = rect.bottom - bounding.bottom + yMargin;
            if (side < 0 && rect.top - moveY < bounding.top)
              moveY = -(bounding.top + moveY - rect.top + yMargin);
          }
        } else {
          let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
          let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
          moveY = targetTop - bounding.top;
        }
        if (x == "nearest") {
          if (rect.left < bounding.left) {
            moveX = -(bounding.left - rect.left + xMargin);
            if (side > 0 && rect.right > bounding.right + moveX)
              moveX = rect.right - bounding.right + moveX + xMargin;
          } else if (rect.right > bounding.right) {
            moveX = rect.right - bounding.right + xMargin;
            if (side < 0 && rect.left < bounding.left + moveX)
              moveX = -(bounding.left + moveX - rect.left + xMargin);
          }
        } else {
          let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
          moveX = targetLeft - bounding.left;
        }
        if (moveX || moveY) {
          if (top2) {
            win.scrollBy(moveX, moveY);
          } else {
            if (moveY) {
              let start2 = cur2.scrollTop;
              cur2.scrollTop += moveY;
              moveY = cur2.scrollTop - start2;
            }
            if (moveX) {
              let start2 = cur2.scrollLeft;
              cur2.scrollLeft += moveX;
              moveX = cur2.scrollLeft - start2;
            }
            rect = {
              left: rect.left - moveX,
              top: rect.top - moveY,
              right: rect.right - moveX,
              bottom: rect.bottom - moveY
            };
          }
        }
        if (top2)
          break;
        cur2 = cur2.assignedSlot || cur2.parentNode;
        x = y = "nearest";
      } else if (cur2.nodeType == 11) {
        cur2 = cur2.host;
      } else {
        break;
      }
    }
  }
  var DOMSelectionState = class {
    constructor() {
      this.anchorNode = null;
      this.anchorOffset = 0;
      this.focusNode = null;
      this.focusOffset = 0;
    }
    eq(domSel) {
      return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range2) {
      this.set(range2.anchorNode, range2.anchorOffset, range2.focusNode, range2.focusOffset);
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
      this.anchorNode = anchorNode;
      this.anchorOffset = anchorOffset;
      this.focusNode = focusNode;
      this.focusOffset = focusOffset;
    }
  };
  var preventScrollSupported = null;
  function focusPreventScroll(dom2) {
    if (dom2.setActive)
      return dom2.setActive();
    if (preventScrollSupported)
      return dom2.focus(preventScrollSupported);
    let stack = [];
    for (let cur2 = dom2; cur2; cur2 = cur2.parentNode) {
      stack.push(cur2, cur2.scrollTop, cur2.scrollLeft);
      if (cur2 == cur2.ownerDocument)
        break;
    }
    dom2.focus(preventScrollSupported == null ? {
      get preventScroll() {
        preventScrollSupported = { preventScroll: true };
        return true;
      }
    } : void 0);
    if (!preventScrollSupported) {
      preventScrollSupported = false;
      for (let i2 = 0; i2 < stack.length; ) {
        let elt = stack[i2++], top2 = stack[i2++], left = stack[i2++];
        if (elt.scrollTop != top2)
          elt.scrollTop = top2;
        if (elt.scrollLeft != left)
          elt.scrollLeft = left;
      }
    }
  }
  var scratchRange;
  function textRange(node, from, to2 = from) {
    let range2 = scratchRange || (scratchRange = document.createRange());
    range2.setEnd(node, to2);
    range2.setStart(node, from);
    return range2;
  }
  function dispatchKey(elt, name3, code2) {
    let options2 = { key: name3, code: name3, keyCode: code2, which: code2, cancelable: true };
    let down = new KeyboardEvent("keydown", options2);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options2);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
  }
  function getRoot(node) {
    while (node) {
      if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
        return node;
      node = node.assignedSlot || node.parentNode;
    }
    return null;
  }
  function clearAttributes(node) {
    while (node.attributes.length)
      node.removeAttributeNode(node.attributes[0]);
  }
  var DOMPos = class {
    constructor(node, offset, precise = true) {
      this.node = node;
      this.offset = offset;
      this.precise = precise;
    }
    static before(dom2, precise) {
      return new DOMPos(dom2.parentNode, domIndex(dom2), precise);
    }
    static after(dom2, precise) {
      return new DOMPos(dom2.parentNode, domIndex(dom2) + 1, precise);
    }
  };
  var noChildren = [];
  var ContentView = class {
    constructor() {
      this.parent = null;
      this.dom = null;
      this.dirty = 2;
    }
    get editorView() {
      if (!this.parent)
        throw new Error("Accessing view in orphan content view");
      return this.parent.editorView;
    }
    get overrideDOMText() {
      return null;
    }
    get posAtStart() {
      return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
      return this.posAtStart + this.length;
    }
    posBefore(view) {
      let pos = this.posAtStart;
      for (let child of this.children) {
        if (child == view)
          return pos;
        pos += child.length + child.breakAfter;
      }
      throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
      return this.posBefore(view) + view.length;
    }
    coordsAt(_pos, _side) {
      return null;
    }
    sync(track) {
      if (this.dirty & 2) {
        let parent = this.dom;
        let prev = null, next;
        for (let child of this.children) {
          if (child.dirty) {
            if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
              let contentView = ContentView.get(next);
              if (!contentView || !contentView.parent && contentView.constructor == child.constructor)
                child.reuseDOM(next);
            }
            child.sync(track);
            child.dirty = 0;
          }
          next = prev ? prev.nextSibling : parent.firstChild;
          if (track && !track.written && track.node == parent && next != child.dom)
            track.written = true;
          if (child.dom.parentNode == parent) {
            while (next && next != child.dom)
              next = rm$1(next);
          } else {
            parent.insertBefore(child.dom, next);
          }
          prev = child.dom;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (next && track && track.node == parent)
          track.written = true;
        while (next)
          next = rm$1(next);
      } else if (this.dirty & 1) {
        for (let child of this.children)
          if (child.dirty) {
            child.sync(track);
            child.dirty = 0;
          }
      }
    }
    reuseDOM(_dom) {
    }
    localPosFromDOM(node, offset) {
      let after;
      if (node == this.dom) {
        after = this.dom.childNodes[offset];
      } else {
        let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
        for (; ; ) {
          let parent = node.parentNode;
          if (parent == this.dom)
            break;
          if (bias == 0 && parent.firstChild != parent.lastChild) {
            if (node == parent.firstChild)
              bias = -1;
            else
              bias = 1;
          }
          node = parent;
        }
        if (bias < 0)
          after = node;
        else
          after = node.nextSibling;
      }
      if (after == this.dom.firstChild)
        return 0;
      while (after && !ContentView.get(after))
        after = after.nextSibling;
      if (!after)
        return this.length;
      for (let i2 = 0, pos = 0; ; i2++) {
        let child = this.children[i2];
        if (child.dom == after)
          return pos;
        pos += child.length + child.breakAfter;
      }
    }
    domBoundsAround(from, to2, offset = 0) {
      let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
      for (let i2 = 0, pos = offset, prevEnd = offset; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (pos < from && end > to2)
          return child.domBoundsAround(from, to2, pos);
        if (end >= from && fromI == -1) {
          fromI = i2;
          fromStart = pos;
        }
        if (pos > to2 && child.dom.parentNode == this.dom) {
          toI = i2;
          toEnd = prevEnd;
          break;
        }
        prevEnd = end;
        pos = end + child.breakAfter;
      }
      return {
        from: fromStart,
        to: toEnd < 0 ? offset + this.length : toEnd,
        startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
        endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
      };
    }
    markDirty(andParent = false) {
      this.dirty |= 2;
      this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
      for (let parent = this.parent; parent; parent = parent.parent) {
        if (childList)
          parent.dirty |= 2;
        if (parent.dirty & 1)
          return;
        parent.dirty |= 1;
        childList = false;
      }
    }
    setParent(parent) {
      if (this.parent != parent) {
        this.parent = parent;
        if (this.dirty)
          this.markParentsDirty(true);
      }
    }
    setDOM(dom2) {
      if (this.dom)
        this.dom.cmView = null;
      this.dom = dom2;
      dom2.cmView = this;
    }
    get rootView() {
      for (let v = this; ; ) {
        let parent = v.parent;
        if (!parent)
          return v;
        v = parent;
      }
    }
    replaceChildren(from, to2, children = noChildren) {
      this.markDirty();
      for (let i2 = from; i2 < to2; i2++) {
        let child = this.children[i2];
        if (child.parent == this)
          child.destroy();
      }
      this.children.splice(from, to2 - from, ...children);
      for (let i2 = 0; i2 < children.length; i2++)
        children[i2].setParent(this);
    }
    ignoreMutation(_rec) {
      return false;
    }
    ignoreEvent(_event) {
      return false;
    }
    childCursor(pos = this.length) {
      return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
      return this.childCursor().findPos(pos, bias);
    }
    toString() {
      let name3 = this.constructor.name.replace("View", "");
      return name3 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name3 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
    }
    static get(node) {
      return node.cmView;
    }
    get isEditable() {
      return true;
    }
    merge(from, to2, source, hasStart, openStart, openEnd) {
      return false;
    }
    become(other) {
      return false;
    }
    getSide() {
      return 0;
    }
    destroy() {
      this.parent = null;
    }
  };
  ContentView.prototype.breakAfter = 0;
  function rm$1(dom2) {
    let next = dom2.nextSibling;
    dom2.parentNode.removeChild(dom2);
    return next;
  }
  var ChildCursor = class {
    constructor(children, pos, i2) {
      this.children = children;
      this.pos = pos;
      this.i = i2;
      this.off = 0;
    }
    findPos(pos, bias = 1) {
      for (; ; ) {
        if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
          this.off = pos - this.pos;
          return this;
        }
        let next = this.children[--this.i];
        this.pos -= next.length + next.breakAfter;
      }
    }
  };
  function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last2 = insert2.length ? insert2[insert2.length - 1] : null;
    let breakAtEnd = last2 ? last2.breakAfter : breakAtStart;
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last2 : null, fromOff == 0, openStart, openEnd))
      return;
    if (toI < children.length) {
      let after = children[toI];
      if (after && toOff < after.length) {
        if (fromI == toI) {
          after = after.split(toOff);
          toOff = 0;
        }
        if (!breakAtEnd && last2 && after.merge(0, toOff, last2, true, 0, openEnd)) {
          insert2[insert2.length - 1] = after;
        } else {
          if (toOff)
            after.merge(0, toOff, null, false, 0, openEnd);
          insert2.push(after);
        }
      } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
        if (last2)
          last2.breakAfter = 1;
        else
          breakAtStart = 1;
      }
      toI++;
    }
    if (before) {
      before.breakAfter = breakAtStart;
      if (fromOff > 0) {
        if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
          before.breakAfter = insert2.shift().breakAfter;
        } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
          before.merge(fromOff, before.length, null, false, openStart, 0);
        }
        fromI++;
      }
    }
    while (fromI < toI && insert2.length) {
      if (children[toI - 1].become(insert2[insert2.length - 1])) {
        toI--;
        insert2.pop();
        openEnd = insert2.length ? 0 : openStart;
      } else if (children[fromI].become(insert2[0])) {
        fromI++;
        insert2.shift();
        openStart = insert2.length ? 0 : openEnd;
      } else {
        break;
      }
    }
    if (!insert2.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
      fromI--;
    if (fromI < toI || insert2.length)
      parent.replaceChildren(fromI, toI, insert2);
  }
  function mergeChildrenInto(parent, from, to2, insert2, openStart, openEnd) {
    let cur2 = parent.childCursor();
    let { i: toI, off: toOff } = cur2.findPos(to2, 1);
    let { i: fromI, off: fromOff } = cur2.findPos(from, -1);
    let dLen = from - to2;
    for (let view of insert2)
      dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
  }
  var nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
  var doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
  var ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
  var ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
  var ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
  var ie2 = !!(ie_upto10 || ie_11up || ie_edge);
  var gecko2 = !ie2 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
  var chrome2 = !ie2 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
  var webkit = "webkitFontSmoothing" in doc.documentElement.style;
  var safari = !ie2 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
  var ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
  var browser = {
    mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
    windows: /* @__PURE__ */ /Win/.test(nav.platform),
    linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
    ie: ie2,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko: gecko2,
    gecko_version: gecko2 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome2,
    chrome_version: chrome2 ? +chrome2[1] : 0,
    ios,
    android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
  };
  var MaxJoinLen = 256;
  var TextView = class extends ContentView {
    constructor(text) {
      super();
      this.text = text;
    }
    get length() {
      return this.text.length;
    }
    createDOM(textDOM) {
      this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(track) {
      if (!this.dom)
        this.createDOM();
      if (this.dom.nodeValue != this.text) {
        if (track && track.node == this.dom)
          track.written = true;
        this.dom.nodeValue = this.text;
      }
    }
    reuseDOM(dom2) {
      if (dom2.nodeType == 3)
        this.createDOM(dom2);
    }
    merge(from, to2, source) {
      if (source && (!(source instanceof TextView) || this.length - (to2 - from) + source.length > MaxJoinLen))
        return false;
      this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to2);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = new TextView(this.text.slice(from));
      this.text = this.text.slice(0, from);
      this.markDirty();
      return result;
    }
    localPosFromDOM(node, offset) {
      return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) {
      return new DOMPos(this.dom, pos);
    }
    domBoundsAround(_from, _to, offset) {
      return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
      return textCoords(this.dom, pos, side);
    }
  };
  var MarkView = class extends ContentView {
    constructor(mark, children = [], length = 0) {
      super();
      this.mark = mark;
      this.children = children;
      this.length = length;
      for (let ch of children)
        ch.setParent(this);
    }
    setAttrs(dom2) {
      clearAttributes(dom2);
      if (this.mark.class)
        dom2.className = this.mark.class;
      if (this.mark.attrs)
        for (let name3 in this.mark.attrs)
          dom2.setAttribute(name3, this.mark.attrs[name3]);
      return dom2;
    }
    reuseDOM(node) {
      if (node.nodeName == this.mark.tagName.toUpperCase()) {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      if (!this.dom)
        this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
      else if (this.dirty & 4)
        this.setAttrs(this.dom);
      super.sync(track);
    }
    merge(from, to2, source, _hasStart, openStart, openEnd) {
      if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to2 < this.length && openEnd <= 0))
        return false;
      mergeChildrenInto(this, from, to2, source ? source.children : [], openStart - 1, openEnd - 1);
      this.markDirty();
      return true;
    }
    split(from) {
      let result = [], off = 0, detachFrom = -1, i2 = 0;
      for (let elt of this.children) {
        let end = off + elt.length;
        if (end > from)
          result.push(off < from ? elt.split(from - off) : elt);
        if (detachFrom < 0 && off >= from)
          detachFrom = i2;
        off = end;
        i2++;
      }
      let length = this.length - from;
      this.length = from;
      if (detachFrom > -1) {
        this.children.length = detachFrom;
        this.markDirty();
      }
      return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
  };
  function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
      pos = length;
    let from = pos, to2 = pos, flatten3 = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
      if (!(browser.chrome || browser.gecko)) {
        if (pos) {
          from--;
          flatten3 = 1;
        } else if (to2 < length) {
          to2++;
          flatten3 = -1;
        }
      }
    } else {
      if (side < 0)
        from--;
      else if (to2 < length)
        to2++;
    }
    let rects = textRange(text, from, to2).getClientRects();
    if (!rects.length)
      return Rect0;
    let rect = rects[(flatten3 ? flatten3 < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten3 && rect.width == 0)
      rect = Array.prototype.find.call(rects, (r) => r.width) || rect;
    return flatten3 ? flattenRect(rect, flatten3 < 0) : rect || null;
  }
  var WidgetView = class extends ContentView {
    constructor(widget, length, side) {
      super();
      this.widget = widget;
      this.length = length;
      this.side = side;
      this.prevWidget = null;
    }
    static create(widget, length, side) {
      return new (widget.customView || WidgetView)(widget, length, side);
    }
    split(from) {
      let result = WidgetView.create(this.widget, this.length - from, this.side);
      this.length -= from;
      return result;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    getSide() {
      return this.side;
    }
    merge(from, to2, source, hasStart, openStart, openEnd) {
      if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to2);
      return true;
    }
    become(other) {
      if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
        if (this.widget.constructor == other.widget.constructor) {
          if (!this.widget.eq(other.widget))
            this.markDirty(true);
          if (this.dom && !this.prevWidget)
            this.prevWidget = this.widget;
          this.widget = other.widget;
          return true;
        }
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    get overrideDOMText() {
      if (this.length == 0)
        return Text.empty;
      let top2 = this;
      while (top2.parent)
        top2 = top2.parent;
      let view = top2.editorView, text = view && view.state.doc, start2 = this.posAtStart;
      return text ? text.slice(start2, start2 + this.length) : Text.empty;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos, side) {
      let rects = this.dom.getClientRects(), rect = null;
      if (!rects.length)
        return Rect0;
      for (let i2 = pos > 0 ? rects.length - 1 : 0; ; i2 += pos > 0 ? -1 : 1) {
        rect = rects[i2];
        if (pos > 0 ? i2 == 0 : i2 == rects.length - 1 || rect.top < rect.bottom)
          break;
      }
      return pos == 0 && side > 0 || pos == this.length && side <= 0 ? rect : flattenRect(rect, pos == 0);
    }
    get isEditable() {
      return false;
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var CompositionView = class extends WidgetView {
    domAtPos(pos) {
      let { topView, text } = this.widget;
      if (!topView)
        return new DOMPos(text, Math.min(pos, text.nodeValue.length));
      return scanCompositionTree(pos, 0, topView, text, (v, p2) => v.domAtPos(p2), (p2) => new DOMPos(text, Math.min(p2, text.nodeValue.length)));
    }
    sync() {
      this.setDOM(this.widget.toDOM());
    }
    localPosFromDOM(node, offset) {
      let { topView, text } = this.widget;
      if (!topView)
        return Math.min(offset, this.length);
      return posFromDOMInCompositionTree(node, offset, topView, text);
    }
    ignoreMutation() {
      return false;
    }
    get overrideDOMText() {
      return null;
    }
    coordsAt(pos, side) {
      let { topView, text } = this.widget;
      if (!topView)
        return textCoords(text, pos, side);
      return scanCompositionTree(pos, side, topView, text, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text, pos2, side2));
    }
    destroy() {
      var _a2;
      super.destroy();
      (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    }
    get isEditable() {
      return true;
    }
  };
  function scanCompositionTree(pos, side, view, text, enterView, fromText) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let hasComp = contains(child.dom, text);
        let len = hasComp ? text.nodeValue.length : child.length;
        if (pos < len || pos == len && child.getSide() <= 0)
          return hasComp ? scanCompositionTree(pos, side, child, text, enterView, fromText) : enterView(child, pos, side);
        pos -= len;
      }
      return enterView(view, view.length, -1);
    } else if (view.dom == text) {
      return fromText(pos, side);
    } else {
      return enterView(view, pos, side);
    }
  }
  function posFromDOMInCompositionTree(node, offset, view, text) {
    if (view instanceof MarkView) {
      for (let child of view.children) {
        let pos = 0, hasComp = contains(child.dom, text);
        if (contains(child.dom, node))
          return pos + (hasComp ? posFromDOMInCompositionTree(node, offset, child, text) : child.localPosFromDOM(node, offset));
        pos += hasComp ? text.nodeValue.length : child.length;
      }
    } else if (view.dom == text) {
      return Math.min(offset, text.nodeValue.length);
    }
    return view.localPosFromDOM(node, offset);
  }
  var WidgetBufferView = class extends ContentView {
    constructor(side) {
      super();
      this.side = side;
    }
    get length() {
      return 0;
    }
    merge() {
      return false;
    }
    become(other) {
      return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() {
      return new WidgetBufferView(this.side);
    }
    sync() {
      if (!this.dom) {
        let dom2 = document.createElement("img");
        dom2.className = "cm-widgetBuffer";
        dom2.setAttribute("aria-hidden", "true");
        this.setDOM(dom2);
      }
    }
    getSide() {
      return this.side;
    }
    domAtPos(pos) {
      return DOMPos.before(this.dom);
    }
    localPosFromDOM() {
      return 0;
    }
    domBoundsAround() {
      return null;
    }
    coordsAt(pos) {
      let imgRect = this.dom.getBoundingClientRect();
      let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
      return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
    }
    get overrideDOMText() {
      return Text.empty;
    }
  };
  TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
  function inlineSiblingRect(view, side) {
    let parent = view.parent, index = parent ? parent.children.indexOf(view) : -1;
    while (parent && index >= 0) {
      if (side < 0 ? index > 0 : index < parent.children.length) {
        let next = parent.children[index + side];
        if (next instanceof TextView) {
          let nextRect = next.coordsAt(side < 0 ? next.length : 0, side);
          if (nextRect)
            return nextRect;
        }
        index += side;
      } else if (parent instanceof MarkView && parent.parent) {
        index = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
        parent = parent.parent;
      } else {
        let last2 = parent.dom.lastChild;
        if (last2 && last2.nodeName == "BR")
          return last2.getClientRects()[0];
        break;
      }
    }
    return void 0;
  }
  function inlineDOMAtPos(dom2, children, pos) {
    let i2 = 0;
    for (let off = 0; i2 < children.length; i2++) {
      let child = children[i2], end = off + child.length;
      if (end == off && child.getSide() <= 0)
        continue;
      if (pos > off && pos < end && child.dom.parentNode == dom2)
        return child.domAtPos(pos - off);
      if (pos <= off)
        break;
      off = end;
    }
    for (; i2 > 0; i2--) {
      let before = children[i2 - 1].dom;
      if (before.parentNode == dom2)
        return DOMPos.after(before);
    }
    return new DOMPos(dom2, 0);
  }
  function joinInlineInto(parent, view, open) {
    let last2, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length && (last2 = children[children.length - 1]) instanceof MarkView && last2.mark.eq(view.mark)) {
      joinInlineInto(last2, view.children[0], open - 1);
    } else {
      children.push(view);
      view.setParent(parent);
    }
    parent.length += view.length;
  }
  function coordsInChildren(view, pos, side) {
    for (let off = 0, i2 = 0; i2 < view.children.length; i2++) {
      let child = view.children[i2], end = off + child.length, next;
      if ((side <= 0 || end == view.length || child.getSide() > 0 ? end >= pos : end > pos) && (pos < end || i2 + 1 == view.children.length || (next = view.children[i2 + 1]).length || next.getSide() > 0)) {
        let flatten3 = 0;
        if (end == off) {
          if (child.getSide() <= 0)
            continue;
          flatten3 = side = -child.getSide();
        }
        let rect = child.coordsAt(Math.max(0, pos - off), side);
        return flatten3 && rect ? flattenRect(rect, side < 0) : rect;
      }
      off = end;
    }
    let last2 = view.dom.lastChild;
    if (!last2)
      return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last2);
    return rects[rects.length - 1] || null;
  }
  function combineAttrs(source, target) {
    for (let name3 in source) {
      if (name3 == "class" && target.class)
        target.class += " " + source.class;
      else if (name3 == "style" && target.style)
        target.style += ";" + source.style;
      else
        target[name3] = source[name3];
    }
    return target;
  }
  function attrsEq(a2, b2) {
    if (a2 == b2)
      return true;
    if (!a2 || !b2)
      return false;
    let keysA = Object.keys(a2), keysB = Object.keys(b2);
    if (keysA.length != keysB.length)
      return false;
    for (let key2 of keysA) {
      if (keysB.indexOf(key2) == -1 || a2[key2] !== b2[key2])
        return false;
    }
    return true;
  }
  function updateAttrs(dom2, prev, attrs) {
    let changed2 = null;
    if (prev) {
      for (let name3 in prev)
        if (!(attrs && name3 in attrs))
          dom2.removeAttribute(changed2 = name3);
    }
    if (attrs) {
      for (let name3 in attrs)
        if (!(prev && prev[name3] == attrs[name3]))
          dom2.setAttribute(changed2 = name3, attrs[name3]);
    }
    return !!changed2;
  }
  var WidgetType = class {
    eq(widget) {
      return false;
    }
    updateDOM(dom2) {
      return false;
    }
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    get estimatedHeight() {
      return -1;
    }
    ignoreEvent(event) {
      return true;
    }
    get customView() {
      return null;
    }
    destroy(dom2) {
    }
  };
  var BlockType = /* @__PURE__ */ function(BlockType2) {
    BlockType2[BlockType2["Text"] = 0] = "Text";
    BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
    BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
    BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
    return BlockType2;
  }(BlockType || (BlockType = {}));
  var Decoration = class extends RangeValue {
    constructor(startSide, endSide, widget, spec) {
      super();
      this.startSide = startSide;
      this.endSide = endSide;
      this.widget = widget;
      this.spec = spec;
    }
    get heightRelevant() {
      return false;
    }
    static mark(spec) {
      return new MarkDecoration(spec);
    }
    static widget(spec) {
      let side = spec.side || 0, block = !!spec.block;
      side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
      return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    static replace(spec) {
      let block = !!spec.block, startSide, endSide;
      if (spec.isBlockGap) {
        startSide = -5e8;
        endSide = 4e8;
      } else {
        let { start: start2, end } = getInclusive(spec, block);
        startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
        endSide = (end ? block ? 2e8 : 1 : -6e8) + 1;
      }
      return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    static line(spec) {
      return new LineDecoration(spec);
    }
    static set(of, sort = false) {
      return RangeSet.of(of, sort);
    }
    hasHeight() {
      return this.widget ? this.widget.estimatedHeight > -1 : false;
    }
  };
  Decoration.none = RangeSet.empty;
  var MarkDecoration = class extends Decoration {
    constructor(spec) {
      let { start: start2, end } = getInclusive(spec);
      super(start2 ? -1 : 5e8, end ? 1 : -6e8, null, spec);
      this.tagName = spec.tagName || "span";
      this.class = spec.class || "";
      this.attrs = spec.attributes || null;
    }
    eq(other) {
      return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
    }
    range(from, to2 = from) {
      if (from >= to2)
        throw new RangeError("Mark decorations may not be empty");
      return super.range(from, to2);
    }
  };
  MarkDecoration.prototype.point = false;
  var LineDecoration = class extends Decoration {
    constructor(spec) {
      super(-2e8, -2e8, null, spec);
    }
    eq(other) {
      return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to2 = from) {
      if (to2 != from)
        throw new RangeError("Line decoration ranges must be zero-length");
      return super.range(from, to2);
    }
  };
  LineDecoration.prototype.mapMode = MapMode.TrackBefore;
  LineDecoration.prototype.point = true;
  var PointDecoration = class extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
      super(startSide, endSide, widget, spec);
      this.block = block;
      this.isReplace = isReplace;
      this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    get type() {
      return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
      return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
    }
    eq(other) {
      return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to2 = from) {
      if (this.isReplace && (from > to2 || from == to2 && this.startSide > 0 && this.endSide <= 0))
        throw new RangeError("Invalid range for replacement decoration");
      if (!this.isReplace && to2 != from)
        throw new RangeError("Widget decorations can only have zero-length ranges");
      return super.range(from, to2);
    }
  };
  PointDecoration.prototype.point = true;
  function getInclusive(spec, block = false) {
    let { inclusiveStart: start2, inclusiveEnd: end } = spec;
    if (start2 == null)
      start2 = spec.inclusive;
    if (end == null)
      end = spec.inclusive;
    return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end !== null && end !== void 0 ? end : block };
  }
  function widgetsEq(a2, b2) {
    return a2 == b2 || !!(a2 && b2 && a2.compare(b2));
  }
  function addRange(from, to2, ranges, margin = 0) {
    let last2 = ranges.length - 1;
    if (last2 >= 0 && ranges[last2] + margin >= from)
      ranges[last2] = Math.max(ranges[last2], to2);
    else
      ranges.push(from, to2);
  }
  var LineView = class extends ContentView {
    constructor() {
      super(...arguments);
      this.children = [];
      this.length = 0;
      this.prevAttrs = void 0;
      this.attrs = null;
      this.breakAfter = 0;
    }
    merge(from, to2, source, hasStart, openStart, openEnd) {
      if (source) {
        if (!(source instanceof LineView))
          return false;
        if (!this.dom)
          source.transferDOM(this);
      }
      if (hasStart)
        this.setDeco(source ? source.attrs : null);
      mergeChildrenInto(this, from, to2, source ? source.children : [], openStart, openEnd);
      return true;
    }
    split(at) {
      let end = new LineView();
      end.breakAfter = this.breakAfter;
      if (this.length == 0)
        return end;
      let { i: i2, off } = this.childPos(at);
      if (off) {
        end.append(this.children[i2].split(off), 0);
        this.children[i2].merge(off, this.children[i2].length, null, false, 0, 0);
        i2++;
      }
      for (let j = i2; j < this.children.length; j++)
        end.append(this.children[j], 0);
      while (i2 > 0 && this.children[i2 - 1].length == 0)
        this.children[--i2].destroy();
      this.children.length = i2;
      this.markDirty();
      this.length = at;
      return end;
    }
    transferDOM(other) {
      if (!this.dom)
        return;
      this.markDirty();
      other.setDOM(this.dom);
      other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
      this.prevAttrs = void 0;
      this.dom = null;
    }
    setDeco(attrs) {
      if (!attrsEq(this.attrs, attrs)) {
        if (this.dom) {
          this.prevAttrs = this.attrs;
          this.markDirty();
        }
        this.attrs = attrs;
      }
    }
    append(child, openStart) {
      joinInlineInto(this, child, openStart);
    }
    addLineDeco(deco) {
      let attrs = deco.spec.attributes, cls = deco.spec.class;
      if (attrs)
        this.attrs = combineAttrs(attrs, this.attrs || {});
      if (cls)
        this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
      return inlineDOMAtPos(this.dom, this.children, pos);
    }
    reuseDOM(node) {
      if (node.nodeName == "DIV") {
        this.setDOM(node);
        this.dirty |= 4 | 2;
      }
    }
    sync(track) {
      var _a2;
      if (!this.dom) {
        this.setDOM(document.createElement("div"));
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      } else if (this.dirty & 4) {
        clearAttributes(this.dom);
        this.dom.className = "cm-line";
        this.prevAttrs = this.attrs ? null : void 0;
      }
      if (this.prevAttrs !== void 0) {
        updateAttrs(this.dom, this.prevAttrs, this.attrs);
        this.dom.classList.add("cm-line");
        this.prevAttrs = void 0;
      }
      super.sync(track);
      let last2 = this.dom.lastChild;
      while (last2 && ContentView.get(last2) instanceof MarkView)
        last2 = last2.lastChild;
      if (!last2 || !this.length || last2.nodeName != "BR" && ((_a2 = ContentView.get(last2)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
        let hack = document.createElement("BR");
        hack.cmIgnore = true;
        this.dom.appendChild(hack);
      }
    }
    measureTextSize() {
      if (this.children.length == 0 || this.length > 20)
        return null;
      let totalWidth = 0;
      for (let child of this.children) {
        if (!(child instanceof TextView))
          return null;
        let rects = clientRectsFor(child.dom);
        if (rects.length != 1)
          return null;
        totalWidth += rects[0].width;
      }
      return {
        lineHeight: this.dom.getBoundingClientRect().height,
        charWidth: totalWidth / this.length
      };
    }
    coordsAt(pos, side) {
      return coordsInChildren(this, pos, side);
    }
    become(_other) {
      return false;
    }
    get type() {
      return BlockType.Text;
    }
    static find(docView, pos) {
      for (let i2 = 0, off = 0; i2 < docView.children.length; i2++) {
        let block = docView.children[i2], end = off + block.length;
        if (end >= pos) {
          if (block instanceof LineView)
            return block;
          if (end > pos)
            break;
        }
        off = end + block.breakAfter;
      }
      return null;
    }
  };
  var BlockWidgetView = class extends ContentView {
    constructor(widget, length, type2) {
      super();
      this.widget = widget;
      this.length = length;
      this.type = type2;
      this.breakAfter = 0;
      this.prevWidget = null;
    }
    merge(from, to2, source, _takeDeco, openStart, openEnd) {
      if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
        return false;
      this.length = from + (source ? source.length : 0) + (this.length - to2);
      return true;
    }
    domAtPos(pos) {
      return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
      let len = this.length - at;
      this.length = at;
      let end = new BlockWidgetView(this.widget, len, this.type);
      end.breakAfter = this.breakAfter;
      return end;
    }
    get children() {
      return noChildren;
    }
    sync() {
      if (!this.dom || !this.widget.updateDOM(this.dom)) {
        if (this.dom && this.prevWidget)
          this.prevWidget.destroy(this.dom);
        this.prevWidget = null;
        this.setDOM(this.widget.toDOM(this.editorView));
        this.dom.contentEditable = "false";
      }
    }
    get overrideDOMText() {
      return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() {
      return null;
    }
    become(other) {
      if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
        if (!other.widget.eq(this.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        this.length = other.length;
        this.breakAfter = other.breakAfter;
        return true;
      }
      return false;
    }
    ignoreMutation() {
      return true;
    }
    ignoreEvent(event) {
      return this.widget.ignoreEvent(event);
    }
    destroy() {
      super.destroy();
      if (this.dom)
        this.widget.destroy(this.dom);
    }
  };
  var ContentBuilder = class {
    constructor(doc2, pos, end, disallowBlockEffectsFor) {
      this.doc = doc2;
      this.pos = pos;
      this.end = end;
      this.disallowBlockEffectsFor = disallowBlockEffectsFor;
      this.content = [];
      this.curLine = null;
      this.breakAtStart = 0;
      this.pendingBuffer = 0;
      this.atCursorPos = true;
      this.openStart = -1;
      this.openEnd = -1;
      this.text = "";
      this.textOff = 0;
      this.cursor = doc2.iter();
      this.skip = pos;
    }
    posCovered() {
      if (this.content.length == 0)
        return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
      let last2 = this.content[this.content.length - 1];
      return !last2.breakAfter && !(last2 instanceof BlockWidgetView && last2.type == BlockType.WidgetBefore);
    }
    getLine() {
      if (!this.curLine) {
        this.content.push(this.curLine = new LineView());
        this.atCursorPos = true;
      }
      return this.curLine;
    }
    flushBuffer(active) {
      if (this.pendingBuffer) {
        this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
        this.pendingBuffer = 0;
      }
    }
    addBlockWidget(view) {
      this.flushBuffer([]);
      this.curLine = null;
      this.content.push(view);
    }
    finish(openEnd) {
      if (!openEnd)
        this.flushBuffer([]);
      else
        this.pendingBuffer = 0;
      if (!this.posCovered())
        this.getLine();
    }
    buildText(length, active, openStart) {
      while (length > 0) {
        if (this.textOff == this.text.length) {
          let { value, lineBreak, done } = this.cursor.next(this.skip);
          this.skip = 0;
          if (done)
            throw new Error("Ran out of text content when drawing inline views");
          if (lineBreak) {
            if (!this.posCovered())
              this.getLine();
            if (this.content.length)
              this.content[this.content.length - 1].breakAfter = 1;
            else
              this.breakAtStart = 1;
            this.flushBuffer([]);
            this.curLine = null;
            length--;
            continue;
          } else {
            this.text = value;
            this.textOff = 0;
          }
        }
        let take = Math.min(this.text.length - this.textOff, length, 512);
        this.flushBuffer(active.slice(0, openStart));
        this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
        this.atCursorPos = true;
        this.textOff += take;
        length -= take;
        openStart = 0;
      }
    }
    span(from, to2, active, openStart) {
      this.buildText(to2 - from, active, openStart);
      this.pos = to2;
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    point(from, to2, deco, active, openStart, index) {
      if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
        if (deco.block)
          throw new RangeError("Block decorations may not be specified via plugins");
        if (to2 > this.doc.lineAt(this.pos).to)
          throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
      }
      let len = to2 - from;
      if (deco instanceof PointDecoration) {
        if (deco.block) {
          let { type: type2 } = deco;
          if (type2 == BlockType.WidgetAfter && !this.posCovered())
            this.getLine();
          this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type2));
        } else {
          let view = WidgetView.create(deco.widget || new NullWidget("span"), len, deco.startSide);
          let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to2 || deco.startSide > 0);
          let cursorAfter = !view.isEditable && (from < to2 || deco.startSide <= 0);
          let line = this.getLine();
          if (this.pendingBuffer == 2 && !cursorBefore)
            this.pendingBuffer = 0;
          this.flushBuffer(active);
          if (cursorBefore) {
            line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
            openStart = active.length + Math.max(0, openStart - active.length);
          }
          line.append(wrapMarks(view, active), openStart);
          this.atCursorPos = cursorAfter;
          this.pendingBuffer = !cursorAfter ? 0 : from < to2 ? 1 : 2;
        }
      } else if (this.doc.lineAt(this.pos).from == this.pos) {
        this.getLine().addLineDeco(deco);
      }
      if (len) {
        if (this.textOff + len <= this.text.length) {
          this.textOff += len;
        } else {
          this.skip += len - (this.text.length - this.textOff);
          this.text = "";
          this.textOff = 0;
        }
        this.pos = to2;
      }
      if (this.openStart < 0)
        this.openStart = openStart;
    }
    static build(text, from, to2, decorations2, dynamicDecorationMap) {
      let builder = new ContentBuilder(text, from, to2, dynamicDecorationMap);
      builder.openEnd = RangeSet.spans(decorations2, from, to2, builder);
      if (builder.openStart < 0)
        builder.openStart = builder.openEnd;
      builder.finish(builder.openEnd);
      return builder;
    }
  };
  function wrapMarks(view, active) {
    for (let mark of active)
      view = new MarkView(mark, [view], view.length);
    return view;
  }
  var NullWidget = class extends WidgetType {
    constructor(tag) {
      super();
      this.tag = tag;
    }
    eq(other) {
      return other.tag == this.tag;
    }
    toDOM() {
      return document.createElement(this.tag);
    }
    updateDOM(elt) {
      return elt.nodeName.toLowerCase() == this.tag;
    }
  };
  var clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
  var dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
  var mouseSelectionStyle = /* @__PURE__ */ Facet.define();
  var exceptionSink = /* @__PURE__ */ Facet.define();
  var updateListener = /* @__PURE__ */ Facet.define();
  var inputHandler = /* @__PURE__ */ Facet.define();
  var perLineTextDirection = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  var ScrollTarget = class {
    constructor(range2, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5) {
      this.range = range2;
      this.y = y;
      this.x = x;
      this.yMargin = yMargin;
      this.xMargin = xMargin;
    }
    map(changes) {
      return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
    }
  };
  var scrollIntoView = /* @__PURE__ */ StateEffect.define({ map: (t2, ch) => t2.map(ch) });
  function logException(state3, exception, context2) {
    let handler = state3.facet(exceptionSink);
    if (handler.length)
      handler[0](exception);
    else if (window.onerror)
      window.onerror(String(exception), context2, void 0, void 0, exception);
    else if (context2)
      console.error(context2 + ":", exception);
    else
      console.error(exception);
  }
  var editable = /* @__PURE__ */ Facet.define({ combine: (values) => values.length ? values[0] : true });
  var nextPluginID = 0;
  var viewPlugin = /* @__PURE__ */ Facet.define();
  var ViewPlugin = class {
    constructor(id2, create, domEventHandlers, buildExtensions) {
      this.id = id2;
      this.create = create;
      this.domEventHandlers = domEventHandlers;
      this.extension = buildExtensions(this);
    }
    static define(create, spec) {
      const { eventHandlers, provide, decorations: deco } = spec || {};
      return new ViewPlugin(nextPluginID++, create, eventHandlers, (plugin) => {
        let ext = [viewPlugin.of(plugin)];
        if (deco)
          ext.push(decorations.of((view) => {
            let pluginInst = view.plugin(plugin);
            return pluginInst ? deco(pluginInst) : Decoration.none;
          }));
        if (provide)
          ext.push(provide(plugin));
        return ext;
      });
    }
    static fromClass(cls, spec) {
      return ViewPlugin.define((view) => new cls(view), spec);
    }
  };
  var PluginInstance = class {
    constructor(spec) {
      this.spec = spec;
      this.mustUpdate = null;
      this.value = null;
    }
    update(view) {
      if (!this.value) {
        if (this.spec) {
          try {
            this.value = this.spec.create(view);
          } catch (e2) {
            logException(view.state, e2, "CodeMirror plugin crashed");
            this.deactivate();
          }
        }
      } else if (this.mustUpdate) {
        let update3 = this.mustUpdate;
        this.mustUpdate = null;
        if (this.value.update) {
          try {
            this.value.update(update3);
          } catch (e2) {
            logException(update3.state, e2, "CodeMirror plugin crashed");
            if (this.value.destroy)
              try {
                this.value.destroy();
              } catch (_) {
              }
            this.deactivate();
          }
        }
      }
      return this;
    }
    destroy(view) {
      var _a2;
      if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
        try {
          this.value.destroy();
        } catch (e2) {
          logException(view.state, e2, "CodeMirror plugin crashed");
        }
      }
    }
    deactivate() {
      this.spec = this.value = null;
    }
  };
  var editorAttributes = /* @__PURE__ */ Facet.define();
  var contentAttributes = /* @__PURE__ */ Facet.define();
  var decorations = /* @__PURE__ */ Facet.define();
  var atomicRanges = /* @__PURE__ */ Facet.define();
  var scrollMargins = /* @__PURE__ */ Facet.define();
  var styleModule = /* @__PURE__ */ Facet.define();
  var ChangedRange = class {
    constructor(fromA, toA, fromB, toB) {
      this.fromA = fromA;
      this.toA = toA;
      this.fromB = fromB;
      this.toB = toB;
    }
    join(other) {
      return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set3) {
      let i2 = set3.length, me = this;
      for (; i2 > 0; i2--) {
        let range2 = set3[i2 - 1];
        if (range2.fromA > me.toA)
          continue;
        if (range2.toA < me.fromA)
          break;
        me = me.join(range2);
        set3.splice(i2 - 1, 1);
      }
      set3.splice(i2, 0, me);
      return set3;
    }
    static extendWithRanges(diff, ranges) {
      if (ranges.length == 0)
        return diff;
      let result = [];
      for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
        let next = dI == diff.length ? null : diff[dI], off = posA - posB;
        let end = next ? next.fromB : 1e9;
        while (rI < ranges.length && ranges[rI] < end) {
          let from = ranges[rI], to2 = ranges[rI + 1];
          let fromB = Math.max(posB, from), toB = Math.min(end, to2);
          if (fromB <= toB)
            new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
          if (to2 > end)
            break;
          else
            rI += 2;
        }
        if (!next)
          return result;
        new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
        posA = next.toA;
        posB = next.toB;
      }
    }
  };
  var ViewUpdate = class {
    constructor(view, state3, transactions) {
      this.view = view;
      this.state = state3;
      this.transactions = transactions;
      this.flags = 0;
      this.startState = view.state;
      this.changes = ChangeSet.empty(this.startState.doc.length);
      for (let tr of transactions)
        this.changes = this.changes.compose(tr.changes);
      let changedRanges = [];
      this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
      this.changedRanges = changedRanges;
      let focus = view.hasFocus;
      if (focus != view.inputState.notifiedFocused) {
        view.inputState.notifiedFocused = focus;
        this.flags |= 1;
      }
    }
    static create(view, state3, transactions) {
      return new ViewUpdate(view, state3, transactions);
    }
    get viewportChanged() {
      return (this.flags & 4) > 0;
    }
    get heightChanged() {
      return (this.flags & 2) > 0;
    }
    get geometryChanged() {
      return this.docChanged || (this.flags & (8 | 2)) > 0;
    }
    get focusChanged() {
      return (this.flags & 1) > 0;
    }
    get docChanged() {
      return !this.changes.empty;
    }
    get selectionSet() {
      return this.transactions.some((tr) => tr.selection);
    }
    get empty() {
      return this.flags == 0 && this.transactions.length == 0;
    }
  };
  var Direction = /* @__PURE__ */ function(Direction2) {
    Direction2[Direction2["LTR"] = 0] = "LTR";
    Direction2[Direction2["RTL"] = 1] = "RTL";
    return Direction2;
  }(Direction || (Direction = {}));
  var LTR = Direction.LTR;
  var RTL = Direction.RTL;
  function dec(str) {
    let result = [];
    for (let i2 = 0; i2 < str.length; i2++)
      result.push(1 << +str[i2]);
    return result;
  }
  var LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
  var ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
  var Brackets = /* @__PURE__ */ Object.create(null);
  var BracketStack = [];
  for (let p2 of ["()", "[]", "{}"]) {
    let l = /* @__PURE__ */ p2.charCodeAt(0), r = /* @__PURE__ */ p2.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
  }
  function charType(ch) {
    return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : ch == 8204 ? 256 : 1;
  }
  var BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  var BidiSpan = class {
    constructor(from, to2, level) {
      this.from = from;
      this.to = to2;
      this.level = level;
    }
    get dir() {
      return this.level % 2 ? RTL : LTR;
    }
    side(end, dir) {
      return this.dir == dir == end ? this.to : this.from;
    }
    static find(order, index, level, assoc) {
      let maybe = -1;
      for (let i2 = 0; i2 < order.length; i2++) {
        let span = order[i2];
        if (span.from <= index && span.to >= index) {
          if (span.level == level)
            return i2;
          if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level))
            maybe = i2;
        }
      }
      if (maybe < 0)
        throw new RangeError("Index out of range");
      return maybe;
    }
  };
  var types = [];
  function computeOrder(line, direction) {
    let len = line.length, outerType = direction == LTR ? 1 : 2, oppositeType = direction == LTR ? 2 : 1;
    if (!line || outerType == 1 && !BidiRE.test(line))
      return trivialOrder(len);
    for (let i2 = 0, prev = outerType, prevStrong = outerType; i2 < len; i2++) {
      let type2 = charType(line.charCodeAt(i2));
      if (type2 == 512)
        type2 = prev;
      else if (type2 == 8 && prevStrong == 4)
        type2 = 16;
      types[i2] = type2 == 4 ? 2 : type2;
      if (type2 & 7)
        prevStrong = type2;
      prev = type2;
    }
    for (let i2 = 0, prev = outerType, prevStrong = outerType; i2 < len; i2++) {
      let type2 = types[i2];
      if (type2 == 128) {
        if (i2 < len - 1 && prev == types[i2 + 1] && prev & 24)
          type2 = types[i2] = prev;
        else
          types[i2] = 256;
      } else if (type2 == 64) {
        let end = i2 + 1;
        while (end < len && types[end] == 64)
          end++;
        let replace = i2 && prev == 8 || end < len && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i2; j < end; j++)
          types[j] = replace;
        i2 = end - 1;
      } else if (type2 == 8 && prevStrong == 1) {
        types[i2] = 1;
      }
      prev = type2;
      if (type2 & 7)
        prevStrong = type2;
    }
    for (let i2 = 0, sI = 0, context2 = 0, ch, br, type2; i2 < len; i2++) {
      if (br = Brackets[ch = line.charCodeAt(i2)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type3 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type3)
                types[i2] = types[BracketStack[sJ]] = type3;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i2;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context2;
        }
      } else if ((type2 = types[i2]) == 2 || type2 == 1) {
        let embed = type2 == outerType;
        context2 = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur2 = BracketStack[sJ + 2];
          if (cur2 & 2)
            break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur2 & 4)
              break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
    for (let i2 = 0; i2 < len; i2++) {
      if (types[i2] == 256) {
        let end = i2 + 1;
        while (end < len && types[end] == 256)
          end++;
        let beforeL = (i2 ? types[i2 - 1] : outerType) == 1;
        let afterL = (end < len ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = i2; j < end; j++)
          types[j] = replace;
        i2 = end - 1;
      }
    }
    let order = [];
    if (outerType == 1) {
      for (let i2 = 0; i2 < len; ) {
        let start2 = i2, rtl = types[i2++] != 1;
        while (i2 < len && rtl == (types[i2] != 1))
          i2++;
        if (rtl) {
          for (let j = i2; j > start2; ) {
            let end = j, l = types[--j] != 2;
            while (j > start2 && l == (types[j - 1] != 2))
              j--;
            order.push(new BidiSpan(j, end, l ? 2 : 1));
          }
        } else {
          order.push(new BidiSpan(start2, i2, 0));
        }
      }
    } else {
      for (let i2 = 0; i2 < len; ) {
        let start2 = i2, rtl = types[i2++] == 2;
        while (i2 < len && rtl == (types[i2] == 2))
          i2++;
        order.push(new BidiSpan(start2, i2, rtl ? 1 : 2));
      }
    }
    return order;
  }
  function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
  }
  var movedOver = "";
  function moveVisually(line, order, dir, start2, forward) {
    var _a2;
    let startIndex = start2.head - line.from, spanI = -1;
    if (startIndex == 0) {
      if (!forward || !line.length)
        return null;
      if (order[0].level != dir) {
        startIndex = order[0].side(false, dir);
        spanI = 0;
      }
    } else if (startIndex == line.length) {
      if (forward)
        return null;
      let last2 = order[order.length - 1];
      if (last2.level != dir) {
        startIndex = last2.side(true, dir);
        spanI = order.length - 1;
      }
    }
    if (spanI < 0)
      spanI = BidiSpan.find(order, startIndex, (_a2 = start2.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start2.assoc);
    let span = order[spanI];
    if (startIndex == span.side(forward, dir)) {
      span = order[spanI += forward ? 1 : -1];
      startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex != span.side(forward, dir))
      return EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
      return EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
      return EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
  }
  var LineBreakPlaceholder = "\uFFFF";
  var DOMReader = class {
    constructor(points, state3) {
      this.points = points;
      this.text = "";
      this.lineSeparator = state3.facet(EditorState.lineSeparator);
    }
    append(text) {
      this.text += text;
    }
    lineBreak() {
      this.text += LineBreakPlaceholder;
    }
    readRange(start2, end) {
      if (!start2)
        return this;
      let parent = start2.parentNode;
      for (let cur2 = start2; ; ) {
        this.findPointBefore(parent, cur2);
        this.readNode(cur2);
        let next = cur2.nextSibling;
        if (next == end)
          break;
        let view = ContentView.get(cur2), nextView = ContentView.get(next);
        if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next) && (cur2.nodeName != "BR" || cur2.cmIgnore))
          this.lineBreak();
        cur2 = next;
      }
      this.findPointBefore(parent, end);
      return this;
    }
    readTextNode(node) {
      let text = node.nodeValue;
      for (let point of this.points)
        if (point.node == node)
          point.pos = this.text.length + Math.min(point.offset, text.length);
      for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
        let nextBreak = -1, breakSize = 1, m3;
        if (this.lineSeparator) {
          nextBreak = text.indexOf(this.lineSeparator, off);
          breakSize = this.lineSeparator.length;
        } else if (m3 = re.exec(text)) {
          nextBreak = m3.index;
          breakSize = m3[0].length;
        }
        this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
        if (nextBreak < 0)
          break;
        this.lineBreak();
        if (breakSize > 1) {
          for (let point of this.points)
            if (point.node == node && point.pos > this.text.length)
              point.pos -= breakSize - 1;
        }
        off = nextBreak + breakSize;
      }
    }
    readNode(node) {
      if (node.cmIgnore)
        return;
      let view = ContentView.get(node);
      let fromView = view && view.overrideDOMText;
      if (fromView != null) {
        this.findPointInside(node, fromView.length);
        for (let i2 = fromView.iter(); !i2.next().done; ) {
          if (i2.lineBreak)
            this.lineBreak();
          else
            this.append(i2.value);
        }
      } else if (node.nodeType == 3) {
        this.readTextNode(node);
      } else if (node.nodeName == "BR") {
        if (node.nextSibling)
          this.lineBreak();
      } else if (node.nodeType == 1) {
        this.readRange(node.firstChild, null);
      }
    }
    findPointBefore(node, next) {
      for (let point of this.points)
        if (point.node == node && node.childNodes[point.offset] == next)
          point.pos = this.text.length;
    }
    findPointInside(node, maxLen) {
      for (let point of this.points)
        if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
          point.pos = this.text.length + Math.min(maxLen, point.offset);
    }
  };
  function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
  }
  var DOMPoint = class {
    constructor(node, offset) {
      this.node = node;
      this.offset = offset;
      this.pos = -1;
    }
  };
  var DocView = class extends ContentView {
    constructor(view) {
      super();
      this.view = view;
      this.compositionDeco = Decoration.none;
      this.decorations = [];
      this.dynamicDecorationMap = [];
      this.minWidth = 0;
      this.minWidthFrom = 0;
      this.minWidthTo = 0;
      this.impreciseAnchor = null;
      this.impreciseHead = null;
      this.forceSelection = false;
      this.lastUpdate = Date.now();
      this.setDOM(view.contentDOM);
      this.children = [new LineView()];
      this.children[0].setParent(this);
      this.updateDeco();
      this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
    }
    get root() {
      return this.view.root;
    }
    get editorView() {
      return this.view;
    }
    get length() {
      return this.view.state.doc.length;
    }
    update(update3) {
      let changedRanges = update3.changedRanges;
      if (this.minWidth > 0 && changedRanges.length) {
        if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
          this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
        } else {
          this.minWidthFrom = update3.changes.mapPos(this.minWidthFrom, 1);
          this.minWidthTo = update3.changes.mapPos(this.minWidthTo, 1);
        }
      }
      if (this.view.inputState.composing < 0)
        this.compositionDeco = Decoration.none;
      else if (update3.transactions.length || this.dirty)
        this.compositionDeco = computeCompositionDeco(this.view, update3.changes);
      if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update3 && update3.state.doc.lines != update3.startState.doc.lines)
        this.forceSelection = true;
      let prevDeco = this.decorations, deco = this.updateDeco();
      let decoDiff = findChangedDeco(prevDeco, deco, update3.changes);
      changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
      if (this.dirty == 0 && changedRanges.length == 0) {
        return false;
      } else {
        this.updateInner(changedRanges, update3.startState.doc.length);
        if (update3.transactions.length)
          this.lastUpdate = Date.now();
        return true;
      }
    }
    updateInner(changes, oldLength) {
      this.view.viewState.mustMeasureContent = true;
      this.updateChildren(changes, oldLength);
      let { observer } = this.view;
      observer.ignore(() => {
        this.dom.style.height = this.view.viewState.contentHeight + "px";
        this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
        let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
        this.sync(track);
        this.dirty = 0;
        if (track && (track.written || observer.selectionRange.focusNode != track.node))
          this.forceSelection = true;
        this.dom.style.height = "";
      });
      let gaps = [];
      if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
        for (let child of this.children)
          if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
            gaps.push(child.dom);
      }
      observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength) {
      let cursor = this.childCursor(oldLength);
      for (let i2 = changes.length - 1; ; i2--) {
        let next = i2 >= 0 ? changes[i2] : null;
        if (!next)
          break;
        let { fromA, toA, fromB, toB } = next;
        let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
        let { i: toI, off: toOff } = cursor.findPos(toA, 1);
        let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
        replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
      }
    }
    updateSelection(mustRead = false, fromPointer = false) {
      if (mustRead)
        this.view.observer.readSelectionRange();
      if (!(fromPointer || this.mayControlSelection()) || browser.ios && this.view.inputState.rapidCompositionStart)
        return;
      let force = this.forceSelection;
      this.forceSelection = false;
      let main = this.view.state.selection.main;
      let anchor = this.domAtPos(main.anchor);
      let head = main.empty ? anchor : this.domAtPos(main.head);
      if (browser.gecko && main.empty && betweenUneditable(anchor)) {
        let dummy = document.createTextNode("");
        this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
        anchor = head = new DOMPos(dummy, 0);
        force = true;
      }
      let domSel = this.view.observer.selectionRange;
      if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
        this.view.observer.ignore(() => {
          if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
            this.dom.blur();
            this.dom.focus({ preventScroll: true });
          }
          let rawSel = getSelection(this.root);
          if (main.empty) {
            if (browser.gecko) {
              let nextTo = nextToUneditable(anchor.node, anchor.offset);
              if (nextTo && nextTo != (1 | 2)) {
                let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
                if (text)
                  anchor = new DOMPos(text, nextTo == 1 ? 0 : text.nodeValue.length);
              }
            }
            rawSel.collapse(anchor.node, anchor.offset);
            if (main.bidiLevel != null && domSel.cursorBidiLevel != null)
              domSel.cursorBidiLevel = main.bidiLevel;
          } else if (rawSel.extend) {
            rawSel.collapse(anchor.node, anchor.offset);
            rawSel.extend(head.node, head.offset);
          } else {
            let range2 = document.createRange();
            if (main.anchor > main.head)
              [anchor, head] = [head, anchor];
            range2.setEnd(head.node, head.offset);
            range2.setStart(anchor.node, anchor.offset);
            rawSel.removeAllRanges();
            rawSel.addRange(range2);
          }
        });
        this.view.observer.setSelectionRange(anchor, head);
      }
      this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
      this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
      if (this.compositionDeco.size)
        return;
      let cursor = this.view.state.selection.main;
      let sel = getSelection(this.root);
      if (!cursor.empty || !cursor.assoc || !sel.modify)
        return;
      let line = LineView.find(this, cursor.head);
      if (!line)
        return;
      let lineStart = line.posAtStart;
      if (cursor.head == lineStart || cursor.head == lineStart + line.length)
        return;
      let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
      if (!before || !after || before.bottom > after.top)
        return;
      let dom2 = this.domAtPos(cursor.head + cursor.assoc);
      sel.collapse(dom2.node, dom2.offset);
      sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    }
    mayControlSelection() {
      return this.view.state.facet(editable) ? this.root.activeElement == this.dom : hasSelection(this.dom, this.view.observer.selectionRange);
    }
    nearest(dom2) {
      for (let cur2 = dom2; cur2; ) {
        let domView = ContentView.get(cur2);
        if (domView && domView.rootView == this)
          return domView;
        cur2 = cur2.parentNode;
      }
      return null;
    }
    posFromDOM(node, offset) {
      let view = this.nearest(node);
      if (!view)
        throw new RangeError("Trying to find position for a DOM position outside of the document");
      return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
      let { i: i2, off } = this.childCursor().findPos(pos, -1);
      for (; i2 < this.children.length - 1; ) {
        let child = this.children[i2];
        if (off < child.length || child instanceof LineView)
          break;
        i2++;
        off = 0;
      }
      return this.children[i2].domAtPos(off);
    }
    coordsAt(pos, side) {
      for (let off = this.length, i2 = this.children.length - 1; ; i2--) {
        let child = this.children[i2], start2 = off - child.breakAfter - child.length;
        if (pos > start2 || pos == start2 && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i2 || side == 2 || this.children[i2 - 1].breakAfter || this.children[i2 - 1].type == BlockType.WidgetBefore && side > -2))
          return child.coordsAt(pos - start2, side);
        off = start2;
      }
    }
    measureVisibleLineHeights(viewport) {
      let result = [], { from, to: to2 } = viewport;
      let contentWidth = this.view.contentDOM.clientWidth;
      let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
      let widest = -1, ltr = this.view.textDirection == Direction.LTR;
      for (let pos = 0, i2 = 0; i2 < this.children.length; i2++) {
        let child = this.children[i2], end = pos + child.length;
        if (end > to2)
          break;
        if (pos >= from) {
          let childRect = child.dom.getBoundingClientRect();
          result.push(childRect.height);
          if (isWider) {
            let last2 = child.dom.lastChild;
            let rects = last2 ? clientRectsFor(last2) : [];
            if (rects.length) {
              let rect = rects[rects.length - 1];
              let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
              if (width > widest) {
                widest = width;
                this.minWidth = contentWidth;
                this.minWidthFrom = pos;
                this.minWidthTo = end;
              }
            }
          }
        }
        pos = end + child.breakAfter;
      }
      return result;
    }
    textDirectionAt(pos) {
      let { i: i2 } = this.childPos(pos, 1);
      return getComputedStyle(this.children[i2].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
      for (let child of this.children) {
        if (child instanceof LineView) {
          let measure = child.measureTextSize();
          if (measure)
            return measure;
        }
      }
      let dummy = document.createElement("div"), lineHeight, charWidth;
      dummy.className = "cm-line";
      dummy.textContent = "abc def ghi jkl mno pqr stu";
      this.view.observer.ignore(() => {
        this.dom.appendChild(dummy);
        let rect = clientRectsFor(dummy.firstChild)[0];
        lineHeight = dummy.getBoundingClientRect().height;
        charWidth = rect ? rect.width / 27 : 7;
        dummy.remove();
      });
      return { lineHeight, charWidth };
    }
    childCursor(pos = this.length) {
      let i2 = this.children.length;
      if (i2)
        pos -= this.children[--i2].length;
      return new ChildCursor(this.children, pos, i2);
    }
    computeBlockGapDeco() {
      let deco = [], vs = this.view.viewState;
      for (let pos = 0, i2 = 0; ; i2++) {
        let next = i2 == vs.viewports.length ? null : vs.viewports[i2];
        let end = next ? next.from - 1 : this.length;
        if (end > pos) {
          let height = vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top;
          deco.push(Decoration.replace({
            widget: new BlockGapWidget(height),
            block: true,
            inclusive: true,
            isBlockGap: true
          }).range(pos, end));
        }
        if (!next)
          break;
        pos = next.to + 1;
      }
      return Decoration.set(deco);
    }
    updateDeco() {
      let allDeco = this.view.state.facet(decorations).map((d2, i2) => {
        let dynamic = this.dynamicDecorationMap[i2] = typeof d2 == "function";
        return dynamic ? d2(this.view) : d2;
      });
      for (let i2 = allDeco.length; i2 < allDeco.length + 3; i2++)
        this.dynamicDecorationMap[i2] = false;
      return this.decorations = [
        ...allDeco,
        this.compositionDeco,
        this.computeBlockGapDeco(),
        this.view.viewState.lineGapDeco
      ];
    }
    scrollIntoView(target) {
      let { range: range2 } = target;
      let rect = this.coordsAt(range2.head, range2.empty ? range2.assoc : range2.head > range2.anchor ? -1 : 1), other;
      if (!rect)
        return;
      if (!range2.empty && (other = this.coordsAt(range2.anchor, range2.anchor > range2.head ? -1 : 1)))
        rect = {
          left: Math.min(rect.left, other.left),
          top: Math.min(rect.top, other.top),
          right: Math.max(rect.right, other.right),
          bottom: Math.max(rect.bottom, other.bottom)
        };
      let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
      for (let margins of this.view.state.facet(scrollMargins).map((f) => f(this.view)))
        if (margins) {
          let { left, right, top: top2, bottom } = margins;
          if (left != null)
            mLeft = Math.max(mLeft, left);
          if (right != null)
            mRight = Math.max(mRight, right);
          if (top2 != null)
            mTop = Math.max(mTop, top2);
          if (bottom != null)
            mBottom = Math.max(mBottom, bottom);
        }
      let targetRect = {
        left: rect.left - mLeft,
        top: rect.top - mTop,
        right: rect.right + mRight,
        bottom: rect.bottom + mBottom
      };
      scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
    }
  };
  function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
  }
  var BlockGapWidget = class extends WidgetType {
    constructor(height) {
      super();
      this.height = height;
    }
    toDOM() {
      let elt = document.createElement("div");
      this.updateDOM(elt);
      return elt;
    }
    eq(other) {
      return other.height == this.height;
    }
    updateDOM(elt) {
      elt.style.height = this.height + "px";
      return true;
    }
    get estimatedHeight() {
      return this.height;
    }
  };
  function compositionSurroundingNode(view) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
      return null;
    let cView = view.docView.nearest(textNode);
    if (!cView)
      return null;
    if (cView instanceof LineView) {
      let topNode = textNode;
      while (topNode.parentNode != cView.dom)
        topNode = topNode.parentNode;
      let prev = topNode.previousSibling;
      while (prev && !ContentView.get(prev))
        prev = prev.previousSibling;
      let pos = prev ? ContentView.get(prev).posAtEnd : cView.posAtStart;
      return { from: pos, to: pos, node: topNode, text: textNode };
    } else {
      for (; ; ) {
        let { parent } = cView;
        if (!parent)
          return null;
        if (parent instanceof LineView)
          break;
        cView = parent;
      }
      let from = cView.posAtStart;
      return { from, to: from + cView.length, node: cView.dom, text: textNode };
    }
  }
  function computeCompositionDeco(view, changes) {
    let surrounding = compositionSurroundingNode(view);
    if (!surrounding)
      return Decoration.none;
    let { from, to: to2, node, text: textNode } = surrounding;
    let newFrom = changes.mapPos(from, 1), newTo = Math.max(newFrom, changes.mapPos(to2, -1));
    let { state: state3 } = view, text = node.nodeType == 3 ? node.nodeValue : new DOMReader([], state3).readRange(node.firstChild, null).text;
    if (newTo - newFrom < text.length) {
      if (state3.doc.sliceString(newFrom, Math.min(state3.doc.length, newFrom + text.length), LineBreakPlaceholder) == text)
        newTo = newFrom + text.length;
      else if (state3.doc.sliceString(Math.max(0, newTo - text.length), newTo, LineBreakPlaceholder) == text)
        newFrom = newTo - text.length;
      else
        return Decoration.none;
    } else if (state3.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text) {
      return Decoration.none;
    }
    let topView = ContentView.get(node);
    if (topView instanceof CompositionView)
      topView = topView.widget.topView;
    else if (topView)
      topView.parent = null;
    return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node, textNode, topView), inclusive: true }).range(newFrom, newTo));
  }
  var CompositionWidget = class extends WidgetType {
    constructor(top2, text, topView) {
      super();
      this.top = top2;
      this.text = text;
      this.topView = topView;
    }
    eq(other) {
      return this.top == other.top && this.text == other.text;
    }
    toDOM() {
      return this.top;
    }
    ignoreEvent() {
      return false;
    }
    get customView() {
      return CompositionView;
    }
  };
  function nearbyTextNode(node, offset, side) {
    for (; ; ) {
      if (node.nodeType == 3)
        return node;
      if (node.nodeType == 1 && offset > 0 && side <= 0) {
        node = node.childNodes[offset - 1];
        offset = maxOffset(node);
      } else if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
        node = node.childNodes[offset];
        offset = 0;
      } else {
        return null;
      }
    }
  }
  function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
      return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
  }
  var DecorationComparator$1 = class {
    constructor() {
      this.changes = [];
    }
    compareRange(from, to2) {
      addRange(from, to2, this.changes);
    }
    comparePoint(from, to2) {
      addRange(from, to2, this.changes);
    }
  };
  function findChangedDeco(a2, b2, diff) {
    let comp = new DecorationComparator$1();
    RangeSet.compare(a2, b2, diff, comp);
    return comp.changes;
  }
  function inUneditable(node, inside2) {
    for (let cur2 = node; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
      if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
        return true;
      }
    }
    return false;
  }
  function groupAt(state3, pos, bias = 1) {
    let categorize = state3.charCategorizer(pos);
    let line = state3.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
      return EditorSelection.cursor(pos);
    if (linePos == 0)
      bias = 1;
    else if (linePos == line.length)
      bias = -1;
    let from = linePos, to2 = linePos;
    if (bias < 0)
      from = findClusterBreak(line.text, linePos, false);
    else
      to2 = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to2));
    while (from > 0) {
      let prev = findClusterBreak(line.text, from, false);
      if (categorize(line.text.slice(prev, from)) != cat)
        break;
      from = prev;
    }
    while (to2 < line.length) {
      let next = findClusterBreak(line.text, to2);
      if (categorize(line.text.slice(to2, next)) != cat)
        break;
      to2 = next;
    }
    return EditorSelection.range(from + line.from, to2 + line.from);
  }
  function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
  }
  function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
  }
  function yOverlap(a2, b2) {
    return a2.top < b2.bottom - 1 && a2.bottom > b2.top + 1;
  }
  function upTop(rect, top2) {
    return top2 < rect.top ? { top: top2, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
  }
  function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
  }
  function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
      let rects = clientRectsFor(child);
      for (let i2 = 0; i2 < rects.length; i2++) {
        let rect = rects[i2];
        if (closestRect && yOverlap(closestRect, rect))
          rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
        let dx = getdx(x, rect), dy = getdy(y, rect);
        if (dx == 0 && dy == 0)
          return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
        if (!closest || closestY > dy || closestY == dy && closestX > dx) {
          closest = child;
          closestRect = rect;
          closestX = dx;
          closestY = dy;
        }
        if (dx == 0) {
          if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
            above = child;
            aboveRect = rect;
          } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
            below = child;
            belowRect = rect;
          }
        } else if (aboveRect && yOverlap(aboveRect, rect)) {
          aboveRect = upBot(aboveRect, rect.bottom);
        } else if (belowRect && yOverlap(belowRect, rect)) {
          belowRect = upTop(belowRect, rect.top);
        }
      }
    }
    if (aboveRect && aboveRect.bottom >= y) {
      closest = above;
      closestRect = aboveRect;
    } else if (belowRect && belowRect.top <= y) {
      closest = below;
      closestRect = belowRect;
    }
    if (!closest)
      return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
      return domPosInText(closest, clipX, y);
    if (!closestX && closest.contentEditable == "true")
      return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
  }
  function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i2 = 0; i2 < len; i2++) {
      let rects = textRange(node, i2, i2 + 1).getClientRects();
      for (let j = 0; j < rects.length; j++) {
        let rect = rects[j];
        if (rect.top == rect.bottom)
          continue;
        if (!generalSide)
          generalSide = x - rect.left;
        let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
        if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
          let right = x >= (rect.left + rect.right) / 2, after = right;
          if (browser.chrome || browser.gecko) {
            let rectBefore = textRange(node, i2).getBoundingClientRect();
            if (rectBefore.left == rect.right)
              after = !right;
          }
          if (dy <= 0)
            return { node, offset: i2 + (after ? 1 : 0) };
          closestOffset = i2 + (after ? 1 : 0);
          closestDY = dy;
        }
      }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
  }
  function posAtCoords(view, { x, y }, precise, bias = -1) {
    var _a2;
    let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let yOffset = y - docTop;
    if (yOffset < 0)
      return 0;
    if (yOffset > docHeight)
      return view.state.doc.length;
    for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
      block = view.elementAtHeight(yOffset);
      if (block.type == BlockType.Text)
        break;
      for (; ; ) {
        yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
        if (yOffset >= 0 && yOffset <= docHeight)
          break;
        if (bounced)
          return precise ? null : 0;
        bounced = true;
        bias = -bias;
      }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    if (lineStart < view.viewport.from)
      return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    if (lineStart > view.viewport.to)
      return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x, y);
    let doc2 = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc2;
    let element3 = root.elementFromPoint(x, y);
    if (element3 && !view.contentDOM.contains(element3))
      element3 = null;
    if (!element3) {
      x = Math.max(content2.left + 1, Math.min(content2.right - 1, x));
      element3 = root.elementFromPoint(x, y);
      if (element3 && !view.contentDOM.contains(element3))
        element3 = null;
    }
    let node, offset = -1;
    if (element3 && ((_a2 = view.docView.nearest(element3)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
      if (doc2.caretPositionFromPoint) {
        let pos = doc2.caretPositionFromPoint(x, y);
        if (pos)
          ({ offsetNode: node, offset } = pos);
      } else if (doc2.caretRangeFromPoint) {
        let range2 = doc2.caretRangeFromPoint(x, y);
        if (range2) {
          ({ startContainer: node, startOffset: offset } = range2);
          if (browser.safari && isSuspiciousCaretResult(node, offset, x))
            node = void 0;
        }
      }
    }
    if (!node || !view.docView.dom.contains(node)) {
      let line = LineView.find(view.docView, lineStart);
      if (!line)
        return yOffset > block.top + block.height / 2 ? block.to : block.from;
      ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    return view.docView.posFromDOM(node, offset);
  }
  function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
      let line = Math.floor((y - block.top) / view.defaultLineHeight);
      into += line * view.viewState.heightOracle.lineLength;
    }
    let content2 = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content2, into, view.state.tabSize);
  }
  function isSuspiciousCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
      return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
      if (next.nodeType != 1 || next.nodeName != "BR")
        return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
  }
  function moveToLineBoundary(view, start2, forward, includeWrap) {
    let line = view.state.doc.lineAt(start2.head);
    let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line.from ? start2.head - 1 : start2.head);
    if (coords) {
      let editorRect = view.dom.getBoundingClientRect();
      let direction = view.textDirectionAt(line.from);
      let pos = view.posAtCoords({
        x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
        y: (coords.top + coords.bottom) / 2
      });
      if (pos != null)
        return EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    let lineView = LineView.find(view.docView, start2.head);
    let end = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line.to : line.from;
    return EditorSelection.cursor(end, forward ? -1 : 1);
  }
  function moveByChar(view, start2, forward, by) {
    let line = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur2 = start2, check = null; ; ) {
      let next = moveVisually(line, spans, direction, cur2, forward), char = movedOver;
      if (!next) {
        if (line.number == (forward ? view.state.doc.lines : 1))
          return cur2;
        char = "\n";
        line = view.state.doc.line(line.number + (forward ? 1 : -1));
        spans = view.bidiSpans(line);
        next = EditorSelection.cursor(forward ? line.from : line.to);
      }
      if (!check) {
        if (!by)
          return next;
        check = by(char);
      } else if (!check(char)) {
        return cur2;
      }
      cur2 = next;
    }
  }
  function byGroup(view, pos, start2) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start2);
    return (next) => {
      let nextCat = categorize(next);
      if (cat == CharCategory.Space)
        cat = nextCat;
      return cat == nextCat;
    };
  }
  function moveVertically(view, start2, forward, distance2) {
    let startPos = start2.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
      return EditorSelection.cursor(startPos, start2.assoc);
    let goal = start2.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
    if (startCoords) {
      if (goal == null)
        goal = startCoords.left - rect.left;
      startY = dir < 0 ? startCoords.top : startCoords.bottom;
    } else {
      let line = view.viewState.lineBlockAt(startPos);
      if (goal == null)
        goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
      startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance2 !== null && distance2 !== void 0 ? distance2 : view.defaultLineHeight >> 1;
    for (let extra = 0; ; extra += 10) {
      let curY = startY + (dist + extra) * dir;
      let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
      if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos))
        return EditorSelection.cursor(pos, start2.assoc, void 0, goal);
    }
  }
  function skipAtoms(view, oldPos, pos) {
    let atoms = view.state.facet(atomicRanges).map((f) => f(view));
    for (; ; ) {
      let moved = false;
      for (let set3 of atoms) {
        set3.between(pos.from - 1, pos.from + 1, (from, to2, value) => {
          if (pos.from > from && pos.from < to2) {
            pos = oldPos.from > pos.from ? EditorSelection.cursor(from, 1) : EditorSelection.cursor(to2, -1);
            moved = true;
          }
        });
      }
      if (!moved)
        return pos;
    }
  }
  var InputState = class {
    constructor(view) {
      this.lastKeyCode = 0;
      this.lastKeyTime = 0;
      this.chromeScrollHack = -1;
      this.pendingIOSKey = void 0;
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastEscPress = 0;
      this.lastContextMenu = 0;
      this.scrollHandlers = [];
      this.registeredEvents = [];
      this.customHandlers = [];
      this.composing = -1;
      this.compositionFirstChange = null;
      this.compositionEndedAt = 0;
      this.rapidCompositionStart = false;
      this.mouseSelection = null;
      for (let type2 in handlers2) {
        let handler = handlers2[type2];
        view.contentDOM.addEventListener(type2, (event) => {
          if (!eventBelongsToEditor(view, event) || this.ignoreDuringComposition(event))
            return;
          if (type2 == "keydown" && this.keydown(view, event))
            return;
          if (this.mustFlushObserver(event))
            view.observer.forceFlush();
          if (this.runCustomHandlers(type2, view, event))
            event.preventDefault();
          else
            handler(view, event);
        });
        this.registeredEvents.push(type2);
      }
      if (browser.chrome && browser.chrome_version >= 102) {
        view.scrollDOM.addEventListener("wheel", () => {
          if (this.chromeScrollHack < 0)
            view.contentDOM.style.pointerEvents = "none";
          else
            window.clearTimeout(this.chromeScrollHack);
          this.chromeScrollHack = setTimeout(() => {
            this.chromeScrollHack = -1;
            view.contentDOM.style.pointerEvents = "";
          }, 100);
        }, { passive: true });
      }
      this.notifiedFocused = view.hasFocus;
      if (browser.safari)
        view.contentDOM.addEventListener("input", () => null);
    }
    setSelectionOrigin(origin) {
      this.lastSelectionOrigin = origin;
      this.lastSelectionTime = Date.now();
    }
    ensureHandlers(view, plugins) {
      var _a2;
      let handlers3;
      this.customHandlers = [];
      for (let plugin of plugins)
        if (handlers3 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
          this.customHandlers.push({ plugin: plugin.value, handlers: handlers3 });
          for (let type2 in handlers3)
            if (this.registeredEvents.indexOf(type2) < 0 && type2 != "scroll") {
              this.registeredEvents.push(type2);
              view.contentDOM.addEventListener(type2, (event) => {
                if (!eventBelongsToEditor(view, event))
                  return;
                if (this.runCustomHandlers(type2, view, event))
                  event.preventDefault();
              });
            }
        }
    }
    runCustomHandlers(type2, view, event) {
      for (let set3 of this.customHandlers) {
        let handler = set3.handlers[type2];
        if (handler) {
          try {
            if (handler.call(set3.plugin, event, view) || event.defaultPrevented)
              return true;
          } catch (e2) {
            logException(view.state, e2);
          }
        }
      }
      return false;
    }
    runScrollHandlers(view, event) {
      for (let set3 of this.customHandlers) {
        let handler = set3.handlers.scroll;
        if (handler) {
          try {
            handler.call(set3.plugin, event, view);
          } catch (e2) {
            logException(view.state, e2);
          }
        }
      }
    }
    keydown(view, event) {
      this.lastKeyCode = event.keyCode;
      this.lastKeyTime = Date.now();
      if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
        return true;
      if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
        view.observer.delayAndroidKey(event.key, event.keyCode);
        return true;
      }
      let pending;
      if (browser.ios && (pending = PendingKeys.find((key2) => key2.keyCode == event.keyCode)) && !(event.ctrlKey || event.altKey || event.metaKey) && !event.synthetic) {
        this.pendingIOSKey = pending;
        setTimeout(() => this.flushIOSKey(view), 250);
        return true;
      }
      return false;
    }
    flushIOSKey(view) {
      let key2 = this.pendingIOSKey;
      if (!key2)
        return false;
      this.pendingIOSKey = void 0;
      return dispatchKey(view.contentDOM, key2.key, key2.keyCode);
    }
    ignoreDuringComposition(event) {
      if (!/^key/.test(event.type))
        return false;
      if (this.composing > 0)
        return true;
      if (browser.safari && Date.now() - this.compositionEndedAt < 100) {
        this.compositionEndedAt = 0;
        return true;
      }
      return false;
    }
    mustFlushObserver(event) {
      return event.type == "keydown" && event.keyCode != 229 || event.type == "compositionend" && !browser.ios;
    }
    startMouseSelection(mouseSelection) {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
      this.mouseSelection = mouseSelection;
    }
    update(update3) {
      if (this.mouseSelection)
        this.mouseSelection.update(update3);
      if (update3.transactions.length)
        this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
      if (this.mouseSelection)
        this.mouseSelection.destroy();
    }
  };
  var PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
  ];
  var modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
  var MouseSelection = class {
    constructor(view, startEvent, style, mustSelect) {
      this.view = view;
      this.style = style;
      this.mustSelect = mustSelect;
      this.lastEvent = startEvent;
      let doc2 = view.contentDOM.ownerDocument;
      doc2.addEventListener("mousemove", this.move = this.move.bind(this));
      doc2.addEventListener("mouseup", this.up = this.up.bind(this));
      this.extend = startEvent.shiftKey;
      this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
      this.dragMove = dragMovesSelection(view, startEvent);
      this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
      if (this.dragging === false) {
        startEvent.preventDefault();
        this.select(startEvent);
      }
    }
    move(event) {
      if (event.buttons == 0)
        return this.destroy();
      if (this.dragging !== false)
        return;
      this.select(this.lastEvent = event);
    }
    up(event) {
      if (this.dragging == null)
        this.select(this.lastEvent);
      if (!this.dragging)
        event.preventDefault();
      this.destroy();
    }
    destroy() {
      let doc2 = this.view.contentDOM.ownerDocument;
      doc2.removeEventListener("mousemove", this.move);
      doc2.removeEventListener("mouseup", this.up);
      this.view.inputState.mouseSelection = null;
    }
    select(event) {
      let selection = this.style.get(event, this.extend, this.multiple);
      if (this.mustSelect || !selection.eq(this.view.state.selection) || selection.main.assoc != this.view.state.selection.main.assoc)
        this.view.dispatch({
          selection,
          userEvent: "select.pointer",
          scrollIntoView: true
        });
      this.mustSelect = false;
    }
    update(update3) {
      if (update3.docChanged && this.dragging)
        this.dragging = this.dragging.map(update3.changes);
      if (this.style.update(update3))
        setTimeout(() => this.select(this.lastEvent), 20);
    }
  };
  function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
  }
  function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
  }
  function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
      return false;
    let sel = getSelection(view.root);
    if (sel.rangeCount == 0)
      return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY)
        return true;
    }
    return false;
  }
  function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
      return true;
    if (event.defaultPrevented)
      return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
      if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event))
        return false;
    return true;
  }
  var handlers2 = /* @__PURE__ */ Object.create(null);
  var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
  function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
      view.focus();
      target.remove();
      doPaste(view, target.value);
    }, 50);
  }
  function doPaste(view, input) {
    let { state: state3 } = view, changes, i2 = 1, text = state3.toText(input);
    let byLine = text.lines == state3.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state3.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
      let lastLine = -1;
      changes = state3.changeByRange((range2) => {
        let line = state3.doc.lineAt(range2.from);
        if (line.from == lastLine)
          return { range: range2 };
        lastLine = line.from;
        let insert2 = state3.toText((byLine ? text.line(i2++).text : input) + state3.lineBreak);
        return {
          changes: { from: line.from, insert: insert2 },
          range: EditorSelection.cursor(range2.from + insert2.length)
        };
      });
    } else if (byLine) {
      changes = state3.changeByRange((range2) => {
        let line = text.line(i2++);
        return {
          changes: { from: range2.from, to: range2.to, insert: line.text },
          range: EditorSelection.cursor(range2.from + line.length)
        };
      });
    } else {
      changes = state3.replaceSelection(text);
    }
    view.dispatch(changes, {
      userEvent: "input.paste",
      scrollIntoView: true
    });
  }
  handlers2.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
      view.inputState.lastEscPress = Date.now();
    else if (modifierCodes.indexOf(event.keyCode) < 0)
      view.inputState.lastEscPress = 0;
  };
  var lastTouch = 0;
  handlers2.touchstart = (view, e2) => {
    lastTouch = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers2.touchmove = (view) => {
    view.inputState.setSelectionOrigin("select.pointer");
  };
  handlers2.mousedown = (view, event) => {
    view.observer.flush();
    if (lastTouch > Date.now() - 2e3 && getClickType(event) == 1)
      return;
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
      style = makeStyle(view, event);
      if (style)
        break;
    }
    if (!style && event.button == 0)
      style = basicMouseSelection(view, event);
    if (style) {
      let mustFocus = view.root.activeElement != view.contentDOM;
      if (mustFocus)
        view.observer.ignore(() => focusPreventScroll(view.contentDOM));
      view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    }
  };
  function rangeForClick(view, pos, bias, type2) {
    if (type2 == 1) {
      return EditorSelection.cursor(pos, bias);
    } else if (type2 == 2) {
      return groupAt(view.state, pos, bias);
    } else {
      let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
      let from = visual ? visual.posAtStart : line.from, to2 = visual ? visual.posAtEnd : line.to;
      if (to2 < view.state.doc.length && to2 == line.to)
        to2++;
      return EditorSelection.range(from, to2);
    }
  }
  var insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
  var inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
  function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
      return 1;
    let off = pos - line.posAtStart;
    if (off == 0)
      return 1;
    if (off == line.length)
      return -1;
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
      return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
      return 1;
    return before && insideY(y, before) ? -1 : 1;
  }
  function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
  }
  var BadMouseDetail = browser.ie && browser.ie_version <= 11;
  var lastMouseDown = null;
  var lastMouseDownCount = 0;
  var lastMouseDownTime = 0;
  function getClickType(event) {
    if (!BadMouseDetail)
      return event.detail;
    let last2 = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last2 || lastTime > Date.now() - 400 && Math.abs(last2.clientX - event.clientX) < 2 && Math.abs(last2.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
  }
  function basicMouseSelection(view, event) {
    let start2 = queryPos(view, event), type2 = getClickType(event);
    let startSel = view.state.selection;
    let last2 = start2, lastEvent = event;
    return {
      update(update3) {
        if (update3.docChanged) {
          if (start2)
            start2.pos = update3.changes.mapPos(start2.pos);
          startSel = startSel.map(update3.changes);
          lastEvent = null;
        }
      },
      get(event2, extend3, multiple) {
        let cur2;
        if (lastEvent && event2.clientX == lastEvent.clientX && event2.clientY == lastEvent.clientY)
          cur2 = last2;
        else {
          cur2 = last2 = queryPos(view, event2);
          lastEvent = event2;
        }
        if (!cur2 || !start2)
          return startSel;
        let range2 = rangeForClick(view, cur2.pos, cur2.bias, type2);
        if (start2.pos != cur2.pos && !extend3) {
          let startRange = rangeForClick(view, start2.pos, start2.bias, type2);
          let from = Math.min(startRange.from, range2.from), to2 = Math.max(startRange.to, range2.to);
          range2 = from < range2.from ? EditorSelection.range(from, to2) : EditorSelection.range(to2, from);
        }
        if (extend3)
          return startSel.replaceRange(startSel.main.extend(range2.from, range2.to));
        else if (multiple)
          return startSel.addRange(range2);
        else
          return EditorSelection.create([range2]);
      }
    };
  }
  handlers2.dragstart = (view, event) => {
    let { selection: { main } } = view.state;
    let { mouseSelection } = view.inputState;
    if (mouseSelection)
      mouseSelection.dragging = main;
    if (event.dataTransfer) {
      event.dataTransfer.setData("Text", view.state.sliceDoc(main.from, main.to));
      event.dataTransfer.effectAllowed = "copyMove";
    }
  };
  function dropText(view, event, text, direct) {
    if (!text)
      return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    event.preventDefault();
    let { mouseSelection } = view.inputState;
    let del2 = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del2 ? [del2, ins] : ins);
    view.focus();
    view.dispatch({
      changes,
      selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
      userEvent: del2 ? "move.drop" : "input.drop"
    });
  }
  handlers2.drop = (view, event) => {
    if (!event.dataTransfer)
      return;
    if (view.state.readOnly)
      return event.preventDefault();
    let files = event.dataTransfer.files;
    if (files && files.length) {
      event.preventDefault();
      let text = Array(files.length), read = 0;
      let finishFile = () => {
        if (++read == files.length)
          dropText(view, event, text.filter((s) => s != null).join(view.state.lineBreak), false);
      };
      for (let i2 = 0; i2 < files.length; i2++) {
        let reader = new FileReader();
        reader.onerror = finishFile;
        reader.onload = () => {
          if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
            text[i2] = reader.result;
          finishFile();
        };
        reader.readAsText(files[i2]);
      }
    } else {
      dropText(view, event, event.dataTransfer.getData("Text"), true);
    }
  };
  handlers2.paste = (view, event) => {
    if (view.state.readOnly)
      return event.preventDefault();
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      doPaste(view, data.getData("text/plain"));
      event.preventDefault();
    } else {
      capturePaste(view);
    }
  };
  function captureCopy(view, text) {
    let parent = view.dom.parentNode;
    if (!parent)
      return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
      target.remove();
      view.focus();
    }, 50);
  }
  function copiedRange(state3) {
    let content2 = [], ranges = [], linewise = false;
    for (let range2 of state3.selection.ranges)
      if (!range2.empty) {
        content2.push(state3.sliceDoc(range2.from, range2.to));
        ranges.push(range2);
      }
    if (!content2.length) {
      let upto = -1;
      for (let { from } of state3.selection.ranges) {
        let line = state3.doc.lineAt(from);
        if (line.number > upto) {
          content2.push(line.text);
          ranges.push({ from: line.from, to: Math.min(state3.doc.length, line.to + 1) });
        }
        upto = line.number;
      }
      linewise = true;
    }
    return { text: content2.join(state3.lineBreak), ranges, linewise };
  }
  var lastLinewiseCopy = null;
  handlers2.copy = handlers2.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
      return;
    lastLinewiseCopy = linewise ? text : null;
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
      event.preventDefault();
      data.clearData();
      data.setData("text/plain", text);
    } else {
      captureCopy(view, text);
    }
    if (event.type == "cut" && !view.state.readOnly)
      view.dispatch({
        changes: ranges,
        scrollIntoView: true,
        userEvent: "delete.cut"
      });
  };
  function updateForFocusChange(view) {
    setTimeout(() => {
      if (view.hasFocus != view.inputState.notifiedFocused)
        view.update([]);
    }, 10);
  }
  handlers2.focus = updateForFocusChange;
  handlers2.blur = (view) => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
  };
  function forceClearComposition(view, rapid) {
    if (view.docView.compositionDeco.size) {
      view.inputState.rapidCompositionStart = rapid;
      try {
        view.update([]);
      } finally {
        view.inputState.rapidCompositionStart = false;
      }
    }
  }
  handlers2.compositionstart = handlers2.compositionupdate = (view) => {
    if (view.inputState.compositionFirstChange == null)
      view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
      view.inputState.composing = 0;
      if (view.docView.compositionDeco.size) {
        view.observer.flush();
        forceClearComposition(view, true);
      }
    }
  };
  handlers2.compositionend = (view) => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionFirstChange = null;
    setTimeout(() => {
      if (view.inputState.composing < 0)
        forceClearComposition(view, false);
    }, 50);
  };
  handlers2.contextmenu = (view) => {
    view.inputState.lastContextMenu = Date.now();
  };
  handlers2.beforeinput = (view, event) => {
    var _a2;
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find((key2) => key2.inputType == event.inputType))) {
      view.observer.delayAndroidKey(pending.key, pending.keyCode);
      if (pending.key == "Backspace" || pending.key == "Delete") {
        let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
        setTimeout(() => {
          var _a3;
          if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
            view.contentDOM.blur();
            view.focus();
          }
        }, 100);
      }
    }
  };
  var wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
  var HeightOracle = class {
    constructor() {
      this.doc = Text.empty;
      this.lineWrapping = false;
      this.heightSamples = {};
      this.lineHeight = 14;
      this.charWidth = 7;
      this.lineLength = 30;
      this.heightChanged = false;
    }
    heightForGap(from, to2) {
      let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from).number + 1;
      if (this.lineWrapping)
        lines += Math.ceil((to2 - from - lines * this.lineLength * 0.5) / this.lineLength);
      return this.lineHeight * lines;
    }
    heightForLine(length) {
      if (!this.lineWrapping)
        return this.lineHeight;
      let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
      return lines * this.lineHeight;
    }
    setDoc(doc2) {
      this.doc = doc2;
      return this;
    }
    mustRefreshForWrapping(whiteSpace) {
      return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
      let newHeight = false;
      for (let i2 = 0; i2 < lineHeights.length; i2++) {
        let h = lineHeights[i2];
        if (h < 0) {
          i2++;
        } else if (!this.heightSamples[Math.floor(h * 10)]) {
          newHeight = true;
          this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
      let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
      let changed2 = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
      this.lineWrapping = lineWrapping;
      this.lineHeight = lineHeight;
      this.charWidth = charWidth;
      this.lineLength = lineLength;
      if (changed2) {
        this.heightSamples = {};
        for (let i2 = 0; i2 < knownHeights.length; i2++) {
          let h = knownHeights[i2];
          if (h < 0)
            i2++;
          else
            this.heightSamples[Math.floor(h * 10)] = true;
        }
      }
      return changed2;
    }
  };
  var MeasuredHeights = class {
    constructor(from, heights) {
      this.from = from;
      this.heights = heights;
      this.index = 0;
    }
    get more() {
      return this.index < this.heights.length;
    }
  };
  var BlockInfo = class {
    constructor(from, length, top2, height, type2) {
      this.from = from;
      this.length = length;
      this.top = top2;
      this.height = height;
      this.type = type2;
    }
    get to() {
      return this.from + this.length;
    }
    get bottom() {
      return this.top + this.height;
    }
    join(other) {
      let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
      return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
    }
  };
  var QueryType = /* @__PURE__ */ function(QueryType3) {
    QueryType3[QueryType3["ByPos"] = 0] = "ByPos";
    QueryType3[QueryType3["ByHeight"] = 1] = "ByHeight";
    QueryType3[QueryType3["ByPosNoHeight"] = 2] = "ByPosNoHeight";
    return QueryType3;
  }(QueryType || (QueryType = {}));
  var Epsilon = 1e-3;
  var HeightMap = class {
    constructor(length, height, flags = 2) {
      this.length = length;
      this.height = height;
      this.flags = flags;
    }
    get outdated() {
      return (this.flags & 2) > 0;
    }
    set outdated(value) {
      this.flags = (value ? 2 : 0) | this.flags & ~2;
    }
    setHeight(oracle, height) {
      if (this.height != height) {
        if (Math.abs(this.height - height) > Epsilon)
          oracle.heightChanged = true;
        this.height = height;
      }
    }
    replace(_from, _to, nodes) {
      return HeightMap.of(nodes);
    }
    decomposeLeft(_to, result) {
      result.push(this);
    }
    decomposeRight(_from, result) {
      result.push(this);
    }
    applyChanges(decorations2, oldDoc, oracle, changes) {
      let me = this;
      for (let i2 = changes.length - 1; i2 >= 0; i2--) {
        let { fromA, toA, fromB, toB } = changes[i2];
        let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        let end = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        toB += end.to - toA;
        toA = end.to;
        while (i2 > 0 && start2.from <= changes[i2 - 1].toA) {
          fromA = changes[i2 - 1].fromA;
          fromB = changes[i2 - 1].fromB;
          i2--;
          if (fromA < start2.from)
            start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
        }
        fromB += start2.from - fromA;
        fromA = start2.from;
        let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
        me = me.replace(fromA, toA, nodes);
      }
      return me.updateHeight(oracle, 0);
    }
    static empty() {
      return new HeightMapText(0, 0);
    }
    static of(nodes) {
      if (nodes.length == 1)
        return nodes[0];
      let i2 = 0, j = nodes.length, before = 0, after = 0;
      for (; ; ) {
        if (i2 == j) {
          if (before > after * 2) {
            let split = nodes[i2 - 1];
            if (split.break)
              nodes.splice(--i2, 1, split.left, null, split.right);
            else
              nodes.splice(--i2, 1, split.left, split.right);
            j += 1 + split.break;
            before -= split.size;
          } else if (after > before * 2) {
            let split = nodes[j];
            if (split.break)
              nodes.splice(j, 1, split.left, null, split.right);
            else
              nodes.splice(j, 1, split.left, split.right);
            j += 2 + split.break;
            after -= split.size;
          } else {
            break;
          }
        } else if (before < after) {
          let next = nodes[i2++];
          if (next)
            before += next.size;
        } else {
          let next = nodes[--j];
          if (next)
            after += next.size;
        }
      }
      let brk = 0;
      if (nodes[i2 - 1] == null) {
        brk = 1;
        i2--;
      } else if (nodes[i2] == null) {
        brk = 1;
        j++;
      }
      return new HeightMapBranch(HeightMap.of(nodes.slice(0, i2)), brk, HeightMap.of(nodes.slice(j)));
    }
  };
  HeightMap.prototype.size = 1;
  var HeightMapBlock = class extends HeightMap {
    constructor(length, height, type2) {
      super(length, height);
      this.type = type2;
    }
    blockAt(_height, _doc, top2, offset) {
      return new BlockInfo(offset, this.length, top2, this.height, this.type);
    }
    lineAt(_value, _type, doc2, top2, offset) {
      return this.blockAt(0, doc2, top2, offset);
    }
    forEachLine(from, to2, doc2, top2, offset, f) {
      if (from <= offset + this.length && to2 >= offset)
        f(this.blockAt(0, doc2, top2, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      this.outdated = false;
      return this;
    }
    toString() {
      return `block(${this.length})`;
    }
  };
  var HeightMapText = class extends HeightMapBlock {
    constructor(length, height) {
      super(length, height, BlockType.Text);
      this.collapsed = 0;
      this.widgetHeight = 0;
    }
    replace(_from, _to, nodes) {
      let node = nodes[0];
      if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
        if (node instanceof HeightMapGap)
          node = new HeightMapText(node.length, this.height);
        else
          node.height = this.height;
        if (!this.outdated)
          node.outdated = false;
        return node;
      } else {
        return HeightMap.of(nodes);
      }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      if (measured && measured.from <= offset && measured.more)
        this.setHeight(oracle, measured.heights[measured.index++]);
      else if (force || this.outdated)
        this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
      this.outdated = false;
      return this;
    }
    toString() {
      return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
  };
  var HeightMapGap = class extends HeightMap {
    constructor(length) {
      super(length, 0);
    }
    lines(doc2, offset) {
      let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
      return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
    }
    blockAt(height, doc2, top2, offset) {
      let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top2) / lineHeight)));
      let { from, length } = doc2.line(firstLine + line);
      return new BlockInfo(from, length, top2 + lineHeight * line, lineHeight, BlockType.Text);
    }
    lineAt(value, type2, doc2, top2, offset) {
      if (type2 == QueryType.ByHeight)
        return this.blockAt(value, doc2, top2, offset);
      if (type2 == QueryType.ByPosNoHeight) {
        let { from: from2, to: to2 } = doc2.lineAt(value);
        return new BlockInfo(from2, to2 - from2, 0, 0, BlockType.Text);
      }
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      let { from, length, number: number2 } = doc2.lineAt(value);
      return new BlockInfo(from, length, top2 + lineHeight * (number2 - firstLine), lineHeight, BlockType.Text);
    }
    forEachLine(from, to2, doc2, top2, offset, f) {
      let { firstLine, lineHeight } = this.lines(doc2, offset);
      for (let pos = Math.max(from, offset), end = Math.min(offset + this.length, to2); pos <= end; ) {
        let line = doc2.lineAt(pos);
        if (pos == from)
          top2 += lineHeight * (line.number - firstLine);
        f(new BlockInfo(line.from, line.length, top2, lineHeight, BlockType.Text));
        top2 += lineHeight;
        pos = line.to + 1;
      }
    }
    replace(from, to2, nodes) {
      let after = this.length - to2;
      if (after > 0) {
        let last2 = nodes[nodes.length - 1];
        if (last2 instanceof HeightMapGap)
          nodes[nodes.length - 1] = new HeightMapGap(last2.length + after);
        else
          nodes.push(null, new HeightMapGap(after - 1));
      }
      if (from > 0) {
        let first = nodes[0];
        if (first instanceof HeightMapGap)
          nodes[0] = new HeightMapGap(from + first.length);
        else
          nodes.unshift(new HeightMapGap(from - 1), null);
      }
      return HeightMap.of(nodes);
    }
    decomposeLeft(to2, result) {
      result.push(new HeightMapGap(to2 - 1), null);
    }
    decomposeRight(from, result) {
      result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let end = offset + this.length;
      if (measured && measured.from <= offset + this.length && measured.more) {
        let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
        let wasChanged = oracle.heightChanged;
        if (measured.from > offset)
          nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
        while (pos <= end && measured.more) {
          let len = oracle.doc.lineAt(pos).length;
          if (nodes.length)
            nodes.push(null);
          let height = measured.heights[measured.index++];
          if (singleHeight == -1)
            singleHeight = height;
          else if (Math.abs(height - singleHeight) >= Epsilon)
            singleHeight = -2;
          let line = new HeightMapText(len, height);
          line.outdated = false;
          nodes.push(line);
          pos += len + 1;
        }
        if (pos <= end)
          nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
        let result = HeightMap.of(nodes);
        oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
        return result;
      } else if (force || this.outdated) {
        this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
        this.outdated = false;
      }
      return this;
    }
    toString() {
      return `gap(${this.length})`;
    }
  };
  var HeightMapBranch = class extends HeightMap {
    constructor(left, brk, right) {
      super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
      this.left = left;
      this.right = right;
      this.size = left.size + right.size;
    }
    get break() {
      return this.flags & 1;
    }
    blockAt(height, doc2, top2, offset) {
      let mid = top2 + this.left.height;
      return height < mid ? this.left.blockAt(height, doc2, top2, offset) : this.right.blockAt(height, doc2, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type2, doc2, top2, offset) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      let left = type2 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
      let base2 = left ? this.left.lineAt(value, type2, doc2, top2, offset) : this.right.lineAt(value, type2, doc2, rightTop, rightOffset);
      if (this.break || (left ? base2.to < rightOffset : base2.from > rightOffset))
        return base2;
      let subQuery = type2 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
      if (left)
        return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
      else
        return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
    }
    forEachLine(from, to2, doc2, top2, offset, f) {
      let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
      if (this.break) {
        if (from < rightOffset)
          this.left.forEachLine(from, to2, doc2, top2, offset, f);
        if (to2 >= rightOffset)
          this.right.forEachLine(from, to2, doc2, rightTop, rightOffset, f);
      } else {
        let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
        if (from < mid.from)
          this.left.forEachLine(from, mid.from - 1, doc2, top2, offset, f);
        if (mid.to >= from && mid.from <= to2)
          f(mid);
        if (to2 > mid.to)
          this.right.forEachLine(mid.to + 1, to2, doc2, rightTop, rightOffset, f);
      }
    }
    replace(from, to2, nodes) {
      let rightStart = this.left.length + this.break;
      if (to2 < rightStart)
        return this.balanced(this.left.replace(from, to2, nodes), this.right);
      if (from > this.left.length)
        return this.balanced(this.left, this.right.replace(from - rightStart, to2 - rightStart, nodes));
      let result = [];
      if (from > 0)
        this.decomposeLeft(from, result);
      let left = result.length;
      for (let node of nodes)
        result.push(node);
      if (from > 0)
        mergeGaps(result, left - 1);
      if (to2 < this.length) {
        let right = result.length;
        this.decomposeRight(to2, result);
        mergeGaps(result, right);
      }
      return HeightMap.of(result);
    }
    decomposeLeft(to2, result) {
      let left = this.left.length;
      if (to2 <= left)
        return this.left.decomposeLeft(to2, result);
      result.push(this.left);
      if (this.break) {
        left++;
        if (to2 >= left)
          result.push(null);
      }
      if (to2 > left)
        this.right.decomposeLeft(to2 - left, result);
    }
    decomposeRight(from, result) {
      let left = this.left.length, right = left + this.break;
      if (from >= right)
        return this.right.decomposeRight(from - right, result);
      if (from < left)
        this.left.decomposeRight(from, result);
      if (this.break && from < right)
        result.push(null);
      result.push(this.right);
    }
    balanced(left, right) {
      if (left.size > 2 * right.size || right.size > 2 * left.size)
        return HeightMap.of(this.break ? [left, null, right] : [left, right]);
      this.left = left;
      this.right = right;
      this.height = left.height + right.height;
      this.outdated = left.outdated || right.outdated;
      this.size = left.size + right.size;
      this.length = left.length + this.break + right.length;
      return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
      let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
      if (measured && measured.from <= offset + left.length && measured.more)
        rebalance = left = left.updateHeight(oracle, offset, force, measured);
      else
        left.updateHeight(oracle, offset, force);
      if (measured && measured.from <= rightStart + right.length && measured.more)
        rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
      else
        right.updateHeight(oracle, rightStart, force);
      if (rebalance)
        return this.balanced(left, right);
      this.height = this.left.height + this.right.height;
      this.outdated = false;
      return this;
    }
    toString() {
      return this.left + (this.break ? " " : "-") + this.right;
    }
  };
  function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
      nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
  }
  var relevantWidgetHeight = 5;
  var NodeBuilder = class {
    constructor(pos, oracle) {
      this.pos = pos;
      this.oracle = oracle;
      this.nodes = [];
      this.lineStart = -1;
      this.lineEnd = -1;
      this.covering = null;
      this.writtenTo = pos;
    }
    get isCovered() {
      return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to2) {
      if (this.lineStart > -1) {
        let end = Math.min(to2, this.lineEnd), last2 = this.nodes[this.nodes.length - 1];
        if (last2 instanceof HeightMapText)
          last2.length += end - this.pos;
        else if (end > this.pos || !this.isCovered)
          this.nodes.push(new HeightMapText(end - this.pos, -1));
        this.writtenTo = end;
        if (to2 > end) {
          this.nodes.push(null);
          this.writtenTo++;
          this.lineStart = -1;
        }
      }
      this.pos = to2;
    }
    point(from, to2, deco) {
      if (from < to2 || deco.heightRelevant) {
        let height = deco.widget ? deco.widget.estimatedHeight : 0;
        if (height < 0)
          height = this.oracle.lineHeight;
        let len = to2 - from;
        if (deco.block) {
          this.addBlock(new HeightMapBlock(len, height, deco.type));
        } else if (len || height >= relevantWidgetHeight) {
          this.addLineDeco(height, len);
        }
      } else if (to2 > from) {
        this.span(from, to2);
      }
      if (this.lineEnd > -1 && this.lineEnd < this.pos)
        this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
      if (this.lineStart > -1)
        return;
      let { from, to: to2 } = this.oracle.doc.lineAt(this.pos);
      this.lineStart = from;
      this.lineEnd = to2;
      if (this.writtenTo < from) {
        if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
          this.nodes.push(this.blankContent(this.writtenTo, from - 1));
        this.nodes.push(null);
      }
      if (this.pos > from)
        this.nodes.push(new HeightMapText(this.pos - from, -1));
      this.writtenTo = this.pos;
    }
    blankContent(from, to2) {
      let gap = new HeightMapGap(to2 - from);
      if (this.oracle.doc.lineAt(from).to == to2)
        gap.flags |= 4;
      return gap;
    }
    ensureLine() {
      this.enterLine();
      let last2 = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
      if (last2 instanceof HeightMapText)
        return last2;
      let line = new HeightMapText(0, -1);
      this.nodes.push(line);
      return line;
    }
    addBlock(block) {
      this.enterLine();
      if (block.type == BlockType.WidgetAfter && !this.isCovered)
        this.ensureLine();
      this.nodes.push(block);
      this.writtenTo = this.pos = this.pos + block.length;
      if (block.type != BlockType.WidgetBefore)
        this.covering = block;
    }
    addLineDeco(height, length) {
      let line = this.ensureLine();
      line.length += length;
      line.collapsed += length;
      line.widgetHeight = Math.max(line.widgetHeight, height);
      this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
      let last2 = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
      if (this.lineStart > -1 && !(last2 instanceof HeightMapText) && !this.isCovered)
        this.nodes.push(new HeightMapText(0, -1));
      else if (this.writtenTo < this.pos || last2 == null)
        this.nodes.push(this.blankContent(this.writtenTo, this.pos));
      let pos = from;
      for (let node of this.nodes) {
        if (node instanceof HeightMapText)
          node.updateHeight(this.oracle, pos);
        pos += node ? node.length : 1;
      }
      return this.nodes;
    }
    static build(oracle, decorations2, from, to2) {
      let builder = new NodeBuilder(from, oracle);
      RangeSet.spans(decorations2, from, to2, builder, 0);
      return builder.finish(from);
    }
  };
  function heightRelevantDecoChanges(a2, b2, diff) {
    let comp = new DecorationComparator();
    RangeSet.compare(a2, b2, diff, comp, 0);
    return comp.changes;
  }
  var DecorationComparator = class {
    constructor() {
      this.changes = [];
    }
    compareRange() {
    }
    comparePoint(from, to2, a2, b2) {
      if (from < to2 || a2 && a2.heightRelevant || b2 && b2.heightRelevant)
        addRange(from, to2, this.changes, 5);
    }
  };
  function visiblePixelRange(dom2, paddingTop) {
    let rect = dom2.getBoundingClientRect();
    let left = Math.max(0, rect.left), right = Math.min(innerWidth, rect.right);
    let top2 = Math.max(0, rect.top), bottom = Math.min(innerHeight, rect.bottom);
    let body = dom2.ownerDocument.body;
    for (let parent = dom2.parentNode; parent && parent != body; ) {
      if (parent.nodeType == 1) {
        let elt = parent;
        let style = window.getComputedStyle(elt);
        if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
          let parentRect = elt.getBoundingClientRect();
          left = Math.max(left, parentRect.left);
          right = Math.min(right, parentRect.right);
          top2 = Math.max(top2, parentRect.top);
          bottom = Math.min(bottom, parentRect.bottom);
        }
        parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
      } else if (parent.nodeType == 11) {
        parent = parent.host;
      } else {
        break;
      }
    }
    return {
      left: left - rect.left,
      right: Math.max(left, right) - rect.left,
      top: top2 - (rect.top + paddingTop),
      bottom: Math.max(top2, bottom) - (rect.top + paddingTop)
    };
  }
  function fullPixelRange(dom2, paddingTop) {
    let rect = dom2.getBoundingClientRect();
    return {
      left: 0,
      right: rect.right - rect.left,
      top: paddingTop,
      bottom: rect.bottom - (rect.top + paddingTop)
    };
  }
  var LineGap = class {
    constructor(from, to2, size2) {
      this.from = from;
      this.to = to2;
      this.size = size2;
    }
    static same(a2, b2) {
      if (a2.length != b2.length)
        return false;
      for (let i2 = 0; i2 < a2.length; i2++) {
        let gA = a2[i2], gB = b2[i2];
        if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
          return false;
      }
      return true;
    }
    draw(wrapping) {
      return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
    }
  };
  var LineGapWidget = class extends WidgetType {
    constructor(size2, vertical) {
      super();
      this.size = size2;
      this.vertical = vertical;
    }
    eq(other) {
      return other.size == this.size && other.vertical == this.vertical;
    }
    toDOM() {
      let elt = document.createElement("div");
      if (this.vertical) {
        elt.style.height = this.size + "px";
      } else {
        elt.style.width = this.size + "px";
        elt.style.height = "2px";
        elt.style.display = "inline-block";
      }
      return elt;
    }
    get estimatedHeight() {
      return this.vertical ? this.size : -1;
    }
  };
  var ViewState = class {
    constructor(state3) {
      this.state = state3;
      this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
      this.inView = true;
      this.paddingTop = 0;
      this.paddingBottom = 0;
      this.contentDOMWidth = 0;
      this.contentDOMHeight = 0;
      this.editorHeight = 0;
      this.editorWidth = 0;
      this.heightOracle = new HeightOracle();
      this.scaler = IdScaler;
      this.scrollTarget = null;
      this.printing = false;
      this.mustMeasureContent = true;
      this.defaultTextDirection = Direction.RTL;
      this.visibleRanges = [];
      this.mustEnforceCursorAssoc = false;
      this.stateDeco = state3.facet(decorations).filter((d2) => typeof d2 != "function");
      this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state3.doc), [new ChangedRange(0, 0, 0, state3.doc.length)]);
      this.viewport = this.getViewport(0, null);
      this.updateViewportLines();
      this.updateForViewport();
      this.lineGaps = this.ensureLineGaps([]);
      this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
      this.computeVisibleRanges();
    }
    updateForViewport() {
      let viewports = [this.viewport], { main } = this.state.selection;
      for (let i2 = 0; i2 <= 1; i2++) {
        let pos = i2 ? main.head : main.anchor;
        if (!viewports.some(({ from, to: to2 }) => pos >= from && pos <= to2)) {
          let { from, to: to2 } = this.lineBlockAt(pos);
          viewports.push(new Viewport(from, to2));
        }
      }
      this.viewports = viewports.sort((a2, b2) => a2.from - b2.from);
      this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
    }
    updateViewportLines() {
      this.viewportLines = [];
      this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
        this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
      });
    }
    update(update3, scrollTarget = null) {
      this.state = update3.state;
      let prevDeco = this.stateDeco;
      this.stateDeco = this.state.facet(decorations).filter((d2) => typeof d2 != "function");
      let contentChanges = update3.changedRanges;
      let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update3 ? update3.changes : ChangeSet.empty(this.state.doc.length)));
      let prevHeight = this.heightMap.height;
      this.heightMap = this.heightMap.applyChanges(this.stateDeco, update3.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
      if (this.heightMap.height != prevHeight)
        update3.flags |= 2;
      let viewport = heightChanges.length ? this.mapViewport(this.viewport, update3.changes) : this.viewport;
      if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
        viewport = this.getViewport(0, scrollTarget);
      let updateLines = !update3.changes.empty || update3.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
      this.viewport = viewport;
      this.updateForViewport();
      if (updateLines)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
        this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update3.changes)));
      update3.flags |= this.computeVisibleRanges();
      if (scrollTarget)
        this.scrollTarget = scrollTarget;
      if (!this.mustEnforceCursorAssoc && update3.selectionSet && update3.view.lineWrapping && update3.state.selection.main.empty && update3.state.selection.main.assoc)
        this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
      let dom2 = view.contentDOM, style = window.getComputedStyle(dom2);
      let oracle = this.heightOracle;
      let whiteSpace = style.whiteSpace;
      this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
      let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
      let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom2.clientHeight;
      this.contentDOMHeight = dom2.clientHeight;
      this.mustMeasureContent = false;
      let result = 0, bias = 0;
      let paddingTop = parseInt(style.paddingTop) || 0, paddingBottom = parseInt(style.paddingBottom) || 0;
      if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
        this.paddingTop = paddingTop;
        this.paddingBottom = paddingBottom;
        result |= 8 | 2;
      }
      if (this.editorWidth != view.scrollDOM.clientWidth) {
        if (oracle.lineWrapping)
          measureContent = true;
        this.editorWidth = view.scrollDOM.clientWidth;
        result |= 8;
      }
      let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom2, this.paddingTop);
      let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
      this.pixelViewport = pixelViewport;
      let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
      if (inView != this.inView) {
        this.inView = inView;
        if (inView)
          measureContent = true;
      }
      if (!this.inView)
        return 0;
      let contentWidth = dom2.clientWidth;
      if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
        this.contentDOMWidth = contentWidth;
        this.editorHeight = view.scrollDOM.clientHeight;
        result |= 8;
      }
      if (measureContent) {
        let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
        if (oracle.mustRefreshForHeights(lineHeights))
          refresh = true;
        if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
          let { lineHeight, charWidth } = view.docView.measureTextSize();
          refresh = oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
          if (refresh) {
            view.docView.minWidth = 0;
            result |= 8;
          }
        }
        if (dTop > 0 && dBottom > 0)
          bias = Math.max(dTop, dBottom);
        else if (dTop < 0 && dBottom < 0)
          bias = Math.min(dTop, dBottom);
        oracle.heightChanged = false;
        for (let vp of this.viewports) {
          let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
          this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
        }
        if (oracle.heightChanged)
          result |= 2;
      }
      let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
      if (viewportChange)
        this.viewport = this.getViewport(bias, this.scrollTarget);
      this.updateForViewport();
      if (result & 2 || viewportChange)
        this.updateViewportLines();
      if (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3)
        this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps));
      result |= this.computeVisibleRanges();
      if (this.mustEnforceCursorAssoc) {
        this.mustEnforceCursorAssoc = false;
        view.docView.enforceCursorAssoc();
      }
      return result;
    }
    get visibleTop() {
      return this.scaler.fromDOM(this.pixelViewport.top);
    }
    get visibleBottom() {
      return this.scaler.fromDOM(this.pixelViewport.bottom);
    }
    getViewport(bias, scrollTarget) {
      let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
      let map = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
      let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
      if (scrollTarget) {
        let { head } = scrollTarget.range;
        if (head < viewport.from || head > viewport.to) {
          let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
          let block = map.lineAt(head, QueryType.ByPos, doc2, 0, 0), topPos;
          if (scrollTarget.y == "center")
            topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
          else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
            topPos = block.top;
          else
            topPos = block.bottom - viewHeight;
          viewport = new Viewport(map.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
        }
      }
      return viewport;
    }
    mapViewport(viewport, changes) {
      let from = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
      return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to2, QueryType.ByPos, this.state.doc, 0, 0).to);
    }
    viewportIsAppropriate({ from, to: to2 }, bias = 0) {
      if (!this.inView)
        return true;
      let { top: top2 } = this.heightMap.lineAt(from, QueryType.ByPos, this.state.doc, 0, 0);
      let { bottom } = this.heightMap.lineAt(to2, QueryType.ByPos, this.state.doc, 0, 0);
      let { visibleTop, visibleBottom } = this;
      return (from == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to2 == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom < visibleBottom + 2 * 1e3);
    }
    mapLineGaps(gaps, changes) {
      if (!gaps.length || changes.empty)
        return gaps;
      let mapped = [];
      for (let gap of gaps)
        if (!changes.touchesRange(gap.from, gap.to))
          mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
      return mapped;
    }
    ensureLineGaps(current) {
      let gaps = [];
      if (this.defaultTextDirection != Direction.LTR)
        return gaps;
      for (let line of this.viewportLines) {
        if (line.length < 4e3)
          continue;
        let structure = lineStructure(line.from, line.to, this.stateDeco);
        if (structure.total < 4e3)
          continue;
        let viewFrom, viewTo;
        if (this.heightOracle.lineWrapping) {
          let marginHeight = 2e3 / this.heightOracle.lineLength * this.heightOracle.lineHeight;
          viewFrom = findPosition(structure, (this.visibleTop - line.top - marginHeight) / line.height);
          viewTo = findPosition(structure, (this.visibleBottom - line.top + marginHeight) / line.height);
        } else {
          let totalWidth = structure.total * this.heightOracle.charWidth;
          let marginWidth = 2e3 * this.heightOracle.charWidth;
          viewFrom = findPosition(structure, (this.pixelViewport.left - marginWidth) / totalWidth);
          viewTo = findPosition(structure, (this.pixelViewport.right + marginWidth) / totalWidth);
        }
        let outside = [];
        if (viewFrom > line.from)
          outside.push({ from: line.from, to: viewFrom });
        if (viewTo < line.to)
          outside.push({ from: viewTo, to: line.to });
        let sel = this.state.selection.main;
        if (sel.from >= line.from && sel.from <= line.to)
          cutRange(outside, sel.from - 10, sel.from + 10);
        if (!sel.empty && sel.to >= line.from && sel.to <= line.to)
          cutRange(outside, sel.to - 10, sel.to + 10);
        for (let { from, to: to2 } of outside)
          if (to2 - from > 1e3) {
            gaps.push(find(current, (gap) => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < 1e3 && Math.abs(gap.to - to2) < 1e3) || new LineGap(from, to2, this.gapSize(line, from, to2, structure)));
          }
      }
      return gaps;
    }
    gapSize(line, from, to2, structure) {
      let fraction = findFraction(structure, to2) - findFraction(structure, from);
      if (this.heightOracle.lineWrapping) {
        return line.height * fraction;
      } else {
        return structure.total * this.heightOracle.charWidth * fraction;
      }
    }
    updateLineGaps(gaps) {
      if (!LineGap.same(gaps, this.lineGaps)) {
        this.lineGaps = gaps;
        this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
      }
    }
    computeVisibleRanges() {
      let deco = this.stateDeco;
      if (this.lineGaps.length)
        deco = deco.concat(this.lineGapDeco);
      let ranges = [];
      RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
        span(from, to2) {
          ranges.push({ from, to: to2 });
        },
        point() {
        }
      }, 20);
      let changed2 = ranges.length != this.visibleRanges.length || this.visibleRanges.some((r, i2) => r.from != ranges[i2].from || r.to != ranges[i2].to);
      this.visibleRanges = ranges;
      return changed2 ? 4 : 0;
    }
    lineBlockAt(pos) {
      return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b2) => b2.from <= pos && b2.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
      return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
    }
    elementAtHeight(height) {
      return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.state.doc, 0, 0), this.scaler);
    }
    get docHeight() {
      return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
      return this.docHeight + this.paddingTop + this.paddingBottom;
    }
  };
  var Viewport = class {
    constructor(from, to2) {
      this.from = from;
      this.to = to2;
    }
  };
  function lineStructure(from, to2, stateDeco) {
    let ranges = [], pos = from, total = 0;
    RangeSet.spans(stateDeco, from, to2, {
      span() {
      },
      point(from2, to3) {
        if (from2 > pos) {
          ranges.push({ from: pos, to: from2 });
          total += from2 - pos;
        }
        pos = to3;
      }
    }, 20);
    if (pos < to2) {
      ranges.push({ from: pos, to: to2 });
      total += to2 - pos;
    }
    return { total, ranges };
  }
  function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
      return ranges[0].from;
    if (ratio >= 1)
      return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i2 = 0; ; i2++) {
      let { from, to: to2 } = ranges[i2], size2 = to2 - from;
      if (dist <= size2)
        return from + dist;
      dist -= size2;
    }
  }
  function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to: to2 } of structure.ranges) {
      if (pos <= to2) {
        counted += pos - from;
        break;
      }
      counted += to2 - from;
    }
    return counted / structure.total;
  }
  function cutRange(ranges, from, to2) {
    for (let i2 = 0; i2 < ranges.length; i2++) {
      let r = ranges[i2];
      if (r.from < to2 && r.to > from) {
        let pieces = [];
        if (r.from < from)
          pieces.push({ from: r.from, to: from });
        if (r.to > to2)
          pieces.push({ from: to2, to: r.to });
        ranges.splice(i2, 1, ...pieces);
        i2 += pieces.length - 1;
      }
    }
  }
  function find(array, f) {
    for (let val of array)
      if (f(val))
        return val;
    return void 0;
  }
  var IdScaler = {
    toDOM(n2) {
      return n2;
    },
    fromDOM(n2) {
      return n2;
    },
    scale: 1
  };
  var BigScaler = class {
    constructor(doc2, heightMap, viewports) {
      let vpHeight = 0, base2 = 0, domBase = 0;
      this.viewports = viewports.map(({ from, to: to2 }) => {
        let top2 = heightMap.lineAt(from, QueryType.ByPos, doc2, 0, 0).top;
        let bottom = heightMap.lineAt(to2, QueryType.ByPos, doc2, 0, 0).bottom;
        vpHeight += bottom - top2;
        return { from, to: to2, top: top2, bottom, domTop: 0, domBottom: 0 };
      });
      this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
      for (let obj of this.viewports) {
        obj.domTop = domBase + (obj.top - base2) * this.scale;
        domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
        base2 = obj.bottom;
      }
    }
    toDOM(n2) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n2 < vp.top)
          return domBase + (n2 - base2) * this.scale;
        if (n2 <= vp.bottom)
          return vp.domTop + (n2 - vp.top);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
    fromDOM(n2) {
      for (let i2 = 0, base2 = 0, domBase = 0; ; i2++) {
        let vp = i2 < this.viewports.length ? this.viewports[i2] : null;
        if (!vp || n2 < vp.domTop)
          return base2 + (n2 - domBase) / this.scale;
        if (n2 <= vp.domBottom)
          return vp.top + (n2 - vp.domTop);
        base2 = vp.bottom;
        domBase = vp.domBottom;
      }
    }
  };
  function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
      return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b2) => scaleBlock(b2, scaler)) : block.type);
  }
  var theme = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
  var darkTheme = /* @__PURE__ */ Facet.define({ combine: (values) => values.indexOf(true) > -1 });
  var baseThemeID = /* @__PURE__ */ StyleModule.newName();
  var baseLightID = /* @__PURE__ */ StyleModule.newName();
  var baseDarkID = /* @__PURE__ */ StyleModule.newName();
  var lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
  function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
      finish(sel) {
        return /&/.test(sel) ? sel.replace(/&\w*/, (m3) => {
          if (m3 == "&")
            return main;
          if (!scopes || !scopes[m3])
            throw new RangeError(`Unsupported selector: ${m3}`);
          return scopes[m3];
        }) : main + " " + sel;
      }
    });
  }
  var baseTheme$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
    "&.cm-editor": {
      position: "relative !important",
      boxSizing: "border-box",
      "&.cm-focused": {
        outline: "1px dotted #212121"
      },
      display: "flex !important",
      flexDirection: "column"
    },
    ".cm-scroller": {
      display: "flex !important",
      alignItems: "flex-start !important",
      fontFamily: "monospace",
      lineHeight: 1.4,
      height: "100%",
      overflowX: "auto",
      position: "relative",
      zIndex: 0
    },
    ".cm-content": {
      margin: 0,
      flexGrow: 2,
      minHeight: "100%",
      display: "block",
      whiteSpace: "pre",
      wordWrap: "normal",
      boxSizing: "border-box",
      padding: "4px 0",
      outline: "none",
      "&[contenteditable=true]": {
        WebkitUserModify: "read-write-plaintext-only"
      }
    },
    ".cm-lineWrapping": {
      whiteSpace_fallback: "pre-wrap",
      whiteSpace: "break-spaces",
      wordBreak: "break-word",
      overflowWrap: "anywhere"
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
      display: "block",
      padding: "0 2px 0 4px"
    },
    ".cm-selectionLayer": {
      zIndex: -1,
      contain: "size style"
    },
    ".cm-selectionBackground": {
      position: "absolute"
    },
    "&light .cm-selectionBackground": {
      background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
      background: "#222"
    },
    "&light.cm-focused .cm-selectionBackground": {
      background: "#d7d4f0"
    },
    "&dark.cm-focused .cm-selectionBackground": {
      background: "#233"
    },
    ".cm-cursorLayer": {
      zIndex: 100,
      contain: "size style",
      pointerEvents: "none"
    },
    "&.cm-focused .cm-cursorLayer": {
      animation: "steps(1) cm-blink 1.2s infinite"
    },
    "@keyframes cm-blink": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { visibility: "hidden" }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
      position: "absolute",
      borderLeft: "1.2px solid black",
      marginLeft: "-0.6px",
      pointerEvents: "none"
    },
    ".cm-cursor": {
      display: "none"
    },
    "&dark .cm-cursor": {
      borderLeftColor: "#444"
    },
    "&.cm-focused .cm-cursor": {
      display: "block"
    },
    "&light .cm-activeLine": { backgroundColor: "#f3f9ff" },
    "&dark .cm-activeLine": { backgroundColor: "#223039" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
      display: "flex",
      height: "100%",
      boxSizing: "border-box",
      left: 0,
      zIndex: 200
    },
    "&light .cm-gutters": {
      backgroundColor: "#f5f5f5",
      color: "#6c6c6c",
      borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
      backgroundColor: "#333338",
      color: "#ccc"
    },
    ".cm-gutter": {
      display: "flex !important",
      flexDirection: "column",
      flexShrink: 0,
      boxSizing: "border-box",
      minHeight: "100%",
      overflow: "hidden"
    },
    ".cm-gutterElement": {
      boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
      padding: "0 3px 0 5px",
      minWidth: "20px",
      textAlign: "right",
      whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
      backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
      backgroundColor: "#222227"
    },
    ".cm-panels": {
      boxSizing: "border-box",
      position: "sticky",
      left: 0,
      right: 0
    },
    "&light .cm-panels": {
      backgroundColor: "#f5f5f5",
      color: "black"
    },
    "&light .cm-panels-top": {
      borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
      borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tab": {
      display: "inline-block",
      overflow: "hidden",
      verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
      verticalAlign: "text-top",
      height: "1em",
      display: "inline"
    },
    ".cm-placeholder": {
      color: "#888",
      display: "inline-block",
      verticalAlign: "top"
    },
    ".cm-button": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      padding: ".2em 1em",
      borderRadius: "1px"
    },
    "&light .cm-button": {
      backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
      }
    },
    "&dark .cm-button": {
      backgroundImage: "linear-gradient(#393939, #111)",
      border: "1px solid #888",
      "&:active": {
        backgroundImage: "linear-gradient(#111, #333)"
      }
    },
    ".cm-textfield": {
      verticalAlign: "middle",
      color: "inherit",
      fontSize: "70%",
      border: "1px solid silver",
      padding: ".2em .5em"
    },
    "&light .cm-textfield": {
      backgroundColor: "white"
    },
    "&dark .cm-textfield": {
      border: "1px solid #555",
      backgroundColor: "inherit"
    }
  }, lightDarkIDs);
  var observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
  };
  var useCharData = browser.ie && browser.ie_version <= 11;
  var DOMObserver = class {
    constructor(view, onChange, onScrollChanged) {
      this.view = view;
      this.onChange = onChange;
      this.onScrollChanged = onScrollChanged;
      this.active = false;
      this.selectionRange = new DOMSelectionState();
      this.selectionChanged = false;
      this.delayedFlush = -1;
      this.resizeTimeout = -1;
      this.queue = [];
      this.delayedAndroidKey = null;
      this.scrollTargets = [];
      this.intersection = null;
      this.resize = null;
      this.intersecting = false;
      this.gapIntersection = null;
      this.gaps = [];
      this.parentCheck = -1;
      this.dom = view.contentDOM;
      this.observer = new MutationObserver((mutations) => {
        for (let mut of mutations)
          this.queue.push(mut);
        if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m3) => m3.type == "childList" && m3.removedNodes.length || m3.type == "characterData" && m3.oldValue.length > m3.target.nodeValue.length))
          this.flushSoon();
        else
          this.flush();
      });
      if (useCharData)
        this.onCharData = (event) => {
          this.queue.push({
            target: event.target,
            type: "characterData",
            oldValue: event.prevValue
          });
          this.flushSoon();
        };
      this.onSelectionChange = this.onSelectionChange.bind(this);
      window.addEventListener("resize", this.onResize = this.onResize.bind(this));
      if (typeof ResizeObserver == "function") {
        this.resize = new ResizeObserver(() => {
          if (this.view.docView.lastUpdate < Date.now() - 75)
            this.onResize();
        });
        this.resize.observe(view.scrollDOM);
      }
      window.addEventListener("beforeprint", this.onPrint = this.onPrint.bind(this));
      this.start();
      window.addEventListener("scroll", this.onScroll = this.onScroll.bind(this));
      if (typeof IntersectionObserver == "function") {
        this.intersection = new IntersectionObserver((entries) => {
          if (this.parentCheck < 0)
            this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
            this.intersecting = !this.intersecting;
            if (this.intersecting != this.view.inView)
              this.onScrollChanged(document.createEvent("Event"));
          }
        }, {});
        this.intersection.observe(this.dom);
        this.gapIntersection = new IntersectionObserver((entries) => {
          if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
            this.onScrollChanged(document.createEvent("Event"));
        }, {});
      }
      this.listenForScroll();
      this.readSelectionRange();
      this.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
    onScroll(e2) {
      if (this.intersecting)
        this.flush(false);
      this.onScrollChanged(e2);
    }
    onResize() {
      if (this.resizeTimeout < 0)
        this.resizeTimeout = setTimeout(() => {
          this.resizeTimeout = -1;
          this.view.requestMeasure();
        }, 50);
    }
    onPrint() {
      this.view.viewState.printing = true;
      this.view.measure();
      setTimeout(() => {
        this.view.viewState.printing = false;
        this.view.requestMeasure();
      }, 500);
    }
    updateGaps(gaps) {
      if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g2, i2) => g2 != gaps[i2]))) {
        this.gapIntersection.disconnect();
        for (let gap of gaps)
          this.gapIntersection.observe(gap);
        this.gaps = gaps;
      }
    }
    onSelectionChange(event) {
      if (!this.readSelectionRange() || this.delayedAndroidKey)
        return;
      let { view } = this, sel = this.selectionRange;
      if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
        return;
      let context2 = sel.anchorNode && view.docView.nearest(sel.anchorNode);
      if (context2 && context2.ignoreEvent(event))
        return;
      if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        this.flushSoon();
      else
        this.flush(false);
    }
    readSelectionRange() {
      let { root } = this.view, domSel = getSelection(root);
      let range2 = browser.safari && root.nodeType == 11 && deepActiveElement() == this.view.contentDOM && safariSelectionRangeHack(this.view) || domSel;
      if (this.selectionRange.eq(range2))
        return false;
      this.selectionRange.setRange(range2);
      return this.selectionChanged = true;
    }
    setSelectionRange(anchor, head) {
      this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
      this.selectionChanged = false;
    }
    clearSelectionRange() {
      this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
      this.parentCheck = -1;
      let i2 = 0, changed2 = null;
      for (let dom2 = this.dom; dom2; ) {
        if (dom2.nodeType == 1) {
          if (!changed2 && i2 < this.scrollTargets.length && this.scrollTargets[i2] == dom2)
            i2++;
          else if (!changed2)
            changed2 = this.scrollTargets.slice(0, i2);
          if (changed2)
            changed2.push(dom2);
          dom2 = dom2.assignedSlot || dom2.parentNode;
        } else if (dom2.nodeType == 11) {
          dom2 = dom2.host;
        } else {
          break;
        }
      }
      if (i2 < this.scrollTargets.length && !changed2)
        changed2 = this.scrollTargets.slice(0, i2);
      if (changed2) {
        for (let dom2 of this.scrollTargets)
          dom2.removeEventListener("scroll", this.onScroll);
        for (let dom2 of this.scrollTargets = changed2)
          dom2.addEventListener("scroll", this.onScroll);
      }
    }
    ignore(f) {
      if (!this.active)
        return f();
      try {
        this.stop();
        return f();
      } finally {
        this.start();
        this.clear();
      }
    }
    start() {
      if (this.active)
        return;
      this.observer.observe(this.dom, observeOptions);
      if (useCharData)
        this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.active = true;
    }
    stop() {
      if (!this.active)
        return;
      this.active = false;
      this.observer.disconnect();
      if (useCharData)
        this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    clear() {
      this.processRecords();
      this.queue.length = 0;
      this.selectionChanged = false;
    }
    delayAndroidKey(key2, keyCode) {
      if (!this.delayedAndroidKey)
        requestAnimationFrame(() => {
          let key3 = this.delayedAndroidKey;
          this.delayedAndroidKey = null;
          this.delayedFlush = -1;
          if (!this.flush())
            dispatchKey(this.view.contentDOM, key3.key, key3.keyCode);
        });
      if (!this.delayedAndroidKey || key2 == "Enter")
        this.delayedAndroidKey = { key: key2, keyCode };
    }
    flushSoon() {
      if (this.delayedFlush < 0)
        this.delayedFlush = window.setTimeout(() => {
          this.delayedFlush = -1;
          this.flush();
        }, 20);
    }
    forceFlush() {
      if (this.delayedFlush >= 0) {
        window.clearTimeout(this.delayedFlush);
        this.delayedFlush = -1;
        this.flush();
      }
    }
    processRecords() {
      let records = this.queue;
      for (let mut of this.observer.takeRecords())
        records.push(mut);
      if (records.length)
        this.queue = [];
      let from = -1, to2 = -1, typeOver = false;
      for (let record of records) {
        let range2 = this.readMutation(record);
        if (!range2)
          continue;
        if (range2.typeOver)
          typeOver = true;
        if (from == -1) {
          ({ from, to: to2 } = range2);
        } else {
          from = Math.min(range2.from, from);
          to2 = Math.max(range2.to, to2);
        }
      }
      return { from, to: to2, typeOver };
    }
    flush(readSelection = true) {
      if (this.delayedFlush >= 0 || this.delayedAndroidKey)
        return;
      if (readSelection)
        this.readSelectionRange();
      let { from, to: to2, typeOver } = this.processRecords();
      let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
      if (from < 0 && !newSel)
        return;
      this.selectionChanged = false;
      let startState = this.view.state;
      let handled = this.onChange(from, to2, typeOver);
      if (this.view.state == startState)
        this.view.update([]);
      return handled;
    }
    readMutation(rec) {
      let cView = this.view.docView.nearest(rec.target);
      if (!cView || cView.ignoreMutation(rec))
        return null;
      cView.markDirty(rec.type == "attributes");
      if (rec.type == "attributes")
        cView.dirty |= 4;
      if (rec.type == "childList") {
        let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
        let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
        return {
          from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
          to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
          typeOver: false
        };
      } else if (rec.type == "characterData") {
        return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
      } else {
        return null;
      }
    }
    destroy() {
      var _a2, _b, _c;
      this.stop();
      (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
      (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
      (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
      for (let dom2 of this.scrollTargets)
        dom2.removeEventListener("scroll", this.onScroll);
      window.removeEventListener("scroll", this.onScroll);
      window.removeEventListener("resize", this.onResize);
      window.removeEventListener("beforeprint", this.onPrint);
      this.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      clearTimeout(this.parentCheck);
      clearTimeout(this.resizeTimeout);
    }
  };
  function findChild(cView, dom2, dir) {
    while (dom2) {
      let curView = ContentView.get(dom2);
      if (curView && curView.parent == cView)
        return curView;
      let parent = dom2.parentNode;
      dom2 = parent != cView.dom ? parent : dir > 0 ? dom2.nextSibling : dom2.previousSibling;
    }
    return null;
  }
  function safariSelectionRangeHack(view) {
    let found = null;
    function read(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
      found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    document.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
      return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
  }
  function applyDOMChange(view, start2, end, typeOver) {
    let change, newSel;
    let sel = view.state.selection.main;
    if (start2 > -1) {
      let bounds = view.docView.domBoundsAround(start2, end, 0);
      if (!bounds || view.state.readOnly)
        return false;
      let { from, to: to2 } = bounds;
      let selPoints = view.docView.impreciseHead || view.docView.impreciseAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(bounds.startDOM, bounds.endDOM);
      let preferredPos = sel.from, preferredSide = null;
      if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && reader.text.length < to2 - from) {
        preferredPos = sel.to;
        preferredSide = "end";
      }
      let diff = findDiff(view.state.doc.sliceString(from, to2, LineBreakPlaceholder), reader.text, preferredPos - from, preferredSide);
      if (diff) {
        if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && reader.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
          diff.toB--;
        change = {
          from: from + diff.from,
          to: from + diff.toA,
          insert: Text.of(reader.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
        };
      }
      newSel = selectionFromPoints(selPoints, from);
    } else if (view.hasFocus || !view.state.facet(editable)) {
      let domSel = view.observer.selectionRange;
      let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      if (head != sel.head || anchor != sel.anchor)
        newSel = EditorSelection.single(anchor, head);
    }
    if (!change && !newSel)
      return false;
    if (!change && typeOver && !sel.empty && newSel && newSel.main.empty)
      change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4)
      change = {
        from: sel.from,
        to: sel.to,
        insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
      };
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && change.insert.toString() == ".")
      change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    if (change) {
      let startState = view.state;
      if (browser.ios && view.inputState.flushIOSKey(view))
        return true;
      if (browser.android && (change.from == sel.from && change.to == sel.to && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
        return true;
      let text = change.insert.toString();
      if (view.state.facet(inputHandler).some((h) => h(view, change.from, change.to, text)))
        return true;
      if (view.inputState.composing >= 0)
        view.inputState.composing++;
      let tr;
      if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, void 0, view.state.lineBreak) + after));
      } else {
        let changes = startState.changes(change);
        let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
          let replaced = view.state.sliceDoc(change.from, change.to);
          let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
          let offset = sel.to - change.to, size2 = sel.to - sel.from;
          tr = startState.changeByRange((range2) => {
            if (range2.from == sel.from && range2.to == sel.to)
              return { changes, range: mainSel || range2.map(changes) };
            let to2 = range2.to - offset, from = to2 - replaced.length;
            if (range2.to - range2.from != size2 || view.state.sliceDoc(from, to2) != replaced || compositionRange && range2.to >= compositionRange.from && range2.from <= compositionRange.to)
              return { range: range2 };
            let rangeChanges = startState.changes({ from, to: to2, insert: change.insert }), selOff = range2.to - sel.to;
            return {
              changes: rangeChanges,
              range: !mainSel ? range2.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
            };
          });
        } else {
          tr = {
            changes,
            selection: mainSel && startState.selection.replaceRange(mainSel)
          };
        }
      }
      let userEvent = "input.type";
      if (view.composing) {
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
          userEvent += ".start";
          view.inputState.compositionFirstChange = false;
        }
      }
      view.dispatch(tr, { scrollIntoView: true, userEvent });
      return true;
    } else if (newSel && !newSel.main.eq(sel)) {
      let scrollIntoView3 = false, userEvent = "select";
      if (view.inputState.lastSelectionTime > Date.now() - 50) {
        if (view.inputState.lastSelectionOrigin == "select")
          scrollIntoView3 = true;
        userEvent = view.inputState.lastSelectionOrigin;
      }
      view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView3, userEvent });
      return true;
    } else {
      return false;
    }
  }
  function findDiff(a2, b2, preferredPos, preferredSide) {
    let minLen = Math.min(a2.length, b2.length);
    let from = 0;
    while (from < minLen && a2.charCodeAt(from) == b2.charCodeAt(from))
      from++;
    if (from == minLen && a2.length == b2.length)
      return null;
    let toA = a2.length, toB = b2.length;
    while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b2.charCodeAt(toB - 1)) {
      toA--;
      toB--;
    }
    if (preferredSide == "end") {
      let adjust2 = Math.max(0, from - Math.min(toA, toB));
      preferredPos -= toA + adjust2 - from;
    }
    if (toA < from && a2.length < b2.length) {
      let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
      from -= move;
      toB = from + (toB - toA);
      toA = from;
    } else if (toB < from) {
      let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
      from -= move;
      toA = from + (toA - toB);
      toB = from;
    }
    return { from, toA, toB };
  }
  function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
      return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
      result.push(new DOMPoint(anchorNode, anchorOffset));
      if (focusNode != anchorNode || focusOffset != anchorOffset)
        result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
  }
  function selectionFromPoints(points, base2) {
    if (points.length == 0)
      return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? EditorSelection.single(anchor + base2, head + base2) : null;
  }
  var EditorView = class {
    constructor(config2 = {}) {
      this.plugins = [];
      this.pluginMap = /* @__PURE__ */ new Map();
      this.editorAttrs = {};
      this.contentAttrs = {};
      this.bidiCache = [];
      this.destroyed = false;
      this.updateState = 2;
      this.measureScheduled = -1;
      this.measureRequests = [];
      this.contentDOM = document.createElement("div");
      this.scrollDOM = document.createElement("div");
      this.scrollDOM.tabIndex = -1;
      this.scrollDOM.className = "cm-scroller";
      this.scrollDOM.appendChild(this.contentDOM);
      this.announceDOM = document.createElement("div");
      this.announceDOM.style.cssText = "position: absolute; top: -10000px";
      this.announceDOM.setAttribute("aria-live", "polite");
      this.dom = document.createElement("div");
      this.dom.appendChild(this.announceDOM);
      this.dom.appendChild(this.scrollDOM);
      this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
      this.dispatch = this.dispatch.bind(this);
      this.root = config2.root || getRoot(config2.parent) || document;
      this.viewState = new ViewState(config2.state || EditorState.create());
      this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      for (let plugin of this.plugins)
        plugin.update(this);
      this.observer = new DOMObserver(this, (from, to2, typeOver) => {
        return applyDOMChange(this, from, to2, typeOver);
      }, (event) => {
        this.inputState.runScrollHandlers(this, event);
        if (this.observer.intersecting)
          this.measure();
      });
      this.inputState = new InputState(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.docView = new DocView(this);
      this.mountStyles();
      this.updateAttrs();
      this.updateState = 0;
      this.requestMeasure();
      if (config2.parent)
        config2.parent.appendChild(this.dom);
    }
    get state() {
      return this.viewState.state;
    }
    get viewport() {
      return this.viewState.viewport;
    }
    get visibleRanges() {
      return this.viewState.visibleRanges;
    }
    get inView() {
      return this.viewState.inView;
    }
    get composing() {
      return this.inputState.composing > 0;
    }
    get compositionStarted() {
      return this.inputState.composing >= 0;
    }
    dispatch(...input) {
      this._dispatch(input.length == 1 && input[0] instanceof Transaction2 ? input[0] : this.state.update(...input));
    }
    update(transactions) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
      let redrawn = false, attrsChanged = false, update3;
      let state3 = this.state;
      for (let tr of transactions) {
        if (tr.startState != state3)
          throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
        state3 = tr.state;
      }
      if (this.destroyed) {
        this.viewState.state = state3;
        return;
      }
      this.observer.clear();
      if (state3.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
        return this.setState(state3);
      update3 = ViewUpdate.create(this, state3, transactions);
      let scrollTarget = this.viewState.scrollTarget;
      try {
        this.updateState = 2;
        for (let tr of transactions) {
          if (scrollTarget)
            scrollTarget = scrollTarget.map(tr.changes);
          if (tr.scrollIntoView) {
            let { main } = tr.state.selection;
            scrollTarget = new ScrollTarget(main.empty ? main : EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
          }
          for (let e2 of tr.effects)
            if (e2.is(scrollIntoView))
              scrollTarget = e2.value;
        }
        this.viewState.update(update3, scrollTarget);
        this.bidiCache = CachedOrder.update(this.bidiCache, update3.changes);
        if (!update3.empty) {
          this.updatePlugins(update3);
          this.inputState.update(update3);
        }
        redrawn = this.docView.update(update3);
        if (this.state.facet(styleModule) != this.styleModules)
          this.mountStyles();
        attrsChanged = this.updateAttrs();
        this.showAnnouncements(transactions);
        this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
      } finally {
        this.updateState = 0;
      }
      if (update3.startState.facet(theme) != update3.state.facet(theme))
        this.viewState.mustMeasureContent = true;
      if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
        this.requestMeasure();
      if (!update3.empty)
        for (let listener of this.state.facet(updateListener))
          listener(update3);
    }
    setState(newState) {
      if (this.updateState != 0)
        throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
      if (this.destroyed) {
        this.viewState.state = newState;
        return;
      }
      this.updateState = 2;
      let hadFocus = this.hasFocus;
      try {
        for (let plugin of this.plugins)
          plugin.destroy(this);
        this.viewState = new ViewState(newState);
        this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
        this.pluginMap.clear();
        for (let plugin of this.plugins)
          plugin.update(this);
        this.docView = new DocView(this);
        this.inputState.ensureHandlers(this, this.plugins);
        this.mountStyles();
        this.updateAttrs();
        this.bidiCache = [];
      } finally {
        this.updateState = 0;
      }
      if (hadFocus)
        this.focus();
      this.requestMeasure();
    }
    updatePlugins(update3) {
      let prevSpecs = update3.startState.facet(viewPlugin), specs = update3.state.facet(viewPlugin);
      if (prevSpecs != specs) {
        let newPlugins = [];
        for (let spec of specs) {
          let found = prevSpecs.indexOf(spec);
          if (found < 0) {
            newPlugins.push(new PluginInstance(spec));
          } else {
            let plugin = this.plugins[found];
            plugin.mustUpdate = update3;
            newPlugins.push(plugin);
          }
        }
        for (let plugin of this.plugins)
          if (plugin.mustUpdate != update3)
            plugin.destroy(this);
        this.plugins = newPlugins;
        this.pluginMap.clear();
        this.inputState.ensureHandlers(this, this.plugins);
      } else {
        for (let p2 of this.plugins)
          p2.mustUpdate = update3;
      }
      for (let i2 = 0; i2 < this.plugins.length; i2++)
        this.plugins[i2].update(this);
    }
    measure(flush = true) {
      if (this.destroyed)
        return;
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.measureScheduled = 0;
      if (flush)
        this.observer.flush();
      let updated = null;
      try {
        for (let i2 = 0; ; i2++) {
          this.updateState = 1;
          let oldViewport = this.viewport;
          let changed2 = this.viewState.measure(this);
          if (!changed2 && !this.measureRequests.length && this.viewState.scrollTarget == null)
            break;
          if (i2 > 5) {
            console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
            break;
          }
          let measuring = [];
          if (!(changed2 & 4))
            [this.measureRequests, measuring] = [measuring, this.measureRequests];
          let measured = measuring.map((m3) => {
            try {
              return m3.read(this);
            } catch (e2) {
              logException(this.state, e2);
              return BadMeasure;
            }
          });
          let update3 = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
          update3.flags |= changed2;
          if (!updated)
            updated = update3;
          else
            updated.flags |= changed2;
          this.updateState = 2;
          if (!update3.empty) {
            this.updatePlugins(update3);
            this.inputState.update(update3);
            this.updateAttrs();
            redrawn = this.docView.update(update3);
          }
          for (let i3 = 0; i3 < measuring.length; i3++)
            if (measured[i3] != BadMeasure) {
              try {
                let m3 = measuring[i3];
                if (m3.write)
                  m3.write(measured[i3], this);
              } catch (e2) {
                logException(this.state, e2);
              }
            }
          if (this.viewState.scrollTarget) {
            this.docView.scrollIntoView(this.viewState.scrollTarget);
            this.viewState.scrollTarget = null;
            scrolled = true;
          }
          if (redrawn)
            this.docView.updateSelection(true);
          if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
            break;
        }
      } finally {
        this.updateState = 0;
        this.measureScheduled = -1;
      }
      if (updated && !updated.empty)
        for (let listener of this.state.facet(updateListener))
          listener(updated);
    }
    get themeClasses() {
      return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
    }
    updateAttrs() {
      let editorAttrs = attrsFromFacet(this, editorAttributes, {
        class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
      });
      let contentAttrs = {
        spellcheck: "false",
        autocorrect: "off",
        autocapitalize: "off",
        translate: "no",
        contenteditable: !this.state.facet(editable) ? "false" : "true",
        class: "cm-content",
        style: `${browser.tabSize}: ${this.state.tabSize}`,
        role: "textbox",
        "aria-multiline": "true"
      };
      if (this.state.readOnly)
        contentAttrs["aria-readonly"] = "true";
      attrsFromFacet(this, contentAttributes, contentAttrs);
      let changed2 = this.observer.ignore(() => {
        let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
        let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
        return changedContent || changedEditor;
      });
      this.editorAttrs = editorAttrs;
      this.contentAttrs = contentAttrs;
      return changed2;
    }
    showAnnouncements(trs) {
      let first = true;
      for (let tr of trs)
        for (let effect of tr.effects)
          if (effect.is(EditorView.announce)) {
            if (first)
              this.announceDOM.textContent = "";
            first = false;
            let div = this.announceDOM.appendChild(document.createElement("div"));
            div.textContent = effect.value;
          }
    }
    mountStyles() {
      this.styleModules = this.state.facet(styleModule);
      StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse());
    }
    readMeasured() {
      if (this.updateState == 2)
        throw new Error("Reading the editor layout isn't allowed during an update");
      if (this.updateState == 0 && this.measureScheduled > -1)
        this.measure(false);
    }
    requestMeasure(request) {
      if (this.measureScheduled < 0)
        this.measureScheduled = requestAnimationFrame(() => this.measure());
      if (request) {
        if (request.key != null)
          for (let i2 = 0; i2 < this.measureRequests.length; i2++) {
            if (this.measureRequests[i2].key === request.key) {
              this.measureRequests[i2] = request;
              return;
            }
          }
        this.measureRequests.push(request);
      }
    }
    plugin(plugin) {
      let known = this.pluginMap.get(plugin);
      if (known === void 0 || known && known.spec != plugin)
        this.pluginMap.set(plugin, known = this.plugins.find((p2) => p2.spec == plugin) || null);
      return known && known.update(this).value;
    }
    get documentTop() {
      return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    get documentPadding() {
      return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    elementAtHeight(height) {
      this.readMeasured();
      return this.viewState.elementAtHeight(height);
    }
    lineBlockAtHeight(height) {
      this.readMeasured();
      return this.viewState.lineBlockAtHeight(height);
    }
    get viewportLineBlocks() {
      return this.viewState.viewportLines;
    }
    lineBlockAt(pos) {
      return this.viewState.lineBlockAt(pos);
    }
    get contentHeight() {
      return this.viewState.contentHeight;
    }
    moveByChar(start2, forward, by) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
    }
    moveByGroup(start2, forward) {
      return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
    }
    moveToLineBoundary(start2, forward, includeWrap = true) {
      return moveToLineBoundary(this, start2, forward, includeWrap);
    }
    moveVertically(start2, forward, distance2) {
      return skipAtoms(this, start2, moveVertically(this, start2, forward, distance2));
    }
    domAtPos(pos) {
      return this.docView.domAtPos(pos);
    }
    posAtDOM(node, offset = 0) {
      return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
      this.readMeasured();
      return posAtCoords(this, coords, precise);
    }
    coordsAtPos(pos, side = 1) {
      this.readMeasured();
      let rect = this.docView.coordsAt(pos, side);
      if (!rect || rect.left == rect.right)
        return rect;
      let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
      let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
      return flattenRect(rect, span.dir == Direction.LTR == side > 0);
    }
    get defaultCharacterWidth() {
      return this.viewState.heightOracle.charWidth;
    }
    get defaultLineHeight() {
      return this.viewState.heightOracle.lineHeight;
    }
    get textDirection() {
      return this.viewState.defaultTextDirection;
    }
    textDirectionAt(pos) {
      let perLine = this.state.facet(perLineTextDirection);
      if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
        return this.textDirection;
      this.readMeasured();
      return this.docView.textDirectionAt(pos);
    }
    get lineWrapping() {
      return this.viewState.heightOracle.lineWrapping;
    }
    bidiSpans(line) {
      if (line.length > MaxBidiLine)
        return trivialOrder(line.length);
      let dir = this.textDirectionAt(line.from);
      for (let entry of this.bidiCache)
        if (entry.from == line.from && entry.dir == dir)
          return entry.order;
      let order = computeOrder(line.text, dir);
      this.bidiCache.push(new CachedOrder(line.from, line.to, dir, order));
      return order;
    }
    get hasFocus() {
      var _a2;
      return (document.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
    }
    focus() {
      this.observer.ignore(() => {
        focusPreventScroll(this.contentDOM);
        this.docView.updateSelection();
      });
    }
    destroy() {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.plugins = [];
      this.inputState.destroy();
      this.dom.remove();
      this.observer.destroy();
      if (this.measureScheduled > -1)
        cancelAnimationFrame(this.measureScheduled);
      this.destroyed = true;
    }
    static scrollIntoView(pos, options2 = {}) {
      return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
    }
    static domEventHandlers(handlers3) {
      return ViewPlugin.define(() => ({}), { eventHandlers: handlers3 });
    }
    static theme(spec, options2) {
      let prefix2 = StyleModule.newName();
      let result = [theme.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))];
      if (options2 && options2.dark)
        result.push(darkTheme.of(true));
      return result;
    }
    static baseTheme(spec) {
      return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
  };
  EditorView.styleModule = styleModule;
  EditorView.inputHandler = inputHandler;
  EditorView.perLineTextDirection = perLineTextDirection;
  EditorView.exceptionSink = exceptionSink;
  EditorView.updateListener = updateListener;
  EditorView.editable = editable;
  EditorView.mouseSelectionStyle = mouseSelectionStyle;
  EditorView.dragMovesSelection = dragMovesSelection$1;
  EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
  EditorView.decorations = decorations;
  EditorView.atomicRanges = atomicRanges;
  EditorView.scrollMargins = scrollMargins;
  EditorView.darkTheme = darkTheme;
  EditorView.contentAttributes = contentAttributes;
  EditorView.editorAttributes = editorAttributes;
  EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
  EditorView.announce = /* @__PURE__ */ StateEffect.define();
  var MaxBidiLine = 4096;
  var BadMeasure = {};
  var CachedOrder = class {
    constructor(from, to2, dir, order) {
      this.from = from;
      this.to = to2;
      this.dir = dir;
      this.order = order;
    }
    static update(cache2, changes) {
      if (changes.empty)
        return cache2;
      let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
      for (let i2 = Math.max(0, cache2.length - 10); i2 < cache2.length; i2++) {
        let entry = cache2[i2];
        if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
          result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
      }
      return result;
    }
  };
  function attrsFromFacet(view, facet, base2) {
    for (let sources = view.state.facet(facet), i2 = sources.length - 1; i2 >= 0; i2--) {
      let source = sources[i2], value = typeof source == "function" ? source(view) : source;
      if (value)
        combineAttrs(value, base2);
    }
    return base2;
  }
  var currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
  function normalizeKeyName(name3, platform) {
    const parts = name3.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
      result = " ";
    let alt, ctrl, shift2, meta2;
    for (let i2 = 0; i2 < parts.length - 1; ++i2) {
      const mod2 = parts[i2];
      if (/^(cmd|meta|m)$/i.test(mod2))
        meta2 = true;
      else if (/^a(lt)?$/i.test(mod2))
        alt = true;
      else if (/^(c|ctrl|control)$/i.test(mod2))
        ctrl = true;
      else if (/^s(hift)?$/i.test(mod2))
        shift2 = true;
      else if (/^mod$/i.test(mod2)) {
        if (platform == "mac")
          meta2 = true;
        else
          ctrl = true;
      } else
        throw new Error("Unrecognized modifier name: " + mod2);
    }
    if (alt)
      result = "Alt-" + result;
    if (ctrl)
      result = "Ctrl-" + result;
    if (meta2)
      result = "Meta-" + result;
    if (shift2)
      result = "Shift-" + result;
    return result;
  }
  function modifiers(name3, event, shift2) {
    if (event.altKey)
      name3 = "Alt-" + name3;
    if (event.ctrlKey)
      name3 = "Ctrl-" + name3;
    if (event.metaKey)
      name3 = "Meta-" + name3;
    if (shift2 !== false && event.shiftKey)
      name3 = "Shift-" + name3;
    return name3;
  }
  var handleKeyEvents = /* @__PURE__ */ EditorView.domEventHandlers({
    keydown(event, view) {
      return runHandlers(getKeymap(view.state), event, view, "editor");
    }
  });
  var keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
  var Keymaps = /* @__PURE__ */ new WeakMap();
  function getKeymap(state3) {
    let bindings2 = state3.facet(keymap);
    let map = Keymaps.get(bindings2);
    if (!map)
      Keymaps.set(bindings2, map = buildKeymap(bindings2.reduce((a2, b2) => a2.concat(b2), [])));
    return map;
  }
  function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
  }
  var storedPrefix = null;
  var PrefixTimeout = 4e3;
  function buildKeymap(bindings2, platform = currentPlatform) {
    let bound = /* @__PURE__ */ Object.create(null);
    let isPrefix = /* @__PURE__ */ Object.create(null);
    let checkPrefix = (name3, is) => {
      let current = isPrefix[name3];
      if (current == null)
        isPrefix[name3] = is;
      else if (current != is)
        throw new Error("Key binding " + name3 + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add2 = (scope, key2, command2, preventDefault) => {
      let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
      let parts = key2.split(/ (?!$)/).map((k) => normalizeKeyName(k, platform));
      for (let i2 = 1; i2 < parts.length; i2++) {
        let prefix2 = parts.slice(0, i2).join(" ");
        checkPrefix(prefix2, true);
        if (!scopeObj[prefix2])
          scopeObj[prefix2] = {
            preventDefault: true,
            commands: [(view) => {
              let ourObj = storedPrefix = { view, prefix: prefix2, scope };
              setTimeout(() => {
                if (storedPrefix == ourObj)
                  storedPrefix = null;
              }, PrefixTimeout);
              return true;
            }]
          };
      }
      let full = parts.join(" ");
      checkPrefix(full, false);
      let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, commands: [] });
      binding.commands.push(command2);
      if (preventDefault)
        binding.preventDefault = true;
    };
    for (let b2 of bindings2) {
      let name3 = b2[platform] || b2.key;
      if (!name3)
        continue;
      for (let scope of b2.scope ? b2.scope.split(" ") : ["editor"]) {
        add2(scope, name3, b2.run, b2.preventDefault);
        if (b2.shift)
          add2(scope, "Shift-" + name3, b2.shift, b2.preventDefault);
      }
    }
    return bound;
  }
  function runHandlers(map, event, view, scope) {
    let name3 = keyName(event), isChar = name3.length == 1 && name3 != " ";
    let prefix2 = "", fallthrough = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
      prefix2 = storedPrefix.prefix + " ";
      if (fallthrough = modifierCodes.indexOf(event.keyCode) < 0)
        storedPrefix = null;
    }
    let runFor = (binding) => {
      if (binding) {
        for (let cmd2 of binding.commands)
          if (cmd2(view))
            return true;
        if (binding.preventDefault)
          fallthrough = true;
      }
      return false;
    };
    let scopeObj = map[scope], baseName;
    if (scopeObj) {
      if (runFor(scopeObj[prefix2 + modifiers(name3, event, !isChar)]))
        return true;
      if (isChar && (event.shiftKey || event.altKey || event.metaKey) && (baseName = base[event.keyCode]) && baseName != name3) {
        if (runFor(scopeObj[prefix2 + modifiers(baseName, event, true)]))
          return true;
      } else if (isChar && event.shiftKey) {
        if (runFor(scopeObj[prefix2 + modifiers(name3, event, true)]))
          return true;
      }
    }
    return fallthrough;
  }
  var CanHidePrimary = !browser.ios;
  var selectionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        cursorBlinkRate: 1200,
        drawRangeCursor: true
      }, {
        cursorBlinkRate: (a2, b2) => Math.min(a2, b2),
        drawRangeCursor: (a2, b2) => a2 || b2
      });
    }
  });
  function drawSelection(config2 = {}) {
    return [
      selectionConfig.of(config2),
      drawSelectionPlugin,
      hideNativeSelection
    ];
  }
  var Piece = class {
    constructor(left, top2, width, height, className) {
      this.left = left;
      this.top = top2;
      this.width = width;
      this.height = height;
      this.className = className;
    }
    draw() {
      let elt = document.createElement("div");
      elt.className = this.className;
      this.adjust(elt);
      return elt;
    }
    adjust(elt) {
      elt.style.left = this.left + "px";
      elt.style.top = this.top + "px";
      if (this.width >= 0)
        elt.style.width = this.width + "px";
      elt.style.height = this.height + "px";
    }
    eq(p2) {
      return this.left == p2.left && this.top == p2.top && this.width == p2.width && this.height == p2.height && this.className == p2.className;
    }
  };
  var drawSelectionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.rangePieces = [];
      this.cursors = [];
      this.measureReq = { read: this.readPos.bind(this), write: this.drawSel.bind(this) };
      this.selectionLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.selectionLayer.className = "cm-selectionLayer";
      this.selectionLayer.setAttribute("aria-hidden", "true");
      this.cursorLayer = view.scrollDOM.appendChild(document.createElement("div"));
      this.cursorLayer.className = "cm-cursorLayer";
      this.cursorLayer.setAttribute("aria-hidden", "true");
      view.requestMeasure(this.measureReq);
      this.setBlinkRate();
    }
    setBlinkRate() {
      this.cursorLayer.style.animationDuration = this.view.state.facet(selectionConfig).cursorBlinkRate + "ms";
    }
    update(update3) {
      let confChanged = update3.startState.facet(selectionConfig) != update3.state.facet(selectionConfig);
      if (confChanged || update3.selectionSet || update3.geometryChanged || update3.viewportChanged)
        this.view.requestMeasure(this.measureReq);
      if (update3.transactions.some((tr) => tr.scrollIntoView))
        this.cursorLayer.style.animationName = this.cursorLayer.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
      if (confChanged)
        this.setBlinkRate();
    }
    readPos() {
      let { state: state3 } = this.view, conf = state3.facet(selectionConfig);
      let rangePieces = state3.selection.ranges.map((r) => r.empty ? [] : measureRange(this.view, r)).reduce((a2, b2) => a2.concat(b2));
      let cursors = [];
      for (let r of state3.selection.ranges) {
        let prim = r == state3.selection.main;
        if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
          let piece = measureCursor(this.view, r, prim);
          if (piece)
            cursors.push(piece);
        }
      }
      return { rangePieces, cursors };
    }
    drawSel({ rangePieces, cursors }) {
      if (rangePieces.length != this.rangePieces.length || rangePieces.some((p2, i2) => !p2.eq(this.rangePieces[i2]))) {
        this.selectionLayer.textContent = "";
        for (let p2 of rangePieces)
          this.selectionLayer.appendChild(p2.draw());
        this.rangePieces = rangePieces;
      }
      if (cursors.length != this.cursors.length || cursors.some((c4, i2) => !c4.eq(this.cursors[i2]))) {
        let oldCursors = this.cursorLayer.children;
        if (oldCursors.length !== cursors.length) {
          this.cursorLayer.textContent = "";
          for (const c4 of cursors)
            this.cursorLayer.appendChild(c4.draw());
        } else {
          cursors.forEach((c4, idx) => c4.adjust(oldCursors[idx]));
        }
        this.cursors = cursors;
      }
    }
    destroy() {
      this.selectionLayer.remove();
      this.cursorLayer.remove();
    }
  });
  var themeSpec = {
    ".cm-line": {
      "& ::selection": { backgroundColor: "transparent !important" },
      "&::selection": { backgroundColor: "transparent !important" }
    }
  };
  if (CanHidePrimary)
    themeSpec[".cm-line"].caretColor = "transparent !important";
  var hideNativeSelection = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ EditorView.theme(themeSpec));
  function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth;
    return { left: left - view.scrollDOM.scrollLeft, top: rect.top - view.scrollDOM.scrollTop };
  }
  function wrappedLine(view, pos, inside2) {
    let range2 = EditorSelection.cursor(pos);
    return {
      from: Math.max(inside2.from, view.moveToLineBoundary(range2, false, true).from),
      to: Math.min(inside2.to, view.moveToLineBoundary(range2, true, true).from),
      type: BlockType.Text
    };
  }
  function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
      for (let l of line.type) {
        if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
          return l;
      }
    return line;
  }
  function measureRange(view, range2) {
    if (range2.to <= view.viewport.from || range2.from >= view.viewport.to)
      return [];
    let from = Math.max(range2.from, view.viewport.from), to2 = Math.min(range2.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content2 = view.contentDOM, contentRect = content2.getBoundingClientRect(), base2 = getBase(view);
    let lineStyle = window.getComputedStyle(content2.firstChild);
    let leftSide = contentRect.left + parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent));
    let rightSide = contentRect.right - parseInt(lineStyle.paddingRight);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to2);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (view.lineWrapping) {
      if (visualStart)
        visualStart = wrappedLine(view, from, visualStart);
      if (visualEnd)
        visualEnd = wrappedLine(view, to2, visualEnd);
    }
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
      return pieces(drawForLine(range2.from, range2.to, visualStart));
    } else {
      let top2 = visualStart ? drawForLine(range2.from, null, visualStart) : drawForWidget(startBlock, false);
      let bottom = visualEnd ? drawForLine(null, range2.to, visualEnd) : drawForWidget(endBlock, true);
      let between = [];
      if ((visualStart || startBlock).to < (visualEnd || endBlock).from - 1)
        between.push(piece(leftSide, top2.bottom, rightSide, bottom.top));
      else if (top2.bottom < bottom.top && view.elementAtHeight((top2.bottom + bottom.top) / 2).type == BlockType.Text)
        top2.bottom = bottom.top = (top2.bottom + bottom.top) / 2;
      return pieces(top2).concat(between).concat(pieces(bottom));
    }
    function piece(left, top2, right, bottom) {
      return new Piece(left - base2.left, top2 - base2.top - 0.01, right - left, bottom - top2 + 0.01, "cm-selectionBackground");
    }
    function pieces({ top: top2, bottom, horizontal }) {
      let pieces2 = [];
      for (let i2 = 0; i2 < horizontal.length; i2 += 2)
        pieces2.push(piece(horizontal[i2], top2, horizontal[i2 + 1], bottom));
      return pieces2;
    }
    function drawForLine(from2, to3, line) {
      let top2 = 1e9, bottom = -1e9, horizontal = [];
      function addSpan(from3, fromOpen, to4, toOpen, dir) {
        let fromCoords = view.coordsAtPos(from3, from3 == line.to ? -2 : 2);
        let toCoords = view.coordsAtPos(to4, to4 == line.from ? 2 : -2);
        top2 = Math.min(fromCoords.top, toCoords.top, top2);
        bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
        if (dir == Direction.LTR)
          horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
        else
          horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
      }
      let start2 = from2 !== null && from2 !== void 0 ? from2 : line.from, end = to3 !== null && to3 !== void 0 ? to3 : line.to;
      for (let r of view.visibleRanges)
        if (r.to > start2 && r.from < end) {
          for (let pos = Math.max(r.from, start2), endPos = Math.min(r.to, end); ; ) {
            let docLine = view.state.doc.lineAt(pos);
            for (let span of view.bidiSpans(docLine)) {
              let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
              if (spanFrom >= endPos)
                break;
              if (spanTo > pos)
                addSpan(Math.max(spanFrom, pos), from2 == null && spanFrom <= start2, Math.min(spanTo, endPos), to3 == null && spanTo >= end, span.dir);
            }
            pos = docLine.to + 1;
            if (pos >= endPos)
              break;
          }
        }
      if (horizontal.length == 0)
        addSpan(start2, from2 == null, end, to3 == null, view.textDirection);
      return { top: top2, bottom, horizontal };
    }
    function drawForWidget(block, top2) {
      let y = contentRect.top + (top2 ? block.top : block.bottom);
      return { top: y, bottom: y, horizontal: [] };
    }
  }
  function measureCursor(view, cursor, primary) {
    let pos = view.coordsAtPos(cursor.head, cursor.assoc || 1);
    if (!pos)
      return null;
    let base2 = getBase(view);
    return new Piece(pos.left - base2.left, pos.top - base2.top, -1, pos.bottom - pos.top, primary ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary");
  }
  var setDropCursorPos = /* @__PURE__ */ StateEffect.define({
    map(pos, mapping) {
      return pos == null ? null : mapping.mapPos(pos);
    }
  });
  var dropCursorPos = /* @__PURE__ */ StateField.define({
    create() {
      return null;
    },
    update(pos, tr) {
      if (pos != null)
        pos = tr.changes.mapPos(pos);
      return tr.effects.reduce((pos2, e2) => e2.is(setDropCursorPos) ? e2.value : pos2, pos);
    }
  });
  var drawDropCursor = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.cursor = null;
      this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update3) {
      var _a2;
      let cursorPos = update3.state.field(dropCursorPos);
      if (cursorPos == null) {
        if (this.cursor != null) {
          (_a2 = this.cursor) === null || _a2 === void 0 ? void 0 : _a2.remove();
          this.cursor = null;
        }
      } else {
        if (!this.cursor) {
          this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
          this.cursor.className = "cm-dropCursor";
        }
        if (update3.startState.field(dropCursorPos) != cursorPos || update3.docChanged || update3.geometryChanged)
          this.view.requestMeasure(this.measureReq);
      }
    }
    readPos() {
      let pos = this.view.state.field(dropCursorPos);
      let rect = pos != null && this.view.coordsAtPos(pos);
      if (!rect)
        return null;
      let outer = this.view.scrollDOM.getBoundingClientRect();
      return {
        left: rect.left - outer.left + this.view.scrollDOM.scrollLeft,
        top: rect.top - outer.top + this.view.scrollDOM.scrollTop,
        height: rect.bottom - rect.top
      };
    }
    drawCursor(pos) {
      if (this.cursor) {
        if (pos) {
          this.cursor.style.left = pos.left + "px";
          this.cursor.style.top = pos.top + "px";
          this.cursor.style.height = pos.height + "px";
        } else {
          this.cursor.style.left = "-100000px";
        }
      }
    }
    destroy() {
      if (this.cursor)
        this.cursor.remove();
    }
    setDropPos(pos) {
      if (this.view.state.field(dropCursorPos) != pos)
        this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
  }, {
    eventHandlers: {
      dragover(event) {
        this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
      },
      dragleave(event) {
        if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
          this.setDropPos(null);
      },
      dragend() {
        this.setDropPos(null);
      },
      drop() {
        this.setDropPos(null);
      }
    }
  });
  function dropCursor() {
    return [dropCursorPos, drawDropCursor];
  }
  function iterMatches(doc2, re, from, to2, f) {
    re.lastIndex = 0;
    for (let cursor = doc2.iterRange(from, to2), pos = from, m3; !cursor.next().done; pos += cursor.value.length) {
      if (!cursor.lineBreak)
        while (m3 = re.exec(cursor.value))
          f(pos + m3.index, pos + m3.index + m3[0].length, m3);
    }
  }
  function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to)
      return visible;
    let result = [];
    for (let { from, to: to2 } of visible) {
      from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
      to2 = Math.min(view.state.doc.lineAt(to2).to, to2 + maxLength);
      if (result.length && result[result.length - 1].to >= from)
        result[result.length - 1].to = to2;
      else
        result.push({ from, to: to2 });
    }
    return result;
  }
  var MatchDecorator = class {
    constructor(config2) {
      let { regexp, decoration, boundary, maxLength = 1e3 } = config2;
      if (!regexp.global)
        throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
      this.regexp = regexp;
      this.getDeco = typeof decoration == "function" ? decoration : () => decoration;
      this.boundary = boundary;
      this.maxLength = maxLength;
    }
    createDeco(view) {
      let build = new RangeSetBuilder();
      for (let { from, to: to2 } of matchRanges(view, this.maxLength))
        iterMatches(view.state.doc, this.regexp, from, to2, (a2, b2, m3) => build.add(a2, b2, this.getDeco(m3, view, a2)));
      return build.finish();
    }
    updateDeco(update3, deco) {
      let changeFrom = 1e9, changeTo = -1;
      if (update3.docChanged)
        update3.changes.iterChanges((_f, _t, from, to2) => {
          if (to2 > update3.view.viewport.from && from < update3.view.viewport.to) {
            changeFrom = Math.min(from, changeFrom);
            changeTo = Math.max(to2, changeTo);
          }
        });
      if (update3.viewportChanged || changeTo - changeFrom > 1e3)
        return this.createDeco(update3.view);
      if (changeTo > -1)
        return this.updateRange(update3.view, deco.map(update3.changes), changeFrom, changeTo);
      return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
      for (let r of view.visibleRanges) {
        let from = Math.max(r.from, updateFrom), to2 = Math.min(r.to, updateTo);
        if (to2 > from) {
          let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to2 ? view.state.doc.lineAt(to2) : fromLine;
          let start2 = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
          if (this.boundary) {
            for (; from > fromLine.from; from--)
              if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                start2 = from;
                break;
              }
            for (; to2 < toLine.to; to2++)
              if (this.boundary.test(toLine.text[to2 - toLine.from])) {
                end = to2;
                break;
              }
          }
          let ranges = [], m3;
          if (fromLine == toLine) {
            this.regexp.lastIndex = start2 - fromLine.from;
            while ((m3 = this.regexp.exec(fromLine.text)) && m3.index < end - fromLine.from) {
              let pos = m3.index + fromLine.from;
              ranges.push(this.getDeco(m3, view, pos).range(pos, pos + m3[0].length));
            }
          } else {
            iterMatches(view.state.doc, this.regexp, start2, end, (from2, to3, m4) => ranges.push(this.getDeco(m4, view, from2).range(from2, to3)));
          }
          deco = deco.update({ filterFrom: start2, filterTo: end, filter: (from2, to3) => from2 < start2 || to3 > end, add: ranges });
        }
      }
      return deco;
    }
  };
  var UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
  var Specials = /* @__PURE__ */ new RegExp("[\0-\b\n-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\uFEFF\uFFF9-\uFFFC]", UnicodeRegexpSupport);
  var Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
  };
  var _supportsTabSize = null;
  function supportsTabSize() {
    var _a2;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
      let styles = document.body.style;
      _supportsTabSize = ((_a2 = styles.tabSize) !== null && _a2 !== void 0 ? _a2 : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
  }
  var specialCharConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let config2 = combineConfig(configs, {
        render: null,
        specialChars: Specials,
        addSpecialChars: null
      });
      if (config2.replaceTabs = !supportsTabSize())
        config2.specialChars = new RegExp("	|" + config2.specialChars.source, UnicodeRegexpSupport);
      if (config2.addSpecialChars)
        config2.specialChars = new RegExp(config2.specialChars.source + "|" + config2.addSpecialChars.source, UnicodeRegexpSupport);
      return config2;
    }
  });
  function highlightSpecialChars(config2 = {}) {
    return [specialCharConfig.of(config2), specialCharPlugin()];
  }
  var _plugin = null;
  function specialCharPlugin() {
    return _plugin || (_plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.decorations = Decoration.none;
        this.decorationCache = /* @__PURE__ */ Object.create(null);
        this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
        this.decorations = this.decorator.createDeco(view);
      }
      makeDecorator(conf) {
        return new MatchDecorator({
          regexp: conf.specialChars,
          decoration: (m3, view, pos) => {
            let { doc: doc2 } = view.state;
            let code2 = codePointAt(m3[0], 0);
            if (code2 == 9) {
              let line = doc2.lineAt(pos);
              let size2 = view.state.tabSize, col = countColumn(line.text, size2, pos - line.from);
              return Decoration.replace({ widget: new TabWidget((size2 - col % size2) * this.view.defaultCharacterWidth) });
            }
            return this.decorationCache[code2] || (this.decorationCache[code2] = Decoration.replace({ widget: new SpecialCharWidget(conf, code2) }));
          },
          boundary: conf.replaceTabs ? void 0 : /[^]/
        });
      }
      update(update3) {
        let conf = update3.state.facet(specialCharConfig);
        if (update3.startState.facet(specialCharConfig) != conf) {
          this.decorator = this.makeDecorator(conf);
          this.decorations = this.decorator.createDeco(update3.view);
        } else {
          this.decorations = this.decorator.updateDeco(update3, this.decorations);
        }
      }
    }, {
      decorations: (v) => v.decorations
    }));
  }
  var DefaultPlaceholder = "\u2022";
  function placeholder$1(code2) {
    if (code2 >= 32)
      return DefaultPlaceholder;
    if (code2 == 10)
      return "\u2424";
    return String.fromCharCode(9216 + code2);
  }
  var SpecialCharWidget = class extends WidgetType {
    constructor(options2, code2) {
      super();
      this.options = options2;
      this.code = code2;
    }
    eq(other) {
      return other.code == this.code;
    }
    toDOM(view) {
      let ph = placeholder$1(this.code);
      let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
      let custom = this.options.render && this.options.render(this.code, desc, ph);
      if (custom)
        return custom;
      let span = document.createElement("span");
      span.textContent = ph;
      span.title = desc;
      span.setAttribute("aria-label", desc);
      span.className = "cm-specialChar";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  var TabWidget = class extends WidgetType {
    constructor(width) {
      super();
      this.width = width;
    }
    eq(other) {
      return other.width == this.width;
    }
    toDOM() {
      let span = document.createElement("span");
      span.textContent = "	";
      span.className = "cm-tab";
      span.style.width = this.width + "px";
      return span;
    }
    ignoreEvent() {
      return false;
    }
  };
  function highlightActiveLine() {
    return activeLineHighlighter;
  }
  var lineDeco = /* @__PURE__ */ Decoration.line({ class: "cm-activeLine" });
  var activeLineHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update3) {
      if (update3.docChanged || update3.selectionSet)
        this.decorations = this.getDeco(update3.view);
    }
    getDeco(view) {
      let lastLineStart = -1, deco = [];
      for (let r of view.state.selection.ranges) {
        if (!r.empty)
          return Decoration.none;
        let line = view.lineBlockAt(r.head);
        if (line.from > lastLineStart) {
          deco.push(lineDeco.range(line.from));
          lastLineStart = line.from;
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var MaxOff = 2e3;
  function rectangleFor(state3, a2, b2) {
    let startLine = Math.min(a2.line, b2.line), endLine = Math.max(a2.line, b2.line);
    let ranges = [];
    if (a2.off > MaxOff || b2.off > MaxOff || a2.col < 0 || b2.col < 0) {
      let startOff = Math.min(a2.off, b2.off), endOff = Math.max(a2.off, b2.off);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state3.doc.line(i2);
        if (line.length <= endOff)
          ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
      }
    } else {
      let startCol = Math.min(a2.col, b2.col), endCol = Math.max(a2.col, b2.col);
      for (let i2 = startLine; i2 <= endLine; i2++) {
        let line = state3.doc.line(i2);
        let start2 = findColumn(line.text, startCol, state3.tabSize, true);
        if (start2 > -1) {
          let end = findColumn(line.text, endCol, state3.tabSize);
          ranges.push(EditorSelection.range(line.from + start2, line.from + end));
        }
      }
    }
    return ranges;
  }
  function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
  }
  function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
  }
  function rectangleSelectionStyle(view, event) {
    let start2 = getPos(view, event), startSel = view.state.selection;
    if (!start2)
      return null;
    return {
      update(update3) {
        if (update3.docChanged) {
          let newStart = update3.changes.mapPos(update3.startState.doc.line(start2.line).from);
          let newLine = update3.state.doc.lineAt(newStart);
          start2 = { line: newLine.number, col: start2.col, off: Math.min(start2.off, newLine.length) };
          startSel = startSel.map(update3.changes);
        }
      },
      get(event2, _extend, multiple) {
        let cur2 = getPos(view, event2);
        if (!cur2)
          return startSel;
        let ranges = rectangleFor(view.state, start2, cur2);
        if (!ranges.length)
          return startSel;
        if (multiple)
          return EditorSelection.create(ranges.concat(startSel.ranges));
        else
          return EditorSelection.create(ranges);
      }
    };
  }
  function rectangularSelection(options2) {
    let filter = (options2 === null || options2 === void 0 ? void 0 : options2.eventFilter) || ((e2) => e2.altKey && e2.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
  }
  var keys3 = {
    Alt: [18, (e2) => e2.altKey],
    Control: [17, (e2) => e2.ctrlKey],
    Shift: [16, (e2) => e2.shiftKey],
    Meta: [91, (e2) => e2.metaKey]
  };
  var showCrosshair = { style: "cursor: crosshair" };
  function crosshairCursor(options2 = {}) {
    let [code2, getter] = keys3[options2.key || "Alt"];
    let plugin = ViewPlugin.fromClass(class {
      constructor(view) {
        this.view = view;
        this.isDown = false;
      }
      set(isDown) {
        if (this.isDown != isDown) {
          this.isDown = isDown;
          this.view.update([]);
        }
      }
    }, {
      eventHandlers: {
        keydown(e2) {
          this.set(e2.keyCode == code2 || getter(e2));
        },
        keyup(e2) {
          if (e2.keyCode == code2 || !getter(e2))
            this.set(false);
        }
      }
    });
    return [
      plugin,
      EditorView.contentAttributes.of((view) => {
        var _a2;
        return ((_a2 = view.plugin(plugin)) === null || _a2 === void 0 ? void 0 : _a2.isDown) ? showCrosshair : null;
      })
    ];
  }
  var Outside = "-10000px";
  var TooltipViewManager = class {
    constructor(view, facet, createTooltipView) {
      this.facet = facet;
      this.createTooltipView = createTooltipView;
      this.input = view.state.facet(facet);
      this.tooltips = this.input.filter((t2) => t2);
      this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update3) {
      let input = update3.state.facet(this.facet);
      let tooltips = input.filter((x) => x);
      if (input === this.input) {
        for (let t2 of this.tooltipViews)
          if (t2.update)
            t2.update(update3);
        return false;
      }
      let tooltipViews = [];
      for (let i2 = 0; i2 < tooltips.length; i2++) {
        let tip = tooltips[i2], known = -1;
        if (!tip)
          continue;
        for (let i3 = 0; i3 < this.tooltips.length; i3++) {
          let other = this.tooltips[i3];
          if (other && other.create == tip.create)
            known = i3;
        }
        if (known < 0) {
          tooltipViews[i2] = this.createTooltipView(tip);
        } else {
          let tooltipView = tooltipViews[i2] = this.tooltipViews[known];
          if (tooltipView.update)
            tooltipView.update(update3);
        }
      }
      for (let t2 of this.tooltipViews)
        if (tooltipViews.indexOf(t2) < 0)
          t2.dom.remove();
      this.input = input;
      this.tooltips = tooltips;
      this.tooltipViews = tooltipViews;
      return true;
    }
  };
  function windowSpace() {
    return { top: 0, left: 0, bottom: innerHeight, right: innerWidth };
  }
  var tooltipConfig = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      var _a2, _b, _c;
      return {
        position: browser.ios ? "absolute" : ((_a2 = values.find((conf) => conf.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
        parent: ((_b = values.find((conf) => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
        tooltipSpace: ((_c = values.find((conf) => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
      };
    }
  });
  var tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      var _a2;
      this.view = view;
      this.inView = true;
      this.lastTransaction = 0;
      this.measureTimeout = -1;
      let config2 = view.state.facet(tooltipConfig);
      this.position = config2.position;
      this.parent = config2.parent;
      this.classes = view.themeClasses;
      this.createContainer();
      this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
      this.manager = new TooltipViewManager(view, showTooltip, (t2) => this.createTooltip(t2));
      this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries) => {
        if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
          this.measureSoon();
      }, { threshold: [1] }) : null;
      this.observeIntersection();
      (_a2 = view.dom.ownerDocument.defaultView) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
      this.maybeMeasure();
    }
    createContainer() {
      if (this.parent) {
        this.container = document.createElement("div");
        this.container.style.position = "relative";
        this.container.className = this.view.themeClasses;
        this.parent.appendChild(this.container);
      } else {
        this.container = this.view.dom;
      }
    }
    observeIntersection() {
      if (this.intersectionObserver) {
        this.intersectionObserver.disconnect();
        for (let tooltip of this.manager.tooltipViews)
          this.intersectionObserver.observe(tooltip.dom);
      }
    }
    measureSoon() {
      if (this.measureTimeout < 0)
        this.measureTimeout = setTimeout(() => {
          this.measureTimeout = -1;
          this.maybeMeasure();
        }, 50);
    }
    update(update3) {
      if (update3.transactions.length)
        this.lastTransaction = Date.now();
      let updated = this.manager.update(update3);
      if (updated)
        this.observeIntersection();
      let shouldMeasure = updated || update3.geometryChanged;
      let newConfig = update3.state.facet(tooltipConfig);
      if (newConfig.position != this.position) {
        this.position = newConfig.position;
        for (let t2 of this.manager.tooltipViews)
          t2.dom.style.position = this.position;
        shouldMeasure = true;
      }
      if (newConfig.parent != this.parent) {
        if (this.parent)
          this.container.remove();
        this.parent = newConfig.parent;
        this.createContainer();
        for (let t2 of this.manager.tooltipViews)
          this.container.appendChild(t2.dom);
        shouldMeasure = true;
      } else if (this.parent && this.view.themeClasses != this.classes) {
        this.classes = this.container.className = this.view.themeClasses;
      }
      if (shouldMeasure)
        this.maybeMeasure();
    }
    createTooltip(tooltip) {
      let tooltipView = tooltip.create(this.view);
      tooltipView.dom.classList.add("cm-tooltip");
      if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
        let arrow = document.createElement("div");
        arrow.className = "cm-tooltip-arrow";
        tooltipView.dom.appendChild(arrow);
      }
      tooltipView.dom.style.position = this.position;
      tooltipView.dom.style.top = Outside;
      this.container.appendChild(tooltipView.dom);
      if (tooltipView.mount)
        tooltipView.mount(this.view);
      return tooltipView;
    }
    destroy() {
      var _a2, _b;
      (_a2 = this.view.dom.ownerDocument.defaultView) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("resize", this.measureSoon);
      for (let { dom: dom2 } of this.manager.tooltipViews)
        dom2.remove();
      (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
      clearTimeout(this.measureTimeout);
    }
    readMeasure() {
      let editor = this.view.dom.getBoundingClientRect();
      return {
        editor,
        parent: this.parent ? this.container.getBoundingClientRect() : editor,
        pos: this.manager.tooltips.map((t2, i2) => {
          let tv = this.manager.tooltipViews[i2];
          return tv.getCoords ? tv.getCoords(t2.pos) : this.view.coordsAtPos(t2.pos);
        }),
        size: this.manager.tooltipViews.map(({ dom: dom2 }) => dom2.getBoundingClientRect()),
        space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
      };
    }
    writeMeasure(measured) {
      let { editor, space } = measured;
      let others = [];
      for (let i2 = 0; i2 < this.manager.tooltips.length; i2++) {
        let tooltip = this.manager.tooltips[i2], tView = this.manager.tooltipViews[i2], { dom: dom2 } = tView;
        let pos = measured.pos[i2], size2 = measured.size[i2];
        if (!pos || pos.bottom <= Math.max(editor.top, space.top) || pos.top >= Math.min(editor.bottom, space.bottom) || pos.right < Math.max(editor.left, space.left) - 0.1 || pos.left > Math.min(editor.right, space.right) + 0.1) {
          dom2.style.top = Outside;
          continue;
        }
        let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
        let arrowHeight = arrow ? 7 : 0;
        let width = size2.right - size2.left, height = size2.bottom - size2.top;
        let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
        let left = size2.width > space.right - space.left ? ltr ? space.left : space.right - size2.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width) : Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x);
        let above = !!tooltip.above;
        if (!tooltip.strictSide && (above ? pos.top - (size2.bottom - size2.top) - offset.y < space.top : pos.bottom + (size2.bottom - size2.top) + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top)
          above = !above;
        let top2 = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
        let right = left + width;
        if (tView.overlap !== true) {
          for (let r of others)
            if (r.left < right && r.right > left && r.top < top2 + height && r.bottom > top2)
              top2 = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
        if (this.position == "absolute") {
          dom2.style.top = top2 - measured.parent.top + "px";
          dom2.style.left = left - measured.parent.left + "px";
        } else {
          dom2.style.top = top2 + "px";
          dom2.style.left = left + "px";
        }
        if (arrow)
          arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7)}px`;
        if (tView.overlap !== true)
          others.push({ left, top: top2, right, bottom: top2 + height });
        dom2.classList.toggle("cm-tooltip-above", above);
        dom2.classList.toggle("cm-tooltip-below", !above);
        if (tView.positioned)
          tView.positioned();
      }
    }
    maybeMeasure() {
      if (this.manager.tooltips.length) {
        if (this.view.inView)
          this.view.requestMeasure(this.measureReq);
        if (this.inView != this.view.inView) {
          this.inView = this.view.inView;
          if (!this.inView)
            for (let tv of this.manager.tooltipViews)
              tv.dom.style.top = Outside;
        }
      }
    }
  }, {
    eventHandlers: {
      scroll() {
        this.maybeMeasure();
      }
    }
  });
  var baseTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip": {
      zIndex: 100
    },
    "&light .cm-tooltip": {
      border: "1px solid #bbb",
      backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
      borderTop: "1px solid #bbb"
    },
    "&dark .cm-tooltip": {
      backgroundColor: "#333338",
      color: "white"
    },
    ".cm-tooltip-arrow": {
      height: `${7}px`,
      width: `${7 * 2}px`,
      position: "absolute",
      zIndex: -1,
      overflow: "hidden",
      "&:before, &:after": {
        content: "''",
        position: "absolute",
        width: 0,
        height: 0,
        borderLeft: `${7}px solid transparent`,
        borderRight: `${7}px solid transparent`
      },
      ".cm-tooltip-above &": {
        bottom: `-${7}px`,
        "&:before": {
          borderTop: `${7}px solid #bbb`
        },
        "&:after": {
          borderTop: `${7}px solid #f5f5f5`,
          bottom: "1px"
        }
      },
      ".cm-tooltip-below &": {
        top: `-${7}px`,
        "&:before": {
          borderBottom: `${7}px solid #bbb`
        },
        "&:after": {
          borderBottom: `${7}px solid #f5f5f5`,
          top: "1px"
        }
      }
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
      "&:before": {
        borderTopColor: "#333338",
        borderBottomColor: "#333338"
      },
      "&:after": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
      }
    }
  });
  var noOffset = { x: 0, y: 0 };
  var showTooltip = /* @__PURE__ */ Facet.define({
    enables: [tooltipPlugin, baseTheme]
  });
  var showHoverTooltip = /* @__PURE__ */ Facet.define();
  var HoverTooltipHost = class {
    constructor(view) {
      this.view = view;
      this.mounted = false;
      this.dom = document.createElement("div");
      this.dom.classList.add("cm-tooltip-hover");
      this.manager = new TooltipViewManager(view, showHoverTooltip, (t2) => this.createHostedView(t2));
    }
    static create(view) {
      return new HoverTooltipHost(view);
    }
    createHostedView(tooltip) {
      let hostedView = tooltip.create(this.view);
      hostedView.dom.classList.add("cm-tooltip-section");
      this.dom.appendChild(hostedView.dom);
      if (this.mounted && hostedView.mount)
        hostedView.mount(this.view);
      return hostedView;
    }
    mount(view) {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.mount)
          hostedView.mount(view);
      }
      this.mounted = true;
    }
    positioned() {
      for (let hostedView of this.manager.tooltipViews) {
        if (hostedView.positioned)
          hostedView.positioned();
      }
    }
    update(update3) {
      this.manager.update(update3);
    }
  };
  var showHoverTooltipHost = /* @__PURE__ */ showTooltip.compute([showHoverTooltip], (state3) => {
    let tooltips = state3.facet(showHoverTooltip).filter((t2) => t2);
    if (tooltips.length === 0)
      return null;
    return {
      pos: Math.min(...tooltips.map((t2) => t2.pos)),
      end: Math.max(...tooltips.filter((t2) => t2.end != null).map((t2) => t2.end)),
      create: HoverTooltipHost.create,
      above: tooltips[0].above,
      arrow: tooltips.some((t2) => t2.arrow)
    };
  });
  var HoverPlugin = class {
    constructor(view, source, field, setHover, hoverTime) {
      this.view = view;
      this.source = source;
      this.field = field;
      this.setHover = setHover;
      this.hoverTime = hoverTime;
      this.hoverTimeout = -1;
      this.restartTimeout = -1;
      this.pending = null;
      this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
      this.checkHover = this.checkHover.bind(this);
      view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
      view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
      if (this.pending) {
        this.pending = null;
        clearTimeout(this.restartTimeout);
        this.restartTimeout = setTimeout(() => this.startHover(), 20);
      }
    }
    get active() {
      return this.view.state.field(this.field);
    }
    checkHover() {
      this.hoverTimeout = -1;
      if (this.active)
        return;
      let hovered = Date.now() - this.lastMove.time;
      if (hovered < this.hoverTime)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
      else
        this.startHover();
    }
    startHover() {
      clearTimeout(this.restartTimeout);
      let { lastMove } = this;
      let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(lastMove) : null;
      if (pos == null)
        return;
      let posCoords = this.view.coordsAtPos(pos);
      if (posCoords == null || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - this.view.defaultCharacterWidth || lastMove.x > posCoords.right + this.view.defaultCharacterWidth)
        return;
      let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find((s) => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      let open = this.source(this.view, pos, lastMove.x < posCoords.left ? -rtl : rtl);
      if (open === null || open === void 0 ? void 0 : open.then) {
        let pending = this.pending = { pos };
        open.then((result) => {
          if (this.pending == pending) {
            this.pending = null;
            if (result)
              this.view.dispatch({ effects: this.setHover.of(result) });
          }
        }, (e2) => logException(this.view.state, e2, "hover tooltip"));
      } else if (open) {
        this.view.dispatch({ effects: this.setHover.of(open) });
      }
    }
    mousemove(event) {
      var _a2;
      this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
      if (this.hoverTimeout < 0)
        this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
      let tooltip = this.active;
      if (tooltip && !isInTooltip(this.lastMove.target) || this.pending) {
        let { pos } = tooltip || this.pending, end = (_a2 = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a2 !== void 0 ? _a2 : pos;
        if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, 6)) {
          this.view.dispatch({ effects: this.setHover.of(null) });
          this.pending = null;
        }
      }
    }
    mouseleave() {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = -1;
      if (this.active)
        this.view.dispatch({ effects: this.setHover.of(null) });
    }
    destroy() {
      clearTimeout(this.hoverTimeout);
      this.view.dom.removeEventListener("mouseleave", this.mouseleave);
      this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
  };
  function isInTooltip(elt) {
    for (let cur2 = elt; cur2; cur2 = cur2.parentNode)
      if (cur2.nodeType == 1 && cur2.classList.contains("cm-tooltip"))
        return true;
    return false;
  }
  function isOverRange(view, from, to2, x, y, margin) {
    let range2 = document.createRange();
    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to2);
    range2.setEnd(toDOM.node, toDOM.offset);
    range2.setStart(fromDOM.node, fromDOM.offset);
    let rects = range2.getClientRects();
    range2.detach();
    for (let i2 = 0; i2 < rects.length; i2++) {
      let rect = rects[i2];
      let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);
      if (dist <= margin)
        return true;
    }
    return false;
  }
  function hoverTooltip(source, options2 = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
      create() {
        return null;
      },
      update(value, tr) {
        if (value && (options2.hideOnChange && (tr.docChanged || tr.selection) || options2.hideOn && options2.hideOn(tr, value)))
          return null;
        if (value && tr.docChanged) {
          let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
          if (newPos == null)
            return null;
          let copy = Object.assign(/* @__PURE__ */ Object.create(null), value);
          copy.pos = newPos;
          if (value.end != null)
            copy.end = tr.changes.mapPos(value.end);
          value = copy;
        }
        for (let effect of tr.effects) {
          if (effect.is(setHover))
            value = effect.value;
          if (effect.is(closeHoverTooltipEffect))
            value = null;
        }
        return value;
      },
      provide: (f) => showHoverTooltip.from(f)
    });
    return [
      hoverState,
      ViewPlugin.define((view) => new HoverPlugin(view, source, hoverState, setHover, options2.hoverTime || 300)),
      showHoverTooltipHost
    ];
  }
  function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
      return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
  }
  var closeHoverTooltipEffect = /* @__PURE__ */ StateEffect.define();
  var panelConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      let topContainer, bottomContainer;
      for (let c4 of configs) {
        topContainer = topContainer || c4.topContainer;
        bottomContainer = bottomContainer || c4.bottomContainer;
      }
      return { topContainer, bottomContainer };
    }
  });
  function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
  }
  var panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.input = view.state.facet(showPanel);
      this.specs = this.input.filter((s) => s);
      this.panels = this.specs.map((spec) => spec(view));
      let conf = view.state.facet(panelConfig);
      this.top = new PanelGroup(view, true, conf.topContainer);
      this.bottom = new PanelGroup(view, false, conf.bottomContainer);
      this.top.sync(this.panels.filter((p2) => p2.top));
      this.bottom.sync(this.panels.filter((p2) => !p2.top));
      for (let p2 of this.panels) {
        p2.dom.classList.add("cm-panel");
        if (p2.mount)
          p2.mount();
      }
    }
    update(update3) {
      let conf = update3.state.facet(panelConfig);
      if (this.top.container != conf.topContainer) {
        this.top.sync([]);
        this.top = new PanelGroup(update3.view, true, conf.topContainer);
      }
      if (this.bottom.container != conf.bottomContainer) {
        this.bottom.sync([]);
        this.bottom = new PanelGroup(update3.view, false, conf.bottomContainer);
      }
      this.top.syncClasses();
      this.bottom.syncClasses();
      let input = update3.state.facet(showPanel);
      if (input != this.input) {
        let specs = input.filter((x) => x);
        let panels = [], top2 = [], bottom = [], mount = [];
        for (let spec of specs) {
          let known = this.specs.indexOf(spec), panel;
          if (known < 0) {
            panel = spec(update3.view);
            mount.push(panel);
          } else {
            panel = this.panels[known];
            if (panel.update)
              panel.update(update3);
          }
          panels.push(panel);
          (panel.top ? top2 : bottom).push(panel);
        }
        this.specs = specs;
        this.panels = panels;
        this.top.sync(top2);
        this.bottom.sync(bottom);
        for (let p2 of mount) {
          p2.dom.classList.add("cm-panel");
          if (p2.mount)
            p2.mount();
        }
      } else {
        for (let p2 of this.panels)
          if (p2.update)
            p2.update(update3);
      }
    }
    destroy() {
      this.top.sync([]);
      this.bottom.sync([]);
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
  });
  var PanelGroup = class {
    constructor(view, top2, container) {
      this.view = view;
      this.top = top2;
      this.container = container;
      this.dom = void 0;
      this.classes = "";
      this.panels = [];
      this.syncClasses();
    }
    sync(panels) {
      for (let p2 of this.panels)
        if (p2.destroy && panels.indexOf(p2) < 0)
          p2.destroy();
      this.panels = panels;
      this.syncDOM();
    }
    syncDOM() {
      if (this.panels.length == 0) {
        if (this.dom) {
          this.dom.remove();
          this.dom = void 0;
        }
        return;
      }
      if (!this.dom) {
        this.dom = document.createElement("div");
        this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
        this.dom.style[this.top ? "top" : "bottom"] = "0";
        let parent = this.container || this.view.dom;
        parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
      }
      let curDOM = this.dom.firstChild;
      for (let panel of this.panels) {
        if (panel.dom.parentNode == this.dom) {
          while (curDOM != panel.dom)
            curDOM = rm(curDOM);
          curDOM = curDOM.nextSibling;
        } else {
          this.dom.insertBefore(panel.dom, curDOM);
        }
      }
      while (curDOM)
        curDOM = rm(curDOM);
    }
    scrollMargin() {
      return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
      if (!this.container || this.classes == this.view.themeClasses)
        return;
      for (let cls of this.classes.split(" "))
        if (cls)
          this.container.classList.remove(cls);
      for (let cls of (this.classes = this.view.themeClasses).split(" "))
        if (cls)
          this.container.classList.add(cls);
    }
  };
  function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
  }
  var showPanel = /* @__PURE__ */ Facet.define({
    enables: panelPlugin
  });
  var GutterMarker = class extends RangeValue {
    compare(other) {
      return this == other || this.constructor == other.constructor && this.eq(other);
    }
    eq(other) {
      return false;
    }
    destroy(dom2) {
    }
  };
  GutterMarker.prototype.elementClass = "";
  GutterMarker.prototype.toDOM = void 0;
  GutterMarker.prototype.mapMode = MapMode.TrackBefore;
  GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
  GutterMarker.prototype.point = true;
  var gutterLineClass = /* @__PURE__ */ Facet.define();
  var defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => RangeSet.empty,
    lineMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
  };
  var activeGutters = /* @__PURE__ */ Facet.define();
  function gutter(config2) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config2))];
  }
  var unfixGutters = /* @__PURE__ */ Facet.define({
    combine: (values) => values.some((x) => x)
  });
  function gutters(config2) {
    let result = [
      gutterView
    ];
    if (config2 && config2.fixed === false)
      result.push(unfixGutters.of(true));
    return result;
  }
  var gutterView = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.prevViewport = view.viewport;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutters";
      this.dom.setAttribute("aria-hidden", "true");
      this.dom.style.minHeight = this.view.contentHeight + "px";
      this.gutters = view.state.facet(activeGutters).map((conf) => new SingleGutterView(view, conf));
      for (let gutter2 of this.gutters)
        this.dom.appendChild(gutter2.dom);
      this.fixed = !view.state.facet(unfixGutters);
      if (this.fixed) {
        this.dom.style.position = "sticky";
      }
      this.syncGutters(false);
      view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update3) {
      if (this.updateGutters(update3)) {
        let vpA = this.prevViewport, vpB = update3.view.viewport;
        let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
        this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
      }
      if (update3.geometryChanged)
        this.dom.style.minHeight = this.view.contentHeight + "px";
      if (this.view.state.facet(unfixGutters) != !this.fixed) {
        this.fixed = !this.fixed;
        this.dom.style.position = this.fixed ? "sticky" : "";
      }
      this.prevViewport = update3.view.viewport;
    }
    syncGutters(detach) {
      let after = this.dom.nextSibling;
      if (detach)
        this.dom.remove();
      let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
      let classSet = [];
      let contexts = this.gutters.map((gutter2) => new UpdateContext(gutter2, this.view.viewport, -this.view.documentPadding.top));
      for (let line of this.view.viewportLineBlocks) {
        let text;
        if (Array.isArray(line.type)) {
          for (let b2 of line.type)
            if (b2.type == BlockType.Text) {
              text = b2;
              break;
            }
        } else {
          text = line.type == BlockType.Text ? line : void 0;
        }
        if (!text)
          continue;
        if (classSet.length)
          classSet = [];
        advanceCursor(lineClasses, classSet, line.from);
        for (let cx of contexts)
          cx.line(this.view, text, classSet);
      }
      for (let cx of contexts)
        cx.finish();
      if (detach)
        this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update3) {
      let prev = update3.startState.facet(activeGutters), cur2 = update3.state.facet(activeGutters);
      let change = update3.docChanged || update3.heightChanged || update3.viewportChanged || !RangeSet.eq(update3.startState.facet(gutterLineClass), update3.state.facet(gutterLineClass), update3.view.viewport.from, update3.view.viewport.to);
      if (prev == cur2) {
        for (let gutter2 of this.gutters)
          if (gutter2.update(update3))
            change = true;
      } else {
        change = true;
        let gutters2 = [];
        for (let conf of cur2) {
          let known = prev.indexOf(conf);
          if (known < 0) {
            gutters2.push(new SingleGutterView(this.view, conf));
          } else {
            this.gutters[known].update(update3);
            gutters2.push(this.gutters[known]);
          }
        }
        for (let g2 of this.gutters) {
          g2.dom.remove();
          if (gutters2.indexOf(g2) < 0)
            g2.destroy();
        }
        for (let g2 of gutters2)
          this.dom.appendChild(g2.dom);
        this.gutters = gutters2;
      }
      return change;
    }
    destroy() {
      for (let view of this.gutters)
        view.destroy();
      this.dom.remove();
    }
  }, {
    provide: (plugin) => EditorView.scrollMargins.of((view) => {
      let value = view.plugin(plugin);
      if (!value || value.gutters.length == 0 || !value.fixed)
        return null;
      return view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };
    })
  });
  function asArray2(val) {
    return Array.isArray(val) ? val : [val];
  }
  function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
      if (cursor.from == pos)
        collect.push(cursor.value);
      cursor.next();
    }
  }
  var UpdateContext = class {
    constructor(gutter2, viewport, height) {
      this.gutter = gutter2;
      this.height = height;
      this.localMarkers = [];
      this.i = 0;
      this.cursor = RangeSet.iter(gutter2.markers, viewport.from);
    }
    line(view, line, extraMarkers) {
      if (this.localMarkers.length)
        this.localMarkers = [];
      advanceCursor(this.cursor, this.localMarkers, line.from);
      let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;
      let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
      if (forLine)
        localMarkers.unshift(forLine);
      let gutter2 = this.gutter;
      if (localMarkers.length == 0 && !gutter2.config.renderEmptyElements)
        return;
      let above = line.top - this.height;
      if (this.i == gutter2.elements.length) {
        let newElt = new GutterElement(view, line.height, above, localMarkers);
        gutter2.elements.push(newElt);
        gutter2.dom.appendChild(newElt.dom);
      } else {
        gutter2.elements[this.i].update(view, line.height, above, localMarkers);
      }
      this.height = line.bottom;
      this.i++;
    }
    finish() {
      let gutter2 = this.gutter;
      while (gutter2.elements.length > this.i) {
        let last2 = gutter2.elements.pop();
        gutter2.dom.removeChild(last2.dom);
        last2.destroy();
      }
    }
  };
  var SingleGutterView = class {
    constructor(view, config2) {
      this.view = view;
      this.config = config2;
      this.elements = [];
      this.spacer = null;
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
      for (let prop in config2.domEventHandlers) {
        this.dom.addEventListener(prop, (event) => {
          let line = view.lineBlockAtHeight(event.clientY - view.documentTop);
          if (config2.domEventHandlers[prop](view, line, event))
            event.preventDefault();
        });
      }
      this.markers = asArray2(config2.markers(view));
      if (config2.initialSpacer) {
        this.spacer = new GutterElement(view, 0, 0, [config2.initialSpacer(view)]);
        this.dom.appendChild(this.spacer.dom);
        this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
      }
    }
    update(update3) {
      let prevMarkers = this.markers;
      this.markers = asArray2(this.config.markers(update3.view));
      if (this.spacer && this.config.updateSpacer) {
        let updated = this.config.updateSpacer(this.spacer.markers[0], update3);
        if (updated != this.spacer.markers[0])
          this.spacer.update(update3.view, 0, 0, [updated]);
      }
      let vp = update3.view.viewport;
      return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update3) : false);
    }
    destroy() {
      for (let elt of this.elements)
        elt.destroy();
    }
  };
  var GutterElement = class {
    constructor(view, height, above, markers) {
      this.height = -1;
      this.above = 0;
      this.markers = [];
      this.dom = document.createElement("div");
      this.dom.className = "cm-gutterElement";
      this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
      if (this.height != height)
        this.dom.style.height = (this.height = height) + "px";
      if (this.above != above)
        this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
      if (!sameMarkers(this.markers, markers))
        this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
      let cls = "cm-gutterElement", domPos = this.dom.firstChild;
      for (let iNew = 0, iOld = 0; ; ) {
        let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
        if (marker) {
          let c4 = marker.elementClass;
          if (c4)
            cls += " " + c4;
          for (let i2 = iOld; i2 < this.markers.length; i2++)
            if (this.markers[i2].compare(marker)) {
              skipTo = i2;
              matched = true;
              break;
            }
        } else {
          skipTo = this.markers.length;
        }
        while (iOld < skipTo) {
          let next = this.markers[iOld++];
          if (next.toDOM) {
            next.destroy(domPos);
            let after = domPos.nextSibling;
            domPos.remove();
            domPos = after;
          }
        }
        if (!marker)
          break;
        if (marker.toDOM) {
          if (matched)
            domPos = domPos.nextSibling;
          else
            this.dom.insertBefore(marker.toDOM(view), domPos);
        }
        if (matched)
          iOld++;
      }
      this.dom.className = cls;
      this.markers = markers;
    }
    destroy() {
      this.setMarkers(null, []);
    }
  };
  function sameMarkers(a2, b2) {
    if (a2.length != b2.length)
      return false;
    for (let i2 = 0; i2 < a2.length; i2++)
      if (!a2[i2].compare(b2[i2]))
        return false;
    return true;
  }
  var lineNumberMarkers = /* @__PURE__ */ Facet.define();
  var lineNumberConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
        domEventHandlers(a2, b2) {
          let result = Object.assign({}, a2);
          for (let event in b2) {
            let exists = result[event], add2 = b2[event];
            result[event] = exists ? (view, line, event2) => exists(view, line, event2) || add2(view, line, event2) : add2;
          }
          return result;
        }
      });
    }
  });
  var NumberMarker = class extends GutterMarker {
    constructor(number2) {
      super();
      this.number = number2;
    }
    eq(other) {
      return this.number == other.number;
    }
    toDOM() {
      return document.createTextNode(this.number);
    }
  };
  function formatNumber(view, number2) {
    return view.state.facet(lineNumberConfig).formatNumber(number2, view.state);
  }
  var lineNumberGutter = /* @__PURE__ */ activeGutters.compute([lineNumberConfig], (state3) => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) {
      return view.state.facet(lineNumberMarkers);
    },
    lineMarker(view, line, others) {
      if (others.some((m3) => m3.toDOM))
        return null;
      return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    lineMarkerChange: (update3) => update3.startState.facet(lineNumberConfig) != update3.state.facet(lineNumberConfig),
    initialSpacer(view) {
      return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update3) {
      let max3 = formatNumber(update3.view, maxLineNumber(update3.view.state.doc.lines));
      return max3 == spacer.number ? spacer : new NumberMarker(max3);
    },
    domEventHandlers: state3.facet(lineNumberConfig).domEventHandlers
  }));
  function lineNumbers(config2 = {}) {
    return [
      lineNumberConfig.of(config2),
      gutters(),
      lineNumberGutter
    ];
  }
  function maxLineNumber(lines) {
    let last2 = 9;
    while (last2 < lines)
      last2 = last2 * 10 + 9;
    return last2;
  }
  var activeLineGutterMarker = /* @__PURE__ */ new class extends GutterMarker {
    constructor() {
      super(...arguments);
      this.elementClass = "cm-activeLineGutter";
    }
  }();
  var activeLineGutterHighlighter = /* @__PURE__ */ gutterLineClass.compute(["selection"], (state3) => {
    let marks2 = [], last2 = -1;
    for (let range2 of state3.selection.ranges)
      if (range2.empty) {
        let linePos = state3.doc.lineAt(range2.head).from;
        if (linePos > last2) {
          last2 = linePos;
          marks2.push(activeLineGutterMarker.range(linePos));
        }
      }
    return RangeSet.of(marks2);
  });
  function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
  }

  // node_modules/@lezer/common/dist/index.js
  var DefaultBufferLength = 1024;
  var nextPropID = 0;
  var Range2 = class {
    constructor(from, to2) {
      this.from = from;
      this.to = to2;
    }
  };
  var NodeProp = class {
    constructor(config2 = {}) {
      this.id = nextPropID++;
      this.perNode = !!config2.perNode;
      this.deserialize = config2.deserialize || (() => {
        throw new Error("This node type doesn't define a deserialize function");
      });
    }
    add(match) {
      if (this.perNode)
        throw new RangeError("Can't add per-node props to node types");
      if (typeof match != "function")
        match = NodeType.match(match);
      return (type2) => {
        let result = match(type2);
        return result === void 0 ? null : [this, result];
      };
    }
  };
  NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
  NodeProp.contextHash = new NodeProp({ perNode: true });
  NodeProp.lookAhead = new NodeProp({ perNode: true });
  NodeProp.mounted = new NodeProp({ perNode: true });
  var noProps = /* @__PURE__ */ Object.create(null);
  var NodeType = class {
    constructor(name3, props, id2, flags = 0) {
      this.name = name3;
      this.props = props;
      this.id = id2;
      this.flags = flags;
    }
    static define(spec) {
      let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
      let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
      let type2 = new NodeType(spec.name || "", props, spec.id, flags);
      if (spec.props)
        for (let src of spec.props) {
          if (!Array.isArray(src))
            src = src(type2);
          if (src) {
            if (src[0].perNode)
              throw new RangeError("Can't store a per-node prop on a node type");
            props[src[0].id] = src[1];
          }
        }
      return type2;
    }
    prop(prop) {
      return this.props[prop.id];
    }
    get isTop() {
      return (this.flags & 1) > 0;
    }
    get isSkipped() {
      return (this.flags & 2) > 0;
    }
    get isError() {
      return (this.flags & 4) > 0;
    }
    get isAnonymous() {
      return (this.flags & 8) > 0;
    }
    is(name3) {
      if (typeof name3 == "string") {
        if (this.name == name3)
          return true;
        let group = this.prop(NodeProp.group);
        return group ? group.indexOf(name3) > -1 : false;
      }
      return this.id == name3;
    }
    static match(map) {
      let direct = /* @__PURE__ */ Object.create(null);
      for (let prop in map)
        for (let name3 of prop.split(" "))
          direct[name3] = map[prop];
      return (node) => {
        for (let groups = node.prop(NodeProp.group), i2 = -1; i2 < (groups ? groups.length : 0); i2++) {
          let found = direct[i2 < 0 ? node.name : groups[i2]];
          if (found)
            return found;
        }
      };
    }
  };
  NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
  var CachedNode = /* @__PURE__ */ new WeakMap();
  var CachedInnerNode = /* @__PURE__ */ new WeakMap();
  var IterMode;
  (function(IterMode2) {
    IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
    IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
  })(IterMode || (IterMode = {}));
  var Tree = class {
    constructor(type2, children, positions, length, props) {
      this.type = type2;
      this.children = children;
      this.positions = positions;
      this.length = length;
      this.props = null;
      if (props && props.length) {
        this.props = /* @__PURE__ */ Object.create(null);
        for (let [prop, value] of props)
          this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
    toString() {
      let mounted = this.prop(NodeProp.mounted);
      if (mounted && !mounted.overlay)
        return mounted.tree.toString();
      let children = "";
      for (let ch of this.children) {
        let str = ch.toString();
        if (str) {
          if (children)
            children += ",";
          children += str;
        }
      }
      return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
    }
    cursor(mode = 0) {
      return new TreeCursor(this.topNode, mode);
    }
    cursorAt(pos, side = 0, mode = 0) {
      let scope = CachedNode.get(this) || this.topNode;
      let cursor = new TreeCursor(scope);
      cursor.moveTo(pos, side);
      CachedNode.set(this, cursor._tree);
      return cursor;
    }
    get topNode() {
      return new TreeNode(this, 0, 0, null);
    }
    resolve(pos, side = 0) {
      let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
      CachedNode.set(this, node);
      return node;
    }
    resolveInner(pos, side = 0) {
      let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
      CachedInnerNode.set(this, node);
      return node;
    }
    iterate(spec) {
      let { enter, leave, from = 0, to: to2 = this.length } = spec;
      for (let c4 = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
        let entered = false;
        if (c4.from <= to2 && c4.to >= from && (c4.type.isAnonymous || enter(c4) !== false)) {
          if (c4.firstChild())
            continue;
          entered = true;
        }
        for (; ; ) {
          if (entered && leave && !c4.type.isAnonymous)
            leave(c4);
          if (c4.nextSibling())
            break;
          if (!c4.parent())
            return;
          entered = true;
        }
      }
    }
    prop(prop) {
      return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
    }
    get propValues() {
      let result = [];
      if (this.props)
        for (let id2 in this.props)
          result.push([+id2, this.props[id2]]);
      return result;
    }
    balance(config2 = {}) {
      return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config2.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
    }
    static build(data) {
      return buildTree(data);
    }
  };
  Tree.empty = new Tree(NodeType.none, [], [], 0);
  var FlatBufferCursor = class {
    constructor(buffer, index) {
      this.buffer = buffer;
      this.index = index;
    }
    get id() {
      return this.buffer[this.index - 4];
    }
    get start() {
      return this.buffer[this.index - 3];
    }
    get end() {
      return this.buffer[this.index - 2];
    }
    get size() {
      return this.buffer[this.index - 1];
    }
    get pos() {
      return this.index;
    }
    next() {
      this.index -= 4;
    }
    fork() {
      return new FlatBufferCursor(this.buffer, this.index);
    }
  };
  var TreeBuffer = class {
    constructor(buffer, length, set3) {
      this.buffer = buffer;
      this.length = length;
      this.set = set3;
    }
    get type() {
      return NodeType.none;
    }
    toString() {
      let result = [];
      for (let index = 0; index < this.buffer.length; ) {
        result.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result.join(",");
    }
    childString(index) {
      let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
      let type2 = this.set.types[id2], result = type2.name;
      if (/\W/.test(result) && !type2.isError)
        result = JSON.stringify(result);
      index += 4;
      if (endIndex == index)
        return result;
      let children = [];
      while (index < endIndex) {
        children.push(this.childString(index));
        index = this.buffer[index + 3];
      }
      return result + "(" + children.join(",") + ")";
    }
    findChild(startIndex, endIndex, dir, pos, side) {
      let { buffer } = this, pick = -1;
      for (let i2 = startIndex; i2 != endIndex; i2 = buffer[i2 + 3]) {
        if (checkSide(side, pos, buffer[i2 + 1], buffer[i2 + 2])) {
          pick = i2;
          if (dir > 0)
            break;
        }
      }
      return pick;
    }
    slice(startI, endI, from, to2) {
      let b2 = this.buffer;
      let copy = new Uint16Array(endI - startI);
      for (let i2 = startI, j = 0; i2 < endI; ) {
        copy[j++] = b2[i2++];
        copy[j++] = b2[i2++] - from;
        copy[j++] = b2[i2++] - from;
        copy[j++] = b2[i2++] - startI;
      }
      return new TreeBuffer(copy, to2 - from, this.set);
    }
  };
  function checkSide(side, pos, from, to2) {
    switch (side) {
      case -2:
        return from < pos;
      case -1:
        return to2 >= pos && from < pos;
      case 0:
        return from < pos && to2 > pos;
      case 1:
        return from <= pos && to2 > pos;
      case 2:
        return to2 > pos;
      case 4:
        return true;
    }
  }
  function enterUnfinishedNodesBefore(node, pos) {
    let scan = node.childBefore(pos);
    while (scan) {
      let last2 = scan.lastChild;
      if (!last2 || last2.to != scan.to)
        break;
      if (last2.type.isError && last2.from == last2.to) {
        node = scan;
        scan = last2.prevSibling;
      } else {
        scan = last2;
      }
    }
    return node;
  }
  function resolveNode(node, pos, side, overlays) {
    var _a2;
    while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
      let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
      if (!parent)
        return node;
      node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    if (overlays)
      for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
        if (scan instanceof TreeNode && scan.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan.from)
          node = parent;
      }
    for (; ; ) {
      let inner = node.enter(pos, side, mode);
      if (!inner)
        return node;
      node = inner;
    }
  }
  var TreeNode = class {
    constructor(_tree, from, index, _parent) {
      this._tree = _tree;
      this.from = from;
      this.index = index;
      this._parent = _parent;
    }
    get type() {
      return this._tree.type;
    }
    get name() {
      return this._tree.type.name;
    }
    get to() {
      return this.from + this._tree.length;
    }
    nextChild(i2, dir, pos, side, mode = 0) {
      for (let parent = this; ; ) {
        for (let { children, positions } = parent._tree, e2 = dir > 0 ? children.length : -1; i2 != e2; i2 += dir) {
          let next = children[i2], start2 = positions[i2] + parent.from;
          if (!checkSide(side, pos, start2, start2 + next.length))
            continue;
          if (next instanceof TreeBuffer) {
            if (mode & IterMode.ExcludeBuffers)
              continue;
            let index = next.findChild(0, next.buffer.length, dir, pos - start2, side);
            if (index > -1)
              return new BufferNode(new BufferContext(parent, next, i2, start2), null, index);
          } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
            let mounted;
            if (!(mode & IterMode.IgnoreMounts) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)
              return new TreeNode(mounted.tree, start2, i2, parent);
            let inner = new TreeNode(next, start2, i2, parent);
            return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
          }
        }
        if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
          return null;
        if (parent.index >= 0)
          i2 = parent.index + dir;
        else
          i2 = dir < 0 ? -1 : parent._parent._tree.children.length;
        parent = parent._parent;
        if (!parent)
          return null;
      }
    }
    get firstChild() {
      return this.nextChild(0, 1, 0, 4);
    }
    get lastChild() {
      return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
    }
    childAfter(pos) {
      return this.nextChild(0, 1, pos, 2);
    }
    childBefore(pos) {
      return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      let mounted;
      if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
        let rPos = pos - this.from;
        for (let { from, to: to2 } of mounted.overlay) {
          if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos))
            return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
        }
      }
      return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
      let val = this;
      while (val.type.isAnonymous && val._parent)
        val = val._parent;
      return val;
    }
    get parent() {
      return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
    }
    get prevSibling() {
      return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return this._tree;
    }
    toTree() {
      return this._tree;
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    getChild(type2, before = null, after = null) {
      let r = getChildren(this, type2, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    toString() {
      return this._tree.toString();
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  function getChildren(node, type2, before, after) {
    let cur2 = node.cursor(), result = [];
    if (!cur2.firstChild())
      return result;
    if (before != null) {
      while (!cur2.type.is(before))
        if (!cur2.nextSibling())
          return result;
    }
    for (; ; ) {
      if (after != null && cur2.type.is(after))
        return result;
      if (cur2.type.is(type2))
        result.push(cur2.node);
      if (!cur2.nextSibling())
        return after == null ? result : [];
    }
  }
  function matchNodeContext(node, context2, i2 = context2.length - 1) {
    for (let p2 = node.parent; i2 >= 0; p2 = p2.parent) {
      if (!p2)
        return false;
      if (!p2.type.isAnonymous) {
        if (context2[i2] && context2[i2] != p2.name)
          return false;
        i2--;
      }
    }
    return true;
  }
  var BufferContext = class {
    constructor(parent, buffer, index, start2) {
      this.parent = parent;
      this.buffer = buffer;
      this.index = index;
      this.start = start2;
    }
  };
  var BufferNode = class {
    constructor(context2, _parent, index) {
      this.context = context2;
      this._parent = _parent;
      this.index = index;
      this.type = context2.buffer.set.types[context2.buffer.buffer[index]];
    }
    get name() {
      return this.type.name;
    }
    get from() {
      return this.context.start + this.context.buffer.buffer[this.index + 1];
    }
    get to() {
      return this.context.start + this.context.buffer.buffer[this.index + 2];
    }
    child(dir, pos, side) {
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() {
      return this.child(1, 0, 4);
    }
    get lastChild() {
      return this.child(-1, 0, 4);
    }
    childAfter(pos) {
      return this.child(1, pos, 2);
    }
    childBefore(pos) {
      return this.child(-1, pos, -2);
    }
    enter(pos, side, mode = 0) {
      if (mode & IterMode.ExcludeBuffers)
        return null;
      let { buffer } = this.context;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
      return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
      return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
      return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
    }
    get nextSibling() {
      let { buffer } = this.context;
      let after = buffer.buffer[this.index + 3];
      if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
        return new BufferNode(this.context, this._parent, after);
      return this.externalSibling(1);
    }
    get prevSibling() {
      let { buffer } = this.context;
      let parentStart = this._parent ? this._parent.index + 4 : 0;
      if (this.index == parentStart)
        return this.externalSibling(-1);
      return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
    }
    cursor(mode = 0) {
      return new TreeCursor(this, mode);
    }
    get tree() {
      return null;
    }
    toTree() {
      let children = [], positions = [];
      let { buffer } = this.context;
      let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
      if (endI > startI) {
        let from = buffer.buffer[this.index + 1], to2 = buffer.buffer[this.index + 2];
        children.push(buffer.slice(startI, endI, from, to2));
        positions.push(0);
      }
      return new Tree(this.type, children, positions, this.to - this.from);
    }
    resolve(pos, side = 0) {
      return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
      return resolveNode(this, pos, side, true);
    }
    enterUnfinishedNodesBefore(pos) {
      return enterUnfinishedNodesBefore(this, pos);
    }
    toString() {
      return this.context.buffer.childString(this.index);
    }
    getChild(type2, before = null, after = null) {
      let r = getChildren(this, type2, before, after);
      return r.length ? r[0] : null;
    }
    getChildren(type2, before = null, after = null) {
      return getChildren(this, type2, before, after);
    }
    get node() {
      return this;
    }
    matchContext(context2) {
      return matchNodeContext(this, context2);
    }
  };
  var TreeCursor = class {
    constructor(node, mode = 0) {
      this.mode = mode;
      this.buffer = null;
      this.stack = [];
      this.index = 0;
      this.bufferNode = null;
      if (node instanceof TreeNode) {
        this.yieldNode(node);
      } else {
        this._tree = node.context.parent;
        this.buffer = node.context;
        for (let n2 = node._parent; n2; n2 = n2._parent)
          this.stack.unshift(n2.index);
        this.bufferNode = node;
        this.yieldBuf(node.index);
      }
    }
    get name() {
      return this.type.name;
    }
    yieldNode(node) {
      if (!node)
        return false;
      this._tree = node;
      this.type = node.type;
      this.from = node.from;
      this.to = node.to;
      return true;
    }
    yieldBuf(index, type2) {
      this.index = index;
      let { start: start2, buffer } = this.buffer;
      this.type = type2 || buffer.set.types[buffer.buffer[index]];
      this.from = start2 + buffer.buffer[index + 1];
      this.to = start2 + buffer.buffer[index + 2];
      return true;
    }
    yield(node) {
      if (!node)
        return false;
      if (node instanceof TreeNode) {
        this.buffer = null;
        return this.yieldNode(node);
      }
      this.buffer = node.context;
      return this.yieldBuf(node.index, node.type);
    }
    toString() {
      return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    enterChild(dir, pos, side) {
      if (!this.buffer)
        return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
      let { buffer } = this.buffer;
      let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
      if (index < 0)
        return false;
      this.stack.push(this.index);
      return this.yieldBuf(index);
    }
    firstChild() {
      return this.enterChild(1, 0, 4);
    }
    lastChild() {
      return this.enterChild(-1, 0, 4);
    }
    childAfter(pos) {
      return this.enterChild(1, pos, 2);
    }
    childBefore(pos) {
      return this.enterChild(-1, pos, -2);
    }
    enter(pos, side, mode = this.mode) {
      if (!this.buffer)
        return this.yield(this._tree.enter(pos, side, mode));
      return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    parent() {
      if (!this.buffer)
        return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
      if (this.stack.length)
        return this.yieldBuf(this.stack.pop());
      let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
      this.buffer = null;
      return this.yieldNode(parent);
    }
    sibling(dir) {
      if (!this.buffer)
        return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
      let { buffer } = this.buffer, d2 = this.stack.length - 1;
      if (dir < 0) {
        let parentStart = d2 < 0 ? 0 : this.stack[d2] + 4;
        if (this.index != parentStart)
          return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
      } else {
        let after = buffer.buffer[this.index + 3];
        if (after < (d2 < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d2] + 3]))
          return this.yieldBuf(after);
      }
      return d2 < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
    }
    nextSibling() {
      return this.sibling(1);
    }
    prevSibling() {
      return this.sibling(-1);
    }
    atLastNode(dir) {
      let index, parent, { buffer } = this;
      if (buffer) {
        if (dir > 0) {
          if (this.index < buffer.buffer.buffer.length)
            return false;
        } else {
          for (let i2 = 0; i2 < this.index; i2++)
            if (buffer.buffer.buffer[i2 + 3] < this.index)
              return false;
        }
        ({ index, parent } = buffer);
      } else {
        ({ index, _parent: parent } = this._tree);
      }
      for (; parent; { index, _parent: parent } = parent) {
        if (index > -1)
          for (let i2 = index + dir, e2 = dir < 0 ? -1 : parent._tree.children.length; i2 != e2; i2 += dir) {
            let child = parent._tree.children[i2];
            if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
              return false;
          }
      }
      return true;
    }
    move(dir, enter) {
      if (enter && this.enterChild(dir, 0, 4))
        return true;
      for (; ; ) {
        if (this.sibling(dir))
          return true;
        if (this.atLastNode(dir) || !this.parent())
          return false;
      }
    }
    next(enter = true) {
      return this.move(1, enter);
    }
    prev(enter = true) {
      return this.move(-1, enter);
    }
    moveTo(pos, side = 0) {
      while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
        if (!this.parent())
          break;
      while (this.enterChild(1, pos, side)) {
      }
      return this;
    }
    get node() {
      if (!this.buffer)
        return this._tree;
      let cache2 = this.bufferNode, result = null, depth = 0;
      if (cache2 && cache2.context == this.buffer) {
        scan:
          for (let index = this.index, d2 = this.stack.length; d2 >= 0; ) {
            for (let c4 = cache2; c4; c4 = c4._parent)
              if (c4.index == index) {
                if (index == this.index)
                  return c4;
                result = c4;
                depth = d2 + 1;
                break scan;
              }
            index = this.stack[--d2];
          }
      }
      for (let i2 = depth; i2 < this.stack.length; i2++)
        result = new BufferNode(this.buffer, result, this.stack[i2]);
      return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    get tree() {
      return this.buffer ? null : this._tree._tree;
    }
    iterate(enter, leave) {
      for (let depth = 0; ; ) {
        let mustLeave = false;
        if (this.type.isAnonymous || enter(this) !== false) {
          if (this.firstChild()) {
            depth++;
            continue;
          }
          if (!this.type.isAnonymous)
            mustLeave = true;
        }
        for (; ; ) {
          if (mustLeave && leave)
            leave(this);
          mustLeave = this.type.isAnonymous;
          if (this.nextSibling())
            break;
          if (!depth)
            return;
          this.parent();
          depth--;
          mustLeave = true;
        }
      }
    }
    matchContext(context2) {
      if (!this.buffer)
        return matchNodeContext(this.node, context2);
      let { buffer } = this.buffer, { types: types2 } = buffer.set;
      for (let i2 = context2.length - 1, d2 = this.stack.length - 1; i2 >= 0; d2--) {
        if (d2 < 0)
          return matchNodeContext(this.node, context2, i2);
        let type2 = types2[buffer.buffer[this.stack[d2]]];
        if (!type2.isAnonymous) {
          if (context2[i2] && context2[i2] != type2.name)
            return false;
          i2--;
        }
      }
      return true;
    }
  };
  function hasChild(tree) {
    return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
  }
  function buildTree(data) {
    var _a2;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types2 = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children2, positions2, inRepeat) {
      let { id: id2, start: start2, end, size: size2 } = cursor;
      let lookAheadAtStart = lookAhead;
      while (size2 < 0) {
        cursor.next();
        if (size2 == -1) {
          let node2 = reused[id2];
          children2.push(node2);
          positions2.push(start2 - parentStart);
          return;
        } else if (size2 == -3) {
          contextHash = id2;
          return;
        } else if (size2 == -4) {
          lookAhead = id2;
          return;
        } else {
          throw new RangeError(`Unrecognized record size: ${size2}`);
        }
      }
      let type2 = types2[id2], node, buffer2;
      let startPos = start2 - parentStart;
      if (end - start2 <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
        let data2 = new Uint16Array(buffer2.size - buffer2.skip);
        let endPos = cursor.pos - buffer2.size, index = data2.length;
        while (cursor.pos > endPos)
          index = copyToBuffer(buffer2.start, data2, index);
        node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
        startPos = buffer2.start - parentStart;
      } else {
        let endPos = cursor.pos - size2;
        cursor.next();
        let localChildren = [], localPositions = [];
        let localInRepeat = id2 >= minRepeatType ? id2 : -1;
        let lastGroup = 0, lastEnd = end;
        while (cursor.pos > endPos) {
          if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
            if (cursor.end <= lastEnd - maxBufferLength) {
              makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
              lastGroup = localChildren.length;
              lastEnd = cursor.end;
            }
            cursor.next();
          } else {
            takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
          }
        }
        if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
          makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
        localChildren.reverse();
        localPositions.reverse();
        if (localInRepeat > -1 && lastGroup > 0) {
          let make = makeBalanced(type2);
          node = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end - start2, make, make);
        } else {
          node = makeTree(type2, localChildren, localPositions, end - start2, lookAheadAtStart - end);
        }
      }
      children2.push(node);
      positions2.push(startPos);
    }
    function makeBalanced(type2) {
      return (children2, positions2, length2) => {
        let lookAhead2 = 0, lastI = children2.length - 1, last2, lookAheadProp;
        if (lastI >= 0 && (last2 = children2[lastI]) instanceof Tree) {
          if (!lastI && last2.type == type2 && last2.length == length2)
            return last2;
          if (lookAheadProp = last2.prop(NodeProp.lookAhead))
            lookAhead2 = positions2[lastI] + last2.length + lookAheadProp;
        }
        return makeTree(type2, children2, positions2, length2, lookAhead2);
      };
    }
    function makeRepeatLeaf(children2, positions2, base2, i2, from, to2, type2, lookAhead2) {
      let localChildren = [], localPositions = [];
      while (children2.length > i2) {
        localChildren.push(children2.pop());
        localPositions.push(positions2.pop() + base2 - from);
      }
      children2.push(makeTree(nodeSet.types[type2], localChildren, localPositions, to2 - from, lookAhead2 - to2));
      positions2.push(from - base2);
    }
    function makeTree(type2, children2, positions2, length2, lookAhead2 = 0, props) {
      if (contextHash) {
        let pair = [NodeProp.contextHash, contextHash];
        props = props ? [pair].concat(props) : [pair];
      }
      if (lookAhead2 > 25) {
        let pair = [NodeProp.lookAhead, lookAhead2];
        props = props ? [pair].concat(props) : [pair];
      }
      return new Tree(type2, children2, positions2, length2, props);
    }
    function findBufferSize(maxSize, inRepeat) {
      let fork = cursor.fork();
      let size2 = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
      let result = { size: 0, start: 0, skip: 0 };
      scan:
        for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
          let nodeSize2 = fork.size;
          if (fork.id == inRepeat && nodeSize2 >= 0) {
            result.size = size2;
            result.start = start2;
            result.skip = skip;
            skip += 4;
            size2 += 4;
            fork.next();
            continue;
          }
          let startPos = fork.pos - nodeSize2;
          if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
            break;
          let localSkipped = fork.id >= minRepeatType ? 4 : 0;
          let nodeStart2 = fork.start;
          fork.next();
          while (fork.pos > startPos) {
            if (fork.size < 0) {
              if (fork.size == -3)
                localSkipped += 4;
              else
                break scan;
            } else if (fork.id >= minRepeatType) {
              localSkipped += 4;
            }
            fork.next();
          }
          start2 = nodeStart2;
          size2 += nodeSize2;
          skip += localSkipped;
        }
      if (inRepeat < 0 || size2 == maxSize) {
        result.size = size2;
        result.start = start2;
        result.skip = skip;
      }
      return result.size > 4 ? result : void 0;
    }
    function copyToBuffer(bufferStart, buffer2, index) {
      let { id: id2, start: start2, end, size: size2 } = cursor;
      cursor.next();
      if (size2 >= 0 && id2 < minRepeatType) {
        let startIndex = index;
        if (size2 > 4) {
          let endPos = cursor.pos - (size2 - 4);
          while (cursor.pos > endPos)
            index = copyToBuffer(bufferStart, buffer2, index);
        }
        buffer2[--index] = startIndex;
        buffer2[--index] = end - bufferStart;
        buffer2[--index] = start2 - bufferStart;
        buffer2[--index] = id2;
      } else if (size2 == -3) {
        contextHash = id2;
      } else if (size2 == -4) {
        lookAhead = id2;
      }
      return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
      takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);
    let length = (_a2 = data.length) !== null && _a2 !== void 0 ? _a2 : children.length ? positions[0] + children[0].length : 0;
    return new Tree(types2[data.topID], children.reverse(), positions.reverse(), length);
  }
  var nodeSizeCache = /* @__PURE__ */ new WeakMap();
  function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
      return 1;
    let size2 = nodeSizeCache.get(node);
    if (size2 == null) {
      size2 = 1;
      for (let child of node.children) {
        if (child.type != balanceType || !(child instanceof Tree)) {
          size2 = 1;
          break;
        }
        size2 += nodeSize(balanceType, child);
      }
      nodeSizeCache.set(node, size2);
    }
    return size2;
  }
  function balanceRange(balanceType, children, positions, from, to2, start2, length, mkTop, mkTree) {
    let total = 0;
    for (let i2 = from; i2 < to2; i2++)
      total += nodeSize(balanceType, children[i2]);
    let maxChild = Math.ceil(total * 1.5 / 8);
    let localChildren = [], localPositions = [];
    function divide(children2, positions2, from2, to3, offset) {
      for (let i2 = from2; i2 < to3; ) {
        let groupFrom = i2, groupStart = positions2[i2], groupSize = nodeSize(balanceType, children2[i2]);
        i2++;
        for (; i2 < to3; i2++) {
          let nextSize = nodeSize(balanceType, children2[i2]);
          if (groupSize + nextSize >= maxChild)
            break;
          groupSize += nextSize;
        }
        if (i2 == groupFrom + 1) {
          if (groupSize > maxChild) {
            let only = children2[groupFrom];
            divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
            continue;
          }
          localChildren.push(children2[groupFrom]);
        } else {
          let length2 = positions2[i2 - 1] + children2[i2 - 1].length - groupStart;
          localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i2, groupStart, length2, null, mkTree));
        }
        localPositions.push(groupStart + offset - start2);
      }
    }
    divide(children, positions, from, to2, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
  }
  var TreeFragment = class {
    constructor(from, to2, tree, offset, openStart = false, openEnd = false) {
      this.from = from;
      this.to = to2;
      this.tree = tree;
      this.offset = offset;
      this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
    }
    get openStart() {
      return (this.open & 1) > 0;
    }
    get openEnd() {
      return (this.open & 2) > 0;
    }
    static addTree(tree, fragments = [], partial = false) {
      let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
      for (let f of fragments)
        if (f.to > tree.length)
          result.push(f);
      return result;
    }
    static applyChanges(fragments, changes, minGap = 128) {
      if (!changes.length)
        return fragments;
      let result = [];
      let fI = 1, nextF = fragments.length ? fragments[0] : null;
      for (let cI = 0, pos = 0, off = 0; ; cI++) {
        let nextC = cI < changes.length ? changes[cI] : null;
        let nextPos = nextC ? nextC.fromA : 1e9;
        if (nextPos - pos >= minGap)
          while (nextF && nextF.from < nextPos) {
            let cut = nextF;
            if (pos >= cut.from || nextPos <= cut.to || off) {
              let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
              cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
            }
            if (cut)
              result.push(cut);
            if (nextF.to > nextPos)
              break;
            nextF = fI < fragments.length ? fragments[fI++] : null;
          }
        if (!nextC)
          break;
        pos = nextC.toA;
        off = nextC.toA - nextC.toB;
      }
      return result;
    }
  };
  var Parser = class {
    startParse(input, fragments, ranges) {
      if (typeof input == "string")
        input = new StringInput(input);
      ranges = !ranges ? [new Range2(0, input.length)] : ranges.length ? ranges.map((r) => new Range2(r.from, r.to)) : [new Range2(0, 0)];
      return this.createParse(input, fragments || [], ranges);
    }
    parse(input, fragments, ranges) {
      let parse5 = this.startParse(input, fragments, ranges);
      for (; ; ) {
        let done = parse5.advance();
        if (done)
          return done;
      }
    }
  };
  var StringInput = class {
    constructor(string2) {
      this.string = string2;
    }
    get length() {
      return this.string.length;
    }
    chunk(from) {
      return this.string.slice(from);
    }
    get lineChunks() {
      return false;
    }
    read(from, to2) {
      return this.string.slice(from, to2);
    }
  };
  var stoppedInner = new NodeProp({ perNode: true });

  // node_modules/@lezer/highlight/dist/index.js
  var nextTagID = 0;
  var Tag = class {
    constructor(set3, base2, modified) {
      this.set = set3;
      this.base = base2;
      this.modified = modified;
      this.id = nextTagID++;
    }
    static define(parent) {
      if (parent === null || parent === void 0 ? void 0 : parent.base)
        throw new Error("Can not derive from a modified tag");
      let tag = new Tag([], null, []);
      tag.set.push(tag);
      if (parent)
        for (let t2 of parent.set)
          tag.set.push(t2);
      return tag;
    }
    static defineModifier() {
      let mod2 = new Modifier();
      return (tag) => {
        if (tag.modified.indexOf(mod2) > -1)
          return tag;
        return Modifier.get(tag.base || tag, tag.modified.concat(mod2).sort((a2, b2) => a2.id - b2.id));
      };
    }
  };
  var nextModifierID = 0;
  var Modifier = class {
    constructor() {
      this.instances = [];
      this.id = nextModifierID++;
    }
    static get(base2, mods) {
      if (!mods.length)
        return base2;
      let exists = mods[0].instances.find((t2) => t2.base == base2 && sameArray2(mods, t2.modified));
      if (exists)
        return exists;
      let set3 = [], tag = new Tag(set3, base2, mods);
      for (let m3 of mods)
        m3.instances.push(tag);
      let configs = permute(mods);
      for (let parent of base2.set)
        for (let config2 of configs)
          set3.push(Modifier.get(parent, config2));
      return tag;
    }
  };
  function sameArray2(a2, b2) {
    return a2.length == b2.length && a2.every((x, i2) => x == b2[i2]);
  }
  function permute(array) {
    let result = [array];
    for (let i2 = 0; i2 < array.length; i2++) {
      for (let a2 of permute(array.slice(0, i2).concat(array.slice(i2 + 1))))
        result.push(a2);
    }
    return result;
  }
  function styleTags(spec) {
    let byName = /* @__PURE__ */ Object.create(null);
    for (let prop in spec) {
      let tags2 = spec[prop];
      if (!Array.isArray(tags2))
        tags2 = [tags2];
      for (let part of prop.split(" "))
        if (part) {
          let pieces = [], mode = 2, rest = part;
          for (let pos = 0; ; ) {
            if (rest == "..." && pos > 0 && pos + 3 == part.length) {
              mode = 1;
              break;
            }
            let m3 = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
            if (!m3)
              throw new RangeError("Invalid path: " + part);
            pieces.push(m3[0] == "*" ? "" : m3[0][0] == '"' ? JSON.parse(m3[0]) : m3[0]);
            pos += m3[0].length;
            if (pos == part.length)
              break;
            let next = part[pos++];
            if (pos == part.length && next == "!") {
              mode = 0;
              break;
            }
            if (next != "/")
              throw new RangeError("Invalid path: " + part);
            rest = part.slice(pos);
          }
          let last2 = pieces.length - 1, inner = pieces[last2];
          if (!inner)
            throw new RangeError("Invalid path: " + part);
          let rule = new Rule(tags2, mode, last2 > 0 ? pieces.slice(0, last2) : null);
          byName[inner] = rule.sort(byName[inner]);
        }
    }
    return ruleNodeProp.add(byName);
  }
  var ruleNodeProp = new NodeProp();
  var Rule = class {
    constructor(tags2, mode, context2, next) {
      this.tags = tags2;
      this.mode = mode;
      this.context = context2;
      this.next = next;
    }
    sort(other) {
      if (!other || other.depth < this.depth) {
        this.next = other;
        return this;
      }
      other.next = this.sort(other.next);
      return other;
    }
    get depth() {
      return this.context ? this.context.length : 0;
    }
  };
  function tagHighlighter(tags2, options2) {
    let map = /* @__PURE__ */ Object.create(null);
    for (let style of tags2) {
      if (!Array.isArray(style.tag))
        map[style.tag.id] = style.class;
      else
        for (let tag of style.tag)
          map[tag.id] = style.class;
    }
    let { scope, all = null } = options2 || {};
    return {
      style: (tags3) => {
        let cls = all;
        for (let tag of tags3) {
          for (let sub of tag.set) {
            let tagClass = map[sub.id];
            if (tagClass) {
              cls = cls ? cls + " " + tagClass : tagClass;
              break;
            }
          }
        }
        return cls;
      },
      scope
    };
  }
  function highlightTags(highlighters, tags2) {
    let result = null;
    for (let highlighter of highlighters) {
      let value = highlighter.style(tags2);
      if (value)
        result = result ? result + " " + value : value;
    }
    return result;
  }
  function highlightTree(tree, highlighter, putStyle, from = 0, to2 = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to2, "", builder.highlighters);
    builder.flush(to2);
  }
  var HighlightBuilder = class {
    constructor(at, highlighters, span) {
      this.at = at;
      this.highlighters = highlighters;
      this.span = span;
      this.class = "";
    }
    startSpan(at, cls) {
      if (cls != this.class) {
        this.flush(at);
        if (at > this.at)
          this.at = at;
        this.class = cls;
      }
    }
    flush(to2) {
      if (to2 > this.at && this.class)
        this.span(this.at, to2, this.class);
    }
    highlightRange(cursor, from, to2, inheritedClass, highlighters) {
      let { type: type2, from: start2, to: end } = cursor;
      if (start2 >= to2 || end <= from)
        return;
      if (type2.isTop)
        highlighters = this.highlighters.filter((h) => !h.scope || h.scope(type2));
      let cls = inheritedClass;
      let rule = type2.prop(ruleNodeProp), opaque = false;
      while (rule) {
        if (!rule.context || cursor.matchContext(rule.context)) {
          let tagCls = highlightTags(highlighters, rule.tags);
          if (tagCls) {
            if (cls)
              cls += " ";
            cls += tagCls;
            if (rule.mode == 1)
              inheritedClass += (inheritedClass ? " " : "") + tagCls;
            else if (rule.mode == 0)
              opaque = true;
          }
          break;
        }
        rule = rule.next;
      }
      this.startSpan(cursor.from, cls);
      if (opaque)
        return;
      let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
      if (mounted && mounted.overlay) {
        let inner = cursor.node.enter(mounted.overlay[0].from + start2, 1);
        let innerHighlighters = this.highlighters.filter((h) => !h.scope || h.scope(mounted.tree.type));
        let hasChild2 = cursor.firstChild();
        for (let i2 = 0, pos = start2; ; i2++) {
          let next = i2 < mounted.overlay.length ? mounted.overlay[i2] : null;
          let nextPos = next ? next.from + start2 : end;
          let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to2, nextPos);
          if (rangeFrom < rangeTo && hasChild2) {
            while (cursor.from < rangeTo) {
              this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
              this.startSpan(Math.min(to2, cursor.to), cls);
              if (cursor.to >= nextPos || !cursor.nextSibling())
                break;
            }
          }
          if (!next || nextPos > to2)
            break;
          pos = next.to + start2;
          if (pos > from) {
            this.highlightRange(inner.cursor(), Math.max(from, next.from + start2), Math.min(to2, pos), inheritedClass, innerHighlighters);
            this.startSpan(pos, cls);
          }
        }
        if (hasChild2)
          cursor.parent();
      } else if (cursor.firstChild()) {
        do {
          if (cursor.to <= from)
            continue;
          if (cursor.from >= to2)
            break;
          this.highlightRange(cursor, from, to2, inheritedClass, highlighters);
          this.startSpan(Math.min(to2, cursor.to), cls);
        } while (cursor.nextSibling());
        cursor.parent();
      }
    }
  };
  var t = Tag.define;
  var comment = t();
  var name2 = t();
  var typeName = t(name2);
  var propertyName = t(name2);
  var literal = t();
  var string = t(literal);
  var number = t(literal);
  var content = t();
  var heading = t(content);
  var keyword = t();
  var operator = t();
  var punctuation = t();
  var bracket = t(punctuation);
  var meta = t();
  var tags = {
    comment,
    lineComment: t(comment),
    blockComment: t(comment),
    docComment: t(comment),
    name: name2,
    variableName: t(name2),
    typeName,
    tagName: t(typeName),
    propertyName,
    attributeName: t(propertyName),
    className: t(name2),
    labelName: t(name2),
    namespace: t(name2),
    macroName: t(name2),
    literal,
    string,
    docString: t(string),
    character: t(string),
    attributeValue: t(string),
    number,
    integer: t(number),
    float: t(number),
    bool: t(literal),
    regexp: t(literal),
    escape: t(literal),
    color: t(literal),
    url: t(literal),
    keyword,
    self: t(keyword),
    null: t(keyword),
    atom: t(keyword),
    unit: t(keyword),
    modifier: t(keyword),
    operatorKeyword: t(keyword),
    controlKeyword: t(keyword),
    definitionKeyword: t(keyword),
    moduleKeyword: t(keyword),
    operator,
    derefOperator: t(operator),
    arithmeticOperator: t(operator),
    logicOperator: t(operator),
    bitwiseOperator: t(operator),
    compareOperator: t(operator),
    updateOperator: t(operator),
    definitionOperator: t(operator),
    typeOperator: t(operator),
    controlOperator: t(operator),
    punctuation,
    separator: t(punctuation),
    bracket,
    angleBracket: t(bracket),
    squareBracket: t(bracket),
    paren: t(bracket),
    brace: t(bracket),
    content,
    heading,
    heading1: t(heading),
    heading2: t(heading),
    heading3: t(heading),
    heading4: t(heading),
    heading5: t(heading),
    heading6: t(heading),
    contentSeparator: t(content),
    list: t(content),
    quote: t(content),
    emphasis: t(content),
    strong: t(content),
    link: t(content),
    monospace: t(content),
    strikethrough: t(content),
    inserted: t(),
    deleted: t(),
    changed: t(),
    invalid: t(),
    meta,
    documentMeta: t(meta),
    annotation: t(meta),
    processingInstruction: t(meta),
    definition: Tag.defineModifier(),
    constant: Tag.defineModifier(),
    function: Tag.defineModifier(),
    standard: Tag.defineModifier(),
    local: Tag.defineModifier(),
    special: Tag.defineModifier()
  };
  var classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
  ]);

  // node_modules/@codemirror/language/dist/index.js
  var _a;
  var languageDataProp = /* @__PURE__ */ new NodeProp();
  var Language = class {
    constructor(data, parser, extraExtensions = []) {
      this.data = data;
      if (!EditorState.prototype.hasOwnProperty("tree"))
        Object.defineProperty(EditorState.prototype, "tree", { get() {
          return syntaxTree(this);
        } });
      this.parser = parser;
      this.extension = [
        language.of(this),
        EditorState.languageData.of((state3, pos, side) => state3.facet(languageDataFacetAt(state3, pos, side)))
      ].concat(extraExtensions);
    }
    isActiveAt(state3, pos, side = -1) {
      return languageDataFacetAt(state3, pos, side) == this.data;
    }
    findRegions(state3) {
      let lang = state3.facet(language);
      if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
        return [{ from: 0, to: state3.doc.length }];
      if (!lang || !lang.allowsNesting)
        return [];
      let result = [];
      let explore = (tree, from) => {
        if (tree.prop(languageDataProp) == this.data) {
          result.push({ from, to: from + tree.length });
          return;
        }
        let mount = tree.prop(NodeProp.mounted);
        if (mount) {
          if (mount.tree.prop(languageDataProp) == this.data) {
            if (mount.overlay)
              for (let r of mount.overlay)
                result.push({ from: r.from + from, to: r.to + from });
            else
              result.push({ from, to: from + tree.length });
            return;
          } else if (mount.overlay) {
            let size2 = result.length;
            explore(mount.tree, mount.overlay[0].from + from);
            if (result.length > size2)
              return;
          }
        }
        for (let i2 = 0; i2 < tree.children.length; i2++) {
          let ch = tree.children[i2];
          if (ch instanceof Tree)
            explore(ch, tree.positions[i2] + from);
        }
      };
      explore(syntaxTree(state3), 0);
      return result;
    }
    get allowsNesting() {
      return true;
    }
  };
  Language.setState = /* @__PURE__ */ StateEffect.define();
  function languageDataFacetAt(state3, pos, side) {
    let topLang = state3.facet(language);
    if (!topLang)
      return null;
    let facet = topLang.data;
    if (topLang.allowsNesting) {
      for (let node = syntaxTree(state3).topNode; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
        facet = node.type.prop(languageDataProp) || facet;
    }
    return facet;
  }
  function syntaxTree(state3) {
    let field = state3.field(Language.state, false);
    return field ? field.tree : Tree.empty;
  }
  var DocInput = class {
    constructor(doc2, length = doc2.length) {
      this.doc = doc2;
      this.length = length;
      this.cursorPos = 0;
      this.string = "";
      this.cursor = doc2.iter();
    }
    syncTo(pos) {
      this.string = this.cursor.next(pos - this.cursorPos).value;
      this.cursorPos = pos + this.string.length;
      return this.cursorPos - this.string.length;
    }
    chunk(pos) {
      this.syncTo(pos);
      return this.string;
    }
    get lineChunks() {
      return true;
    }
    read(from, to2) {
      let stringStart = this.cursorPos - this.string.length;
      if (from < stringStart || to2 >= this.cursorPos)
        return this.doc.sliceString(from, to2);
      else
        return this.string.slice(from - stringStart, to2 - stringStart);
    }
  };
  var currentContext = null;
  var ParseContext = class {
    constructor(parser, state3, fragments = [], tree, treeLen, viewport, skipped, scheduleOn) {
      this.parser = parser;
      this.state = state3;
      this.fragments = fragments;
      this.tree = tree;
      this.treeLen = treeLen;
      this.viewport = viewport;
      this.skipped = skipped;
      this.scheduleOn = scheduleOn;
      this.parse = null;
      this.tempSkipped = [];
    }
    static create(parser, state3, viewport) {
      return new ParseContext(parser, state3, [], Tree.empty, 0, viewport, [], null);
    }
    startParse() {
      return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    work(until, upto) {
      if (upto != null && upto >= this.state.doc.length)
        upto = void 0;
      if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
        this.takeTree();
        return true;
      }
      return this.withContext(() => {
        var _a2;
        if (typeof until == "number") {
          let endTime = Date.now() + until;
          until = () => Date.now() > endTime;
        }
        if (!this.parse)
          this.parse = this.startParse();
        if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
          this.parse.stopAt(upto);
        for (; ; ) {
          let done = this.parse.advance();
          if (done) {
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
            this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
            this.tree = done;
            this.parse = null;
            if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
              this.parse = this.startParse();
            else
              return true;
          }
          if (until())
            return false;
        }
      });
    }
    takeTree() {
      let pos, tree;
      if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
        if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
          this.parse.stopAt(pos);
        this.withContext(() => {
          while (!(tree = this.parse.advance())) {
          }
        });
        this.treeLen = pos;
        this.tree = tree;
        this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
        this.parse = null;
      }
    }
    withContext(f) {
      let prev = currentContext;
      currentContext = this;
      try {
        return f();
      } finally {
        currentContext = prev;
      }
    }
    withoutTempSkipped(fragments) {
      for (let r; r = this.tempSkipped.pop(); )
        fragments = cutFragments(fragments, r.from, r.to);
      return fragments;
    }
    changes(changes, newState) {
      let { fragments, tree, treeLen, viewport, skipped } = this;
      this.takeTree();
      if (!changes.empty) {
        let ranges = [];
        changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
        fragments = TreeFragment.applyChanges(fragments, ranges);
        tree = Tree.empty;
        treeLen = 0;
        viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
        if (this.skipped.length) {
          skipped = [];
          for (let r of this.skipped) {
            let from = changes.mapPos(r.from, 1), to2 = changes.mapPos(r.to, -1);
            if (from < to2)
              skipped.push({ from, to: to2 });
          }
        }
      }
      return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    updateViewport(viewport) {
      if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
        return false;
      this.viewport = viewport;
      let startLen = this.skipped.length;
      for (let i2 = 0; i2 < this.skipped.length; i2++) {
        let { from, to: to2 } = this.skipped[i2];
        if (from < viewport.to && to2 > viewport.from) {
          this.fragments = cutFragments(this.fragments, from, to2);
          this.skipped.splice(i2--, 1);
        }
      }
      if (this.skipped.length >= startLen)
        return false;
      this.reset();
      return true;
    }
    reset() {
      if (this.parse) {
        this.takeTree();
        this.parse = null;
      }
    }
    skipUntilInView(from, to2) {
      this.skipped.push({ from, to: to2 });
    }
    static getSkippingParser(until) {
      return new class extends Parser {
        createParse(input, fragments, ranges) {
          let from = ranges[0].from, to2 = ranges[ranges.length - 1].to;
          let parser = {
            parsedPos: from,
            advance() {
              let cx = currentContext;
              if (cx) {
                for (let r of ranges)
                  cx.tempSkipped.push(r);
                if (until)
                  cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
              }
              this.parsedPos = to2;
              return new Tree(NodeType.none, [], [], to2 - from);
            },
            stoppedAt: null,
            stopAt() {
            }
          };
          return parser;
        }
      }();
    }
    isDone(upto) {
      upto = Math.min(upto, this.state.doc.length);
      let frags = this.fragments;
      return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    static get() {
      return currentContext;
    }
  };
  function cutFragments(fragments, from, to2) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to2, fromB: from, toB: to2 }]);
  }
  var LanguageState = class {
    constructor(context2) {
      this.context = context2;
      this.tree = context2.tree;
    }
    apply(tr) {
      if (!tr.docChanged && this.tree == this.context.tree)
        return this;
      let newCx = this.context.changes(tr.changes, tr.state);
      let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
      if (!newCx.work(20, upto))
        newCx.takeTree();
      return new LanguageState(newCx);
    }
    static init(state3) {
      let vpTo = Math.min(3e3, state3.doc.length);
      let parseState = ParseContext.create(state3.facet(language).parser, state3, { from: 0, to: vpTo });
      if (!parseState.work(20, vpTo))
        parseState.takeTree();
      return new LanguageState(parseState);
    }
  };
  Language.state = /* @__PURE__ */ StateField.define({
    create: LanguageState.init,
    update(value, tr) {
      for (let e2 of tr.effects)
        if (e2.is(Language.setState))
          return e2.value;
      if (tr.startState.facet(language) != tr.state.facet(language))
        return LanguageState.init(tr.state);
      return value.apply(tr);
    }
  });
  var requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500);
    return () => clearTimeout(timeout);
  };
  if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
      let idle = -1, timeout = setTimeout(() => {
        idle = requestIdleCallback(callback, { timeout: 500 - 100 });
      }, 100);
      return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
  var isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
  var parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
      this.view = view;
      this.working = null;
      this.workScheduled = 0;
      this.chunkEnd = -1;
      this.chunkBudget = -1;
      this.work = this.work.bind(this);
      this.scheduleWork();
    }
    update(update3) {
      let cx = this.view.state.field(Language.state).context;
      if (cx.updateViewport(update3.view.viewport) || this.view.viewport.to > cx.treeLen)
        this.scheduleWork();
      if (update3.docChanged) {
        if (this.view.hasFocus)
          this.chunkBudget += 50;
        this.scheduleWork();
      }
      this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
      if (this.working)
        return;
      let { state: state3 } = this.view, field = state3.field(Language.state);
      if (field.tree != field.context.tree || !field.context.isDone(state3.doc.length))
        this.working = requestIdle(this.work);
    }
    work(deadline) {
      this.working = null;
      let now = Date.now();
      if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
        this.chunkEnd = now + 3e4;
        this.chunkBudget = 3e3;
      }
      if (this.chunkBudget <= 0)
        return;
      let { state: state3, viewport: { to: vpTo } } = this.view, field = state3.field(Language.state);
      if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
        return;
      let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
      let viewportFirst = field.context.treeLen < vpTo && state3.doc.length > vpTo + 1e3;
      let done = field.context.work(() => {
        return isInputPending && isInputPending() || Date.now() > endTime;
      }, vpTo + (viewportFirst ? 0 : 1e5));
      this.chunkBudget -= Date.now() - now;
      if (done || this.chunkBudget <= 0) {
        field.context.takeTree();
        this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
      }
      if (this.chunkBudget > 0 && !(done && !viewportFirst))
        this.scheduleWork();
      this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
      if (cx.scheduleOn) {
        this.workScheduled++;
        cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
        cx.scheduleOn = null;
      }
    }
    destroy() {
      if (this.working)
        this.working();
    }
    isWorking() {
      return !!(this.working || this.workScheduled > 0);
    }
  }, {
    eventHandlers: { focus() {
      this.scheduleWork();
    } }
  });
  var language = /* @__PURE__ */ Facet.define({
    combine(languages) {
      return languages.length ? languages[0] : null;
    },
    enables: [Language.state, parseWorker]
  });
  var indentService = /* @__PURE__ */ Facet.define();
  var indentUnit = /* @__PURE__ */ Facet.define({
    combine: (values) => {
      if (!values.length)
        return "  ";
      if (!/^(?: +|\t+)$/.test(values[0]))
        throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
      return values[0];
    }
  });
  function getIndentUnit(state3) {
    let unit = state3.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state3.tabSize * unit.length : unit.length;
  }
  function indentString(state3, cols) {
    let result = "", ts = state3.tabSize;
    if (state3.facet(indentUnit).charCodeAt(0) == 9)
      while (cols >= ts) {
        result += "	";
        cols -= ts;
      }
    for (let i2 = 0; i2 < cols; i2++)
      result += " ";
    return result;
  }
  function getIndentation(context2, pos) {
    if (context2 instanceof EditorState)
      context2 = new IndentContext(context2);
    for (let service of context2.state.facet(indentService)) {
      let result = service(context2, pos);
      if (result != null)
        return result;
    }
    let tree = syntaxTree(context2.state);
    return tree ? syntaxIndentation(context2, tree, pos) : null;
  }
  var IndentContext = class {
    constructor(state3, options2 = {}) {
      this.state = state3;
      this.options = options2;
      this.unit = getIndentUnit(state3);
    }
    lineAt(pos, bias = 1) {
      let line = this.state.doc.lineAt(pos);
      let { simulateBreak, simulateDoubleBreak } = this.options;
      if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
        if (simulateDoubleBreak && simulateBreak == pos)
          return { text: "", from: pos };
        else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
          return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
        else
          return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
      }
      return line;
    }
    textAfterPos(pos, bias = 1) {
      if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
        return "";
      let { text, from } = this.lineAt(pos, bias);
      return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    column(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let result = this.countColumn(text, pos - from);
      let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
      if (override > -1)
        result += override - this.countColumn(text, text.search(/\S|$/));
      return result;
    }
    countColumn(line, pos = line.length) {
      return countColumn(line, this.state.tabSize, pos);
    }
    lineIndent(pos, bias = 1) {
      let { text, from } = this.lineAt(pos, bias);
      let override = this.options.overrideIndentation;
      if (override) {
        let overriden = override(from);
        if (overriden > -1)
          return overriden;
      }
      return this.countColumn(text, text.search(/\S|$/));
    }
    get simulatedBreak() {
      return this.options.simulateBreak || null;
    }
  };
  var indentNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxIndentation(cx, ast, pos) {
    return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
  }
  function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
  }
  function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
      return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(NodeProp.closedBy))) {
      let last2 = tree.lastChild, closed = last2 && close.indexOf(last2.name) > -1;
      return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last2.from : void 0);
    }
    return tree.parent == null ? topIndent : null;
  }
  function indentFrom(node, pos, base2) {
    for (; node; node = node.parent) {
      let strategy = indentStrategy(node);
      if (strategy)
        return strategy(TreeIndentContext.create(base2, pos, node));
    }
    return null;
  }
  function topIndent() {
    return 0;
  }
  var TreeIndentContext = class extends IndentContext {
    constructor(base2, pos, node) {
      super(base2.state, base2.options);
      this.base = base2;
      this.pos = pos;
      this.node = node;
    }
    static create(base2, pos, node) {
      return new TreeIndentContext(base2, pos, node);
    }
    get textAfter() {
      return this.textAfterPos(this.pos);
    }
    get baseIndent() {
      let line = this.state.doc.lineAt(this.node.from);
      for (; ; ) {
        let atBreak = this.node.resolve(line.from);
        while (atBreak.parent && atBreak.parent.from == atBreak.from)
          atBreak = atBreak.parent;
        if (isParent(atBreak, this.node))
          break;
        line = this.state.doc.lineAt(atBreak.from);
      }
      return this.lineIndent(line.from);
    }
    continue() {
      let parent = this.node.parent;
      return parent ? indentFrom(parent, this.pos, this.base) : 0;
    }
  };
  function isParent(parent, of) {
    for (let cur2 = of; cur2; cur2 = cur2.parent)
      if (parent == cur2)
        return true;
    return false;
  }
  function bracketedAligned(context2) {
    let tree = context2.node;
    let openToken = tree.childAfter(tree.from), last2 = tree.lastChild;
    if (!openToken)
      return null;
    let sim = context2.options.simulateBreak;
    let openLine = context2.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to; ; ) {
      let next = tree.childAfter(pos);
      if (!next || next == last2)
        return null;
      if (!next.type.isSkipped)
        return next.from < lineEnd ? openToken : null;
      pos = next.to;
    }
  }
  function delimitedStrategy(context2, align, units, closing2, closedAt) {
    let after = context2.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing2 && after.slice(space, space + closing2.length) == closing2 || closedAt == context2.pos + space;
    let aligned = align ? bracketedAligned(context2) : null;
    if (aligned)
      return closed ? context2.column(aligned.from) : context2.column(aligned.to);
    return context2.baseIndent + (closed ? 0 : context2.unit * units);
  }
  var DontIndentBeyond = 200;
  function indentOnInput() {
    return EditorState.transactionFilter.of((tr) => {
      if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
        return tr;
      let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
      if (!rules.length)
        return tr;
      let doc2 = tr.newDoc, { head } = tr.newSelection.main, line = doc2.lineAt(head);
      if (head > line.from + DontIndentBeyond)
        return tr;
      let lineStart = doc2.sliceString(line.from, head);
      if (!rules.some((r) => r.test(lineStart)))
        return tr;
      let { state: state3 } = tr, last2 = -1, changes = [];
      for (let { head: head2 } of state3.selection.ranges) {
        let line2 = state3.doc.lineAt(head2);
        if (line2.from == last2)
          continue;
        last2 = line2.from;
        let indent = getIndentation(state3, line2.from);
        if (indent == null)
          continue;
        let cur2 = /^\s*/.exec(line2.text)[0];
        let norm = indentString(state3, indent);
        if (cur2 != norm)
          changes.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
      }
      return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
  }
  var foldService = /* @__PURE__ */ Facet.define();
  var foldNodeProp = /* @__PURE__ */ new NodeProp();
  function syntaxFolding(state3, start2, end) {
    let tree = syntaxTree(state3);
    if (tree.length < end)
      return null;
    let inner = tree.resolveInner(end);
    let found = null;
    for (let cur2 = inner; cur2; cur2 = cur2.parent) {
      if (cur2.to <= end || cur2.from > end)
        continue;
      if (found && cur2.from < start2)
        break;
      let prop = cur2.type.prop(foldNodeProp);
      if (prop && (cur2.to < tree.length - 50 || tree.length == state3.doc.length || !isUnfinished(cur2))) {
        let value = prop(cur2, state3);
        if (value && value.from <= end && value.from >= start2 && value.to > end)
          found = value;
      }
    }
    return found;
  }
  function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
  }
  function foldable(state3, lineStart, lineEnd) {
    for (let service of state3.facet(foldService)) {
      let result = service(state3, lineStart, lineEnd);
      if (result)
        return result;
    }
    return syntaxFolding(state3, lineStart, lineEnd);
  }
  function mapRange(range2, mapping) {
    let from = mapping.mapPos(range2.from, 1), to2 = mapping.mapPos(range2.to, -1);
    return from >= to2 ? void 0 : { from, to: to2 };
  }
  var foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  var unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
  function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
      if (lines.some((l) => l.from <= head && l.to >= head))
        continue;
      lines.push(view.lineBlockAt(head));
    }
    return lines;
  }
  var foldState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(folded, tr) {
      folded = folded.map(tr.changes);
      for (let e2 of tr.effects) {
        if (e2.is(foldEffect) && !foldExists(folded, e2.value.from, e2.value.to))
          folded = folded.update({ add: [foldWidget.range(e2.value.from, e2.value.to)] });
        else if (e2.is(unfoldEffect))
          folded = folded.update({
            filter: (from, to2) => e2.value.from != from || e2.value.to != to2,
            filterFrom: e2.value.from,
            filterTo: e2.value.to
          });
      }
      if (tr.selection) {
        let onSelection = false, { head } = tr.selection.main;
        folded.between(head, head, (a2, b2) => {
          if (a2 < head && b2 > head)
            onSelection = true;
        });
        if (onSelection)
          folded = folded.update({
            filterFrom: head,
            filterTo: head,
            filter: (a2, b2) => b2 <= head || a2 >= head
          });
      }
      return folded;
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  function findFold(state3, from, to2) {
    var _a2;
    let found = null;
    (_a2 = state3.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from, to2, (from2, to3) => {
      if (!found || found.from > from2)
        found = { from: from2, to: to3 };
    });
    return found;
  }
  function foldExists(folded, from, to2) {
    let found = false;
    folded.between(from, from, (a2, b2) => {
      if (a2 == from && b2 == to2)
        found = true;
    });
    return found;
  }
  function maybeEnable(state3, other) {
    return state3.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
  }
  var foldCode = (view) => {
    for (let line of selectedLines(view)) {
      let range2 = foldable(view.state, line.from, line.to);
      if (range2) {
        view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range2), announceFold(view, range2)]) });
        return true;
      }
    }
    return false;
  };
  var unfoldCode = (view) => {
    if (!view.state.field(foldState, false))
      return false;
    let effects = [];
    for (let line of selectedLines(view)) {
      let folded = findFold(view.state, line.from, line.to);
      if (folded)
        effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
      view.dispatch({ effects });
    return effects.length > 0;
  };
  function announceFold(view, range2, fold = true) {
    let lineFrom = view.state.doc.lineAt(range2.from).number, lineTo = view.state.doc.lineAt(range2.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
  }
  var foldAll = (view) => {
    let { state: state3 } = view, effects = [];
    for (let pos = 0; pos < state3.doc.length; ) {
      let line = view.lineBlockAt(pos), range2 = foldable(state3, line.from, line.to);
      if (range2)
        effects.push(foldEffect.of(range2));
      pos = (range2 ? view.lineBlockAt(range2.to) : line).to + 1;
    }
    if (effects.length)
      view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
  };
  var unfoldAll = (view) => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
      return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to2) => {
      effects.push(unfoldEffect.of({ from, to: to2 }));
    });
    view.dispatch({ effects });
    return true;
  };
  var foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
  ];
  var defaultConfig = {
    placeholderDOM: null,
    placeholderText: "\u2026"
  };
  var foldConfig = /* @__PURE__ */ Facet.define({
    combine(values) {
      return combineConfig(values, defaultConfig);
    }
  });
  function codeFolding(config2) {
    let result = [foldState, baseTheme$12];
    if (config2)
      result.push(foldConfig.of(config2));
    return result;
  }
  var foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
    toDOM(view) {
      let { state: state3 } = view, conf = state3.facet(foldConfig);
      let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
          view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
      };
      if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick);
      let element3 = document.createElement("span");
      element3.textContent = conf.placeholderText;
      element3.setAttribute("aria-label", state3.phrase("folded code"));
      element3.title = state3.phrase("unfold");
      element3.className = "cm-foldPlaceholder";
      element3.onclick = onclick;
      return element3;
    }
  }() });
  var foldGutterDefaults = {
    openText: "\u2304",
    closedText: "\u203A",
    markerDOM: null,
    domEventHandlers: {}
  };
  var FoldMarker = class extends GutterMarker {
    constructor(config2, open) {
      super();
      this.config = config2;
      this.open = open;
    }
    eq(other) {
      return this.config == other.config && this.open == other.open;
    }
    toDOM(view) {
      if (this.config.markerDOM)
        return this.config.markerDOM(this.open);
      let span = document.createElement("span");
      span.textContent = this.open ? this.config.openText : this.config.closedText;
      span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
      return span;
    }
  };
  function foldGutter(config2 = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config2);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = ViewPlugin.fromClass(class {
      constructor(view) {
        this.from = view.viewport.from;
        this.markers = this.buildMarkers(view);
      }
      update(update3) {
        if (update3.docChanged || update3.viewportChanged || update3.startState.facet(language) != update3.state.facet(language) || update3.startState.field(foldState, false) != update3.state.field(foldState, false) || syntaxTree(update3.startState) != syntaxTree(update3.state))
          this.markers = this.buildMarkers(update3.view);
      }
      buildMarkers(view) {
        let builder = new RangeSetBuilder();
        for (let line of view.viewportLineBlocks) {
          let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
          if (mark)
            builder.add(line.from, line.from, mark);
        }
        return builder.finish();
      }
    });
    let { domEventHandlers } = fullConfig;
    return [
      markers,
      gutter({
        class: "cm-foldGutter",
        markers(view) {
          var _a2;
          return ((_a2 = view.plugin(markers)) === null || _a2 === void 0 ? void 0 : _a2.markers) || RangeSet.empty;
        },
        initialSpacer() {
          return new FoldMarker(fullConfig, false);
        },
        domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
          if (domEventHandlers.click && domEventHandlers.click(view, line, event))
            return true;
          let folded = findFold(view.state, line.from, line.to);
          if (folded) {
            view.dispatch({ effects: unfoldEffect.of(folded) });
            return true;
          }
          let range2 = foldable(view.state, line.from, line.to);
          if (range2) {
            view.dispatch({ effects: foldEffect.of(range2) });
            return true;
          }
          return false;
        } })
      }),
      codeFolding()
    ];
  }
  var baseTheme$12 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-foldPlaceholder": {
      backgroundColor: "#eee",
      border: "1px solid #ddd",
      color: "#888",
      borderRadius: ".2em",
      margin: "0 1px",
      padding: "0 1px",
      cursor: "pointer"
    },
    ".cm-foldGutter span": {
      padding: "0 1px",
      cursor: "pointer"
    }
  });
  var HighlightStyle = class {
    constructor(spec, options2) {
      let modSpec;
      function def(spec2) {
        let cls = StyleModule.newName();
        (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec2;
        return cls;
      }
      const all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
      const scopeOpt = options2.scope;
      this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
      this.style = tagHighlighter(spec.map((style) => ({
        tag: style.tag,
        class: style.class || def(Object.assign({}, style, { tag: null }))
      })), {
        all
      }).style;
      this.module = modSpec ? new StyleModule(modSpec) : null;
      this.themeType = options2.themeType;
    }
    static define(specs, options2) {
      return new HighlightStyle(specs, options2 || {});
    }
  };
  var highlighterFacet = /* @__PURE__ */ Facet.define();
  var fallbackHighlighter = /* @__PURE__ */ Facet.define({
    combine(values) {
      return values.length ? [values[0]] : null;
    }
  });
  function getHighlighters(state3) {
    let main = state3.facet(highlighterFacet);
    return main.length ? main : state3.facet(fallbackHighlighter);
  }
  function syntaxHighlighting(highlighter, options2) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
      if (highlighter.module)
        ext.push(EditorView.styleModule.of(highlighter.module));
      themeType = highlighter.themeType;
    }
    if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
      ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
      ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state3) => {
        return state3.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
      }));
    else
      ext.push(highlighterFacet.of(highlighter));
    return ext;
  }
  var TreeHighlighter = class {
    constructor(view) {
      this.markCache = /* @__PURE__ */ Object.create(null);
      this.tree = syntaxTree(view.state);
      this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update3) {
      let tree = syntaxTree(update3.state), highlighters = getHighlighters(update3.state);
      let styleChange = highlighters != getHighlighters(update3.startState);
      if (tree.length < update3.view.viewport.to && !styleChange && tree.type == this.tree.type) {
        this.decorations = this.decorations.map(update3.changes);
      } else if (tree != this.tree || update3.viewportChanged || styleChange) {
        this.tree = tree;
        this.decorations = this.buildDeco(update3.view, highlighters);
      }
    }
    buildDeco(view, highlighters) {
      if (!highlighters || !this.tree.length)
        return Decoration.none;
      let builder = new RangeSetBuilder();
      for (let { from, to: to2 } of view.visibleRanges) {
        highlightTree(this.tree, highlighters, (from2, to3, style) => {
          builder.add(from2, to3, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
        }, from, to2);
      }
      return builder.finish();
    }
  };
  var treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
    decorations: (v) => v.decorations
  }));
  var defaultHighlightStyle = /* @__PURE__ */ HighlightStyle.define([
    {
      tag: tags.meta,
      color: "#7a757a"
    },
    {
      tag: tags.link,
      textDecoration: "underline"
    },
    {
      tag: tags.heading,
      textDecoration: "underline",
      fontWeight: "bold"
    },
    {
      tag: tags.emphasis,
      fontStyle: "italic"
    },
    {
      tag: tags.strong,
      fontWeight: "bold"
    },
    {
      tag: tags.strikethrough,
      textDecoration: "line-through"
    },
    {
      tag: tags.keyword,
      color: "#708"
    },
    {
      tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
      color: "#219"
    },
    {
      tag: [tags.literal, tags.inserted],
      color: "#164"
    },
    {
      tag: [tags.string, tags.deleted],
      color: "#a11"
    },
    {
      tag: [tags.regexp, tags.escape, /* @__PURE__ */ tags.special(tags.string)],
      color: "#e40"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.variableName),
      color: "#00f"
    },
    {
      tag: /* @__PURE__ */ tags.local(tags.variableName),
      color: "#30a"
    },
    {
      tag: [tags.typeName, tags.namespace],
      color: "#085"
    },
    {
      tag: tags.className,
      color: "#167"
    },
    {
      tag: [/* @__PURE__ */ tags.special(tags.variableName), tags.macroName],
      color: "#256"
    },
    {
      tag: /* @__PURE__ */ tags.definition(tags.propertyName),
      color: "#00c"
    },
    {
      tag: tags.comment,
      color: "#940"
    },
    {
      tag: tags.invalid,
      color: "#f00"
    }
  ]);
  var baseTheme2 = /* @__PURE__ */ EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
  });
  var DefaultScanDist = 1e4;
  var DefaultBrackets = "()[]{}";
  var bracketMatchingConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        afterCursor: true,
        brackets: DefaultBrackets,
        maxScanDistance: DefaultScanDist,
        renderMatch: defaultRenderMatch
      });
    }
  });
  var matchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-matchingBracket" });
  var nonmatchingMark = /* @__PURE__ */ Decoration.mark({ class: "cm-nonmatchingBracket" });
  function defaultRenderMatch(match) {
    let decorations2 = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations2.push(mark.range(match.start.from, match.start.to));
    if (match.end)
      decorations2.push(mark.range(match.end.from, match.end.to));
    return decorations2;
  }
  var bracketMatchingState = /* @__PURE__ */ StateField.define({
    create() {
      return Decoration.none;
    },
    update(deco, tr) {
      if (!tr.docChanged && !tr.selection)
        return deco;
      let decorations2 = [];
      let config2 = tr.state.facet(bracketMatchingConfig);
      for (let range2 of tr.state.selection.ranges) {
        if (!range2.empty)
          continue;
        let match = matchBrackets(tr.state, range2.head, -1, config2) || range2.head > 0 && matchBrackets(tr.state, range2.head - 1, 1, config2) || config2.afterCursor && (matchBrackets(tr.state, range2.head, 1, config2) || range2.head < tr.state.doc.length && matchBrackets(tr.state, range2.head + 1, -1, config2));
        if (match)
          decorations2 = decorations2.concat(config2.renderMatch(match, tr.state));
      }
      return Decoration.set(decorations2, true);
    },
    provide: (f) => EditorView.decorations.from(f)
  });
  var bracketMatchingUnique = [
    bracketMatchingState,
    baseTheme2
  ];
  function bracketMatching(config2 = {}) {
    return [bracketMatchingConfig.of(config2), bracketMatchingUnique];
  }
  function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
    if (byProp)
      return byProp;
    if (node.name.length == 1) {
      let index = brackets.indexOf(node.name);
      if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
        return [brackets[index + dir]];
    }
    return null;
  }
  function matchBrackets(state3, pos, dir, config2 = {}) {
    let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
    let tree = syntaxTree(state3), node = tree.resolveInner(pos, dir);
    for (let cur2 = node; cur2; cur2 = cur2.parent) {
      let matches2 = matchingNodes(cur2.type, dir, brackets);
      if (matches2 && cur2.from < cur2.to)
        return matchMarkedBrackets(state3, pos, dir, cur2, matches2, brackets);
    }
    return matchPlainBrackets(state3, pos, dir, tree, node.type, maxScanDistance, brackets);
  }
  function matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {
    let parent = token.parent, firstToken = { from: token.from, to: token.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
      do {
        if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
          if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
            return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
          } else if (matchingNodes(cursor.type, dir, brackets)) {
            depth++;
          } else if (matchingNodes(cursor.type, -dir, brackets)) {
            depth--;
            if (depth == 0)
              return {
                start: firstToken,
                end: cursor.from == cursor.to ? void 0 : { from: cursor.from, to: cursor.to },
                matched: false
              };
          }
        }
      } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
  }
  function matchPlainBrackets(state3, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state3.sliceDoc(pos - 1, pos) : state3.sliceDoc(pos, pos + 1);
    let bracket2 = brackets.indexOf(startCh);
    if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
      return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state3.doc.iterRange(pos, dir > 0 ? state3.doc.length : 0), depth = 0;
    for (let distance2 = 0; !iter.next().done && distance2 <= maxScanDistance; ) {
      let text = iter.value;
      if (dir < 0)
        distance2 += text.length;
      let basePos = pos + distance2 * dir;
      for (let pos2 = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos2 != end; pos2 += dir) {
        let found = brackets.indexOf(text[pos2]);
        if (found < 0 || tree.resolve(basePos + pos2, 1).type != tokenType)
          continue;
        if (found % 2 == 0 == dir > 0) {
          depth++;
        } else if (depth == 1) {
          return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
        } else {
          depth--;
        }
      }
      if (dir > 0)
        distance2 += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
  }
  var noTokens = /* @__PURE__ */ Object.create(null);
  var typeArray = [NodeType.none];
  var warned = [];
  var defaultTable = /* @__PURE__ */ Object.create(null);
  for (let [legacyName, name3] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "typeName"],
    ["attribute", "propertyName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
  ])
    defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name3);
  function warnForPart(part, msg2) {
    if (warned.indexOf(part) > -1)
      return;
    warned.push(part);
    console.warn(msg2);
  }
  function createTokenType(extra, tagStr) {
    let tag = null;
    for (let part of tagStr.split(".")) {
      let value = extra[part] || tags[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!tag)
          warnForPart(part, `Modifier ${part} used at start of tag`);
        else
          tag = value(tag);
      } else {
        if (tag)
          warnForPart(part, `Tag ${part} used as modifier`);
        else
          tag = value;
      }
    }
    if (!tag)
      return 0;
    let name3 = tagStr.replace(/ /g, "_"), type2 = NodeType.define({
      id: typeArray.length,
      name: name3,
      props: [styleTags({ [name3]: tag })]
    });
    typeArray.push(type2);
    return type2.id;
  }

  // node_modules/@codemirror/commands/dist/index.js
  var toggleComment = (target) => {
    let config2 = getConfig2(target.state);
    return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
  };
  function command(f, option) {
    return ({ state: state3, dispatch: dispatch2 }) => {
      if (state3.readOnly)
        return false;
      let tr = f(option, state3);
      if (!tr)
        return false;
      dispatch2(state3.update(tr));
      return true;
    };
  }
  var toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
  var toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
  var toggleBlockCommentByLine = /* @__PURE__ */ command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
  function getConfig2(state3, pos = state3.selection.main.head) {
    let data = state3.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
  }
  var SearchMargin = 50;
  function findBlockComment(state3, { open, close }, from, to2) {
    let textBefore = state3.sliceDoc(from - SearchMargin, from);
    let textAfter = state3.sliceDoc(to2, to2 + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
      return {
        open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
        close: { pos: to2 + spaceAfter, margin: spaceAfter && 1 }
      };
    }
    let startText, endText;
    if (to2 - from <= 2 * SearchMargin) {
      startText = endText = state3.sliceDoc(from, to2);
    } else {
      startText = state3.sliceDoc(from, from + SearchMargin);
      endText = state3.sliceDoc(to2 - SearchMargin, to2);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
      return {
        open: {
          pos: from + startSpace + open.length,
          margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
        },
        close: {
          pos: to2 - endSpace - close.length,
          margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
        }
      };
    }
    return null;
  }
  function selectedLineRanges(state3) {
    let ranges = [];
    for (let r of state3.selection.ranges) {
      let fromLine = state3.doc.lineAt(r.from);
      let toLine = r.to <= fromLine.to ? fromLine : state3.doc.lineAt(r.to);
      let last2 = ranges.length - 1;
      if (last2 >= 0 && ranges[last2].to > fromLine.from)
        ranges[last2].to = toLine.to;
      else
        ranges.push({ from: fromLine.from, to: toLine.to });
    }
    return ranges;
  }
  function changeBlockComment(option, state3, ranges = state3.selection.ranges) {
    let tokens = ranges.map((r) => getConfig2(state3, r.from).block);
    if (!tokens.every((c4) => c4))
      return null;
    let comments = ranges.map((r, i2) => findBlockComment(state3, tokens[i2], r.from, r.to));
    if (option != 2 && !comments.every((c4) => c4)) {
      return { changes: state3.changes(ranges.map((range2, i2) => {
        if (comments[i2])
          return [];
        return [{ from: range2.from, insert: tokens[i2].open + " " }, { from: range2.to, insert: " " + tokens[i2].close }];
      })) };
    } else if (option != 1 && comments.some((c4) => c4)) {
      let changes = [];
      for (let i2 = 0, comment2; i2 < comments.length; i2++)
        if (comment2 = comments[i2]) {
          let token = tokens[i2], { open, close } = comment2;
          changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
        }
      return { changes };
    }
    return null;
  }
  function changeLineComment(option, state3, ranges = state3.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to: to2 } of ranges) {
      let startI = lines.length, minIndent = 1e9;
      for (let pos = from; pos <= to2; ) {
        let line = state3.doc.lineAt(pos);
        if (line.from > prevLine && (from == to2 || to2 > line.from)) {
          prevLine = line.from;
          let token = getConfig2(state3, pos).line;
          if (!token)
            continue;
          let indent = /^\s*/.exec(line.text)[0].length;
          let empty2 = indent == line.length;
          let comment2 = line.text.slice(indent, indent + token.length) == token ? indent : -1;
          if (indent < line.text.length && indent < minIndent)
            minIndent = indent;
          lines.push({ line, comment: comment2, token, indent, empty: empty2, single: false });
        }
        pos = line.to + 1;
      }
      if (minIndent < 1e9) {
        for (let i2 = startI; i2 < lines.length; i2++)
          if (lines[i2].indent < lines[i2].line.text.length)
            lines[i2].indent = minIndent;
      }
      if (lines.length == startI + 1)
        lines[startI].single = true;
    }
    if (option != 2 && lines.some((l) => l.comment < 0 && (!l.empty || l.single))) {
      let changes = [];
      for (let { line, token, indent, empty: empty2, single } of lines)
        if (single || !empty2)
          changes.push({ from: line.from + indent, insert: token + " " });
      let changeSet = state3.changes(changes);
      return { changes: changeSet, selection: state3.selection.map(changeSet, 1) };
    } else if (option != 1 && lines.some((l) => l.comment >= 0)) {
      let changes = [];
      for (let { line, comment: comment2, token } of lines)
        if (comment2 >= 0) {
          let from = line.from + comment2, to2 = from + token.length;
          if (line.text[to2 - line.from] == " ")
            to2++;
          changes.push({ from, to: to2 });
        }
      return { changes };
    }
    return null;
  }
  var fromHistory = /* @__PURE__ */ Annotation.define();
  var isolateHistory = /* @__PURE__ */ Annotation.define();
  var invertedEffects = /* @__PURE__ */ Facet.define();
  var historyConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        minDepth: 100,
        newGroupDelay: 500
      }, { minDepth: Math.max, newGroupDelay: Math.min });
    }
  });
  function changeEnd(changes) {
    let end = 0;
    changes.iterChangedRanges((_, to2) => end = to2);
    return end;
  }
  var historyField_ = /* @__PURE__ */ StateField.define({
    create() {
      return HistoryState.empty;
    },
    update(state3, tr) {
      let config2 = tr.state.facet(historyConfig);
      let fromHist = tr.annotation(fromHistory);
      if (fromHist) {
        let selection = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
        let item = HistEvent.fromTransaction(tr, selection), from = fromHist.side;
        let other = from == 0 ? state3.undone : state3.done;
        if (item)
          other = updateBranch(other, other.length, config2.minDepth, item);
        else
          other = addSelection(other, tr.startState.selection);
        return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
      }
      let isolate = tr.annotation(isolateHistory);
      if (isolate == "full" || isolate == "before")
        state3 = state3.isolate();
      if (tr.annotation(Transaction2.addToHistory) === false)
        return !tr.changes.empty ? state3.addMapping(tr.changes.desc) : state3;
      let event = HistEvent.fromTransaction(tr);
      let time = tr.annotation(Transaction2.time), userEvent = tr.annotation(Transaction2.userEvent);
      if (event)
        state3 = state3.addChanges(event, time, userEvent, config2.newGroupDelay, config2.minDepth);
      else if (tr.selection)
        state3 = state3.addSelection(tr.startState.selection, time, userEvent, config2.newGroupDelay);
      if (isolate == "full" || isolate == "after")
        state3 = state3.isolate();
      return state3;
    },
    toJSON(value) {
      return { done: value.done.map((e2) => e2.toJSON()), undone: value.undone.map((e2) => e2.toJSON()) };
    },
    fromJSON(json) {
      return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
  });
  function history(config2 = {}) {
    return [
      historyField_,
      historyConfig.of(config2),
      EditorView.domEventHandlers({
        beforeinput(e2, view) {
          let command2 = e2.inputType == "historyUndo" ? undo : e2.inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e2.preventDefault();
          return command2(view);
        }
      })
    ];
  }
  function cmd(side, selection) {
    return function({ state: state3, dispatch: dispatch2 }) {
      if (!selection && state3.readOnly)
        return false;
      let historyState = state3.field(historyField_, false);
      if (!historyState)
        return false;
      let tr = historyState.pop(side, state3, selection);
      if (!tr)
        return false;
      dispatch2(tr);
      return true;
    };
  }
  var undo = /* @__PURE__ */ cmd(0, false);
  var redo = /* @__PURE__ */ cmd(1, false);
  var undoSelection = /* @__PURE__ */ cmd(0, true);
  var redoSelection = /* @__PURE__ */ cmd(1, true);
  var HistEvent = class {
    constructor(changes, effects, mapped, startSelection, selectionsAfter) {
      this.changes = changes;
      this.effects = effects;
      this.mapped = mapped;
      this.startSelection = startSelection;
      this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
      return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
      var _a2, _b, _c;
      return {
        changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
        mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
        startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
        selectionsAfter: this.selectionsAfter.map((s) => s.toJSON())
      };
    }
    static fromJSON(json) {
      return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(EditorSelection.fromJSON));
    }
    static fromTransaction(tr, selection) {
      let effects = none2;
      for (let invert of tr.startState.facet(invertedEffects)) {
        let result = invert(tr);
        if (result.length)
          effects = effects.concat(result);
      }
      if (!effects.length && tr.changes.empty)
        return null;
      return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection || tr.startState.selection, none2);
    }
    static selection(selections) {
      return new HistEvent(void 0, none2, void 0, void 0, selections);
    }
  };
  function updateBranch(branch, to2, maxLen, newEvent) {
    let start2 = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
    let newBranch = branch.slice(start2, to2);
    newBranch.push(newEvent);
    return newBranch;
  }
  function isAdjacent(a2, b2) {
    let ranges = [], isAdjacent2 = false;
    a2.iterChangedRanges((f, t2) => ranges.push(f, t2));
    b2.iterChangedRanges((_f, _t, f, t2) => {
      for (let i2 = 0; i2 < ranges.length; ) {
        let from = ranges[i2++], to2 = ranges[i2++];
        if (t2 >= from && f <= to2)
          isAdjacent2 = true;
      }
    });
    return isAdjacent2;
  }
  function eqSelectionShape(a2, b2) {
    return a2.ranges.length == b2.ranges.length && a2.ranges.filter((r, i2) => r.empty != b2.ranges[i2].empty).length === 0;
  }
  function conc(a2, b2) {
    return !a2.length ? b2 : !b2.length ? a2 : a2.concat(b2);
  }
  var none2 = [];
  var MaxSelectionsPerEvent = 200;
  function addSelection(branch, selection) {
    if (!branch.length) {
      return [HistEvent.selection([selection])];
    } else {
      let lastEvent = branch[branch.length - 1];
      let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
      if (sels.length && sels[sels.length - 1].eq(selection))
        return branch;
      sels.push(selection);
      return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
  }
  function popSelection(branch) {
    let last2 = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last2.setSelAfter(last2.selectionsAfter.slice(0, last2.selectionsAfter.length - 1));
    return newBranch;
  }
  function addMappingToBranch(branch, mapping) {
    if (!branch.length)
      return branch;
    let length = branch.length, selections = none2;
    while (length) {
      let event = mapEvent(branch[length - 1], mapping, selections);
      if (event.changes && !event.changes.empty || event.effects.length) {
        let result = branch.slice(0, length);
        result[length - 1] = event;
        return result;
      } else {
        mapping = event.mapped;
        length--;
        selections = event.selectionsAfter;
      }
    }
    return selections.length ? [HistEvent.selection(selections)] : none2;
  }
  function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map((s) => s.map(mapping)) : none2, extraSelections);
    if (!event.changes)
      return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
  }
  var joinableUserEvent = /^(input\.type|delete)($|\.)/;
  var HistoryState = class {
    constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
      this.done = done;
      this.undone = undone;
      this.prevTime = prevTime;
      this.prevUserEvent = prevUserEvent;
    }
    isolate() {
      return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, newGroupDelay, maxLen) {
      let done = this.done, lastEvent = done[done.length - 1];
      if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event.changes) || userEvent == "input.type.compose")) {
        done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none2));
      } else {
        done = updateBranch(done, done.length, maxLen, event);
      }
      return new HistoryState(done, none2, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
      let last2 = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none2;
      if (last2.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last2[last2.length - 1], selection))
        return this;
      return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
      return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state3, selection) {
      let branch = side == 0 ? this.done : this.undone;
      if (branch.length == 0)
        return null;
      let event = branch[branch.length - 1];
      if (selection && event.selectionsAfter.length) {
        return state3.update({
          selection: event.selectionsAfter[event.selectionsAfter.length - 1],
          annotations: fromHistory.of({ side, rest: popSelection(branch) }),
          userEvent: side == 0 ? "select.undo" : "select.redo",
          scrollIntoView: true
        });
      } else if (!event.changes) {
        return null;
      } else {
        let rest = branch.length == 1 ? none2 : branch.slice(0, branch.length - 1);
        if (event.mapped)
          rest = addMappingToBranch(rest, event.mapped);
        return state3.update({
          changes: event.changes,
          selection: event.startSelection,
          effects: event.effects,
          annotations: fromHistory.of({ side, rest }),
          filter: false,
          userEvent: side == 0 ? "undo" : "redo",
          scrollIntoView: true
        });
      }
    }
  };
  HistoryState.empty = /* @__PURE__ */ new HistoryState(none2, none2);
  var historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
  ];
  function updateSel(sel, by) {
    return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
  }
  function setSel(state3, selection) {
    return state3.update({ selection, scrollIntoView: true, userEvent: "select" });
  }
  function moveSel({ state: state3, dispatch: dispatch2 }, how) {
    let selection = updateSel(state3.selection, how);
    if (selection.eq(state3.selection))
      return false;
    dispatch2(setSel(state3, selection));
    return true;
  }
  function rangeEnd(range2, forward) {
    return EditorSelection.cursor(forward ? range2.to : range2.from);
  }
  function cursorByChar(view, forward) {
    return moveSel(view, (range2) => range2.empty ? view.moveByChar(range2, forward) : rangeEnd(range2, forward));
  }
  function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
  }
  var cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
  var cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
  function cursorByGroup(view, forward) {
    return moveSel(view, (range2) => range2.empty ? view.moveByGroup(range2, forward) : rangeEnd(range2, forward));
  }
  var cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
  var cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
  function interestingNode(state3, node, bracketProp) {
    if (node.type.prop(bracketProp))
      return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state3.sliceDoc(node.from, node.to))) || node.firstChild;
  }
  function moveBySyntax(state3, start2, forward) {
    let pos = syntaxTree(state3).resolveInner(start2.head);
    let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
    for (let at = start2.head; ; ) {
      let next = forward ? pos.childAfter(at) : pos.childBefore(at);
      if (!next)
        break;
      if (interestingNode(state3, next, bracketProp))
        pos = next;
      else
        at = forward ? next.to : next.from;
    }
    let bracket2 = pos.type.prop(bracketProp), match, newPos;
    if (bracket2 && (match = forward ? matchBrackets(state3, pos.from, 1) : matchBrackets(state3, pos.to, -1)) && match.matched)
      newPos = forward ? match.end.to : match.end.from;
    else
      newPos = forward ? pos.to : pos.from;
    return EditorSelection.cursor(newPos, forward ? -1 : 1);
  }
  var cursorSyntaxLeft = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
  var cursorSyntaxRight = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
  function cursorByLine(view, forward) {
    return moveSel(view, (range2) => {
      if (!range2.empty)
        return rangeEnd(range2, forward);
      let moved = view.moveVertically(range2, forward);
      return moved.head != range2.head ? moved : view.moveToLineBoundary(range2, forward);
    });
  }
  var cursorLineUp = (view) => cursorByLine(view, false);
  var cursorLineDown = (view) => cursorByLine(view, true);
  function cursorByPage(view, forward) {
    let { state: state3 } = view, selection = updateSel(state3.selection, (range2) => {
      return range2.empty ? view.moveVertically(range2, forward, Math.min(view.dom.clientHeight, innerHeight)) : rangeEnd(range2, forward);
    });
    if (selection.eq(state3.selection))
      return false;
    let startPos = view.coordsAtPos(state3.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let effect;
    if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
      effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
    view.dispatch(setSel(state3, selection), { effects: effect });
    return true;
  }
  var cursorPageUp = (view) => cursorByPage(view, false);
  var cursorPageDown = (view) => cursorByPage(view, true);
  function moveByLineBoundary(view, start2, forward) {
    let line = view.lineBlockAt(start2.head), moved = view.moveToLineBoundary(start2, forward);
    if (moved.head == start2.head && moved.head != (forward ? line.to : line.from))
      moved = view.moveToLineBoundary(start2, forward, false);
    if (!forward && moved.head == line.from && line.length) {
      let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
      if (space && start2.head != line.from + space)
        moved = EditorSelection.cursor(line.from + space);
    }
    return moved;
  }
  var cursorLineBoundaryForward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, true));
  var cursorLineBoundaryBackward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, false));
  var cursorLineStart = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from, 1));
  var cursorLineEnd = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to, -1));
  function toMatchingBracket(state3, dispatch2, extend3) {
    let found = false, selection = updateSel(state3.selection, (range2) => {
      let matching = matchBrackets(state3, range2.head, -1) || matchBrackets(state3, range2.head, 1) || range2.head > 0 && matchBrackets(state3, range2.head - 1, 1) || range2.head < state3.doc.length && matchBrackets(state3, range2.head + 1, -1);
      if (!matching || !matching.end)
        return range2;
      found = true;
      let head = matching.start.from == range2.head ? matching.end.to : matching.end.from;
      return extend3 ? EditorSelection.range(range2.anchor, head) : EditorSelection.cursor(head);
    });
    if (!found)
      return false;
    dispatch2(setSel(state3, selection));
    return true;
  }
  var cursorMatchingBracket = ({ state: state3, dispatch: dispatch2 }) => toMatchingBracket(state3, dispatch2, false);
  function extendSel(view, how) {
    let selection = updateSel(view.state.selection, (range2) => {
      let head = how(range2);
      return EditorSelection.range(range2.anchor, head.head, head.goalColumn);
    });
    if (selection.eq(view.state.selection))
      return false;
    view.dispatch(setSel(view.state, selection));
    return true;
  }
  function selectByChar(view, forward) {
    return extendSel(view, (range2) => view.moveByChar(range2, forward));
  }
  var selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
  var selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
  function selectByGroup(view, forward) {
    return extendSel(view, (range2) => view.moveByGroup(range2, forward));
  }
  var selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
  var selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
  var selectSyntaxLeft = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
  var selectSyntaxRight = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
  function selectByLine(view, forward) {
    return extendSel(view, (range2) => view.moveVertically(range2, forward));
  }
  var selectLineUp = (view) => selectByLine(view, false);
  var selectLineDown = (view) => selectByLine(view, true);
  function selectByPage(view, forward) {
    return extendSel(view, (range2) => view.moveVertically(range2, forward, Math.min(view.dom.clientHeight, innerHeight)));
  }
  var selectPageUp = (view) => selectByPage(view, false);
  var selectPageDown = (view) => selectByPage(view, true);
  var selectLineBoundaryForward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, true));
  var selectLineBoundaryBackward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, false));
  var selectLineStart = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from));
  var selectLineEnd = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to));
  var cursorDocStart = ({ state: state3, dispatch: dispatch2 }) => {
    dispatch2(setSel(state3, { anchor: 0 }));
    return true;
  };
  var cursorDocEnd = ({ state: state3, dispatch: dispatch2 }) => {
    dispatch2(setSel(state3, { anchor: state3.doc.length }));
    return true;
  };
  var selectDocStart = ({ state: state3, dispatch: dispatch2 }) => {
    dispatch2(setSel(state3, { anchor: state3.selection.main.anchor, head: 0 }));
    return true;
  };
  var selectDocEnd = ({ state: state3, dispatch: dispatch2 }) => {
    dispatch2(setSel(state3, { anchor: state3.selection.main.anchor, head: state3.doc.length }));
    return true;
  };
  var selectAll = ({ state: state3, dispatch: dispatch2 }) => {
    dispatch2(state3.update({ selection: { anchor: 0, head: state3.doc.length }, userEvent: "select" }));
    return true;
  };
  var selectLine = ({ state: state3, dispatch: dispatch2 }) => {
    let ranges = selectedLineBlocks(state3).map(({ from, to: to2 }) => EditorSelection.range(from, Math.min(to2 + 1, state3.doc.length)));
    dispatch2(state3.update({ selection: EditorSelection.create(ranges), userEvent: "select" }));
    return true;
  };
  var selectParentSyntax = ({ state: state3, dispatch: dispatch2 }) => {
    let selection = updateSel(state3.selection, (range2) => {
      var _a2;
      let context2 = syntaxTree(state3).resolveInner(range2.head, 1);
      while (!(context2.from < range2.from && context2.to >= range2.to || context2.to > range2.to && context2.from <= range2.from || !((_a2 = context2.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
        context2 = context2.parent;
      return EditorSelection.range(context2.to, context2.from);
    });
    dispatch2(setSel(state3, selection));
    return true;
  };
  var simplifySelection = ({ state: state3, dispatch: dispatch2 }) => {
    let cur2 = state3.selection, selection = null;
    if (cur2.ranges.length > 1)
      selection = EditorSelection.create([cur2.main]);
    else if (!cur2.main.empty)
      selection = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
    if (!selection)
      return false;
    dispatch2(setSel(state3, selection));
    return true;
  };
  function deleteBy({ state: state3, dispatch: dispatch2 }, by) {
    if (state3.readOnly)
      return false;
    let event = "delete.selection";
    let changes = state3.changeByRange((range2) => {
      let { from, to: to2 } = range2;
      if (from == to2) {
        let towards = by(from);
        if (towards < from)
          event = "delete.backward";
        else if (towards > from)
          event = "delete.forward";
        from = Math.min(from, towards);
        to2 = Math.max(to2, towards);
      }
      return from == to2 ? { range: range2 } : { changes: { from, to: to2 }, range: EditorSelection.cursor(from) };
    });
    if (changes.changes.empty)
      return false;
    dispatch2(state3.update(changes, { scrollIntoView: true, userEvent: event }));
    return true;
  }
  function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
      for (let ranges of target.state.facet(EditorView.atomicRanges).map((f) => f(target)))
        ranges.between(pos, pos, (from, to2) => {
          if (from < pos && to2 > pos)
            pos = forward ? to2 : from;
        });
    return pos;
  }
  var deleteByChar = (target, forward) => deleteBy(target, (pos) => {
    let { state: state3 } = target, line = state3.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
      if (before[before.length - 1] == "	")
        return pos - 1;
      let col = countColumn(before, state3.tabSize), drop = col % getIndentUnit(state3) || getIndentUnit(state3);
      for (let i2 = 0; i2 < drop && before[before.length - 1 - i2] == " "; i2++)
        pos--;
      targetPos = pos;
    } else {
      targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
      if (targetPos == pos && line.number != (forward ? state3.doc.lines : 1))
        targetPos += forward ? 1 : -1;
    }
    return skipAtomic(target, targetPos, forward);
  });
  var deleteCharBackward = (view) => deleteByChar(view, false);
  var deleteCharForward = (view) => deleteByChar(view, true);
  var deleteByGroup = (target, forward) => deleteBy(target, (start2) => {
    let pos = start2, { state: state3 } = target, line = state3.doc.lineAt(pos);
    let categorize = state3.charCategorizer(pos);
    for (let cat = null; ; ) {
      if (pos == (forward ? line.to : line.from)) {
        if (pos == start2 && line.number != (forward ? state3.doc.lines : 1))
          pos += forward ? 1 : -1;
        break;
      }
      let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
      let nextChar2 = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
      let nextCat = categorize(nextChar2);
      if (cat != null && nextCat != cat)
        break;
      if (nextChar2 != " " || pos != start2)
        cat = nextCat;
      pos = next;
    }
    return skipAtomic(target, pos, forward);
  });
  var deleteGroupBackward = (target) => deleteByGroup(target, false);
  var deleteGroupForward = (target) => deleteByGroup(target, true);
  var deleteToLineEnd = (view) => deleteBy(view, (pos) => {
    let lineEnd = view.lineBlockAt(pos).to;
    return skipAtomic(view, pos < lineEnd ? lineEnd : Math.min(view.state.doc.length, pos + 1), true);
  });
  var deleteToLineStart = (view) => deleteBy(view, (pos) => {
    let lineStart = view.lineBlockAt(pos).from;
    return skipAtomic(view, pos > lineStart ? lineStart : Math.max(0, pos - 1), false);
  });
  var splitLine = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    let changes = state3.changeByRange((range2) => {
      return {
        changes: { from: range2.from, to: range2.to, insert: Text.of(["", ""]) },
        range: EditorSelection.cursor(range2.from)
      };
    });
    dispatch2(state3.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
  var transposeChars = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    let changes = state3.changeByRange((range2) => {
      if (!range2.empty || range2.from == 0 || range2.from == state3.doc.length)
        return { range: range2 };
      let pos = range2.from, line = state3.doc.lineAt(pos);
      let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
      let to2 = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
      return {
        changes: { from, to: to2, insert: state3.doc.slice(pos, to2).append(state3.doc.slice(from, pos)) },
        range: EditorSelection.cursor(to2)
      };
    });
    if (changes.changes.empty)
      return false;
    dispatch2(state3.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
  };
  function selectedLineBlocks(state3) {
    let blocks = [], upto = -1;
    for (let range2 of state3.selection.ranges) {
      let startLine = state3.doc.lineAt(range2.from), endLine = state3.doc.lineAt(range2.to);
      if (!range2.empty && range2.to == endLine.from)
        endLine = state3.doc.lineAt(range2.to - 1);
      if (upto >= startLine.number) {
        let prev = blocks[blocks.length - 1];
        prev.to = endLine.to;
        prev.ranges.push(range2);
      } else {
        blocks.push({ from: startLine.from, to: endLine.to, ranges: [range2] });
      }
      upto = endLine.number + 1;
    }
    return blocks;
  }
  function moveLine(state3, dispatch2, forward) {
    if (state3.readOnly)
      return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state3)) {
      if (forward ? block.to == state3.doc.length : block.from == 0)
        continue;
      let nextLine = state3.doc.lineAt(forward ? block.to + 1 : block.from - 1);
      let size2 = nextLine.length + 1;
      if (forward) {
        changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state3.lineBreak });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(Math.min(state3.doc.length, r.anchor + size2), Math.min(state3.doc.length, r.head + size2)));
      } else {
        changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state3.lineBreak + nextLine.text });
        for (let r of block.ranges)
          ranges.push(EditorSelection.range(r.anchor - size2, r.head - size2));
      }
    }
    if (!changes.length)
      return false;
    dispatch2(state3.update({
      changes,
      scrollIntoView: true,
      selection: EditorSelection.create(ranges, state3.selection.mainIndex),
      userEvent: "move.line"
    }));
    return true;
  }
  var moveLineUp = ({ state: state3, dispatch: dispatch2 }) => moveLine(state3, dispatch2, false);
  var moveLineDown = ({ state: state3, dispatch: dispatch2 }) => moveLine(state3, dispatch2, true);
  function copyLine(state3, dispatch2, forward) {
    if (state3.readOnly)
      return false;
    let changes = [];
    for (let block of selectedLineBlocks(state3)) {
      if (forward)
        changes.push({ from: block.from, insert: state3.doc.slice(block.from, block.to) + state3.lineBreak });
      else
        changes.push({ from: block.to, insert: state3.lineBreak + state3.doc.slice(block.from, block.to) });
    }
    dispatch2(state3.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
  }
  var copyLineUp = ({ state: state3, dispatch: dispatch2 }) => copyLine(state3, dispatch2, false);
  var copyLineDown = ({ state: state3, dispatch: dispatch2 }) => copyLine(state3, dispatch2, true);
  var deleteLine = (view) => {
    if (view.state.readOnly)
      return false;
    let { state: state3 } = view, changes = state3.changes(selectedLineBlocks(state3).map(({ from, to: to2 }) => {
      if (from > 0)
        from--;
      else if (to2 < state3.doc.length)
        to2++;
      return { from, to: to2 };
    }));
    let selection = updateSel(state3.selection, (range2) => view.moveVertically(range2, true)).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
  };
  function isBetweenBrackets(state3, pos) {
    if (/\(\)|\[\]|\{\}/.test(state3.sliceDoc(pos - 1, pos + 1)))
      return { from: pos, to: pos };
    let context2 = syntaxTree(state3).resolveInner(pos);
    let before = context2.childBefore(pos), after = context2.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state3.doc.lineAt(before.to).from == state3.doc.lineAt(after.from).from)
      return { from: before.to, to: after.from };
    return null;
  }
  var insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
  var insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
  function newlineAndIndent(atEof) {
    return ({ state: state3, dispatch: dispatch2 }) => {
      if (state3.readOnly)
        return false;
      let changes = state3.changeByRange((range2) => {
        let { from, to: to2 } = range2, line = state3.doc.lineAt(from);
        let explode = !atEof && from == to2 && isBetweenBrackets(state3, from);
        if (atEof)
          from = to2 = (to2 <= line.to ? line : state3.doc.lineAt(to2)).to;
        let cx = new IndentContext(state3, { simulateBreak: from, simulateDoubleBreak: !!explode });
        let indent = getIndentation(cx, from);
        if (indent == null)
          indent = /^\s*/.exec(state3.doc.lineAt(from).text)[0].length;
        while (to2 < line.to && /\s/.test(line.text[to2 - line.from]))
          to2++;
        if (explode)
          ({ from, to: to2 } = explode);
        else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
          from = line.from;
        let insert2 = ["", indentString(state3, indent)];
        if (explode)
          insert2.push(indentString(state3, cx.lineIndent(line.from, -1)));
        return {
          changes: { from, to: to2, insert: Text.of(insert2) },
          range: EditorSelection.cursor(from + 1 + insert2[1].length)
        };
      });
      dispatch2(state3.update(changes, { scrollIntoView: true, userEvent: "input" }));
      return true;
    };
  }
  function changeBySelectedLine(state3, f) {
    let atLine = -1;
    return state3.changeByRange((range2) => {
      let changes = [];
      for (let pos = range2.from; pos <= range2.to; ) {
        let line = state3.doc.lineAt(pos);
        if (line.number > atLine && (range2.empty || range2.to > line.from)) {
          f(line, changes, range2);
          atLine = line.number;
        }
        pos = line.to + 1;
      }
      let changeSet = state3.changes(changes);
      return {
        changes,
        range: EditorSelection.range(changeSet.mapPos(range2.anchor, 1), changeSet.mapPos(range2.head, 1))
      };
    });
  }
  var indentSelection = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    let updated = /* @__PURE__ */ Object.create(null);
    let context2 = new IndentContext(state3, { overrideIndentation: (start2) => {
      let found = updated[start2];
      return found == null ? -1 : found;
    } });
    let changes = changeBySelectedLine(state3, (line, changes2, range2) => {
      let indent = getIndentation(context2, line.from);
      if (indent == null)
        return;
      if (!/\S/.test(line.text))
        indent = 0;
      let cur2 = /^\s*/.exec(line.text)[0];
      let norm = indentString(state3, indent);
      if (cur2 != norm || range2.from < line.from + cur2.length) {
        updated[line.from] = indent;
        changes2.push({ from: line.from, to: line.from + cur2.length, insert: norm });
      }
    });
    if (!changes.changes.empty)
      dispatch2(state3.update(changes, { userEvent: "indent" }));
    return true;
  };
  var indentMore = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    dispatch2(state3.update(changeBySelectedLine(state3, (line, changes) => {
      changes.push({ from: line.from, insert: state3.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
  };
  var indentLess = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    dispatch2(state3.update(changeBySelectedLine(state3, (line, changes) => {
      let space = /^\s*/.exec(line.text)[0];
      if (!space)
        return;
      let col = countColumn(space, state3.tabSize), keep = 0;
      let insert2 = indentString(state3, Math.max(0, col - getIndentUnit(state3)));
      while (keep < space.length && keep < insert2.length && space.charCodeAt(keep) == insert2.charCodeAt(keep))
        keep++;
      changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert2.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
  };
  var emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown }
  ];
  var standardKeymap = /* @__PURE__ */ [
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteToLineStart },
    { mac: "Mod-Delete", run: deleteToLineEnd }
  ].concat(/* @__PURE__ */ emacsStyleKeymap.map((b2) => ({ mac: b2.key, run: b2.run, shift: b2.shift })));
  var defaultKeymap = /* @__PURE__ */ [
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
  ].concat(standardKeymap);

  // node_modules/crelt/index.es.js
  function crelt() {
    var elt = arguments[0];
    if (typeof elt == "string")
      elt = document.createElement(elt);
    var i2 = 1, next = arguments[1];
    if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
      for (var name3 in next)
        if (Object.prototype.hasOwnProperty.call(next, name3)) {
          var value = next[name3];
          if (typeof value == "string")
            elt.setAttribute(name3, value);
          else if (value != null)
            elt[name3] = value;
        }
      i2++;
    }
    for (; i2 < arguments.length; i2++)
      add(elt, arguments[i2]);
    return elt;
  }
  function add(elt, child) {
    if (typeof child == "string") {
      elt.appendChild(document.createTextNode(child));
    } else if (child == null) {
    } else if (child.nodeType != null) {
      elt.appendChild(child);
    } else if (Array.isArray(child)) {
      for (var i2 = 0; i2 < child.length; i2++)
        add(elt, child[i2]);
    } else {
      throw new RangeError("Unsupported child node: " + child);
    }
  }

  // node_modules/@codemirror/search/dist/index.js
  var basicNormalize = typeof String.prototype.normalize == "function" ? (x) => x.normalize("NFKD") : (x) => x;
  var SearchCursor = class {
    constructor(text, query, from = 0, to2 = text.length, normalize) {
      this.value = { from: 0, to: 0 };
      this.done = false;
      this.matches = [];
      this.buffer = "";
      this.bufferPos = 0;
      this.iter = text.iterRange(from, to2);
      this.bufferStart = from;
      this.normalize = normalize ? (x) => normalize(basicNormalize(x)) : basicNormalize;
      this.query = this.normalize(query);
    }
    peek() {
      if (this.bufferPos == this.buffer.length) {
        this.bufferStart += this.buffer.length;
        this.iter.next();
        if (this.iter.done)
          return -1;
        this.bufferPos = 0;
        this.buffer = this.iter.value;
      }
      return codePointAt(this.buffer, this.bufferPos);
    }
    next() {
      while (this.matches.length)
        this.matches.pop();
      return this.nextOverlapping();
    }
    nextOverlapping() {
      for (; ; ) {
        let next = this.peek();
        if (next < 0) {
          this.done = true;
          return this;
        }
        let str = fromCodePoint(next), start2 = this.bufferStart + this.bufferPos;
        this.bufferPos += codePointSize(next);
        let norm = this.normalize(str);
        for (let i2 = 0, pos = start2; ; i2++) {
          let code2 = norm.charCodeAt(i2);
          let match = this.match(code2, pos);
          if (match) {
            this.value = match;
            return this;
          }
          if (i2 == norm.length - 1)
            break;
          if (pos == start2 && i2 < str.length && str.charCodeAt(i2) == code2)
            pos++;
        }
      }
    }
    match(code2, pos) {
      let match = null;
      for (let i2 = 0; i2 < this.matches.length; i2 += 2) {
        let index = this.matches[i2], keep = false;
        if (this.query.charCodeAt(index) == code2) {
          if (index == this.query.length - 1) {
            match = { from: this.matches[i2 + 1], to: pos + 1 };
          } else {
            this.matches[i2]++;
            keep = true;
          }
        }
        if (!keep) {
          this.matches.splice(i2, 2);
          i2 -= 2;
        }
      }
      if (this.query.charCodeAt(0) == code2) {
        if (this.query.length == 1)
          match = { from: pos, to: pos + 1 };
        else
          this.matches.push(1, pos);
      }
      return match;
    }
  };
  if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  var empty = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") };
  var baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
  var RegExpCursor = class {
    constructor(text, query, options2, from = 0, to2 = text.length) {
      this.to = to2;
      this.curLine = "";
      this.done = false;
      this.value = empty;
      if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
        return new MultilineRegExpCursor(text, query, options2, from, to2);
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.iter = text.iter();
      let startLine = text.lineAt(from);
      this.curLineStart = startLine.from;
      this.matchPos = from;
      this.getLine(this.curLineStart);
    }
    getLine(skip) {
      this.iter.next(skip);
      if (this.iter.lineBreak) {
        this.curLine = "";
      } else {
        this.curLine = this.iter.value;
        if (this.curLineStart + this.curLine.length > this.to)
          this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
        this.iter.next();
      }
    }
    nextLine() {
      this.curLineStart = this.curLineStart + this.curLine.length + 1;
      if (this.curLineStart > this.to)
        this.curLine = "";
      else
        this.getLine(0);
    }
    next() {
      for (let off = this.matchPos - this.curLineStart; ; ) {
        this.re.lastIndex = off;
        let match = this.matchPos <= this.to && this.re.exec(this.curLine);
        if (match) {
          let from = this.curLineStart + match.index, to2 = from + match[0].length;
          this.matchPos = to2 + (from == to2 ? 1 : 0);
          if (from == this.curLine.length)
            this.nextLine();
          if (from < to2 || from > this.value.to) {
            this.value = { from, to: to2, match };
            return this;
          }
          off = this.matchPos - this.curLineStart;
        } else if (this.curLineStart + this.curLine.length < this.to) {
          this.nextLine();
          off = 0;
        } else {
          this.done = true;
          return this;
        }
      }
    }
  };
  var flattened = /* @__PURE__ */ new WeakMap();
  var FlattenedDoc = class {
    constructor(from, text) {
      this.from = from;
      this.text = text;
    }
    get to() {
      return this.from + this.text.length;
    }
    static get(doc2, from, to2) {
      let cached = flattened.get(doc2);
      if (!cached || cached.from >= to2 || cached.to <= from) {
        let flat = new FlattenedDoc(from, doc2.sliceString(from, to2));
        flattened.set(doc2, flat);
        return flat;
      }
      if (cached.from == from && cached.to == to2)
        return cached;
      let { text, from: cachedFrom } = cached;
      if (cachedFrom > from) {
        text = doc2.sliceString(from, cachedFrom) + text;
        cachedFrom = from;
      }
      if (cached.to < to2)
        text += doc2.sliceString(cached.to, to2);
      flattened.set(doc2, new FlattenedDoc(cachedFrom, text));
      return new FlattenedDoc(from, text.slice(from - cachedFrom, to2 - cachedFrom));
    }
  };
  var MultilineRegExpCursor = class {
    constructor(text, query, options2, from, to2) {
      this.text = text;
      this.to = to2;
      this.done = false;
      this.value = empty;
      this.matchPos = from;
      this.re = new RegExp(query, baseFlags + ((options2 === null || options2 === void 0 ? void 0 : options2.ignoreCase) ? "i" : ""));
      this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5e3));
    }
    chunkEnd(pos) {
      return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
      for (; ; ) {
        let off = this.re.lastIndex = this.matchPos - this.flat.from;
        let match = this.re.exec(this.flat.text);
        if (match && !match[0] && match.index == off) {
          this.re.lastIndex = off + 1;
          match = this.re.exec(this.flat.text);
        }
        if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)
          match = null;
        if (match) {
          let from = this.flat.from + match.index, to2 = from + match[0].length;
          this.value = { from, to: to2, match };
          this.matchPos = to2 + (from == to2 ? 1 : 0);
          return this;
        } else {
          if (this.flat.to == this.to) {
            this.done = true;
            return this;
          }
          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
      }
    }
  };
  if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function() {
      return this;
    };
  }
  function validRegExp(source) {
    try {
      new RegExp(source, baseFlags);
      return true;
    } catch (_a2) {
      return false;
    }
  }
  function createLineDialog(view) {
    let input = crelt("input", { class: "cm-textfield", name: "line" });
    let dom2 = crelt("form", {
      class: "cm-gotoLine",
      onkeydown: (event) => {
        if (event.keyCode == 27) {
          event.preventDefault();
          view.dispatch({ effects: dialogEffect.of(false) });
          view.focus();
        } else if (event.keyCode == 13) {
          event.preventDefault();
          go();
        }
      },
      onsubmit: (event) => {
        event.preventDefault();
        go();
      }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go() {
      let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
      if (!match)
        return;
      let { state: state3 } = view, startLine = state3.doc.lineAt(state3.selection.main.head);
      let [, sign, ln, cl, percent] = match;
      let col = cl ? +cl.slice(1) : 0;
      let line = ln ? +ln : startLine.number;
      if (ln && percent) {
        let pc = line / 100;
        if (sign)
          pc = pc * (sign == "-" ? -1 : 1) + startLine.number / state3.doc.lines;
        line = Math.round(state3.doc.lines * pc);
      } else if (ln && sign) {
        line = line * (sign == "-" ? -1 : 1) + startLine.number;
      }
      let docLine = state3.doc.line(Math.max(1, Math.min(state3.doc.lines, line)));
      view.dispatch({
        effects: dialogEffect.of(false),
        selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
        scrollIntoView: true
      });
      view.focus();
    }
    return { dom: dom2 };
  }
  var dialogEffect = /* @__PURE__ */ StateEffect.define();
  var dialogField = /* @__PURE__ */ StateField.define({
    create() {
      return true;
    },
    update(value, tr) {
      for (let e2 of tr.effects)
        if (e2.is(dialogEffect))
          value = e2.value;
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val ? createLineDialog : null)
  });
  var gotoLine = (view) => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
      let effects = [dialogEffect.of(true)];
      if (view.state.field(dialogField, false) == null)
        effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$13]));
      view.dispatch({ effects });
      panel = getPanel(view, createLineDialog);
    }
    if (panel)
      panel.dom.querySelector("input").focus();
    return true;
  };
  var baseTheme$13 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
      padding: "2px 6px 4px",
      "& label": { fontSize: "80%" }
    }
  });
  var defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
  };
  var highlightConfig = /* @__PURE__ */ Facet.define({
    combine(options2) {
      return combineConfig(options2, defaultHighlightOptions, {
        highlightWordAroundCursor: (a2, b2) => a2 || b2,
        minSelectionLength: Math.min,
        maxMatches: Math.min
      });
    }
  });
  function highlightSelectionMatches(options2) {
    let ext = [defaultTheme, matchHighlighter];
    if (options2)
      ext.push(highlightConfig.of(options2));
    return ext;
  }
  var matchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch" });
  var mainMatchDeco = /* @__PURE__ */ Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
  function insideWordBoundaries(check, state3, from, to2) {
    return (from == 0 || check(state3.sliceDoc(from - 1, from)) != CharCategory.Word) && (to2 == state3.doc.length || check(state3.sliceDoc(to2, to2 + 1)) != CharCategory.Word);
  }
  function insideWord(check, state3, from, to2) {
    return check(state3.sliceDoc(from, from + 1)) == CharCategory.Word && check(state3.sliceDoc(to2 - 1, to2)) == CharCategory.Word;
  }
  var matchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.decorations = this.getDeco(view);
    }
    update(update3) {
      if (update3.selectionSet || update3.docChanged || update3.viewportChanged)
        this.decorations = this.getDeco(update3.view);
    }
    getDeco(view) {
      let conf = view.state.facet(highlightConfig);
      let { state: state3 } = view, sel = state3.selection;
      if (sel.ranges.length > 1)
        return Decoration.none;
      let range2 = sel.main, query, check = null;
      if (range2.empty) {
        if (!conf.highlightWordAroundCursor)
          return Decoration.none;
        let word = state3.wordAt(range2.head);
        if (!word)
          return Decoration.none;
        check = state3.charCategorizer(range2.head);
        query = state3.sliceDoc(word.from, word.to);
      } else {
        let len = range2.to - range2.from;
        if (len < conf.minSelectionLength || len > 200)
          return Decoration.none;
        if (conf.wholeWords) {
          query = state3.sliceDoc(range2.from, range2.to);
          check = state3.charCategorizer(range2.head);
          if (!(insideWordBoundaries(check, state3, range2.from, range2.to) && insideWord(check, state3, range2.from, range2.to)))
            return Decoration.none;
        } else {
          query = state3.sliceDoc(range2.from, range2.to).trim();
          if (!query)
            return Decoration.none;
        }
      }
      let deco = [];
      for (let part of view.visibleRanges) {
        let cursor = new SearchCursor(state3.doc, query, part.from, part.to);
        while (!cursor.next().done) {
          let { from, to: to2 } = cursor.value;
          if (!check || insideWordBoundaries(check, state3, from, to2)) {
            if (range2.empty && from <= range2.from && to2 >= range2.to)
              deco.push(mainMatchDeco.range(from, to2));
            else if (from >= range2.to || to2 <= range2.from)
              deco.push(matchDeco.range(from, to2));
            if (deco.length > conf.maxMatches)
              return Decoration.none;
          }
        }
      }
      return Decoration.set(deco);
    }
  }, {
    decorations: (v) => v.decorations
  });
  var defaultTheme = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
  });
  var selectWord = ({ state: state3, dispatch: dispatch2 }) => {
    let { selection } = state3;
    let newSel = EditorSelection.create(selection.ranges.map((range2) => state3.wordAt(range2.head) || EditorSelection.cursor(range2.head)), selection.mainIndex);
    if (newSel.eq(selection))
      return false;
    dispatch2(state3.update({ selection: newSel }));
    return true;
  };
  function findNextOccurrence(state3, query) {
    let { main, ranges } = state3.selection;
    let word = state3.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state3.doc, query, ranges[ranges.length - 1].to); ; ) {
      cursor.next();
      if (cursor.done) {
        if (cycled)
          return null;
        cursor = new SearchCursor(state3.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
        cycled = true;
      } else {
        if (cycled && ranges.some((r) => r.from == cursor.value.from))
          continue;
        if (fullWord) {
          let word2 = state3.wordAt(cursor.value.from);
          if (!word2 || word2.from != cursor.value.from || word2.to != cursor.value.to)
            continue;
        }
        return cursor.value;
      }
    }
  }
  var selectNextOccurrence = ({ state: state3, dispatch: dispatch2 }) => {
    let { ranges } = state3.selection;
    if (ranges.some((sel) => sel.from === sel.to))
      return selectWord({ state: state3, dispatch: dispatch2 });
    let searchedText = state3.sliceDoc(ranges[0].from, ranges[0].to);
    if (state3.selection.ranges.some((r) => state3.sliceDoc(r.from, r.to) != searchedText))
      return false;
    let range2 = findNextOccurrence(state3, searchedText);
    if (!range2)
      return false;
    dispatch2(state3.update({
      selection: state3.selection.addRange(EditorSelection.range(range2.from, range2.to), false),
      effects: EditorView.scrollIntoView(range2.to)
    }));
    return true;
  };
  var searchConfigFacet = /* @__PURE__ */ Facet.define({
    combine(configs) {
      var _a2;
      return {
        top: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.top, void 0) || false,
        caseSensitive: configs.reduce((val, conf) => val !== null && val !== void 0 ? val : conf.caseSensitive, void 0) || false,
        createPanel: ((_a2 = configs.find((c4) => c4.createPanel)) === null || _a2 === void 0 ? void 0 : _a2.createPanel) || ((view) => new SearchPanel(view))
      };
    }
  });
  var SearchQuery = class {
    constructor(config2) {
      this.search = config2.search;
      this.caseSensitive = !!config2.caseSensitive;
      this.regexp = !!config2.regexp;
      this.replace = config2.replace || "";
      this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
      this.unquoted = config2.literal ? this.search : this.search.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
    }
    eq(other) {
      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;
    }
    create() {
      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    getCursor(doc2, from = 0, to2 = doc2.length) {
      return this.regexp ? regexpCursor(this, doc2, from, to2) : stringCursor(this, doc2, from, to2);
    }
  };
  var QueryType2 = class {
    constructor(spec) {
      this.spec = spec;
    }
  };
  function stringCursor(spec, doc2, from, to2) {
    return new SearchCursor(doc2, spec.unquoted, from, to2, spec.caseSensitive ? void 0 : (x) => x.toLowerCase());
  }
  var StringQuery = class extends QueryType2 {
    constructor(spec) {
      super(spec);
    }
    nextMatch(doc2, curFrom, curTo) {
      let cursor = stringCursor(this.spec, doc2, curTo, doc2.length).nextOverlapping();
      if (cursor.done)
        cursor = stringCursor(this.spec, doc2, 0, curFrom).nextOverlapping();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc2, from, to2) {
      for (let pos = to2; ; ) {
        let start2 = Math.max(from, pos - 1e4 - this.spec.unquoted.length);
        let cursor = stringCursor(this.spec, doc2, start2, pos), range2 = null;
        while (!cursor.nextOverlapping().done)
          range2 = cursor.value;
        if (range2)
          return range2;
        if (start2 == from)
          return null;
        pos -= 1e4;
      }
    }
    prevMatch(doc2, curFrom, curTo) {
      return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
    }
    getReplacement(_result) {
      return this.spec.replace;
    }
    matchAll(doc2, limit) {
      let cursor = stringCursor(this.spec, doc2, 0, doc2.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(doc2, from, to2, add2) {
      let cursor = stringCursor(this.spec, doc2, Math.max(0, from - this.spec.unquoted.length), Math.min(to2 + this.spec.unquoted.length, doc2.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  function regexpCursor(spec, doc2, from, to2) {
    return new RegExpCursor(doc2, spec.search, spec.caseSensitive ? void 0 : { ignoreCase: true }, from, to2);
  }
  var RegExpQuery = class extends QueryType2 {
    nextMatch(doc2, curFrom, curTo) {
      let cursor = regexpCursor(this.spec, doc2, curTo, doc2.length).next();
      if (cursor.done)
        cursor = regexpCursor(this.spec, doc2, 0, curFrom).next();
      return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(doc2, from, to2) {
      for (let size2 = 1; ; size2++) {
        let start2 = Math.max(from, to2 - size2 * 1e4);
        let cursor = regexpCursor(this.spec, doc2, start2, to2), range2 = null;
        while (!cursor.next().done)
          range2 = cursor.value;
        if (range2 && (start2 == from || range2.from > start2 + 10))
          return range2;
        if (start2 == from)
          return null;
      }
    }
    prevMatch(doc2, curFrom, curTo) {
      return this.prevMatchInRange(doc2, 0, curFrom) || this.prevMatchInRange(doc2, curTo, doc2.length);
    }
    getReplacement(result) {
      return this.spec.replace.replace(/\$([$&\d+])/g, (m3, i2) => i2 == "$" ? "$" : i2 == "&" ? result.match[0] : i2 != "0" && +i2 < result.match.length ? result.match[i2] : m3);
    }
    matchAll(doc2, limit) {
      let cursor = regexpCursor(this.spec, doc2, 0, doc2.length), ranges = [];
      while (!cursor.next().done) {
        if (ranges.length >= limit)
          return null;
        ranges.push(cursor.value);
      }
      return ranges;
    }
    highlight(doc2, from, to2, add2) {
      let cursor = regexpCursor(this.spec, doc2, Math.max(0, from - 250), Math.min(to2 + 250, doc2.length));
      while (!cursor.next().done)
        add2(cursor.value.from, cursor.value.to);
    }
  };
  var setSearchQuery = /* @__PURE__ */ StateEffect.define();
  var togglePanel = /* @__PURE__ */ StateEffect.define();
  var searchState = /* @__PURE__ */ StateField.define({
    create(state3) {
      return new SearchState(defaultQuery(state3).create(), null);
    },
    update(value, tr) {
      for (let effect of tr.effects) {
        if (effect.is(setSearchQuery))
          value = new SearchState(effect.value.create(), value.panel);
        else if (effect.is(togglePanel))
          value = new SearchState(value.query, effect.value ? createSearchPanel : null);
      }
      return value;
    },
    provide: (f) => showPanel.from(f, (val) => val.panel)
  });
  var SearchState = class {
    constructor(query, panel) {
      this.query = query;
      this.panel = panel;
    }
  };
  var matchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch" });
  var selectedMatchMark = /* @__PURE__ */ Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
  var searchHighlighter = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update3) {
      let state3 = update3.state.field(searchState);
      if (state3 != update3.startState.field(searchState) || update3.docChanged || update3.selectionSet || update3.viewportChanged)
        this.decorations = this.highlight(state3);
    }
    highlight({ query, panel }) {
      if (!panel || !query.spec.valid)
        return Decoration.none;
      let { view } = this;
      let builder = new RangeSetBuilder();
      for (let i2 = 0, ranges = view.visibleRanges, l = ranges.length; i2 < l; i2++) {
        let { from, to: to2 } = ranges[i2];
        while (i2 < l - 1 && to2 > ranges[i2 + 1].from - 2 * 250)
          to2 = ranges[++i2].to;
        query.highlight(view.state.doc, from, to2, (from2, to3) => {
          let selected = view.state.selection.ranges.some((r) => r.from == from2 && r.to == to3);
          builder.add(from2, to3, selected ? selectedMatchMark : matchMark);
        });
      }
      return builder.finish();
    }
  }, {
    decorations: (v) => v.decorations
  });
  function searchCommand(f) {
    return (view) => {
      let state3 = view.state.field(searchState, false);
      return state3 && state3.query.spec.valid ? f(view, state3) : openSearchPanel(view);
    };
  }
  var findNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { from, to: to2 } = view.state.selection.main;
    let next = query.nextMatch(view.state.doc, from, to2);
    if (!next || next.from == from && next.to == to2)
      return false;
    view.dispatch({
      selection: { anchor: next.from, head: next.to },
      scrollIntoView: true,
      effects: announceMatch(view, next),
      userEvent: "select.search"
    });
    return true;
  });
  var findPrevious = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state: state3 } = view, { from, to: to2 } = state3.selection.main;
    let range2 = query.prevMatch(state3.doc, from, to2);
    if (!range2)
      return false;
    view.dispatch({
      selection: { anchor: range2.from, head: range2.to },
      scrollIntoView: true,
      effects: announceMatch(view, range2),
      userEvent: "select.search"
    });
    return true;
  });
  var selectMatches = /* @__PURE__ */ searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state.doc, 1e3);
    if (!ranges || !ranges.length)
      return false;
    view.dispatch({
      selection: EditorSelection.create(ranges.map((r) => EditorSelection.range(r.from, r.to))),
      userEvent: "select.search.matches"
    });
    return true;
  });
  var selectSelectionMatches = ({ state: state3, dispatch: dispatch2 }) => {
    let sel = state3.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
      return false;
    let { from, to: to2 } = sel.main;
    let ranges = [], main = 0;
    for (let cur2 = new SearchCursor(state3.doc, state3.sliceDoc(from, to2)); !cur2.next().done; ) {
      if (ranges.length > 1e3)
        return false;
      if (cur2.value.from == from)
        main = ranges.length;
      ranges.push(EditorSelection.range(cur2.value.from, cur2.value.to));
    }
    dispatch2(state3.update({
      selection: EditorSelection.create(ranges, main),
      userEvent: "select.search.matches"
    }));
    return true;
  };
  var replaceNext = /* @__PURE__ */ searchCommand((view, { query }) => {
    let { state: state3 } = view, { from, to: to2 } = state3.selection.main;
    if (state3.readOnly)
      return false;
    let next = query.nextMatch(state3.doc, from, from);
    if (!next)
      return false;
    let changes = [], selection, replacement;
    if (next.from == from && next.to == to2) {
      replacement = state3.toText(query.getReplacement(next));
      changes.push({ from: next.from, to: next.to, insert: replacement });
      next = query.nextMatch(state3.doc, next.from, next.to);
    }
    if (next) {
      let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
      selection = { anchor: next.from - off, head: next.to - off };
    }
    view.dispatch({
      changes,
      selection,
      scrollIntoView: !!selection,
      effects: next ? announceMatch(view, next) : void 0,
      userEvent: "input.replace"
    });
    return true;
  });
  var replaceAll = /* @__PURE__ */ searchCommand((view, { query }) => {
    if (view.state.readOnly)
      return false;
    let changes = query.matchAll(view.state.doc, 1e9).map((match) => {
      let { from, to: to2 } = match;
      return { from, to: to2, insert: query.getReplacement(match) };
    });
    if (!changes.length)
      return false;
    view.dispatch({
      changes,
      userEvent: "input.replace.all"
    });
    return true;
  });
  function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
  }
  function defaultQuery(state3, fallback) {
    var _a2;
    let sel = state3.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state3.sliceDoc(sel.from, sel.to);
    let caseSensitive = (_a2 = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a2 !== void 0 ? _a2 : state3.facet(searchConfigFacet).caseSensitive;
    return fallback && !selText ? fallback : new SearchQuery({ search: selText.replace(/\n/g, "\\n"), caseSensitive });
  }
  var openSearchPanel = (view) => {
    let state3 = view.state.field(searchState, false);
    if (state3 && state3.panel) {
      let panel = getPanel(view, createSearchPanel);
      if (!panel)
        return false;
      let searchInput = panel.dom.querySelector("[name=search]");
      if (searchInput != view.root.activeElement) {
        let query = defaultQuery(view.state, state3.query.spec);
        if (query.valid)
          view.dispatch({ effects: setSearchQuery.of(query) });
        searchInput.focus();
        searchInput.select();
      }
    } else {
      view.dispatch({ effects: [
        togglePanel.of(true),
        state3 ? setSearchQuery.of(defaultQuery(view.state, state3.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
      ] });
    }
    return true;
  };
  var closeSearchPanel = (view) => {
    let state3 = view.state.field(searchState, false);
    if (!state3 || !state3.panel)
      return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
      view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
  };
  var searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true }
  ];
  var SearchPanel = class {
    constructor(view) {
      this.view = view;
      let query = this.query = view.state.field(searchState).query.spec;
      this.commit = this.commit.bind(this);
      this.searchField = crelt("input", {
        value: query.search,
        placeholder: phrase(view, "Find"),
        "aria-label": phrase(view, "Find"),
        class: "cm-textfield",
        name: "search",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.replaceField = crelt("input", {
        value: query.replace,
        placeholder: phrase(view, "Replace"),
        "aria-label": phrase(view, "Replace"),
        class: "cm-textfield",
        name: "replace",
        onchange: this.commit,
        onkeyup: this.commit
      });
      this.caseField = crelt("input", {
        type: "checkbox",
        name: "case",
        checked: query.caseSensitive,
        onchange: this.commit
      });
      this.reField = crelt("input", {
        type: "checkbox",
        name: "re",
        checked: query.regexp,
        onchange: this.commit
      });
      function button(name3, onclick, content2) {
        return crelt("button", { class: "cm-button", name: name3, onclick, type: "button" }, content2);
      }
      this.dom = crelt("div", { onkeydown: (e2) => this.keydown(e2), class: "cm-search" }, [
        this.searchField,
        button("next", () => findNext(view), [phrase(view, "next")]),
        button("prev", () => findPrevious(view), [phrase(view, "previous")]),
        button("select", () => selectMatches(view), [phrase(view, "all")]),
        crelt("label", null, [this.caseField, phrase(view, "match case")]),
        crelt("label", null, [this.reField, phrase(view, "regexp")]),
        ...view.state.readOnly ? [] : [
          crelt("br"),
          this.replaceField,
          button("replace", () => replaceNext(view), [phrase(view, "replace")]),
          button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")]),
          crelt("button", {
            name: "close",
            onclick: () => closeSearchPanel(view),
            "aria-label": phrase(view, "close"),
            type: "button"
          }, ["\xD7"])
        ]
      ]);
    }
    commit() {
      let query = new SearchQuery({
        search: this.searchField.value,
        caseSensitive: this.caseField.checked,
        regexp: this.reField.checked,
        replace: this.replaceField.value
      });
      if (!query.eq(this.query)) {
        this.query = query;
        this.view.dispatch({ effects: setSearchQuery.of(query) });
      }
    }
    keydown(e2) {
      if (runScopeHandlers(this.view, e2, "search-panel")) {
        e2.preventDefault();
      } else if (e2.keyCode == 13 && e2.target == this.searchField) {
        e2.preventDefault();
        (e2.shiftKey ? findPrevious : findNext)(this.view);
      } else if (e2.keyCode == 13 && e2.target == this.replaceField) {
        e2.preventDefault();
        replaceNext(this.view);
      }
    }
    update(update3) {
      for (let tr of update3.transactions)
        for (let effect of tr.effects) {
          if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
            this.setQuery(effect.value);
        }
    }
    setQuery(query) {
      this.query = query;
      this.searchField.value = query.search;
      this.replaceField.value = query.replace;
      this.caseField.checked = query.caseSensitive;
      this.reField.checked = query.regexp;
    }
    mount() {
      this.searchField.select();
    }
    get pos() {
      return 80;
    }
    get top() {
      return this.view.state.facet(searchConfigFacet).top;
    }
  };
  function phrase(view, phrase2) {
    return view.state.phrase(phrase2);
  }
  var AnnounceMargin = 30;
  var Break = /[\s\.,:;?!]/;
  function announceMatch(view, { from, to: to2 }) {
    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to2).to;
    let start2 = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to2 + AnnounceMargin);
    let text = view.state.sliceDoc(start2, end);
    if (start2 != lineStart) {
      for (let i2 = 0; i2 < AnnounceMargin; i2++)
        if (!Break.test(text[i2 + 1]) && Break.test(text[i2])) {
          text = text.slice(i2);
          break;
        }
    }
    if (end != lineEnd) {
      for (let i2 = text.length - 1; i2 > text.length - AnnounceMargin; i2--)
        if (!Break.test(text[i2 - 1]) && Break.test(text[i2])) {
          text = text.slice(0, i2);
          break;
        }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${view.state.doc.lineAt(from).number}`);
  }
  var baseTheme3 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-panel.cm-search": {
      padding: "2px 6px 4px",
      position: "relative",
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "4px",
        backgroundColor: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      },
      "& input, & button, & label": {
        margin: ".2em .6em .2em 0"
      },
      "& input[type=checkbox]": {
        marginRight: ".2em"
      },
      "& label": {
        fontSize: "80%",
        whiteSpace: "pre"
      }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
  });
  var searchExtensions = [
    searchState,
    /* @__PURE__ */ Prec.lowest(searchHighlighter),
    baseTheme3
  ];

  // node_modules/@codemirror/autocomplete/dist/index.js
  var CompletionContext = class {
    constructor(state3, pos, explicit) {
      this.state = state3;
      this.pos = pos;
      this.explicit = explicit;
      this.abortListeners = [];
    }
    tokenBefore(types2) {
      let token = syntaxTree(this.state).resolveInner(this.pos, -1);
      while (token && types2.indexOf(token.name) < 0)
        token = token.parent;
      return token ? {
        from: token.from,
        to: this.pos,
        text: this.state.sliceDoc(token.from, this.pos),
        type: token.type
      } : null;
    }
    matchBefore(expr) {
      let line = this.state.doc.lineAt(this.pos);
      let start2 = Math.max(line.from, this.pos - 250);
      let str = line.text.slice(start2 - line.from, this.pos - line.from);
      let found = str.search(ensureAnchor(expr, false));
      return found < 0 ? null : { from: start2 + found, to: this.pos, text: str.slice(found) };
    }
    get aborted() {
      return this.abortListeners == null;
    }
    addEventListener(type2, listener) {
      if (type2 == "abort" && this.abortListeners)
        this.abortListeners.push(listener);
    }
  };
  function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
      flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
  }
  function prefixMatch(options2) {
    let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
    for (let { label } of options2) {
      first[label[0]] = true;
      for (let i2 = 1; i2 < label.length; i2++)
        rest[label[i2]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
  }
  function completeFromList(list) {
    let options2 = list.map((o) => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
    return (context2) => {
      let token = context2.matchBefore(match);
      return token || context2.explicit ? { from: token ? token.from : context2.pos, options: options2, validFor } : null;
    };
  }
  var Option = class {
    constructor(completion, source, match) {
      this.completion = completion;
      this.source = source;
      this.match = match;
    }
  };
  function cur(state3) {
    return state3.selection.main.head;
  }
  function ensureAnchor(expr, start2) {
    var _a2;
    let { source } = expr;
    let addStart = start2 && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
      return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
  }
  function insertCompletionText(state3, text, from, to2) {
    return Object.assign(Object.assign({}, state3.changeByRange((range2) => {
      if (range2 == state3.selection.main)
        return {
          changes: { from, to: to2, insert: text },
          range: EditorSelection.cursor(from + text.length)
        };
      let len = to2 - from;
      if (!range2.empty || len && state3.sliceDoc(range2.from - len, range2.from) != state3.sliceDoc(from, to2))
        return { range: range2 };
      return {
        changes: { from: range2.from - len, to: range2.from, insert: text },
        range: EditorSelection.cursor(range2.from - len + text.length)
      };
    })), { userEvent: "input.complete" });
  }
  function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = option.source;
    if (typeof apply == "string")
      view.dispatch(insertCompletionText(view.state, apply, result.from, result.to));
    else
      apply(view, option.completion, result.from, result.to);
  }
  var SourceCache = /* @__PURE__ */ new WeakMap();
  function asSource(source) {
    if (!Array.isArray(source))
      return source;
    let known = SourceCache.get(source);
    if (!known)
      SourceCache.set(source, known = completeFromList(source));
    return known;
  }
  var FuzzyMatcher = class {
    constructor(pattern) {
      this.pattern = pattern;
      this.chars = [];
      this.folded = [];
      this.any = [];
      this.precise = [];
      this.byWord = [];
      for (let p2 = 0; p2 < pattern.length; ) {
        let char = codePointAt(pattern, p2), size2 = codePointSize(char);
        this.chars.push(char);
        let part = pattern.slice(p2, p2 + size2), upper = part.toUpperCase();
        this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
        p2 += size2;
      }
      this.astral = pattern.length != this.chars.length;
    }
    match(word) {
      if (this.pattern.length == 0)
        return [0];
      if (word.length < this.pattern.length)
        return null;
      let { chars, folded, any, precise, byWord } = this;
      if (chars.length == 1) {
        let first = codePointAt(word, 0);
        return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
      }
      let direct = word.indexOf(this.pattern);
      if (direct == 0)
        return [0, 0, this.pattern.length];
      let len = chars.length, anyTo = 0;
      if (direct < 0) {
        for (let i2 = 0, e2 = Math.min(word.length, 200); i2 < e2 && anyTo < len; ) {
          let next = codePointAt(word, i2);
          if (next == chars[anyTo] || next == folded[anyTo])
            any[anyTo++] = i2;
          i2 += codePointSize(next);
        }
        if (anyTo < len)
          return null;
      }
      let preciseTo = 0;
      let byWordTo = 0, byWordFolded = false;
      let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
      let hasLower = /[a-z]/.test(word), wordAdjacent = true;
      for (let i2 = 0, e2 = Math.min(word.length, 200), prevType = 0; i2 < e2 && byWordTo < len; ) {
        let next = codePointAt(word, i2);
        if (direct < 0) {
          if (preciseTo < len && next == chars[preciseTo])
            precise[preciseTo++] = i2;
          if (adjacentTo < len) {
            if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
              if (adjacentTo == 0)
                adjacentStart = i2;
              adjacentEnd = i2 + 1;
              adjacentTo++;
            } else {
              adjacentTo = 0;
            }
          }
        }
        let ch, type2 = next < 255 ? next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 : next >= 65 && next <= 90 ? 1 : 0 : (ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
        if (!i2 || type2 == 1 && hasLower || prevType == 0 && type2 != 0) {
          if (chars[byWordTo] == next || folded[byWordTo] == next && (byWordFolded = true))
            byWord[byWordTo++] = i2;
          else if (byWord.length)
            wordAdjacent = false;
        }
        prevType = type2;
        i2 += codePointSize(next);
      }
      if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
        return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
      if (adjacentTo == len && adjacentStart == 0)
        return [-200 - word.length, 0, adjacentEnd];
      if (direct > -1)
        return [-700 - word.length, direct, direct + this.pattern.length];
      if (adjacentTo == len)
        return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
      if (byWordTo == len)
        return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
      return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
    }
    result(score2, positions, word) {
      let result = [score2 - word.length], i2 = 1;
      for (let pos of positions) {
        let to2 = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
        if (i2 > 1 && result[i2 - 1] == pos)
          result[i2 - 1] = to2;
        else {
          result[i2++] = pos;
          result[i2++] = to2;
        }
      }
      return result;
    }
  };
  var completionConfig = /* @__PURE__ */ Facet.define({
    combine(configs) {
      return combineConfig(configs, {
        activateOnTyping: true,
        override: null,
        closeOnBlur: true,
        maxRenderedOptions: 100,
        defaultKeymap: true,
        optionClass: () => "",
        aboveCursor: false,
        icons: true,
        addToOptions: []
      }, {
        defaultKeymap: (a2, b2) => a2 && b2,
        closeOnBlur: (a2, b2) => a2 && b2,
        icons: (a2, b2) => a2 && b2,
        optionClass: (a2, b2) => (c4) => joinClass(a2(c4), b2(c4)),
        addToOptions: (a2, b2) => a2.concat(b2)
      });
    }
  });
  function joinClass(a2, b2) {
    return a2 ? b2 ? a2 + " " + b2 : a2 : b2;
  }
  function optionContent(config2) {
    let content2 = config2.addToOptions.slice();
    if (config2.icons)
      content2.push({
        render(completion) {
          let icon = document.createElement("div");
          icon.classList.add("cm-completionIcon");
          if (completion.type)
            icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
          icon.setAttribute("aria-hidden", "true");
          return icon;
        },
        position: 20
      });
    content2.push({
      render(completion, _s, match) {
        let labelElt = document.createElement("span");
        labelElt.className = "cm-completionLabel";
        let { label } = completion, off = 0;
        for (let j = 1; j < match.length; ) {
          let from = match[j++], to2 = match[j++];
          if (from > off)
            labelElt.appendChild(document.createTextNode(label.slice(off, from)));
          let span = labelElt.appendChild(document.createElement("span"));
          span.appendChild(document.createTextNode(label.slice(from, to2)));
          span.className = "cm-completionMatchedText";
          off = to2;
        }
        if (off < label.length)
          labelElt.appendChild(document.createTextNode(label.slice(off)));
        return labelElt;
      },
      position: 50
    }, {
      render(completion) {
        if (!completion.detail)
          return null;
        let detailElt = document.createElement("span");
        detailElt.className = "cm-completionDetail";
        detailElt.textContent = completion.detail;
        return detailElt;
      },
      position: 80
    });
    return content2.sort((a2, b2) => a2.position - b2.position).map((a2) => a2.render);
  }
  function rangeAroundSelected(total, selected, max3) {
    if (total <= max3)
      return { from: 0, to: total };
    if (selected <= total >> 1) {
      let off2 = Math.floor(selected / max3);
      return { from: off2 * max3, to: (off2 + 1) * max3 };
    }
    let off = Math.floor((total - selected) / max3);
    return { from: total - (off + 1) * max3, to: total - off * max3 };
  }
  var CompletionTooltip = class {
    constructor(view, stateField) {
      this.view = view;
      this.stateField = stateField;
      this.info = null;
      this.placeInfo = {
        read: () => this.measureInfo(),
        write: (pos) => this.positionInfo(pos),
        key: this
      };
      let cState = view.state.field(stateField);
      let { options: options2, selected } = cState.open;
      let config2 = view.state.facet(completionConfig);
      this.optionContent = optionContent(config2);
      this.optionClass = config2.optionClass;
      this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
      this.dom = document.createElement("div");
      this.dom.className = "cm-tooltip-autocomplete";
      this.dom.addEventListener("mousedown", (e2) => {
        for (let dom2 = e2.target, match; dom2 && dom2 != this.dom; dom2 = dom2.parentNode) {
          if (dom2.nodeName == "LI" && (match = /-(\d+)$/.exec(dom2.id)) && +match[1] < options2.length) {
            applyCompletion(view, options2[+match[1]]);
            e2.preventDefault();
            return;
          }
        }
      });
      this.list = this.dom.appendChild(this.createListBox(options2, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    mount() {
      this.updateSel();
    }
    update(update3) {
      if (update3.state.field(this.stateField) != update3.startState.field(this.stateField))
        this.updateSel();
    }
    positioned() {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    }
    updateSel() {
      let cState = this.view.state.field(this.stateField), open = cState.open;
      if (open.selected < this.range.from || open.selected >= this.range.to) {
        this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
        this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
        this.list.addEventListener("scroll", () => {
          if (this.info)
            this.view.requestMeasure(this.placeInfo);
        });
      }
      if (this.updateSelectedOption(open.selected)) {
        if (this.info) {
          this.info.remove();
          this.info = null;
        }
        let { completion } = open.options[open.selected];
        let { info } = completion;
        if (!info)
          return;
        let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
        if (!infoResult)
          return;
        if ("then" in infoResult) {
          infoResult.then((node) => {
            if (node && this.view.state.field(this.stateField, false) == cState)
              this.addInfoPane(node);
          }).catch((e2) => logException(this.view.state, e2, "completion info"));
        } else {
          this.addInfoPane(infoResult);
        }
      }
    }
    addInfoPane(content2) {
      let dom2 = this.info = document.createElement("div");
      dom2.className = "cm-tooltip cm-completionInfo";
      dom2.appendChild(content2);
      this.dom.appendChild(dom2);
      this.view.requestMeasure(this.placeInfo);
    }
    updateSelectedOption(selected) {
      let set3 = null;
      for (let opt = this.list.firstChild, i2 = this.range.from; opt; opt = opt.nextSibling, i2++) {
        if (i2 == selected) {
          if (!opt.hasAttribute("aria-selected")) {
            opt.setAttribute("aria-selected", "true");
            set3 = opt;
          }
        } else {
          if (opt.hasAttribute("aria-selected"))
            opt.removeAttribute("aria-selected");
        }
      }
      if (set3)
        scrollIntoView2(this.list, set3);
      return set3;
    }
    measureInfo() {
      let sel = this.dom.querySelector("[aria-selected]");
      if (!sel || !this.info)
        return null;
      let listRect = this.dom.getBoundingClientRect();
      let infoRect = this.info.getBoundingClientRect();
      let selRect = sel.getBoundingClientRect();
      if (selRect.top > Math.min(innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10)
        return null;
      let top2 = Math.max(0, Math.min(selRect.top, innerHeight - infoRect.height)) - listRect.top;
      let left = this.view.textDirection == Direction.RTL;
      let spaceLeft = listRect.left, spaceRight = innerWidth - listRect.right;
      if (left && spaceLeft < Math.min(infoRect.width, spaceRight))
        left = false;
      else if (!left && spaceRight < Math.min(infoRect.width, spaceLeft))
        left = true;
      return { top: top2, left };
    }
    positionInfo(pos) {
      if (this.info) {
        this.info.style.top = (pos ? pos.top : -1e6) + "px";
        if (pos) {
          this.info.classList.toggle("cm-completionInfo-left", pos.left);
          this.info.classList.toggle("cm-completionInfo-right", !pos.left);
        }
      }
    }
    createListBox(options2, id2, range2) {
      const ul = document.createElement("ul");
      ul.id = id2;
      ul.setAttribute("role", "listbox");
      ul.setAttribute("aria-expanded", "true");
      ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
      for (let i2 = range2.from; i2 < range2.to; i2++) {
        let { completion, match } = options2[i2];
        const li = ul.appendChild(document.createElement("li"));
        li.id = id2 + "-" + i2;
        li.setAttribute("role", "option");
        let cls = this.optionClass(completion);
        if (cls)
          li.className = cls;
        for (let source of this.optionContent) {
          let node = source(completion, this.view.state, match);
          if (node)
            li.appendChild(node);
        }
      }
      if (range2.from)
        ul.classList.add("cm-completionListIncompleteTop");
      if (range2.to < options2.length)
        ul.classList.add("cm-completionListIncompleteBottom");
      return ul;
    }
  };
  function completionTooltip(stateField) {
    return (view) => new CompletionTooltip(view, stateField);
  }
  function scrollIntoView2(container, element3) {
    let parent = container.getBoundingClientRect();
    let self2 = element3.getBoundingClientRect();
    if (self2.top < parent.top)
      container.scrollTop -= parent.top - self2.top;
    else if (self2.bottom > parent.bottom)
      container.scrollTop += self2.bottom - parent.bottom;
  }
  function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
  }
  function sortOptions(active, state3) {
    let options2 = [], i2 = 0;
    for (let a2 of active)
      if (a2.hasResult()) {
        if (a2.result.filter === false) {
          let getMatch = a2.result.getMatch;
          for (let option of a2.result.options) {
            let match = [1e9 - i2++];
            if (getMatch)
              for (let n2 of getMatch(option))
                match.push(n2);
            options2.push(new Option(option, a2, match));
          }
        } else {
          let matcher = new FuzzyMatcher(state3.sliceDoc(a2.from, a2.to)), match;
          for (let option of a2.result.options)
            if (match = matcher.match(option.label)) {
              if (option.boost != null)
                match[0] += option.boost;
              options2.push(new Option(option, a2, match));
            }
        }
      }
    let result = [], prev = null;
    for (let opt of options2.sort(cmpOption)) {
      if (!prev || prev.label != opt.completion.label || prev.detail != opt.completion.detail || prev.type != null && opt.completion.type != null && prev.type != opt.completion.type || prev.apply != opt.completion.apply)
        result.push(opt);
      else if (score(opt.completion) > score(prev))
        result[result.length - 1] = opt;
      prev = opt.completion;
    }
    return result;
  }
  var CompletionDialog = class {
    constructor(options2, attrs, tooltip, timestamp, selected) {
      this.options = options2;
      this.attrs = attrs;
      this.tooltip = tooltip;
      this.timestamp = timestamp;
      this.selected = selected;
    }
    setSelected(selected, id2) {
      return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected);
    }
    static build(active, state3, id2, prev, conf) {
      let options2 = sortOptions(active, state3);
      if (!options2.length)
        return null;
      let selected = 0;
      if (prev && prev.selected) {
        let selectedValue = prev.options[prev.selected].completion;
        for (let i2 = 0; i2 < options2.length; i2++)
          if (options2[i2].completion == selectedValue) {
            selected = i2;
            break;
          }
      }
      return new CompletionDialog(options2, makeAttrs(id2, selected), {
        pos: active.reduce((a2, b2) => b2.hasResult() ? Math.min(a2, b2.from) : a2, 1e8),
        create: completionTooltip(completionState),
        above: conf.aboveCursor
      }, prev ? prev.timestamp : Date.now(), selected);
    }
    map(changes) {
      return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
    }
  };
  var CompletionState = class {
    constructor(active, id2, open) {
      this.active = active;
      this.id = id2;
      this.open = open;
    }
    static start() {
      return new CompletionState(none3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
      let { state: state3 } = tr, conf = state3.facet(completionConfig);
      let sources = conf.override || state3.languageDataAt("autocomplete", cur(state3)).map(asSource);
      let active = sources.map((source) => {
        let value = this.active.find((s) => s.source == source) || new ActiveSource(source, this.active.some((a2) => a2.state != 0) ? 1 : 0);
        return value.update(tr, conf);
      });
      if (active.length == this.active.length && active.every((a2, i2) => a2 == this.active[i2]))
        active = this.active;
      let open = tr.selection || active.some((a2) => a2.hasResult() && tr.changes.touchesRange(a2.from, a2.to)) || !sameResults(active, this.active) ? CompletionDialog.build(active, state3, this.id, this.open, conf) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
      if (!open && active.every((a2) => a2.state != 1) && active.some((a2) => a2.hasResult()))
        active = active.map((a2) => a2.hasResult() ? new ActiveSource(a2.source, 0) : a2);
      for (let effect of tr.effects)
        if (effect.is(setSelectedEffect))
          open = open && open.setSelected(effect.value, this.id);
      return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() {
      return this.open ? this.open.tooltip : null;
    }
    get attrs() {
      return this.open ? this.open.attrs : baseAttrs;
    }
  };
  function sameResults(a2, b2) {
    if (a2 == b2)
      return true;
    for (let iA = 0, iB = 0; ; ) {
      while (iA < a2.length && !a2[iA].hasResult)
        iA++;
      while (iB < b2.length && !b2[iB].hasResult)
        iB++;
      let endA = iA == a2.length, endB = iB == b2.length;
      if (endA || endB)
        return endA == endB;
      if (a2[iA++].result != b2[iB++].result)
        return false;
    }
  }
  var baseAttrs = {
    "aria-autocomplete": "list"
  };
  function makeAttrs(id2, selected) {
    return {
      "aria-autocomplete": "list",
      "aria-haspopup": "listbox",
      "aria-activedescendant": id2 + "-" + selected,
      "aria-controls": id2
    };
  }
  var none3 = [];
  function cmpOption(a2, b2) {
    let dScore = b2.match[0] - a2.match[0];
    if (dScore)
      return dScore;
    return a2.completion.label.localeCompare(b2.completion.label);
  }
  function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
  }
  var ActiveSource = class {
    constructor(source, state3, explicitPos = -1) {
      this.source = source;
      this.state = state3;
      this.explicitPos = explicitPos;
    }
    hasResult() {
      return false;
    }
    update(tr, conf) {
      let event = getUserEvent(tr), value = this;
      if (event)
        value = value.handleUserEvent(tr, event, conf);
      else if (tr.docChanged)
        value = value.handleChange(tr);
      else if (tr.selection && value.state != 0)
        value = new ActiveSource(value.source, 0);
      for (let effect of tr.effects) {
        if (effect.is(startCompletionEffect))
          value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
        else if (effect.is(closeCompletionEffect))
          value = new ActiveSource(value.source, 0);
        else if (effect.is(setActiveEffect)) {
          for (let active of effect.value)
            if (active.source == value.source)
              value = active;
        }
      }
      return value;
    }
    handleUserEvent(tr, type2, conf) {
      return type2 == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(changes) {
      return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
  };
  var ActiveResult = class extends ActiveSource {
    constructor(source, explicitPos, result, from, to2) {
      super(source, 2, explicitPos);
      this.result = result;
      this.from = from;
      this.to = to2;
    }
    hasResult() {
      return true;
    }
    handleUserEvent(tr, type2, conf) {
      var _a2;
      let from = tr.changes.mapPos(this.from), to2 = tr.changes.mapPos(this.to, 1);
      let pos = cur(tr.state);
      if ((this.explicitPos < 0 ? pos <= from : pos < this.from) || pos > to2 || type2 == "delete" && cur(tr.startState) == this.from)
        return new ActiveSource(this.source, type2 == "input" && conf.activateOnTyping ? 1 : 0);
      let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
      if (checkValid(this.result.validFor, tr.state, from, to2))
        return new ActiveResult(this.source, explicitPos, this.result, from, to2);
      if (this.result.update && (updated = this.result.update(this.result, from, to2, new CompletionContext(tr.state, pos, explicitPos >= 0))))
        return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
      return new ActiveSource(this.source, 1, explicitPos);
    }
    handleChange(tr) {
      return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
    }
    map(mapping) {
      return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
  };
  function checkValid(validFor, state3, from, to2) {
    if (!validFor)
      return false;
    let text = state3.sliceDoc(from, to2);
    return typeof validFor == "function" ? validFor(text, from, to2, state3) : ensureAnchor(validFor, true).test(text);
  }
  var startCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
  var setActiveEffect = /* @__PURE__ */ StateEffect.define({
    map(sources, mapping) {
      return sources.map((s) => s.map(mapping));
    }
  });
  var setSelectedEffect = /* @__PURE__ */ StateEffect.define();
  var completionState = /* @__PURE__ */ StateField.define({
    create() {
      return CompletionState.start();
    },
    update(value, tr) {
      return value.update(tr);
    },
    provide: (f) => [
      showTooltip.from(f, (val) => val.tooltip),
      EditorView.contentAttributes.from(f, (state3) => state3.attrs)
    ]
  });
  var CompletionInteractMargin = 75;
  function moveCompletionSelection(forward, by = "option") {
    return (view) => {
      let cState = view.state.field(completionState, false);
      if (!cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
        return false;
      let step = 1, tooltip;
      if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
        step = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
      let selected = cState.open.selected + step * (forward ? 1 : -1), { length } = cState.open.options;
      if (selected < 0)
        selected = by == "page" ? 0 : length - 1;
      else if (selected >= length)
        selected = by == "page" ? length - 1 : 0;
      view.dispatch({ effects: setSelectedEffect.of(selected) });
      return true;
    };
  }
  var acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || Date.now() - cState.open.timestamp < CompletionInteractMargin)
      return false;
    applyCompletion(view, cState.open.options[cState.open.selected]);
    return true;
  };
  var startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
      return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
  };
  var closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some((a2) => a2.state != 0))
      return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
  };
  var RunningQuery = class {
    constructor(active, context2) {
      this.active = active;
      this.context = context2;
      this.time = Date.now();
      this.updates = [];
      this.done = void 0;
    }
  };
  var DebounceTime = 50;
  var MaxUpdateCount = 50;
  var MinAbortTime = 1e3;
  var completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.debounceUpdate = -1;
      this.running = [];
      this.debounceAccept = -1;
      this.composing = 0;
      for (let active of view.state.field(completionState).active)
        if (active.state == 1)
          this.startQuery(active);
    }
    update(update3) {
      let cState = update3.state.field(completionState);
      if (!update3.selectionSet && !update3.docChanged && update3.startState.field(completionState) == cState)
        return;
      let doesReset = update3.transactions.some((tr) => {
        return (tr.selection || tr.docChanged) && !getUserEvent(tr);
      });
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (doesReset || query.updates.length + update3.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
          for (let handler of query.context.abortListeners) {
            try {
              handler();
            } catch (e2) {
              logException(this.view.state, e2);
            }
          }
          query.context.abortListeners = null;
          this.running.splice(i2--, 1);
        } else {
          query.updates.push(...update3.transactions);
        }
      }
      if (this.debounceUpdate > -1)
        clearTimeout(this.debounceUpdate);
      this.debounceUpdate = cState.active.some((a2) => a2.state == 1 && !this.running.some((q) => q.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
      if (this.composing != 0)
        for (let tr of update3.transactions) {
          if (getUserEvent(tr) == "input")
            this.composing = 2;
          else if (this.composing == 2 && tr.selection)
            this.composing = 3;
        }
    }
    startUpdate() {
      this.debounceUpdate = -1;
      let { state: state3 } = this.view, cState = state3.field(completionState);
      for (let active of cState.active) {
        if (active.state == 1 && !this.running.some((r) => r.active.source == active.source))
          this.startQuery(active);
      }
    }
    startQuery(active) {
      let { state: state3 } = this.view, pos = cur(state3);
      let context2 = new CompletionContext(state3, pos, active.explicitPos == pos);
      let pending = new RunningQuery(active, context2);
      this.running.push(pending);
      Promise.resolve(active.source(context2)).then((result) => {
        if (!pending.context.aborted) {
          pending.done = result || null;
          this.scheduleAccept();
        }
      }, (err) => {
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
        logException(this.view.state, err);
      });
    }
    scheduleAccept() {
      if (this.running.every((q) => q.done !== void 0))
        this.accept();
      else if (this.debounceAccept < 0)
        this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
    }
    accept() {
      var _a2;
      if (this.debounceAccept > -1)
        clearTimeout(this.debounceAccept);
      this.debounceAccept = -1;
      let updated = [];
      let conf = this.view.state.facet(completionConfig);
      for (let i2 = 0; i2 < this.running.length; i2++) {
        let query = this.running[i2];
        if (query.done === void 0)
          continue;
        this.running.splice(i2--, 1);
        if (query.done) {
          let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
          for (let tr of query.updates)
            active = active.update(tr, conf);
          if (active.hasResult()) {
            updated.push(active);
            continue;
          }
        }
        let current = this.view.state.field(completionState).active.find((a2) => a2.source == query.active.source);
        if (current && current.state == 1) {
          if (query.done == null) {
            let active = new ActiveSource(query.active.source, 0);
            for (let tr of query.updates)
              active = active.update(tr, conf);
            if (active.state != 1)
              updated.push(active);
          } else {
            this.startQuery(current);
          }
        }
      }
      if (updated.length)
        this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
  }, {
    eventHandlers: {
      blur() {
        let state3 = this.view.state.field(completionState, false);
        if (state3 && state3.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
          this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      },
      compositionstart() {
        this.composing = 1;
      },
      compositionend() {
        if (this.composing == 3) {
          setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
        }
        this.composing = 0;
      }
    }
  });
  var baseTheme4 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
      "& > ul": {
        fontFamily: "monospace",
        whiteSpace: "nowrap",
        overflow: "hidden auto",
        maxWidth_fallback: "700px",
        maxWidth: "min(700px, 95vw)",
        minWidth: "250px",
        maxHeight: "10em",
        listStyle: "none",
        margin: 0,
        padding: 0,
        "& > li": {
          overflowX: "hidden",
          textOverflow: "ellipsis",
          cursor: "pointer",
          padding: "1px 3px",
          lineHeight: 1.2
        }
      }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#17c",
      color: "white"
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
      background: "#347",
      color: "white"
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
      content: '"\xB7\xB7\xB7"',
      opacity: 0.5,
      display: "block",
      textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
      position: "absolute",
      padding: "3px 9px",
      width: "max-content",
      maxWidth: "300px"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
      verticalAlign: "text-top",
      width: 0,
      height: "1.15em",
      margin: "0 -0.7px -.7em",
      borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
      textDecoration: "underline"
    },
    ".cm-completionDetail": {
      marginLeft: "0.5em",
      fontStyle: "italic"
    },
    ".cm-completionIcon": {
      fontSize: "90%",
      width: ".8em",
      display: "inline-block",
      textAlign: "center",
      paddingRight: ".6em",
      opacity: "0.6"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
      "&:after": { content: "'\u0192'" }
    },
    ".cm-completionIcon-class": {
      "&:after": { content: "'\u25CB'" }
    },
    ".cm-completionIcon-interface": {
      "&:after": { content: "'\u25CC'" }
    },
    ".cm-completionIcon-variable": {
      "&:after": { content: "'\u{1D465}'" }
    },
    ".cm-completionIcon-constant": {
      "&:after": { content: "'\u{1D436}'" }
    },
    ".cm-completionIcon-type": {
      "&:after": { content: "'\u{1D461}'" }
    },
    ".cm-completionIcon-enum": {
      "&:after": { content: "'\u222A'" }
    },
    ".cm-completionIcon-property": {
      "&:after": { content: "'\u25A1'" }
    },
    ".cm-completionIcon-keyword": {
      "&:after": { content: "'\u{1F511}\uFE0E'" }
    },
    ".cm-completionIcon-namespace": {
      "&:after": { content: "'\u25A2'" }
    },
    ".cm-completionIcon-text": {
      "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
  });
  var defaults2 = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>"
  };
  var closeBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
      return mapped == null ? void 0 : mapped;
    }
  });
  var skipBracketEffect = /* @__PURE__ */ StateEffect.define({
    map(value, mapping) {
      return mapping.mapPos(value);
    }
  });
  var closedBracket = /* @__PURE__ */ new class extends RangeValue {
  }();
  closedBracket.startSide = 1;
  closedBracket.endSide = -1;
  var bracketState = /* @__PURE__ */ StateField.define({
    create() {
      return RangeSet.empty;
    },
    update(value, tr) {
      if (tr.selection) {
        let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
        let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
        if (lineStart != tr.changes.mapPos(prevLineStart, -1))
          value = RangeSet.empty;
      }
      value = value.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(closeBracketEffect))
          value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        else if (effect.is(skipBracketEffect))
          value = value.update({ filter: (from) => from != effect.value });
      }
      return value;
    }
  });
  function closeBrackets() {
    return [inputHandler2, bracketState];
  }
  var definedClosing = "()[]{}<>";
  function closing(ch) {
    for (let i2 = 0; i2 < definedClosing.length; i2 += 2)
      if (definedClosing.charCodeAt(i2) == ch)
        return definedClosing.charAt(i2 + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
  }
  function config(state3, pos) {
    return state3.languageDataAt("closeBrackets", pos)[0] || defaults2;
  }
  var android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
  var inputHandler2 = /* @__PURE__ */ EditorView.inputHandler.of((view, from, to2, insert2) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
      return false;
    let sel = view.state.selection.main;
    if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from != sel.from || to2 != sel.to)
      return false;
    let tr = insertBracket(view.state, insert2);
    if (!tr)
      return false;
    view.dispatch(tr);
    return true;
  });
  var deleteBracketPair = ({ state: state3, dispatch: dispatch2 }) => {
    if (state3.readOnly)
      return false;
    let conf = config(state3, state3.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    let dont = null, changes = state3.changeByRange((range2) => {
      if (range2.empty) {
        let before = prevChar(state3.doc, range2.head);
        for (let token of tokens) {
          if (token == before && nextChar(state3.doc, range2.head) == closing(codePointAt(token, 0)))
            return {
              changes: { from: range2.head - token.length, to: range2.head + token.length },
              range: EditorSelection.cursor(range2.head - token.length),
              userEvent: "delete.backward"
            };
        }
      }
      return { range: dont = range2 };
    });
    if (!dont)
      dispatch2(state3.update(changes, { scrollIntoView: true }));
    return !dont;
  };
  var closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
  ];
  function insertBracket(state3, bracket2) {
    let conf = config(state3, state3.selection.main.head);
    let tokens = conf.brackets || defaults2.brackets;
    for (let tok of tokens) {
      let closed = closing(codePointAt(tok, 0));
      if (bracket2 == tok)
        return closed == tok ? handleSame(state3, tok, tokens.indexOf(tok + tok + tok) > -1) : handleOpen(state3, tok, closed, conf.before || defaults2.before);
      if (bracket2 == closed && closedBracketAt(state3, state3.selection.main.from))
        return handleClose(state3, tok, closed);
    }
    return null;
  }
  function closedBracketAt(state3, pos) {
    let found = false;
    state3.field(bracketState).between(0, state3.doc.length, (from) => {
      if (from == pos)
        found = true;
    });
    return found;
  }
  function nextChar(doc2, pos) {
    let next = doc2.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
  }
  function prevChar(doc2, pos) {
    let prev = doc2.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
  }
  function handleOpen(state3, open, close, closeBefore) {
    let dont = null, changes = state3.changeByRange((range2) => {
      if (!range2.empty)
        return {
          changes: [{ insert: open, from: range2.from }, { insert: close, from: range2.to }],
          effects: closeBracketEffect.of(range2.to + open.length),
          range: EditorSelection.range(range2.anchor + open.length, range2.head + open.length)
        };
      let next = nextChar(state3.doc, range2.head);
      if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
        return {
          changes: { insert: open + close, from: range2.head },
          effects: closeBracketEffect.of(range2.head + open.length),
          range: EditorSelection.cursor(range2.head + open.length)
        };
      return { range: dont = range2 };
    });
    return dont ? null : state3.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function handleClose(state3, _open, close) {
    let dont = null, moved = state3.selection.ranges.map((range2) => {
      if (range2.empty && nextChar(state3.doc, range2.head) == close)
        return EditorSelection.cursor(range2.head + close.length);
      return dont = range2;
    });
    return dont ? null : state3.update({
      selection: EditorSelection.create(moved, state3.selection.mainIndex),
      scrollIntoView: true,
      effects: state3.selection.ranges.map(({ from }) => skipBracketEffect.of(from))
    });
  }
  function handleSame(state3, token, allowTriple) {
    let dont = null, changes = state3.changeByRange((range2) => {
      if (!range2.empty)
        return {
          changes: [{ insert: token, from: range2.from }, { insert: token, from: range2.to }],
          effects: closeBracketEffect.of(range2.to + token.length),
          range: EditorSelection.range(range2.anchor + token.length, range2.head + token.length)
        };
      let pos = range2.head, next = nextChar(state3.doc, pos);
      if (next == token) {
        if (nodeStart(state3, pos)) {
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
        } else if (closedBracketAt(state3, pos)) {
          let isTriple = allowTriple && state3.sliceDoc(pos, pos + token.length * 3) == token + token + token;
          return {
            range: EditorSelection.cursor(pos + token.length * (isTriple ? 3 : 1)),
            effects: skipBracketEffect.of(pos)
          };
        }
      } else if (allowTriple && state3.sliceDoc(pos - 2 * token.length, pos) == token + token && nodeStart(state3, pos - 2 * token.length)) {
        return {
          changes: { insert: token + token + token + token, from: pos },
          effects: closeBracketEffect.of(pos + token.length),
          range: EditorSelection.cursor(pos + token.length)
        };
      } else if (state3.charCategorizer(pos)(next) != CharCategory.Word) {
        let prev = state3.sliceDoc(pos - 1, pos);
        if (prev != token && state3.charCategorizer(pos)(prev) != CharCategory.Word && !probablyInString(state3, pos, token))
          return {
            changes: { insert: token + token, from: pos },
            effects: closeBracketEffect.of(pos + token.length),
            range: EditorSelection.cursor(pos + token.length)
          };
      }
      return { range: dont = range2 };
    });
    return dont ? null : state3.update(changes, {
      scrollIntoView: true,
      userEvent: "input.type"
    });
  }
  function nodeStart(state3, pos) {
    let tree = syntaxTree(state3).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
  }
  function probablyInString(state3, pos, quoteToken) {
    let node = syntaxTree(state3).resolveInner(pos, -1);
    for (let i2 = 0; i2 < 5; i2++) {
      if (state3.sliceDoc(node.from, node.from + quoteToken.length) == quoteToken)
        return true;
      let parent = node.to == pos && node.parent;
      if (!parent)
        break;
      node = parent;
    }
    return false;
  }
  function autocompletion(config2 = {}) {
    return [
      completionState,
      completionConfig.of(config2),
      completionPlugin,
      completionKeymapExt,
      baseTheme4
    ];
  }
  var completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
    { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
    { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
  ];
  var completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state3) => state3.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));

  // node_modules/@codemirror/lint/dist/index.js
  var SelectedDiagnostic = class {
    constructor(from, to2, diagnostic) {
      this.from = from;
      this.to = to2;
      this.diagnostic = diagnostic;
    }
  };
  var LintState = class {
    constructor(diagnostics, panel, selected) {
      this.diagnostics = diagnostics;
      this.panel = panel;
      this.selected = selected;
    }
    static init(diagnostics, panel, state3) {
      let markedDiagnostics = diagnostics;
      let diagnosticFilter = state3.facet(lintConfig).markerFilter;
      if (diagnosticFilter)
        markedDiagnostics = diagnosticFilter(markedDiagnostics);
      let ranges = Decoration.set(markedDiagnostics.map((d2) => {
        return d2.from == d2.to || d2.from == d2.to - 1 && state3.doc.lineAt(d2.from).to == d2.from ? Decoration.widget({
          widget: new DiagnosticWidget(d2),
          diagnostic: d2
        }).range(d2.from) : Decoration.mark({
          attributes: { class: "cm-lintRange cm-lintRange-" + d2.severity },
          diagnostic: d2
        }).range(d2.from, d2.to);
      }), true);
      return new LintState(ranges, panel, findDiagnostic(ranges));
    }
  };
  function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to2, { spec }) => {
      if (diagnostic && spec.diagnostic != diagnostic)
        return;
      found = new SelectedDiagnostic(from, to2, spec.diagnostic);
      return false;
    });
    return found;
  }
  function hideTooltip(tr, tooltip) {
    return !!(tr.effects.some((e2) => e2.is(setDiagnosticsEffect)) || tr.changes.touchesRange(tooltip.pos));
  }
  function maybeEnableLint(state3, effects) {
    return state3.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([
      lintState,
      EditorView.decorations.compute([lintState], (state4) => {
        let { selected, panel } = state4.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
          activeMark.range(selected.from, selected.to)
        ]);
      }),
      hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
      baseTheme5
    ]));
  }
  function setDiagnostics(state3, diagnostics) {
    return {
      effects: maybeEnableLint(state3, [setDiagnosticsEffect.of(diagnostics)])
    };
  }
  var setDiagnosticsEffect = /* @__PURE__ */ StateEffect.define();
  var togglePanel2 = /* @__PURE__ */ StateEffect.define();
  var movePanelSelection = /* @__PURE__ */ StateEffect.define();
  var lintState = /* @__PURE__ */ StateField.define({
    create() {
      return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
      if (tr.docChanged) {
        let mapped = value.diagnostics.map(tr.changes), selected = null;
        if (value.selected) {
          let selPos = tr.changes.mapPos(value.selected.from, 1);
          selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
        }
        value = new LintState(mapped, value.panel, selected);
      }
      for (let effect of tr.effects) {
        if (effect.is(setDiagnosticsEffect)) {
          value = LintState.init(effect.value, value.panel, tr.state);
        } else if (effect.is(togglePanel2)) {
          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
        } else if (effect.is(movePanelSelection)) {
          value = new LintState(value.diagnostics, value.panel, effect.value);
        }
      }
      return value;
    },
    provide: (f) => [
      showPanel.from(f, (val) => val.panel),
      EditorView.decorations.from(f, (s) => s.diagnostics)
    ]
  });
  var activeMark = /* @__PURE__ */ Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
  function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to2, { spec }) => {
      if (pos >= from && pos <= to2 && (from == to2 || (pos > from || side > 0) && (pos < to2 || side < 0))) {
        found.push(spec.diagnostic);
        stackStart = Math.min(from, stackStart);
        stackEnd = Math.max(to2, stackEnd);
      }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
      found = diagnosticFilter(found);
    if (!found.length)
      return null;
    return {
      pos: stackStart,
      end: stackEnd,
      above: view.state.doc.lineAt(stackStart).to < stackEnd,
      create() {
        return { dom: diagnosticsTooltip(view, found) };
      }
    };
  }
  function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map((d2) => renderDiagnostic(view, d2, false)));
  }
  var openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      view.dispatch({ effects: maybeEnableLint(view.state, [togglePanel2.of(true)]) });
    let panel = getPanel(view, LintPanel.open);
    if (panel)
      panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
  };
  var closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
      return false;
    view.dispatch({ effects: togglePanel2.of(false) });
    return true;
  };
  var nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
      return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
      next = field.diagnostics.iter(0);
      if (!next.value || next.from == sel.from && next.to == sel.to)
        return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
  };
  var lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel },
    { key: "F8", run: nextDiagnostic }
  ];
  var lintPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.timeout = -1;
      this.set = true;
      let { delay: delay3 } = view.state.facet(lintConfig);
      this.lintTime = Date.now() + delay3;
      this.run = this.run.bind(this);
      this.timeout = setTimeout(this.run, delay3);
    }
    run() {
      let now = Date.now();
      if (now < this.lintTime - 10) {
        setTimeout(this.run, this.lintTime - now);
      } else {
        this.set = false;
        let { state: state3 } = this.view, { sources } = state3.facet(lintConfig);
        Promise.all(sources.map((source) => Promise.resolve(source(this.view)))).then((annotations) => {
          let all = annotations.reduce((a2, b2) => a2.concat(b2));
          if (this.view.state.doc == state3.doc)
            this.view.dispatch(setDiagnostics(this.view.state, all));
        }, (error) => {
          logException(this.view.state, error);
        });
      }
    }
    update(update3) {
      let config2 = update3.state.facet(lintConfig);
      if (update3.docChanged || config2 != update3.startState.facet(lintConfig)) {
        this.lintTime = Date.now() + config2.delay;
        if (!this.set) {
          this.set = true;
          this.timeout = setTimeout(this.run, config2.delay);
        }
      }
    }
    force() {
      if (this.set) {
        this.lintTime = Date.now();
        this.run();
      }
    }
    destroy() {
      clearTimeout(this.timeout);
    }
  });
  var lintConfig = /* @__PURE__ */ Facet.define({
    combine(input) {
      return Object.assign({ sources: input.map((i2) => i2.source) }, combineConfig(input.map((i2) => i2.config), {
        delay: 750,
        markerFilter: null,
        tooltipFilter: null
      }));
    },
    enables: lintPlugin
  });
  function assignKeys(actions2) {
    let assigned = [];
    if (actions2)
      actions:
        for (let { name: name3 } of actions2) {
          for (let i2 = 0; i2 < name3.length; i2++) {
            let ch = name3[i2];
            if (/[a-zA-Z]/.test(ch) && !assigned.some((c4) => c4.toLowerCase() == ch.toLowerCase())) {
              assigned.push(ch);
              continue actions;
            }
          }
          assigned.push("");
        }
    return assigned;
  }
  function renderDiagnostic(view, diagnostic, inPanel) {
    var _a2;
    let keys4 = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a2 = diagnostic.actions) === null || _a2 === void 0 ? void 0 : _a2.map((action2, i2) => {
      let click = (e2) => {
        e2.preventDefault();
        let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
        if (found)
          action2.apply(view, found.from, found.to);
      };
      let { name: name3 } = action2, keyIndex = keys4[i2] ? name3.indexOf(keys4[i2]) : -1;
      let nameElt = keyIndex < 0 ? name3 : [
        name3.slice(0, keyIndex),
        crelt("u", name3.slice(keyIndex, keyIndex + 1)),
        name3.slice(keyIndex + 1)
      ];
      return crelt("button", {
        type: "button",
        class: "cm-diagnosticAction",
        onclick: click,
        onmousedown: click,
        "aria-label": ` Action: ${name3}${keyIndex < 0 ? "" : ` (access key "${keys4[i2]})"`}.`
      }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
  }
  var DiagnosticWidget = class extends WidgetType {
    constructor(diagnostic) {
      super();
      this.diagnostic = diagnostic;
    }
    eq(other) {
      return other.diagnostic == this.diagnostic;
    }
    toDOM() {
      return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
  };
  var PanelItem = class {
    constructor(view, diagnostic) {
      this.diagnostic = diagnostic;
      this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16);
      this.dom = renderDiagnostic(view, diagnostic, true);
      this.dom.id = this.id;
      this.dom.setAttribute("role", "option");
    }
  };
  var LintPanel = class {
    constructor(view) {
      this.view = view;
      this.items = [];
      let onkeydown = (event) => {
        if (event.keyCode == 27) {
          closeLintPanel(this.view);
          this.view.focus();
        } else if (event.keyCode == 38 || event.keyCode == 33) {
          this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
        } else if (event.keyCode == 40 || event.keyCode == 34) {
          this.moveSelection((this.selectedIndex + 1) % this.items.length);
        } else if (event.keyCode == 36) {
          this.moveSelection(0);
        } else if (event.keyCode == 35) {
          this.moveSelection(this.items.length - 1);
        } else if (event.keyCode == 13) {
          this.view.focus();
        } else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) {
          let { diagnostic } = this.items[this.selectedIndex], keys4 = assignKeys(diagnostic.actions);
          for (let i2 = 0; i2 < keys4.length; i2++)
            if (keys4[i2].toUpperCase().charCodeAt(0) == event.keyCode) {
              let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
              if (found)
                diagnostic.actions[i2].apply(view, found.from, found.to);
            }
        } else {
          return;
        }
        event.preventDefault();
      };
      let onclick = (event) => {
        for (let i2 = 0; i2 < this.items.length; i2++) {
          if (this.items[i2].dom.contains(event.target))
            this.moveSelection(i2);
        }
      };
      this.list = crelt("ul", {
        tabIndex: 0,
        role: "listbox",
        "aria-label": this.view.state.phrase("Diagnostics"),
        onkeydown,
        onclick
      });
      this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
        type: "button",
        name: "close",
        "aria-label": this.view.state.phrase("close"),
        onclick: () => closeLintPanel(this.view)
      }, "\xD7"));
      this.update();
    }
    get selectedIndex() {
      let selected = this.view.state.field(lintState).selected;
      if (!selected)
        return -1;
      for (let i2 = 0; i2 < this.items.length; i2++)
        if (this.items[i2].diagnostic == selected.diagnostic)
          return i2;
      return -1;
    }
    update() {
      let { diagnostics, selected } = this.view.state.field(lintState);
      let i2 = 0, needsSync = false, newSelectedItem = null;
      diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
        let found = -1, item;
        for (let j = i2; j < this.items.length; j++)
          if (this.items[j].diagnostic == spec.diagnostic) {
            found = j;
            break;
          }
        if (found < 0) {
          item = new PanelItem(this.view, spec.diagnostic);
          this.items.splice(i2, 0, item);
          needsSync = true;
        } else {
          item = this.items[found];
          if (found > i2) {
            this.items.splice(i2, found - i2);
            needsSync = true;
          }
        }
        if (selected && item.diagnostic == selected.diagnostic) {
          if (!item.dom.hasAttribute("aria-selected")) {
            item.dom.setAttribute("aria-selected", "true");
            newSelectedItem = item;
          }
        } else if (item.dom.hasAttribute("aria-selected")) {
          item.dom.removeAttribute("aria-selected");
        }
        i2++;
      });
      while (i2 < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
        needsSync = true;
        this.items.pop();
      }
      if (this.items.length == 0) {
        this.items.push(new PanelItem(this.view, {
          from: -1,
          to: -1,
          severity: "info",
          message: this.view.state.phrase("No diagnostics")
        }));
        needsSync = true;
      }
      if (newSelectedItem) {
        this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
        this.view.requestMeasure({
          key: this,
          read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
          write: ({ sel, panel }) => {
            if (sel.top < panel.top)
              this.list.scrollTop -= panel.top - sel.top;
            else if (sel.bottom > panel.bottom)
              this.list.scrollTop += sel.bottom - panel.bottom;
          }
        });
      } else if (this.selectedIndex < 0) {
        this.list.removeAttribute("aria-activedescendant");
      }
      if (needsSync)
        this.sync();
    }
    sync() {
      let domPos = this.list.firstChild;
      function rm2() {
        let prev = domPos;
        domPos = prev.nextSibling;
        prev.remove();
      }
      for (let item of this.items) {
        if (item.dom.parentNode == this.list) {
          while (domPos != item.dom)
            rm2();
          domPos = item.dom.nextSibling;
        } else {
          this.list.insertBefore(item.dom, domPos);
        }
      }
      while (domPos)
        rm2();
    }
    moveSelection(selectedIndex) {
      if (this.selectedIndex < 0)
        return;
      let field = this.view.state.field(lintState);
      let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
      if (!selection)
        return;
      this.view.dispatch({
        selection: { anchor: selection.from, head: selection.to },
        scrollIntoView: true,
        effects: movePanelSelection.of(selection)
      });
    }
    static open(view) {
      return new LintPanel(view);
    }
  };
  function svg(content2, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content2)}</svg>')`;
  }
  function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
  }
  var baseTheme5 = /* @__PURE__ */ EditorView.baseTheme({
    ".cm-diagnostic": {
      padding: "3px 6px 3px 8px",
      marginLeft: "-1px",
      display: "block",
      whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnosticAction": {
      font: "inherit",
      border: "none",
      padding: "2px 4px",
      backgroundColor: "#444",
      color: "white",
      borderRadius: "3px",
      marginLeft: "8px"
    },
    ".cm-diagnosticSource": {
      fontSize: "70%",
      opacity: 0.7
    },
    ".cm-lintRange": {
      backgroundPosition: "left bottom",
      backgroundRepeat: "repeat-x",
      paddingBottom: "0.7px"
    },
    ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ underline("#999") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
      padding: 0,
      margin: 0
    },
    ".cm-lintPoint": {
      position: "relative",
      "&:after": {
        content: '""',
        position: "absolute",
        bottom: 0,
        left: "-2px",
        borderLeft: "3px solid transparent",
        borderRight: "3px solid transparent",
        borderBottom: "4px solid #d11"
      }
    },
    ".cm-lintPoint-warning": {
      "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
      "&:after": { borderBottomColor: "#999" }
    },
    ".cm-panel.cm-panel-lint": {
      position: "relative",
      "& ul": {
        maxHeight: "100px",
        overflowY: "auto",
        "& [aria-selected]": {
          backgroundColor: "#ddd",
          "& u": { textDecoration: "underline" }
        },
        "&:focus [aria-selected]": {
          background_fallback: "#bdf",
          backgroundColor: "Highlight",
          color_fallback: "white",
          color: "HighlightText"
        },
        "& u": { textDecoration: "none" },
        padding: 0,
        margin: 0
      },
      "& [name=close]": {
        position: "absolute",
        top: "0",
        right: "2px",
        background: "inherit",
        border: "none",
        font: "inherit",
        padding: 0,
        margin: 0
      }
    }
  });

  // node_modules/@codemirror/basic-setup/dist/index.js
  var basicSetup = [
    /* @__PURE__ */ lineNumbers(),
    /* @__PURE__ */ highlightActiveLineGutter(),
    /* @__PURE__ */ highlightSpecialChars(),
    /* @__PURE__ */ history(),
    /* @__PURE__ */ foldGutter(),
    /* @__PURE__ */ drawSelection(),
    /* @__PURE__ */ dropCursor(),
    /* @__PURE__ */ EditorState.allowMultipleSelections.of(true),
    /* @__PURE__ */ indentOnInput(),
    /* @__PURE__ */ syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
    /* @__PURE__ */ bracketMatching(),
    /* @__PURE__ */ closeBrackets(),
    /* @__PURE__ */ autocompletion(),
    /* @__PURE__ */ rectangularSelection(),
    /* @__PURE__ */ crosshairCursor(),
    /* @__PURE__ */ highlightActiveLine(),
    /* @__PURE__ */ highlightSelectionMatches(),
    /* @__PURE__ */ keymap.of([
      ...closeBracketsKeymap,
      ...defaultKeymap,
      ...searchKeymap,
      ...historyKeymap,
      ...foldKeymap,
      ...completionKeymap,
      ...lintKeymap
    ])
  ];

  // public/packages/code-module.js
  var $3 = module2("code-module");
  $3.when("click", ".publish", (event) => {
    const link2 = event.target.closest($3.link).getAttribute("src");
    const { file } = $3.learn();
    fetch(link2, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ file })
    }).then(() => {
      window.location.href = window.location.href;
    });
  });
  $3.draw((target) => {
    const link2 = target.getAttribute("src");
    console.log(link2);
    const { file } = $3.learn();
    if (!file) {
      fetch(link2).then((res) => res.json()).then(({ file: file2 }) => $3.teach({ file: file2 }));
      return;
    }
    if (!target.view) {
      target.innerHTML = `
      <button class="publish">Publish</button>
    `;
      const config2 = {
        extensions: [
          basicSetup,
          EditorView.updateListener.of(
            persist(target, $3, {})
          )
        ]
      };
      const state3 = EditorState.create({
        ...config2,
        doc: file
      });
      target.view = new EditorView({
        parent: target,
        state: state3
      });
    }
  });
  function persist(_target, $11, _flags) {
    return (update3) => {
      if (update3.changes.inserted.length < 0)
        return;
      const file = update3.view.state.doc.toString();
      $11.teach({ file });
    };
  }
  $3.flair(`
  & {
		display: block;
    max-height: 60vh;
    overflow: scroll;
  }
`);

  // node_modules/colorjs.io/dist/color.js
  function multiplyMatrices(A, B) {
    let m3 = A.length;
    if (!Array.isArray(A[0])) {
      A = [A];
    }
    if (!Array.isArray(B[0])) {
      B = B.map((x) => [x]);
    }
    let p2 = B[0].length;
    let B_cols = B[0].map((_, i2) => B.map((x) => x[i2]));
    let product = A.map((row) => B_cols.map((col) => {
      let ret = 0;
      if (!Array.isArray(row)) {
        for (let c4 of col) {
          ret += row * c4;
        }
        return ret;
      }
      for (let i2 = 0; i2 < row.length; i2++) {
        ret += row[i2] * (col[i2] || 0);
      }
      return ret;
    }));
    if (m3 === 1) {
      product = product[0];
    }
    if (p2 === 1) {
      return product.map((x) => x[0]);
    }
    return product;
  }
  function isString(str) {
    return type(str) === "string";
  }
  function type(o) {
    let str = Object.prototype.toString.call(o);
    return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
  }
  function toPrecision(n2, precision) {
    n2 = +n2;
    precision = +precision;
    let integerLength = (Math.floor(n2) + "").length;
    if (precision > integerLength) {
      return +n2.toFixed(precision - integerLength);
    } else {
      let p10 = 10 ** (integerLength - precision);
      return Math.round(n2 / p10) * p10;
    }
  }
  function parseFunction(str) {
    if (!str) {
      return;
    }
    str = str.trim();
    const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
    const isNumberRegex = /^-?[\d.]+$/;
    let parts = str.match(isFunctionRegex);
    if (parts) {
      let args = [];
      parts[2].replace(/\/?\s*([-\w.]+(?:%|deg)?)/g, ($0, arg) => {
        if (/%$/.test(arg)) {
          arg = new Number(arg.slice(0, -1) / 100);
          arg.type = "<percentage>";
        } else if (/deg$/.test(arg)) {
          arg = new Number(+arg.slice(0, -3));
          arg.type = "<angle>";
          arg.unit = "deg";
        } else if (isNumberRegex.test(arg)) {
          arg = new Number(arg);
          arg.type = "<number>";
        }
        if ($0.startsWith("/")) {
          arg = arg instanceof Number ? arg : new Number(arg);
          arg.alpha = true;
        }
        args.push(arg);
      });
      return {
        name: parts[1].toLowerCase(),
        rawName: parts[1],
        rawArgs: parts[2],
        args
      };
    }
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function interpolate(start2, end, p2) {
    if (isNaN(start2)) {
      return end;
    }
    if (isNaN(end)) {
      return start2;
    }
    return start2 + (end - start2) * p2;
  }
  function interpolateInv(start2, end, value) {
    return (value - start2) / (end - start2);
  }
  function mapRange2(from, to2, value) {
    return interpolate(to2[0], to2[1], interpolateInv(from[0], from[1], value));
  }
  function parseCoordGrammar(coordGrammars) {
    return coordGrammars.map((coordGrammar2) => {
      return coordGrammar2.split("|").map((type2) => {
        type2 = type2.trim();
        let range2 = type2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
        if (range2) {
          let ret = new String(range2[1]);
          ret.range = [+range2[2], +range2[3]];
          return ret;
        }
        return type2;
      });
    });
  }
  var util = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    interpolate,
    interpolateInv,
    isString,
    last,
    mapRange: mapRange2,
    multiplyMatrices,
    parseCoordGrammar,
    parseFunction,
    toPrecision,
    type
  });
  var Hooks = class {
    add(name3, callback, first) {
      if (typeof arguments[0] != "string") {
        for (var name3 in arguments[0]) {
          this.add(name3, arguments[0][name3], arguments[1]);
        }
        return;
      }
      (Array.isArray(name3) ? name3 : [name3]).forEach(function(name4) {
        this[name4] = this[name4] || [];
        if (callback) {
          this[name4][first ? "unshift" : "push"](callback);
        }
      }, this);
    }
    run(name3, env) {
      this[name3] = this[name3] || [];
      this[name3].forEach(function(callback) {
        callback.call(env && env.context ? env.context : env, env);
      });
    }
  };
  var hooks = new Hooks();
  var defaults3 = {
    gamut_mapping: "lch.c",
    precision: 5,
    deltaE: "76"
  };
  var WHITES = {
    D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
    D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
  };
  function getWhite(name3) {
    if (Array.isArray(name3)) {
      return name3;
    }
    return WHITES[name3];
  }
  function adapt$1(W1, W2, XYZ, options2 = {}) {
    W1 = getWhite(W1);
    W2 = getWhite(W2);
    if (!W1 || !W2) {
      throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
    }
    if (W1 === W2) {
      return XYZ;
    }
    let env = { W1, W2, XYZ, options: options2 };
    hooks.run("chromatic-adaptation-start", env);
    if (!env.M) {
      if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
        env.M = [
          [1.0479298208405488, 0.022946793341019088, -0.05019222954313557],
          [0.029627815688159344, 0.990434484573249, -0.01707382502938514],
          [-0.009243058152591178, 0.015055144896577895, 0.7518742899580008]
        ];
      } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
        env.M = [
          [0.9554734527042182, -0.023098536874261423, 0.0632593086610217],
          [-0.028369706963208136, 1.0099954580058226, 0.021041398966943008],
          [0.012314001688319899, -0.020507696433477912, 1.3303659366080753]
        ];
      }
    }
    hooks.run("chromatic-adaptation-end", env);
    if (env.M) {
      return multiplyMatrices(env.M, env.XYZ);
    } else {
      throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
    }
  }
  var \u03B5$4 = 75e-6;
  var _ColorSpace = class {
    constructor(options2) {
      this.id = options2.id;
      this.name = options2.name;
      this.base = options2.base ? _ColorSpace.get(options2.base) : null;
      this.aliases = options2.aliases;
      if (this.base) {
        this.fromBase = options2.fromBase;
        this.toBase = options2.toBase;
      }
      let coords = options2.coords ?? this.base.coords;
      for (let name3 in coords) {
        if (!("name" in coords[name3])) {
          coords[name3].name = name3;
        }
      }
      this.coords = coords;
      let white2 = options2.white ?? this.base.white ?? "D65";
      this.white = getWhite(white2);
      this.formats = options2.formats ?? {};
      for (let name3 in this.formats) {
        let format = this.formats[name3];
        format.type ||= "function";
        format.name ||= name3;
      }
      if (options2.cssId && !this.formats.functions?.color) {
        this.formats.color = { id: options2.cssId };
        Object.defineProperty(this, "cssId", { value: options2.cssId });
      } else if (this.formats?.color && !this.formats?.color.id) {
        this.formats.color.id = this.id;
      }
      this.referred = options2.referred;
      Object.defineProperty(this, "path", {
        value: getPath(this).reverse(),
        writable: false,
        enumerable: true,
        configurable: true
      });
      hooks.run("colorspace-init-end", this);
    }
    inGamut(coords, { epsilon = \u03B5$4 } = {}) {
      if (this.isPolar) {
        coords = this.toBase(coords);
        return this.base.inGamut(coords, { epsilon });
      }
      let coordMeta = Object.values(this.coords);
      return coords.every((c4, i2) => {
        let meta2 = coordMeta[i2];
        if (meta2.type !== "angle" && meta2.range) {
          if (Number.isNaN(c4)) {
            return true;
          }
          let [min, max3] = meta2.range;
          return (min === void 0 || c4 >= min - epsilon) && (max3 === void 0 || c4 <= max3 + epsilon);
        }
        return true;
      });
    }
    get cssId() {
      return this.formats.functions?.color?.id || this.id;
    }
    get isPolar() {
      for (let id2 in this.coords) {
        if (this.coords[id2].type === "angle") {
          return true;
        }
      }
      return false;
    }
    getFormat(format) {
      if (typeof format === "object") {
        format = processFormat(format, this);
        return format;
      }
      let ret;
      if (format === "default") {
        ret = Object.values(this.formats)[0];
      } else {
        ret = this.formats[format];
      }
      if (ret) {
        ret = processFormat(ret, this);
        return ret;
      }
      return null;
    }
    equals(space) {
      if (!space) {
        return false;
      }
      return this === space || this.id === space.id;
    }
    to(space, coords) {
      if (arguments.length === 1) {
        [space, coords] = [space.space, space.coords];
      }
      space = _ColorSpace.get(space);
      if (this.equals(space)) {
        return coords;
      }
      coords = coords.map((c4) => Number.isNaN(c4) ? 0 : c4);
      let myPath = this.path;
      let otherPath = space.path;
      let connectionSpace, connectionSpaceIndex;
      for (let i2 = 0; i2 < myPath.length; i2++) {
        if (myPath[i2].equals(otherPath[i2])) {
          connectionSpace = myPath[i2];
          connectionSpaceIndex = i2;
        } else {
          break;
        }
      }
      if (!connectionSpace) {
        throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
      }
      for (let i2 = myPath.length - 1; i2 > connectionSpaceIndex; i2--) {
        coords = myPath[i2].toBase(coords);
      }
      for (let i2 = connectionSpaceIndex + 1; i2 < otherPath.length; i2++) {
        coords = otherPath[i2].fromBase(coords);
      }
      return coords;
    }
    from(space, coords) {
      if (arguments.length === 1) {
        [space, coords] = [space.space, space.coords];
      }
      space = _ColorSpace.get(space);
      return space.to(this, coords);
    }
    toString() {
      return `${this.name} (${this.id})`;
    }
    getMinCoords() {
      let ret = [];
      for (let id2 in this.coords) {
        let meta2 = this.coords[id2];
        let range2 = meta2.range || meta2.refRange;
        ret.push(range2?.min ?? 0);
      }
      return ret;
    }
    static get all() {
      return [...new Set(Object.values(_ColorSpace.registry))];
    }
    static register(id2, space) {
      if (arguments.length === 1) {
        space = arguments[0];
        id2 = space.id;
      }
      space = this.get(space);
      if (this.registry[id2] && this.registry[id2] !== space) {
        throw new Error(`Duplicate color space registration: '${id2}'`);
      }
      this.registry[id2] = space;
      if (arguments.length === 1 && space.aliases) {
        for (let alias of space.aliases) {
          this.register(alias, space);
        }
      }
      return space;
    }
    static get(space, ...alternatives) {
      if (!space || space instanceof _ColorSpace) {
        return space;
      }
      let argType = type(space);
      if (argType === "string") {
        let ret = _ColorSpace.registry[space.toLowerCase()];
        if (!ret) {
          throw new TypeError(`No color space found with id = "${space}"`);
        }
        return ret;
      }
      if (alternatives.length) {
        return _ColorSpace.get(...alternatives);
      }
      throw new TypeError(`${space} is not a valid color space`);
    }
    static resolveCoord(ref, workingSpace) {
      let coordType = type(ref);
      let space, coord;
      if (coordType === "string") {
        if (ref.includes(".")) {
          [space, coord] = ref.split(".");
        } else {
          [space, coord] = [, ref];
        }
      } else if (Array.isArray(ref)) {
        [space, coord] = ref;
      } else {
        space = ref.space;
        coord = ref.coordId;
      }
      space = _ColorSpace.get(space);
      if (!space) {
        space = workingSpace;
      }
      if (!space) {
        throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
      }
      coordType = type(coord);
      if (coordType === "number" || coordType === "string" && coord >= 0) {
        let meta2 = Object.entries(space.coords)[coord];
        if (meta2) {
          return { space, id: meta2[0], index: coord, ...meta2[1] };
        }
      }
      space = _ColorSpace.get(space);
      let normalizedCoord = coord.toLowerCase();
      let i2 = 0;
      for (let id2 in space.coords) {
        let meta2 = space.coords[id2];
        if (id2.toLowerCase() === normalizedCoord || meta2.name?.toLowerCase() === normalizedCoord) {
          return { space, id: id2, index: i2, ...meta2 };
        }
        i2++;
      }
      throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
    }
  };
  var ColorSpace = _ColorSpace;
  __publicField(ColorSpace, "registry", {});
  __publicField(ColorSpace, "DEFAULT_FORMAT", {
    type: "functions",
    name: "color"
  });
  function getPath(space) {
    let ret = [space];
    for (let s = space; s = s.base; ) {
      ret.push(s);
    }
    return ret;
  }
  function processFormat(format, { coords } = {}) {
    if (format.coords && !format.coordGrammar) {
      format.type ||= "function";
      format.name ||= "color";
      format.coordGrammar = parseCoordGrammar(format.coords);
      let coordFormats = Object.entries(coords).map(([id2, coordMeta], i2) => {
        let outputType = format.coordGrammar[i2][0];
        let fromRange = coordMeta.range || coordMeta.refRange;
        let toRange = outputType.range, suffix = "";
        if (outputType == "<percentage>") {
          toRange = [0, 100];
          suffix = "%";
        } else if (outputType == "<angle>") {
          suffix = "deg";
        }
        return { fromRange, toRange, suffix };
      });
      format.serializeCoords = (coords2, precision) => {
        return coords2.map((c4, i2) => {
          let { fromRange, toRange, suffix } = coordFormats[i2];
          if (fromRange && toRange) {
            c4 = mapRange2(fromRange, toRange, c4);
          }
          c4 = toPrecision(c4, precision);
          if (suffix) {
            c4 += suffix;
          }
          return c4;
        });
      };
    }
    return format;
  }
  var XYZ_D65 = new ColorSpace({
    id: "xyz-d65",
    name: "XYZ D65",
    coords: {
      x: { name: "X" },
      y: { name: "Y" },
      z: { name: "Z" }
    },
    white: "D65",
    formats: {
      color: {
        ids: ["xyz-d65", "xyz"]
      }
    },
    aliases: ["xyz"]
  });
  var RGBColorSpace = class extends ColorSpace {
    constructor(options2) {
      if (!options2.coords) {
        options2.coords = {
          r: {
            range: [0, 1],
            name: "Red"
          },
          g: {
            range: [0, 1],
            name: "Green"
          },
          b: {
            range: [0, 1],
            name: "Blue"
          }
        };
      }
      if (!options2.base) {
        options2.base = XYZ_D65;
      }
      if (options2.toXYZ_M && options2.fromXYZ_M) {
        options2.toBase ??= (rgb) => {
          let xyz = multiplyMatrices(options2.toXYZ_M, rgb);
          if (this.white !== this.base.white) {
            xyz = adapt$1(this.white, this.base.white, xyz);
          }
          return xyz;
        };
        options2.fromBase ??= (xyz) => {
          xyz = adapt$1(this.base.white, this.white, xyz);
          return multiplyMatrices(options2.fromXYZ_M, xyz);
        };
      }
      options2.referred ??= "display";
      super(options2);
    }
  };
  function parse4(str, { meta: meta2 } = {}) {
    let env = { "str": String(str)?.trim() };
    hooks.run("parse-start", env);
    if (env.color) {
      return env.color;
    }
    env.parsed = parseFunction(env.str);
    if (env.parsed) {
      let name3 = env.parsed.name;
      if (name3 === "color") {
        let id2 = env.parsed.args.shift();
        let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
        for (let space of ColorSpace.all) {
          let colorSpec = space.getFormat("color");
          if (colorSpec) {
            if (id2 === colorSpec.id || colorSpec.ids?.includes(id2)) {
              const coords = Object.keys(space.coords).map((_, i2) => env.parsed.args[i2] || 0);
              if (meta2) {
                meta2.formatId = "color";
              }
              return { spaceId: space.id, coords, alpha };
            }
          }
        }
        let didYouMean = "";
        if (id2 in ColorSpace.registry) {
          let cssId = ColorSpace.registry[id2].formats?.functions?.color?.id;
          if (cssId) {
            didYouMean = `Did you mean color(${cssId})?`;
          }
        }
        throw new TypeError(`Cannot parse color(${id2}). ` + (didYouMean || "Missing a plugin?"));
      } else {
        for (let space of ColorSpace.all) {
          let format = space.getFormat(name3);
          if (format && format.type === "function") {
            let alpha = 1;
            if (format.lastAlpha || last(env.parsed.args).alpha) {
              alpha = env.parsed.args.pop();
            }
            let coords = env.parsed.args;
            let types2;
            if (format.coordGrammar) {
              types2 = Object.entries(space.coords).map(([id2, coordMeta], i2) => {
                let coordGrammar2 = format.coordGrammar[i2];
                let providedType = coords[i2]?.type;
                let type2 = coordGrammar2.find((c4) => c4 == providedType);
                if (!type2) {
                  let coordName = coordMeta.name || id2;
                  throw new TypeError(`${providedType} not allowed for ${coordName} in ${name3}()`);
                }
                let fromRange = type2.range;
                if (providedType === "<percentage>") {
                  fromRange ||= [0, 1];
                }
                let toRange = coordMeta.range || coordMeta.refRange;
                if (fromRange && toRange) {
                  coords[i2] = mapRange2(fromRange, toRange, coords[i2]);
                }
                return type2;
              });
            }
            if (meta2) {
              Object.assign(meta2, { formatId: format.name, types: types2 });
            }
            return {
              spaceId: space.id,
              coords,
              alpha
            };
          }
        }
      }
    } else {
      for (let space of ColorSpace.all) {
        for (let formatId in space.formats) {
          let format = space.formats[formatId];
          if (format.type !== "custom") {
            continue;
          }
          if (format.test && !format.test(env.str)) {
            continue;
          }
          let color = format.parse(env.str);
          if (color) {
            color.alpha ??= 1;
            if (meta2) {
              meta2.formatId = formatId;
            }
            return color;
          }
        }
      }
    }
    throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
  }
  function getColor(color) {
    if (!color) {
      throw new TypeError("Empty color reference");
    }
    if (isString(color)) {
      color = parse4(color);
    }
    let space = color.space || color.spaceId;
    if (!(space instanceof ColorSpace)) {
      color.space = ColorSpace.get(space);
    }
    if (color.alpha === void 0) {
      color.alpha = 1;
    }
    return color;
  }
  function getAll(color, space) {
    space = ColorSpace.get(space);
    return space.from(color);
  }
  function get2(color, prop) {
    let { space, index } = ColorSpace.resolveCoord(prop, color.space);
    let coords = getAll(color, space);
    return coords[index];
  }
  function setAll(color, space, coords) {
    space = ColorSpace.get(space);
    color.coords = space.to(color.space, coords);
    return color;
  }
  function set2(color, prop, value) {
    color = getColor(color);
    if (arguments.length === 2 && type(arguments[1]) === "object") {
      let object = arguments[1];
      for (let p2 in object) {
        set2(color, p2, object[p2]);
      }
    } else {
      if (typeof value === "function") {
        value = value(get2(color, prop));
      }
      let { space, index } = ColorSpace.resolveCoord(prop, color.space);
      let coords = getAll(color, space);
      coords[index] = value;
      setAll(color, space, coords);
    }
    return color;
  }
  var XYZ_D50 = new ColorSpace({
    id: "xyz-d50",
    name: "XYZ D50",
    white: "D50",
    base: XYZ_D65,
    fromBase: (coords) => adapt$1(XYZ_D65.white, "D50", coords),
    toBase: (coords) => adapt$1("D50", XYZ_D65.white, coords),
    formats: {
      color: {}
    }
  });
  var \u03B5$3 = 216 / 24389;
  var \u03B53$1 = 24 / 116;
  var \u03BA$1 = 24389 / 27;
  var white$1 = WHITES.D50;
  var lab = new ColorSpace({
    id: "lab",
    name: "Lab",
    coords: {
      l: {
        refRange: [0, 100],
        name: "L"
      },
      a: {
        refRange: [-125, 125]
      },
      b: {
        refRange: [-125, 125]
      }
    },
    white: white$1,
    base: XYZ_D50,
    fromBase(XYZ) {
      let xyz = XYZ.map((value, i2) => value / white$1[i2]);
      let f = xyz.map((value) => value > \u03B5$3 ? Math.cbrt(value) : (\u03BA$1 * value + 16) / 116);
      return [
        116 * f[1] - 16,
        500 * (f[0] - f[1]),
        200 * (f[1] - f[2])
      ];
    },
    toBase(Lab) {
      let f = [];
      f[1] = (Lab[0] + 16) / 116;
      f[0] = Lab[1] / 500 + f[1];
      f[2] = f[1] - Lab[2] / 200;
      let xyz = [
        f[0] > \u03B53$1 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / \u03BA$1,
        Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / \u03BA$1,
        f[2] > \u03B53$1 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / \u03BA$1
      ];
      return xyz.map((value, i2) => value * white$1[i2]);
    },
    formats: {
      "lab": {
        coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
      }
    }
  });
  function constrain(angle) {
    return (angle % 360 + 360) % 360;
  }
  function adjust(arc, angles) {
    if (arc === "raw") {
      return angles;
    }
    let [a1, a2] = angles.map(constrain);
    let angleDiff = a2 - a1;
    if (arc === "increasing") {
      if (angleDiff < 0) {
        a2 += 360;
      }
    } else if (arc === "decreasing") {
      if (angleDiff > 0) {
        a1 += 360;
      }
    } else if (arc === "longer") {
      if (-180 < angleDiff && angleDiff < 180) {
        if (angleDiff > 0) {
          a1 += 360;
        } else {
          a2 += 360;
        }
      }
    } else if (arc === "shorter") {
      if (angleDiff > 180) {
        a1 += 360;
      } else if (angleDiff < -180) {
        a2 += 360;
      }
    }
    return [a1, a2];
  }
  var lch = new ColorSpace({
    id: "lch",
    name: "LCH",
    coords: {
      l: {
        refRange: [0, 100],
        name: "Lightness"
      },
      c: {
        refRange: [0, 150],
        name: "Chroma"
      },
      h: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      }
    },
    base: lab,
    fromBase(Lab) {
      let [L, a2, b2] = Lab;
      let hue;
      const \u03B52 = 0.02;
      if (Math.abs(a2) < \u03B52 && Math.abs(b2) < \u03B52) {
        hue = NaN;
      } else {
        hue = Math.atan2(b2, a2) * 180 / Math.PI;
      }
      return [
        L,
        Math.sqrt(a2 ** 2 + b2 ** 2),
        constrain(hue)
      ];
    },
    toBase(LCH) {
      let [Lightness, Chroma, Hue] = LCH;
      if (Chroma < 0) {
        Chroma = 0;
      }
      if (isNaN(Hue)) {
        Hue = 0;
      }
      return [
        Lightness,
        Chroma * Math.cos(Hue * Math.PI / 180),
        Chroma * Math.sin(Hue * Math.PI / 180)
      ];
    },
    formats: {
      "lch": {
        coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
      }
    }
  });
  var Gfactor = 25 ** 7;
  var \u03C0$1 = Math.PI;
  var r2d = 180 / \u03C0$1;
  var d2r$1 = \u03C0$1 / 180;
  function deltaE2000(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
    let [L1, a1, b1] = lab.from(color);
    let C1 = lch.from(lab, [L1, a1, b1])[1];
    let [L2, a2, b2] = lab.from(sample);
    let C2 = lch.from(lab, [L2, a2, b2])[1];
    if (C1 < 0) {
      C1 = 0;
    }
    if (C2 < 0) {
      C2 = 0;
    }
    let Cbar = (C1 + C2) / 2;
    let C7 = Cbar ** 7;
    let G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
    let adash1 = (1 + G) * a1;
    let adash2 = (1 + G) * a2;
    let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
    let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
    let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
    let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
    if (h1 < 0) {
      h1 += 2 * \u03C0$1;
    }
    if (h2 < 0) {
      h2 += 2 * \u03C0$1;
    }
    h1 *= r2d;
    h2 *= r2d;
    let \u0394L = L2 - L1;
    let \u0394C = Cdash2 - Cdash1;
    let hdiff = h2 - h1;
    let hsum = h1 + h2;
    let habs = Math.abs(hdiff);
    let \u0394h;
    if (Cdash1 * Cdash2 === 0) {
      \u0394h = 0;
    } else if (habs <= 180) {
      \u0394h = hdiff;
    } else if (hdiff > 180) {
      \u0394h = hdiff - 360;
    } else if (hdiff < -180) {
      \u0394h = hdiff + 360;
    } else {
      console.log("the unthinkable has happened");
    }
    let \u0394H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(\u0394h * d2r$1 / 2);
    let Ldash = (L1 + L2) / 2;
    let Cdash = (Cdash1 + Cdash2) / 2;
    let Cdash7 = Math.pow(Cdash, 7);
    let hdash;
    if (Cdash1 * Cdash2 === 0) {
      hdash = hsum;
    } else if (habs <= 180) {
      hdash = hsum / 2;
    } else if (hsum < 360) {
      hdash = (hsum + 360) / 2;
    } else {
      hdash = (hsum - 360) / 2;
    }
    let lsq = (Ldash - 50) ** 2;
    let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
    let SC = 1 + 0.045 * Cdash;
    let T = 1;
    T -= 0.17 * Math.cos((hdash - 30) * d2r$1);
    T += 0.24 * Math.cos(2 * hdash * d2r$1);
    T += 0.32 * Math.cos((3 * hdash + 6) * d2r$1);
    T -= 0.2 * Math.cos((4 * hdash - 63) * d2r$1);
    let SH = 1 + 0.015 * Cdash * T;
    let \u0394\u03B8 = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
    let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
    let RT = -1 * Math.sin(2 * \u0394\u03B8 * d2r$1) * RC;
    let dE = (\u0394L / (kL * SL)) ** 2;
    dE += (\u0394C / (kC * SC)) ** 2;
    dE += (\u0394H / (kH * SH)) ** 2;
    dE += RT * (\u0394C / (kC * SC)) * (\u0394H / (kH * SH));
    return Math.sqrt(dE);
  }
  var \u03B5$2 = 75e-6;
  function inGamut(color, space = color.space, { epsilon = \u03B5$2 } = {}) {
    color = getColor(color);
    space = ColorSpace.get(space);
    let coords = color.coords;
    if (space !== color.space) {
      coords = space.from(color);
    }
    return space.inGamut(coords, { epsilon });
  }
  function clone2(color) {
    return {
      space: color.space,
      coords: color.coords.slice(),
      alpha: color.alpha
    };
  }
  function toGamut(color, { method = defaults3.gamut_mapping, space = color.space } = {}) {
    if (isString(arguments[1])) {
      space = arguments[1];
    }
    space = ColorSpace.get(space);
    if (inGamut(color, space, { epsilon: 0 })) {
      return getColor(color);
    }
    let spaceColor = to(color, space);
    if (method !== "clip" && !inGamut(color, space)) {
      let clipped = toGamut(clone2(spaceColor), { method: "clip", space });
      if (deltaE2000(color, clipped) > 2) {
        let coordMeta = ColorSpace.resolveCoord(method);
        let mapSpace = coordMeta.space;
        let coordId = coordMeta.id;
        let mappedColor = to(spaceColor, mapSpace);
        let bounds = coordMeta.range || coordMeta.refRange;
        let min = bounds[0];
        let \u03B52 = 0.01;
        let low = min;
        let high = get2(mappedColor, coordId);
        while (high - low > \u03B52) {
          let clipped2 = clone2(mappedColor);
          clipped2 = toGamut(clipped2, { space, method: "clip" });
          let deltaE2 = deltaE2000(mappedColor, clipped2);
          if (deltaE2 - 2 < \u03B52) {
            low = get2(mappedColor, coordId);
          } else {
            high = get2(mappedColor, coordId);
          }
          set2(mappedColor, coordId, (low + high) / 2);
        }
        spaceColor = to(mappedColor, space);
      } else {
        spaceColor = clipped;
      }
    }
    if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
      let bounds = Object.values(space.coords).map((c4) => c4.range || []);
      spaceColor.coords = spaceColor.coords.map((c4, i2) => {
        let [min, max3] = bounds[i2];
        if (min !== void 0) {
          c4 = Math.max(min, c4);
        }
        if (max3 !== void 0) {
          c4 = Math.min(c4, max3);
        }
        return c4;
      });
    }
    if (space !== color.space) {
      spaceColor = to(spaceColor, color.space);
    }
    color.coords = spaceColor.coords;
    return color;
  }
  toGamut.returns = "color";
  function to(color, space, { inGamut: inGamut2 } = {}) {
    color = getColor(color);
    space = ColorSpace.get(space);
    let coords = space.from(color);
    let ret = { space, coords, alpha: color.alpha };
    if (inGamut2) {
      ret = toGamut(ret);
    }
    return ret;
  }
  to.returns = "color";
  function serialize(color, {
    precision = defaults3.precision,
    format = "default",
    inGamut: inGamut$1 = true,
    ...customOptions
  } = {}) {
    let ret;
    color = getColor(color);
    let formatId = format;
    format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
    inGamut$1 ||= format.toGamut;
    let coords = color.coords;
    coords = coords.map((c4) => c4 ? c4 : 0);
    if (inGamut$1 && !inGamut(color)) {
      coords = toGamut(clone2(color), inGamut$1 === true ? void 0 : inGamut$1).coords;
    }
    if (format.type === "custom") {
      customOptions.precision = precision;
      if (format.serialize) {
        ret = format.serialize(coords, color.alpha, customOptions);
      } else {
        throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
      }
    } else {
      let name3 = format.name || "color";
      if (format.serializeCoords) {
        coords = format.serializeCoords(coords, precision);
      } else {
        if (precision !== null) {
          coords = coords.map((c4) => toPrecision(c4, precision));
        }
      }
      let args = [...coords];
      if (name3 === "color") {
        let cssId = format.id || format.ids?.[0] || color.space.id;
        args.unshift(cssId);
      }
      let alpha = color.alpha;
      if (precision !== null) {
        alpha = toPrecision(alpha, precision);
      }
      let strAlpha = color.alpha < 1 && !format.noAlpha ? `${format.commas ? "," : " /"} ${alpha}` : "";
      ret = `${name3}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
    }
    return ret;
  }
  var toXYZ_M$5 = [
    [0.6369580483012914, 0.14461690358620832, 0.1688809751641721],
    [0.2627002120112671, 0.6779980715188708, 0.05930171646986196],
    [0, 0.028072693049087428, 1.060985057710791]
  ];
  var fromXYZ_M$5 = [
    [1.716651187971268, -0.355670783776392, -0.25336628137366],
    [-0.666684351832489, 1.616481236634939, 0.0157685458139111],
    [0.017639857445311, -0.042770613257809, 0.942103121235474]
  ];
  var REC2020Linear = new RGBColorSpace({
    id: "rec2020-linear",
    name: "Linear REC.2020",
    white: "D65",
    toXYZ_M: toXYZ_M$5,
    fromXYZ_M: fromXYZ_M$5,
    formats: {
      color: {}
    }
  });
  var \u03B1 = 1.09929682680944;
  var \u03B2 = 0.018053968510807;
  var REC2020 = new RGBColorSpace({
    id: "rec2020",
    name: "REC.2020",
    base: REC2020Linear,
    toBase(RGB) {
      return RGB.map(function(val) {
        if (val < \u03B2 * 4.5) {
          return val / 4.5;
        }
        return Math.pow((val + \u03B1 - 1) / \u03B1, 1 / 0.45);
      });
    },
    fromBase(RGB) {
      return RGB.map(function(val) {
        if (val >= \u03B2) {
          return \u03B1 * Math.pow(val, 0.45) - (\u03B1 - 1);
        }
        return 4.5 * val;
      });
    },
    formats: {
      color: {}
    }
  });
  var toXYZ_M$4 = [
    [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
    [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
    [0, 0.04511338185890264, 1.043944368900976]
  ];
  var fromXYZ_M$4 = [
    [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
    [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
    [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
  ];
  var P3Linear = new RGBColorSpace({
    id: "p3-linear",
    name: "Linear P3",
    white: "D65",
    toXYZ_M: toXYZ_M$4,
    fromXYZ_M: fromXYZ_M$4
  });
  var toXYZ_M$3 = [
    [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
    [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
    [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
  ];
  var fromXYZ_M$3 = [
    [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
    [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
    [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
  ];
  var sRGBLinear = new RGBColorSpace({
    id: "srgb-linear",
    name: "Linear sRGB",
    white: "D65",
    toXYZ_M: toXYZ_M$3,
    fromXYZ_M: fromXYZ_M$3,
    formats: {
      color: {}
    }
  });
  var KEYWORDS = {
    "aliceblue": [240 / 255, 248 / 255, 1],
    "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
    "aqua": [0, 1, 1],
    "aquamarine": [127 / 255, 1, 212 / 255],
    "azure": [240 / 255, 1, 1],
    "beige": [245 / 255, 245 / 255, 220 / 255],
    "bisque": [1, 228 / 255, 196 / 255],
    "black": [0, 0, 0],
    "blanchedalmond": [1, 235 / 255, 205 / 255],
    "blue": [0, 0, 1],
    "blueviolet": [138 / 255, 43 / 255, 226 / 255],
    "brown": [165 / 255, 42 / 255, 42 / 255],
    "burlywood": [222 / 255, 184 / 255, 135 / 255],
    "cadetblue": [95 / 255, 158 / 255, 160 / 255],
    "chartreuse": [127 / 255, 1, 0],
    "chocolate": [210 / 255, 105 / 255, 30 / 255],
    "coral": [1, 127 / 255, 80 / 255],
    "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
    "cornsilk": [1, 248 / 255, 220 / 255],
    "crimson": [220 / 255, 20 / 255, 60 / 255],
    "cyan": [0, 1, 1],
    "darkblue": [0, 0, 139 / 255],
    "darkcyan": [0, 139 / 255, 139 / 255],
    "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
    "darkgray": [169 / 255, 169 / 255, 169 / 255],
    "darkgreen": [0, 100 / 255, 0],
    "darkgrey": [169 / 255, 169 / 255, 169 / 255],
    "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
    "darkmagenta": [139 / 255, 0, 139 / 255],
    "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
    "darkorange": [1, 140 / 255, 0],
    "darkorchid": [153 / 255, 50 / 255, 204 / 255],
    "darkred": [139 / 255, 0, 0],
    "darksalmon": [233 / 255, 150 / 255, 122 / 255],
    "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
    "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
    "darkslategray": [47 / 255, 79 / 255, 79 / 255],
    "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
    "darkturquoise": [0, 206 / 255, 209 / 255],
    "darkviolet": [148 / 255, 0, 211 / 255],
    "deeppink": [1, 20 / 255, 147 / 255],
    "deepskyblue": [0, 191 / 255, 1],
    "dimgray": [105 / 255, 105 / 255, 105 / 255],
    "dimgrey": [105 / 255, 105 / 255, 105 / 255],
    "dodgerblue": [30 / 255, 144 / 255, 1],
    "firebrick": [178 / 255, 34 / 255, 34 / 255],
    "floralwhite": [1, 250 / 255, 240 / 255],
    "forestgreen": [34 / 255, 139 / 255, 34 / 255],
    "fuchsia": [1, 0, 1],
    "gainsboro": [220 / 255, 220 / 255, 220 / 255],
    "ghostwhite": [248 / 255, 248 / 255, 1],
    "gold": [1, 215 / 255, 0],
    "goldenrod": [218 / 255, 165 / 255, 32 / 255],
    "gray": [128 / 255, 128 / 255, 128 / 255],
    "green": [0, 128 / 255, 0],
    "greenyellow": [173 / 255, 1, 47 / 255],
    "grey": [128 / 255, 128 / 255, 128 / 255],
    "honeydew": [240 / 255, 1, 240 / 255],
    "hotpink": [1, 105 / 255, 180 / 255],
    "indianred": [205 / 255, 92 / 255, 92 / 255],
    "indigo": [75 / 255, 0, 130 / 255],
    "ivory": [1, 1, 240 / 255],
    "khaki": [240 / 255, 230 / 255, 140 / 255],
    "lavender": [230 / 255, 230 / 255, 250 / 255],
    "lavenderblush": [1, 240 / 255, 245 / 255],
    "lawngreen": [124 / 255, 252 / 255, 0],
    "lemonchiffon": [1, 250 / 255, 205 / 255],
    "lightblue": [173 / 255, 216 / 255, 230 / 255],
    "lightcoral": [240 / 255, 128 / 255, 128 / 255],
    "lightcyan": [224 / 255, 1, 1],
    "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
    "lightgray": [211 / 255, 211 / 255, 211 / 255],
    "lightgreen": [144 / 255, 238 / 255, 144 / 255],
    "lightgrey": [211 / 255, 211 / 255, 211 / 255],
    "lightpink": [1, 182 / 255, 193 / 255],
    "lightsalmon": [1, 160 / 255, 122 / 255],
    "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
    "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
    "lightslategray": [119 / 255, 136 / 255, 153 / 255],
    "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
    "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
    "lightyellow": [1, 1, 224 / 255],
    "lime": [0, 1, 0],
    "limegreen": [50 / 255, 205 / 255, 50 / 255],
    "linen": [250 / 255, 240 / 255, 230 / 255],
    "magenta": [1, 0, 1],
    "maroon": [128 / 255, 0, 0],
    "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
    "mediumblue": [0, 0, 205 / 255],
    "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
    "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
    "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
    "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
    "mediumspringgreen": [0, 250 / 255, 154 / 255],
    "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
    "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
    "midnightblue": [25 / 255, 25 / 255, 112 / 255],
    "mintcream": [245 / 255, 1, 250 / 255],
    "mistyrose": [1, 228 / 255, 225 / 255],
    "moccasin": [1, 228 / 255, 181 / 255],
    "navajowhite": [1, 222 / 255, 173 / 255],
    "navy": [0, 0, 128 / 255],
    "oldlace": [253 / 255, 245 / 255, 230 / 255],
    "olive": [128 / 255, 128 / 255, 0],
    "olivedrab": [107 / 255, 142 / 255, 35 / 255],
    "orange": [1, 165 / 255, 0],
    "orangered": [1, 69 / 255, 0],
    "orchid": [218 / 255, 112 / 255, 214 / 255],
    "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
    "palegreen": [152 / 255, 251 / 255, 152 / 255],
    "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
    "palevioletred": [219 / 255, 112 / 255, 147 / 255],
    "papayawhip": [1, 239 / 255, 213 / 255],
    "peachpuff": [1, 218 / 255, 185 / 255],
    "peru": [205 / 255, 133 / 255, 63 / 255],
    "pink": [1, 192 / 255, 203 / 255],
    "plum": [221 / 255, 160 / 255, 221 / 255],
    "powderblue": [176 / 255, 224 / 255, 230 / 255],
    "purple": [128 / 255, 0, 128 / 255],
    "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
    "red": [1, 0, 0],
    "rosybrown": [188 / 255, 143 / 255, 143 / 255],
    "royalblue": [65 / 255, 105 / 255, 225 / 255],
    "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
    "salmon": [250 / 255, 128 / 255, 114 / 255],
    "sandybrown": [244 / 255, 164 / 255, 96 / 255],
    "seagreen": [46 / 255, 139 / 255, 87 / 255],
    "seashell": [1, 245 / 255, 238 / 255],
    "sienna": [160 / 255, 82 / 255, 45 / 255],
    "silver": [192 / 255, 192 / 255, 192 / 255],
    "skyblue": [135 / 255, 206 / 255, 235 / 255],
    "slateblue": [106 / 255, 90 / 255, 205 / 255],
    "slategray": [112 / 255, 128 / 255, 144 / 255],
    "slategrey": [112 / 255, 128 / 255, 144 / 255],
    "snow": [1, 250 / 255, 250 / 255],
    "springgreen": [0, 1, 127 / 255],
    "steelblue": [70 / 255, 130 / 255, 180 / 255],
    "tan": [210 / 255, 180 / 255, 140 / 255],
    "teal": [0, 128 / 255, 128 / 255],
    "thistle": [216 / 255, 191 / 255, 216 / 255],
    "tomato": [1, 99 / 255, 71 / 255],
    "turquoise": [64 / 255, 224 / 255, 208 / 255],
    "violet": [238 / 255, 130 / 255, 238 / 255],
    "wheat": [245 / 255, 222 / 255, 179 / 255],
    "white": [1, 1, 1],
    "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
    "yellow": [1, 1, 0],
    "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
  };
  var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
  var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
  var sRGB = new RGBColorSpace({
    id: "srgb",
    name: "sRGB",
    base: sRGBLinear,
    fromBase: (rgb) => {
      return rgb.map((val) => {
        let sign = val < 0 ? -1 : 1;
        let abs = val * sign;
        if (abs > 31308e-7) {
          return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
        }
        return 12.92 * val;
      });
    },
    toBase: (rgb) => {
      return rgb.map((val) => {
        let sign = val < 0 ? -1 : 1;
        let abs = val * sign;
        if (abs < 0.04045) {
          return val / 12.92;
        }
        return sign * ((abs + 0.055) / 1.055) ** 2.4;
      });
    },
    formats: {
      "rgb": {
        coords: coordGrammar
      },
      "rgb_number": {
        name: "rgb",
        commas: true,
        coords: coordGrammarNumber,
        noAlpha: true
      },
      "color": {},
      "rgba": {
        coords: coordGrammar,
        commas: true,
        lastAlpha: true
      },
      "rgba_number": {
        name: "rgba",
        commas: true,
        coords: coordGrammarNumber
      },
      "hex": {
        type: "custom",
        toGamut: true,
        test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
        parse(str) {
          if (str.length <= 5) {
            str = str.replace(/[a-f0-9]/gi, "$&$&");
          }
          let rgba = [];
          str.replace(/[a-f0-9]{2}/gi, (component) => {
            rgba.push(parseInt(component, 16) / 255);
          });
          return {
            spaceId: "srgb",
            coords: rgba.slice(0, 3),
            alpha: rgba.slice(3)[0]
          };
        },
        serialize: (coords, alpha, {
          collapse = true
        } = {}) => {
          if (alpha < 1) {
            coords.push(alpha);
          }
          coords = coords.map((c4) => Math.round(c4 * 255));
          let collapsible = collapse && coords.every((c4) => c4 % 17 === 0);
          let hex = coords.map((c4) => {
            if (collapsible) {
              return (c4 / 17).toString(16);
            }
            return c4.toString(16).padStart(2, "0");
          }).join("");
          return "#" + hex;
        }
      },
      "keyword": {
        type: "custom",
        test: (str) => /^[a-z]+$/i.test(str),
        parse(str) {
          str = str.toLowerCase();
          let ret = { spaceId: "srgb", coords: null, alpha: 1 };
          if (str === "transparent") {
            ret.coords = KEYWORDS.black;
            ret.alpha = 0;
          } else {
            ret.coords = KEYWORDS[str];
          }
          if (ret.coords) {
            return ret;
          }
        }
      }
    }
  });
  var P3 = new RGBColorSpace({
    id: "p3",
    name: "P3",
    base: P3Linear,
    fromBase: sRGB.fromBase,
    toBase: sRGB.toBase,
    formats: {
      color: {
        id: "display-p3"
      }
    }
  });
  defaults3.display_space = sRGB;
  if (typeof CSS !== "undefined" && CSS.supports) {
    for (let space of [lab, REC2020, P3]) {
      let coords = space.getMinCoords();
      let color = { space, coords, alpha: 1 };
      let str = serialize(color);
      if (CSS.supports("color", str)) {
        defaults3.display_space = space;
        break;
      }
    }
  }
  function display(color, { space = defaults3.display_space, ...options2 } = {}) {
    let ret = serialize(color, options2);
    if (typeof CSS === "undefined" || CSS.supports("color", ret) || !defaults3.display_space) {
      ret = new String(ret);
      ret.color = color;
    } else {
      let fallbackColor = to(color, space);
      ret = new String(serialize(fallbackColor, options2));
      ret.color = fallbackColor;
    }
    return ret;
  }
  function distance(color1, color2, space = "lab") {
    space = ColorSpace.get(space);
    let coords1 = space.from(color1);
    let coords2 = space.from(color2);
    return Math.sqrt(coords1.reduce((acc, c12, i2) => {
      let c22 = coords2[i2];
      if (isNaN(c12) || isNaN(c22)) {
        return acc;
      }
      return acc + (c22 - c12) ** 2;
    }, 0));
  }
  function equals(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    return color1.space === color2.space && color1.alpha === color2.alpha && color1.coords.every((c4, i2) => c4 === color2.coords[i2]);
  }
  function getLuminance(color) {
    return get2(color, [XYZ_D65, "y"]);
  }
  function setLuminance(color, value) {
    set2(color, [XYZ_D65, "y"], value);
  }
  function register$2(Color2) {
    Object.defineProperty(Color2.prototype, "luminance", {
      get() {
        return getLuminance(this);
      },
      set(value) {
        setLuminance(this, value);
      }
    });
  }
  var luminance = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getLuminance,
    register: register$2,
    setLuminance
  });
  function contrastWCAG21(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    let Y1 = Math.max(getLuminance(color1), 0);
    let Y2 = Math.max(getLuminance(color2), 0);
    if (Y2 > Y1) {
      [Y1, Y2] = [Y2, Y1];
    }
    return (Y1 + 0.05) / (Y2 + 0.05);
  }
  var normBG = 0.56;
  var normTXT = 0.57;
  var revTXT = 0.62;
  var revBG = 0.65;
  var blkThrs = 0.022;
  var blkClmp = 1.414;
  var loClip = 0.1;
  var deltaYmin = 5e-4;
  var scaleBoW = 1.14;
  var loBoWoffset = 0.027;
  var scaleWoB = 1.14;
  function fclamp(Y) {
    if (Y >= blkThrs) {
      return Y;
    }
    return Y + (blkThrs - Y) ** blkClmp;
  }
  function linearize(val) {
    let sign = val < 0 ? -1 : 1;
    let abs = Math.abs(val);
    return sign * Math.pow(abs, 2.4);
  }
  function contrastAPCA(background, foreground) {
    foreground = getColor(foreground);
    background = getColor(background);
    let S;
    let C2;
    let Sapc;
    let R, G, B;
    foreground = to(foreground, "srgb");
    [R, G, B] = foreground.coords;
    let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
    background = to(background, "srgb");
    [R, G, B] = background.coords;
    let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
    let Ytxt = fclamp(lumTxt);
    let Ybg = fclamp(lumBg);
    let BoW = Ybg > Ytxt;
    if (Math.abs(Ybg - Ytxt) < deltaYmin) {
      C2 = 0;
    } else {
      if (BoW) {
        S = Ybg ** normBG - Ytxt ** normTXT;
        C2 = S * scaleBoW;
      } else {
        S = Ybg ** revBG - Ytxt ** revTXT;
        C2 = S * scaleWoB;
      }
    }
    if (Math.abs(C2) < loClip) {
      Sapc = 0;
    } else if (C2 > 0) {
      Sapc = C2 - loBoWoffset;
    } else {
      Sapc = C2 + loBoWoffset;
    }
    return Sapc * 100;
  }
  function contrastMichelson(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    let Y1 = Math.max(getLuminance(color1), 0);
    let Y2 = Math.max(getLuminance(color2), 0);
    if (Y2 > Y1) {
      [Y1, Y2] = [Y2, Y1];
    }
    let denom = Y1 + Y2;
    return denom === 0 ? 0 : (Y1 - Y2) / denom;
  }
  var max2 = 5e4;
  function contrastWeber(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    let Y1 = Math.max(getLuminance(color1), 0);
    let Y2 = Math.max(getLuminance(color2), 0);
    if (Y2 > Y1) {
      [Y1, Y2] = [Y2, Y1];
    }
    return Y2 === 0 ? max2 : (Y1 - Y2) / Y2;
  }
  function contrastLstar(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    let L1 = get2(color1, [lab, "l"]);
    let L2 = get2(color2, [lab, "l"]);
    return Math.abs(L1 - L2);
  }
  var \u03B5$1 = 216 / 24389;
  var \u03B53 = 24 / 116;
  var \u03BA = 24389 / 27;
  var white = WHITES.D65;
  var lab_d65 = new ColorSpace({
    id: "lab-d65",
    name: "Lab D65",
    coords: {
      l: {
        refRange: [0, 100],
        name: "L"
      },
      a: {
        refRange: [-125, 125]
      },
      b: {
        refRange: [-125, 125]
      }
    },
    white,
    base: XYZ_D65,
    fromBase(XYZ) {
      let xyz = XYZ.map((value, i2) => value / white[i2]);
      let f = xyz.map((value) => value > \u03B5$1 ? Math.cbrt(value) : (\u03BA * value + 16) / 116);
      return [
        116 * f[1] - 16,
        500 * (f[0] - f[1]),
        200 * (f[1] - f[2])
      ];
    },
    toBase(Lab) {
      let f = [];
      f[1] = (Lab[0] + 16) / 116;
      f[0] = Lab[1] / 500 + f[1];
      f[2] = f[1] - Lab[2] / 200;
      let xyz = [
        f[0] > \u03B53 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / \u03BA,
        Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / \u03BA,
        f[2] > \u03B53 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / \u03BA
      ];
      return xyz.map((value, i2) => value * white[i2]);
    },
    formats: {
      "lab-d65": {
        coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
      }
    }
  });
  var phi = Math.pow(5, 0.5) * 0.5 + 0.5;
  function contrastDeltaPhi(color1, color2) {
    color1 = getColor(color1);
    color2 = getColor(color2);
    let Lstr1 = get2(color1, [lab_d65, "l"]);
    let Lstr2 = get2(color2, [lab_d65, "l"]);
    let deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));
    let contrast2 = Math.pow(deltaPhiStar, 1 / phi) * Math.SQRT2 - 40;
    return contrast2 < 7.5 ? 0 : contrast2;
  }
  var contrastMethods = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    contrastAPCA,
    contrastDeltaPhi,
    contrastLstar,
    contrastMichelson,
    contrastWCAG21,
    contrastWeber
  });
  function contrast(background, foreground, o = {}) {
    if (isString(o)) {
      o = { algorithm: o };
    }
    let { algorithm, ...rest } = o;
    if (!algorithm) {
      let algorithms = Object.keys(contrastMethods).map((a2) => a2.replace(/^contrast/, "")).join(", ");
      throw new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);
    }
    background = getColor(background);
    foreground = getColor(foreground);
    for (let a2 in contrastMethods) {
      if ("contrast" + algorithm.toLowerCase() === a2.toLowerCase()) {
        return contrastMethods[a2](background, foreground, rest);
      }
    }
    throw new TypeError(`Unknown contrast algorithm: ${algorithm}`);
  }
  function uv(color) {
    let [X, Y, Z] = getAll(color, XYZ_D65);
    let denom = X + 15 * Y + 3 * Z;
    return [4 * X / denom, 9 * Y / denom];
  }
  function xy(color) {
    let [X, Y, Z] = getAll(color, XYZ_D65);
    let sum = X + Y + Z;
    return [X / sum, Y / sum];
  }
  function register$1(Color2) {
    Object.defineProperty(Color2.prototype, "uv", {
      get() {
        return uv(this);
      }
    });
    Object.defineProperty(Color2.prototype, "xy", {
      get() {
        return xy(this);
      }
    });
  }
  var chromaticity = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    register: register$1,
    uv,
    xy
  });
  function deltaE76(color, sample) {
    return distance(color, sample, "lab");
  }
  var \u03C0 = Math.PI;
  var d2r = \u03C0 / 180;
  function deltaECMC(color, sample, { l = 2, c: c4 = 1 } = {}) {
    let [L1, a1, b1] = lab.from(color);
    let [, C1, H1] = lch.from(lab, [L1, a1, b1]);
    let [L2, a2, b2] = lab.from(sample);
    let C2 = lch.from(lab, [L2, a2, b2])[1];
    if (C1 < 0) {
      C1 = 0;
    }
    if (C2 < 0) {
      C2 = 0;
    }
    let \u0394L = L1 - L2;
    let \u0394C = C1 - C2;
    let \u0394a = a1 - a2;
    let \u0394b = b1 - b2;
    let H2 = \u0394a ** 2 + \u0394b ** 2 - \u0394C ** 2;
    let SL = 0.511;
    if (L1 >= 16) {
      SL = 0.040975 * L1 / (1 + 0.01765 * L1);
    }
    let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
    let T;
    if (Number.isNaN(H1)) {
      H1 = 0;
    }
    if (H1 >= 164 && H1 <= 345) {
      T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));
    } else {
      T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));
    }
    let C4 = Math.pow(C1, 4);
    let F = Math.sqrt(C4 / (C4 + 1900));
    let SH = SC * (F * T + 1 - F);
    let dE = (\u0394L / (l * SL)) ** 2;
    dE += (\u0394C / (c4 * SC)) ** 2;
    dE += H2 / SH ** 2;
    return Math.sqrt(dE);
  }
  var Yw$1 = 203;
  var XYZ_Abs_D65 = new ColorSpace({
    id: "xyz-abs-d65",
    name: "Absolute XYZ D65",
    coords: {
      x: {
        refRange: [0, 9504.7],
        name: "Xa"
      },
      y: {
        refRange: [0, 1e4],
        name: "Ya"
      },
      z: {
        refRange: [0, 10888.3],
        name: "Za"
      }
    },
    base: XYZ_D65,
    fromBase(XYZ) {
      return XYZ.map((v) => Math.max(v * Yw$1, 0));
    },
    toBase(AbsXYZ) {
      return AbsXYZ.map((v) => Math.max(v / Yw$1, 0));
    }
  });
  var b$1 = 1.15;
  var g = 0.66;
  var n$1 = 2610 / 2 ** 14;
  var ninv$1 = 2 ** 14 / 2610;
  var c1$2 = 3424 / 2 ** 12;
  var c2$2 = 2413 / 2 ** 7;
  var c3$2 = 2392 / 2 ** 7;
  var p = 1.7 * 2523 / 2 ** 5;
  var pinv = 2 ** 5 / (1.7 * 2523);
  var d = -0.56;
  var d0 = 16295499532821565e-27;
  var XYZtoCone_M = [
    [0.41478972, 0.579999, 0.014648],
    [-0.20151, 1.120649, 0.0531008],
    [-0.0166008, 0.2648, 0.6684799]
  ];
  var ConetoXYZ_M = [
    [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
    [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
    [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
  ];
  var ConetoIab_M = [
    [0.5, 0.5, 0],
    [3.524, -4.066708, 0.542708],
    [0.199076, 1.096799, -1.295875]
  ];
  var IabtoCone_M = [
    [1, 0.1386050432715393, 0.05804731615611886],
    [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
    [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
  ];
  var Jzazbz = new ColorSpace({
    id: "jzazbz",
    name: "Jzazbz",
    coords: {
      jz: {
        refRange: [0, 1],
        name: "Jz"
      },
      az: {
        refRange: [-0.5, 0.5]
      },
      bz: {
        refRange: [-0.5, 0.5]
      }
    },
    base: XYZ_Abs_D65,
    fromBase(XYZ) {
      let [Xa, Ya, Za] = XYZ;
      let Xm = b$1 * Xa - (b$1 - 1) * Za;
      let Ym = g * Ya - (g - 1) * Xa;
      let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
      let PQLMS = LMS.map(function(val) {
        let num = c1$2 + c2$2 * (val / 1e4) ** n$1;
        let denom = 1 + c3$2 * (val / 1e4) ** n$1;
        return (num / denom) ** p;
      });
      let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
      let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;
      return [Jz, az, bz];
    },
    toBase(Jzazbz2) {
      let [Jz, az, bz] = Jzazbz2;
      let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));
      let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
      let LMS = PQLMS.map(function(val) {
        let num = c1$2 - val ** pinv;
        let denom = c3$2 * val ** pinv - c2$2;
        let x = 1e4 * (num / denom) ** ninv$1;
        return x;
      });
      let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
      let Xa = (Xm + (b$1 - 1) * Za) / b$1;
      let Ya = (Ym + (g - 1) * Xa) / g;
      return [Xa, Ya, Za];
    },
    formats: {
      "color": {}
    }
  });
  var jzczhz = new ColorSpace({
    id: "jzczhz",
    name: "JzCzHz",
    coords: {
      jz: {
        refRange: [0, 1],
        name: "Jz"
      },
      cz: {
        refRange: [0, 1],
        name: "Chroma"
      },
      hz: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      }
    },
    base: Jzazbz,
    fromBase(jzazbz) {
      let [Jz, az, bz] = jzazbz;
      let hue;
      const \u03B52 = 2e-4;
      if (Math.abs(az) < \u03B52 && Math.abs(bz) < \u03B52) {
        hue = NaN;
      } else {
        hue = Math.atan2(bz, az) * 180 / Math.PI;
      }
      return [
        Jz,
        Math.sqrt(az ** 2 + bz ** 2),
        constrain(hue)
      ];
    },
    toBase(jzczhz2) {
      return [
        jzczhz2[0],
        jzczhz2[1] * Math.cos(jzczhz2[2] * Math.PI / 180),
        jzczhz2[1] * Math.sin(jzczhz2[2] * Math.PI / 180)
      ];
    },
    formats: {
      color: {}
    }
  });
  function deltaEJz(color, sample) {
    let [Jz1, Cz1, Hz1] = jzczhz.from(color);
    let [Jz2, Cz2, Hz2] = jzczhz.from(sample);
    let \u0394J = Jz1 - Jz2;
    let \u0394C = Cz1 - Cz2;
    if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
      Hz1 = 0;
      Hz2 = 0;
    } else if (Number.isNaN(Hz1)) {
      Hz1 = Hz2;
    } else if (Number.isNaN(Hz2)) {
      Hz2 = Hz1;
    }
    let \u0394h = Hz1 - Hz2;
    let \u0394H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(\u0394h / 2 * (Math.PI / 180));
    return Math.sqrt(\u0394J ** 2 + \u0394C ** 2 + \u0394H ** 2);
  }
  var c1$1 = 3424 / 4096;
  var c2$1 = 2413 / 128;
  var c3$1 = 2392 / 128;
  var m1 = 2610 / 16384;
  var m2 = 2523 / 32;
  var im1 = 16384 / 2610;
  var im2 = 32 / 2523;
  var XYZtoLMS_M$1 = [
    [0.3592, 0.6976, -0.0358],
    [-0.1922, 1.1004, 0.0755],
    [7e-3, 0.0749, 0.8434]
  ];
  var LMStoIPT_M = [
    [2048 / 4096, 2048 / 4096, 0],
    [6610 / 4096, -13613 / 4096, 7003 / 4096],
    [17933 / 4096, -17390 / 4096, -543 / 4096]
  ];
  var IPTtoLMS_M = [
    [0.9999888965628402, 0.008605050147287059, 0.11103437159861648],
    [1.00001110343716, -0.008605050147287059, -0.11103437159861648],
    [1.0000320633910054, 0.56004913547279, -0.3206339100541203]
  ];
  var LMStoXYZ_M$1 = [
    [2.0701800566956137, -1.326456876103021, 0.20661600684785517],
    [0.3649882500326575, 0.6804673628522352, -0.04542175307585323],
    [-0.04959554223893211, -0.04942116118675749, 1.1879959417328034]
  ];
  var ictcp = new ColorSpace({
    id: "ictcp",
    name: "ICTCP",
    coords: {
      i: {
        refRange: [0, 1],
        name: "I"
      },
      ct: {
        refRange: [-0.5, 0.5],
        name: "CT"
      },
      cp: {
        refRange: [-0.5, 0.5],
        name: "CP"
      }
    },
    base: XYZ_Abs_D65,
    fromBase(XYZ) {
      let LMS = multiplyMatrices(XYZtoLMS_M$1, XYZ);
      return LMStoICtCp(LMS);
    },
    toBase(ICtCp) {
      let LMS = ICtCptoLMS(ICtCp);
      return multiplyMatrices(LMStoXYZ_M$1, LMS);
    },
    formats: {
      color: {}
    }
  });
  function LMStoICtCp(LMS) {
    let PQLMS = LMS.map(function(val) {
      let num = c1$1 + c2$1 * (val / 1e4) ** m1;
      let denom = 1 + c3$1 * (val / 1e4) ** m1;
      return (num / denom) ** m2;
    });
    return multiplyMatrices(LMStoIPT_M, PQLMS);
  }
  function ICtCptoLMS(ICtCp) {
    let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
    let LMS = PQLMS.map(function(val) {
      let num = Math.max(val ** im2 - c1$1, 0);
      let denom = c2$1 - c3$1 * val ** im2;
      return 1e4 * (num / denom) ** im1;
    });
    return LMS;
  }
  function deltaEITP(color, sample) {
    let [I1, T1, P1] = ictcp.from(color);
    let [I2, T2, P2] = ictcp.from(sample);
    return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
  }
  var XYZtoLMS_M = [
    [0.8190224432164319, 0.3619062562801221, -0.12887378261216414],
    [0.0329836671980271, 0.9292868468965546, 0.03614466816999844],
    [0.048177199566046255, 0.26423952494422764, 0.6335478258136937]
  ];
  var LMStoXYZ_M = [
    [1.2268798733741557, -0.5578149965554813, 0.28139105017721583],
    [-0.04057576262431372, 1.1122868293970594, -0.07171106666151701],
    [-0.07637294974672142, -0.4214933239627914, 1.5869240244272418]
  ];
  var LMStoLab_M = [
    [0.2104542553, 0.793617785, -0.0040720468],
    [1.9779984951, -2.428592205, 0.4505937099],
    [0.0259040371, 0.7827717662, -0.808675766]
  ];
  var LabtoLMS_M = [
    [0.9999999984505198, 0.39633779217376786, 0.2158037580607588],
    [1.0000000088817609, -0.10556134232365635, -0.06385417477170591],
    [1.0000000546724108, -0.08948418209496575, -1.2914855378640917]
  ];
  var OKLab = new ColorSpace({
    id: "oklab",
    name: "Oklab",
    coords: {
      l: {
        refRange: [0, 1],
        name: "L"
      },
      a: {
        refRange: [-0.4, 0.4]
      },
      b: {
        refRange: [-0.4, 0.4]
      }
    },
    white: "D65",
    base: XYZ_D65,
    fromBase(XYZ) {
      let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
      let LMSg = LMS.map((val) => Math.cbrt(val));
      return multiplyMatrices(LMStoLab_M, LMSg);
    },
    toBase(OKLab2) {
      let LMSg = multiplyMatrices(LabtoLMS_M, OKLab2);
      let LMS = LMSg.map((val) => val ** 3);
      return multiplyMatrices(LMStoXYZ_M, LMS);
    },
    formats: {
      "oklab": {
        coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
      }
    }
  });
  function deltaEOK(color, sample) {
    let [L1, a1, b1] = OKLab.from(color);
    let [L2, a2, b2] = OKLab.from(sample);
    let \u0394L = L1 - L2;
    let \u0394a = a1 - a2;
    let \u0394b = b1 - b2;
    return Math.sqrt(\u0394L ** 2 + \u0394a ** 2 + \u0394b ** 2);
  }
  var deltaEMethods = {
    deltaE76,
    deltaECMC,
    deltaE2000,
    deltaEJz,
    deltaEITP,
    deltaEOK
  };
  function deltaE(c12, c22, o = {}) {
    if (isString(o)) {
      o = { method: o };
    }
    let { method = defaults3.deltaE, ...rest } = o;
    c12 = getColor(c12);
    c22 = getColor(c22);
    for (let m3 in deltaEMethods) {
      if ("deltae" + method.toLowerCase() === m3.toLowerCase()) {
        return deltaEMethods[m3](c12, c22, rest);
      }
    }
    throw new TypeError(`Unknown deltaE method: ${method}`);
  }
  function lighten(color, amount = 0.25) {
    let space = ColorSpace.get("oklch", "lch");
    let lightness = [space, "l"];
    return set2(color, lightness, (l) => l * (1 + amount));
  }
  function darken(color, amount = 0.25) {
    let space = ColorSpace.get("oklch", "lch");
    let lightness = [space, "l"];
    return set2(color, lightness, (l) => l * (1 - amount));
  }
  var variations = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    darken,
    lighten
  });
  function mix(c12, c22, p2 = 0.5, o = {}) {
    [c12, c22] = [getColor(c12), getColor(c22)];
    if (type(p2) === "object") {
      [p2, o] = [0.5, p2];
    }
    let { space, outputSpace, premultiplied } = o;
    let r = range(c12, c22, { space, outputSpace, premultiplied });
    return r(p2);
  }
  function steps(c12, c22, options2 = {}) {
    let colorRange;
    if (isRange(c12)) {
      [colorRange, options2] = [c12, c22];
      [c12, c22] = colorRange.rangeArgs.colors;
    }
    let {
      maxDeltaE,
      deltaEMethod,
      steps: steps2 = 2,
      maxSteps = 1e3,
      ...rangeOptions
    } = options2;
    if (!colorRange) {
      [c12, c22] = [getColor(c12), getColor(c22)];
      colorRange = range(c12, c22, rangeOptions);
    }
    let totalDelta = deltaE(c12, c22);
    let actualSteps = maxDeltaE > 0 ? Math.max(steps2, Math.ceil(totalDelta / maxDeltaE) + 1) : steps2;
    let ret = [];
    if (maxSteps !== void 0) {
      actualSteps = Math.min(actualSteps, maxSteps);
    }
    if (actualSteps === 1) {
      ret = [{ p: 0.5, color: colorRange(0.5) }];
    } else {
      let step = 1 / (actualSteps - 1);
      ret = Array.from({ length: actualSteps }, (_, i2) => {
        let p2 = i2 * step;
        return { p: p2, color: colorRange(p2) };
      });
    }
    if (maxDeltaE > 0) {
      let maxDelta = ret.reduce((acc, cur2, i2) => {
        if (i2 === 0) {
          return 0;
        }
        let \u0394\u0395 = deltaE(cur2.color, ret[i2 - 1].color, deltaEMethod);
        return Math.max(acc, \u0394\u0395);
      }, 0);
      while (maxDelta > maxDeltaE) {
        maxDelta = 0;
        for (let i2 = 1; i2 < ret.length && ret.length < maxSteps; i2++) {
          let prev = ret[i2 - 1];
          let cur2 = ret[i2];
          let p2 = (cur2.p + prev.p) / 2;
          let color = colorRange(p2);
          maxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur2.color));
          ret.splice(i2, 0, { p: p2, color: colorRange(p2) });
          i2++;
        }
      }
    }
    ret = ret.map((a2) => a2.color);
    return ret;
  }
  function range(color1, color2, options2 = {}) {
    if (isRange(color1)) {
      let [r, options3] = [color1, color2];
      return range(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...options3 });
    }
    let { space, outputSpace, progression, premultiplied } = options2;
    color1 = getColor(color1);
    color2 = getColor(color2);
    color1 = clone2(color1);
    color2 = clone2(color2);
    let rangeArgs = { colors: [color1, color2], options: options2 };
    if (space) {
      space = ColorSpace.get(space);
    } else {
      space = ColorSpace.registry[defaults3.interpolationSpace] || color1.space;
    }
    outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
    color1 = to(color1, space);
    color2 = to(color2, space);
    color1 = toGamut(color1);
    color2 = toGamut(color2);
    if (space.coords.h && space.coords.h.type === "angle") {
      let arc = options2.hue = options2.hue || "shorter";
      let hue = [space, "h"];
      let [\u03B81, \u03B82] = [get2(color1, hue), get2(color2, hue)];
      [\u03B81, \u03B82] = adjust(arc, [\u03B81, \u03B82]);
      set2(color1, hue, \u03B81);
      set2(color2, hue, \u03B82);
    }
    if (premultiplied) {
      color1.coords = color1.coords.map((c4) => c4 * color1.alpha);
      color2.coords = color2.coords.map((c4) => c4 * color2.alpha);
    }
    return Object.assign((p2) => {
      p2 = progression ? progression(p2) : p2;
      let coords = color1.coords.map((start2, i2) => {
        let end = color2.coords[i2];
        return interpolate(start2, end, p2);
      });
      let alpha = interpolate(color1.alpha, color2.alpha, p2);
      let ret = { space, coords, alpha };
      if (premultiplied) {
        ret.coords = ret.coords.map((c4) => c4 / alpha);
      }
      if (outputSpace !== space) {
        ret = to(ret, outputSpace);
      }
      return ret;
    }, {
      rangeArgs
    });
  }
  function isRange(val) {
    return type(val) === "function" && !!val.rangeArgs;
  }
  defaults3.interpolationSpace = "lab";
  function register(Color2) {
    Color2.defineFunction("mix", mix, { returns: "color" });
    Color2.defineFunction("range", range, { returns: "function<color>" });
    Color2.defineFunction("steps", steps, { returns: "array<color>" });
  }
  var interpolation = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    isRange,
    mix,
    range,
    register,
    steps
  });
  var HSL = new ColorSpace({
    id: "hsl",
    name: "HSL",
    coords: {
      h: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      },
      s: {
        range: [0, 100],
        name: "Saturation"
      },
      l: {
        range: [0, 100],
        name: "Lightness"
      }
    },
    base: sRGB,
    fromBase: (rgb) => {
      let max3 = Math.max(...rgb);
      let min = Math.min(...rgb);
      let [r, g2, b2] = rgb;
      let [h, s, l] = [NaN, 0, (min + max3) / 2];
      let d2 = max3 - min;
      if (d2 !== 0) {
        s = l === 0 || l === 1 ? 0 : (max3 - l) / Math.min(l, 1 - l);
        switch (max3) {
          case r:
            h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h = (b2 - r) / d2 + 2;
            break;
          case b2:
            h = (r - g2) / d2 + 4;
        }
        h = h * 60;
      }
      return [h, s * 100, l * 100];
    },
    toBase: (hsl) => {
      let [h, s, l] = hsl;
      h = h % 360;
      if (h < 0) {
        h += 360;
      }
      s /= 100;
      l /= 100;
      function f(n2) {
        let k = (n2 + h / 30) % 12;
        let a2 = s * Math.min(l, 1 - l);
        return l - a2 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
      }
      return [f(0), f(8), f(4)];
    },
    formats: {
      "hsl": {
        toGamut: true,
        coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
      },
      "hsla": {
        coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
        commas: true,
        lastAlpha: true
      }
    }
  });
  var HSV = new ColorSpace({
    id: "hsv",
    name: "HSV",
    coords: {
      h: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      },
      s: {
        range: [0, 100],
        name: "Saturation"
      },
      v: {
        range: [0, 100],
        name: "Value"
      }
    },
    base: HSL,
    fromBase(hsl) {
      let [h, s, l] = hsl;
      s /= 100;
      l /= 100;
      let v = l + s * Math.min(l, 1 - l);
      return [
        h,
        v === 0 ? 0 : 200 * (1 - l / v),
        100 * v
      ];
    },
    toBase(hsv) {
      let [h, s, v] = hsv;
      s /= 100;
      v /= 100;
      let l = v * (1 - s / 2);
      return [
        h,
        l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
        l * 100
      ];
    },
    formats: {
      color: {
        toGamut: true
      }
    }
  });
  var hwb = new ColorSpace({
    id: "hwb",
    name: "HWB",
    coords: {
      h: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      },
      w: {
        range: [0, 100],
        name: "Whiteness"
      },
      b: {
        range: [0, 100],
        name: "Blackness"
      }
    },
    base: HSV,
    fromBase(hsv) {
      let [h, s, v] = hsv;
      return [h, v * (100 - s) / 100, 100 - v];
    },
    toBase(hwb2) {
      let [h, w, b2] = hwb2;
      w /= 100;
      b2 /= 100;
      let sum = w + b2;
      if (sum >= 1) {
        let gray = w / sum;
        return [h, 0, gray * 100];
      }
      let v = 1 - b2;
      let s = v === 0 ? 0 : 1 - w / v;
      return [h, s * 100, v * 100];
    },
    formats: {
      "hwb": {
        toGamut: true,
        coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
      }
    }
  });
  var toXYZ_M$2 = [
    [0.5766690429101305, 0.1855582379065463, 0.1882286462349947],
    [0.29734497525053605, 0.6273635662554661, 0.07529145849399788],
    [0.02703136138641234, 0.07068885253582723, 0.9913375368376388]
  ];
  var fromXYZ_M$2 = [
    [2.0415879038107465, -0.5650069742788596, -0.34473135077832956],
    [-0.9692436362808795, 1.8759675015077202, 0.04155505740717557],
    [0.013444280632031142, -0.11836239223101838, 1.0151749943912054]
  ];
  var A98Linear = new RGBColorSpace({
    id: "a98rgb-linear",
    name: "Linear Adobe\xAE 98 RGB compatible",
    white: "D65",
    toXYZ_M: toXYZ_M$2,
    fromXYZ_M: fromXYZ_M$2
  });
  var a98rgb = new RGBColorSpace({
    id: "a98rgb",
    name: "Adobe\xAE 98 RGB compatible",
    base: A98Linear,
    toBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),
    fromBase: (RGB) => RGB.map((val) => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),
    formats: {
      color: {
        id: "a98-rgb"
      }
    }
  });
  var toXYZ_M$1 = [
    [0.7977604896723027, 0.13518583717574031, 0.0313493495815248],
    [0.2880711282292934, 0.7118432178101014, 8565396060525902e-20],
    [0, 0, 0.8251046025104601]
  ];
  var fromXYZ_M$1 = [
    [1.3457989731028281, -0.25558010007997534, -0.05110628506753401],
    [-0.5446224939028347, 1.5082327413132781, 0.02053603239147973],
    [0, 0, 1.2119675456389454]
  ];
  var ProPhotoLinear = new RGBColorSpace({
    id: "prophoto-linear",
    name: "Linear ProPhoto",
    white: "D50",
    base: XYZ_D50,
    toXYZ_M: toXYZ_M$1,
    fromXYZ_M: fromXYZ_M$1
  });
  var Et = 1 / 512;
  var Et2 = 16 / 512;
  var prophoto = new RGBColorSpace({
    id: "prophoto",
    name: "ProPhoto",
    base: ProPhotoLinear,
    toBase(RGB) {
      return RGB.map((v) => v < Et2 ? v / 16 : v ** 1.8);
    },
    fromBase(RGB) {
      return RGB.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
    },
    formats: {
      color: {
        id: "prophoto-rgb"
      }
    }
  });
  var oklch = new ColorSpace({
    id: "oklch",
    name: "Oklch",
    coords: {
      l: {
        refRange: [0, 1],
        name: "Lightness"
      },
      c: {
        refRange: [0, 0.4],
        name: "Chroma"
      },
      h: {
        refRange: [0, 360],
        type: "angle",
        name: "Hue"
      }
    },
    white: "D65",
    base: OKLab,
    fromBase(oklab) {
      let [L, a2, b2] = oklab;
      let h;
      const \u03B52 = 2e-4;
      if (Math.abs(a2) < \u03B52 && Math.abs(b2) < \u03B52) {
        h = NaN;
      } else {
        h = Math.atan2(b2, a2) * 180 / Math.PI;
      }
      return [
        L,
        Math.sqrt(a2 ** 2 + b2 ** 2),
        constrain(h)
      ];
    },
    toBase(oklch2) {
      let [L, C2, h] = oklch2;
      let a2, b2;
      if (isNaN(h)) {
        a2 = 0;
        b2 = 0;
      } else {
        a2 = C2 * Math.cos(h * Math.PI / 180);
        b2 = C2 * Math.sin(h * Math.PI / 180);
      }
      return [L, a2, b2];
    },
    formats: {
      "oklch": {
        coords: ["<number> | <percentage>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
      }
    }
  });
  var Yw = 203;
  var n = 2610 / 2 ** 14;
  var ninv = 2 ** 14 / 2610;
  var m = 2523 / 2 ** 5;
  var minv = 2 ** 5 / 2523;
  var c1 = 3424 / 2 ** 12;
  var c2 = 2413 / 2 ** 7;
  var c3 = 2392 / 2 ** 7;
  var rec2100Pq = new RGBColorSpace({
    id: "rec2100pq",
    name: "REC.2100-PQ",
    base: REC2020Linear,
    toBase(RGB) {
      return RGB.map(function(val) {
        let x = (Math.max(val ** minv - c1, 0) / (c2 - c3 * val ** minv)) ** ninv;
        return x * 1e4 / Yw;
      });
    },
    fromBase(RGB) {
      return RGB.map(function(val) {
        let x = Math.max(val * Yw / 1e4, 0);
        let num = c1 + c2 * x ** n;
        let denom = 1 + c3 * x ** n;
        return (num / denom) ** m;
      });
    },
    formats: {
      color: {
        id: "rec2100-pq"
      }
    }
  });
  var a = 0.17883277;
  var b = 0.28466892;
  var c = 0.55991073;
  var scale = 3.7743;
  var rec2100Hlg = new RGBColorSpace({
    id: "rec2100hlg",
    cssid: "rec2100-hlg",
    name: "REC.2100-HLG",
    referred: "scene",
    base: REC2020Linear,
    toBase(RGB) {
      return RGB.map(function(val) {
        if (val <= 0.5) {
          return val ** 2 / 3 * scale;
        }
        return (Math.exp((val - c) / a) + b) / 12 * scale;
      });
    },
    fromBase(RGB) {
      return RGB.map(function(val) {
        val /= scale;
        if (val <= 1 / 12) {
          return Math.sqrt(3 * val);
        }
        return a * Math.log(12 * val - b) + c;
      });
    },
    formats: {
      color: {
        id: "rec2100-hlg"
      }
    }
  });
  var CATs = {};
  hooks.add("chromatic-adaptation-start", (env) => {
    if (env.options.method) {
      env.M = adapt(env.W1, env.W2, env.options.method);
    }
  });
  hooks.add("chromatic-adaptation-end", (env) => {
    if (!env.M) {
      env.M = adapt(env.W1, env.W2, env.options.method);
    }
  });
  function defineCAT({ id: id2, toCone_M, fromCone_M }) {
    CATs[id2] = arguments[0];
  }
  function adapt(W1, W2, id2 = "Bradford") {
    let method = CATs[id2];
    let [\u03C1s, \u03B3s, \u03B2s] = multiplyMatrices(method.toCone_M, W1);
    let [\u03C1d, \u03B3d, \u03B2d] = multiplyMatrices(method.toCone_M, W2);
    let scale2 = [
      [\u03C1d / \u03C1s, 0, 0],
      [0, \u03B3d / \u03B3s, 0],
      [0, 0, \u03B2d / \u03B2s]
    ];
    let scaled_cone_M = multiplyMatrices(scale2, method.toCone_M);
    let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);
    return adapt_M;
  }
  defineCAT({
    id: "von Kries",
    toCone_M: [
      [0.40024, 0.7076, -0.08081],
      [-0.2263, 1.16532, 0.0457],
      [0, 0, 0.91822]
    ],
    fromCone_M: [
      [1.8599364, -1.1293816, 0.2198974],
      [0.3611914, 0.6388125, -64e-7],
      [0, 0, 1.0890636]
    ]
  });
  defineCAT({
    id: "Bradford",
    toCone_M: [
      [0.8951, 0.2664, -0.1614],
      [-0.7502, 1.7135, 0.0367],
      [0.0389, -0.0685, 1.0296]
    ],
    fromCone_M: [
      [0.9869929, -0.1470543, 0.1599627],
      [0.4323053, 0.5183603, 0.0492912],
      [-85287e-7, 0.0400428, 0.9684867]
    ]
  });
  defineCAT({
    id: "CAT02",
    toCone_M: [
      [0.7328, 0.4296, -0.1624],
      [-0.7036, 1.6975, 61e-4],
      [3e-3, 0.0136, 0.9834]
    ],
    fromCone_M: [
      [1.0961238, -0.278869, 0.1827452],
      [0.454369, 0.4735332, 0.0720978],
      [-96276e-7, -5698e-6, 1.0153256]
    ]
  });
  defineCAT({
    id: "CAT16",
    toCone_M: [
      [0.401288, 0.650173, -0.051461],
      [-0.250268, 1.204414, 0.045854],
      [-2079e-6, 0.048952, 0.953127]
    ],
    fromCone_M: [
      [1.862067855087233, -1.011254630531685, 0.1491867754444518],
      [0.3875265432361372, 0.6214474419314753, -0.008973985167612518],
      [-0.01584149884933386, -0.03412293802851557, 1.04996443687785]
    ]
  });
  Object.assign(WHITES, {
    A: [1.0985, 1, 0.35585],
    C: [0.98074, 1, 1.18232],
    D55: [0.95682, 1, 0.92149],
    D75: [0.94972, 1, 1.22638],
    E: [1, 1, 1],
    F2: [0.99186, 1, 0.67393],
    F7: [0.95041, 1, 1.08747],
    F11: [1.00962, 1, 0.6435]
  });
  WHITES.ACES = [0.32168 / 0.33767, 1, (1 - 0.32168 - 0.33767) / 0.33767];
  var toXYZ_M = [
    [0.6624541811085053, 0.13400420645643313, 0.1561876870049078],
    [0.27222871678091454, 0.6740817658111484, 0.05368951740793705],
    [-0.005574649490394108, 0.004060733528982826, 1.0103391003129971]
  ];
  var fromXYZ_M = [
    [1.6410233796943257, -0.32480329418479, -0.23642469523761225],
    [-0.6636628587229829, 1.6153315916573379, 0.016756347685530137],
    [0.011721894328375376, -0.008284441996237409, 0.9883948585390215]
  ];
  var ACEScg = new RGBColorSpace({
    id: "acescg",
    name: "ACEScg",
    coords: {
      r: {
        range: [0, 65504],
        name: "Red"
      },
      g: {
        range: [0, 65504],
        name: "Green"
      },
      b: {
        range: [0, 65504],
        name: "Blue"
      }
    },
    referred: "scene",
    white: WHITES.ACES,
    toXYZ_M,
    fromXYZ_M,
    formats: {
      color: {}
    }
  });
  var \u03B5 = 2 ** -16;
  var ACES_min_nonzero = -0.35828683;
  var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
  var acescc = new RGBColorSpace({
    id: "acescc",
    name: "ACEScc",
    coords: {
      r: {
        range: [ACES_min_nonzero, ACES_cc_max],
        name: "Red"
      },
      g: {
        range: [ACES_min_nonzero, ACES_cc_max],
        name: "Green"
      },
      b: {
        range: [ACES_min_nonzero, ACES_cc_max],
        name: "Blue"
      }
    },
    referred: "scene",
    base: ACEScg,
    toBase(RGB) {
      const low = (9.72 - 15) / 17.52;
      return RGB.map(function(val) {
        if (val <= low) {
          return (2 ** (val * 17.52 - 9.72) - \u03B5) * 2;
        } else if (val < ACES_cc_max) {
          return 2 ** (val * 17.52 - 9.72);
        } else {
          return 65504;
        }
      });
    },
    fromBase(RGB) {
      return RGB.map(function(val) {
        if (val <= 0) {
          return (Math.log2(\u03B5) + 9.72) / 17.52;
        } else if (val < \u03B5) {
          return (Math.log2(\u03B5 + val * 0.5) + 9.72) / 17.52;
        } else {
          return (Math.log2(val) + 9.72) / 17.52;
        }
      });
    },
    formats: {
      color: {}
    }
  });
  var spaces = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    A98RGB: a98rgb,
    A98RGB_Linear: A98Linear,
    ACEScc: acescc,
    ACEScg,
    HSL,
    HSV,
    HWB: hwb,
    ICTCP: ictcp,
    JzCzHz: jzczhz,
    Jzazbz,
    LCH: lch,
    Lab: lab,
    Lab_D65: lab_d65,
    OKLCH: oklch,
    OKLab,
    P3,
    P3_Linear: P3Linear,
    ProPhoto: prophoto,
    ProPhoto_Linear: ProPhotoLinear,
    REC_2020: REC2020,
    REC_2020_Linear: REC2020Linear,
    REC_2100_HLG: rec2100Hlg,
    REC_2100_PQ: rec2100Pq,
    XYZ_ABS_D65: XYZ_Abs_D65,
    XYZ_D50,
    XYZ_D65,
    sRGB,
    sRGB_Linear: sRGBLinear
  });
  var Color = class {
    constructor(...args) {
      let color;
      if (args.length === 1) {
        color = getColor(args[0]);
      }
      let space, coords, alpha;
      if (color) {
        space = color.space || color.spaceId;
        coords = color.coords;
        alpha = color.alpha;
      } else {
        [space, coords, alpha] = args;
      }
      Object.defineProperty(this, "space", {
        value: ColorSpace.get(space),
        writable: false,
        enumerable: true,
        configurable: true
      });
      this.coords = coords ? coords.slice() : [0, 0, 0];
      this.alpha = alpha < 1 ? alpha : 1;
      for (let i2 = 0; i2 < this.coords.length; i2++) {
        if (this.coords[i2] === "NaN") {
          this.coords[i2] = NaN;
        }
      }
      for (let id2 in this.space.coords) {
        Object.defineProperty(this, id2, {
          get: () => this.get(id2),
          set: (value) => this.set(id2, value)
        });
      }
    }
    get spaceId() {
      return this.space.id;
    }
    clone() {
      return new Color(this.space, this.coords, this.alpha);
    }
    toJSON() {
      return {
        spaceId: this.spaceId,
        coords: this.coords,
        alpha: this.alpha
      };
    }
    display(...args) {
      let ret = display(this, ...args);
      ret.color = new Color(ret.color);
      return ret;
    }
    static get(color, ...args) {
      if (color instanceof Color) {
        return color;
      }
      return new Color(color, ...args);
    }
    static defineFunction(name3, code2, o = code2) {
      let { instance = true, returns } = o;
      let func = function(...args) {
        let ret = code2(...args);
        if (returns === "color") {
          ret = Color.get(ret);
        } else if (returns === "function<color>") {
          let f = ret;
          ret = function(...args2) {
            let ret2 = f(...args2);
            return Color.get(ret2);
          };
          Object.assign(ret, f);
        } else if (returns === "array<color>") {
          ret = ret.map((c4) => Color.get(c4));
        }
        return ret;
      };
      if (!(name3 in Color)) {
        Color[name3] = func;
      }
      if (instance) {
        Color.prototype[name3] = function(...args) {
          return func(this, ...args);
        };
      }
    }
    static defineFunctions(o) {
      for (let name3 in o) {
        Color.defineFunction(name3, o[name3], o[name3]);
      }
    }
    static extend(exports2) {
      if (exports2.register) {
        exports2.register(Color);
      } else {
        for (let name3 in exports2) {
          Color.defineFunction(name3, exports2[name3]);
        }
      }
    }
  };
  Color.defineFunctions({
    get: get2,
    getAll,
    set: set2,
    setAll,
    to,
    equals,
    inGamut,
    toGamut,
    distance,
    toString: serialize
  });
  Object.assign(Color, {
    util,
    hooks,
    WHITES,
    Space: ColorSpace,
    spaces: ColorSpace.registry,
    parse: parse4,
    defaults: defaults3
  });
  for (let key2 of Object.keys(spaces)) {
    ColorSpace.register(spaces[key2]);
  }
  for (let id2 in ColorSpace.registry) {
    addSpaceAccessors(id2, ColorSpace.registry[id2]);
  }
  hooks.add("colorspace-init-end", (space) => {
    addSpaceAccessors(space.id, space);
    space.aliases?.forEach((alias) => {
      addSpaceAccessors(alias, space);
    });
  });
  function addSpaceAccessors(id2, space) {
    Object.keys(space.coords);
    Object.values(space.coords).map((c4) => c4.name);
    let propId = id2.replace(/-/g, "_");
    Object.defineProperty(Color.prototype, propId, {
      get() {
        let ret = this.getAll(id2);
        if (typeof Proxy === "undefined") {
          return ret;
        }
        return new Proxy(ret, {
          has: (obj, property) => {
            try {
              ColorSpace.resolveCoord([space, property]);
              return true;
            } catch (e2) {
            }
            return Reflect.has(obj, property);
          },
          get: (obj, property, receiver) => {
            if (property && typeof property !== "symbol" && !(property in obj)) {
              let { index } = ColorSpace.resolveCoord([space, property]);
              if (index >= 0) {
                return obj[index];
              }
            }
            return Reflect.get(obj, property, receiver);
          },
          set: (obj, property, value, receiver) => {
            if (property && typeof property !== "symbol" && !(property in obj) || property >= 0) {
              let { index } = ColorSpace.resolveCoord([space, property]);
              if (index >= 0) {
                obj[index] = value;
                this.setAll(id2, obj);
                return true;
              }
            }
            return Reflect.set(obj, property, value, receiver);
          }
        });
      },
      set(coords) {
        this.setAll(id2, coords);
      },
      configurable: true,
      enumerable: true
    });
  }
  Color.extend(deltaEMethods);
  Color.extend({ deltaE });
  Object.assign(Color, { deltaEMethods });
  Color.extend(variations);
  Color.extend({ contrast });
  Color.extend(chromaticity);
  Color.extend(luminance);
  Color.extend(interpolation);
  Color.extend(contrastMethods);

  // public/packages/gamepad.js
  var controllers = {};
  function gamepads() {
    const ids = Object.keys(controllers) || [];
    return ids.map((x) => controllers[x]).map(gatherInputs);
  }
  var initialState = {};
  var $4 = module2("gamepad-debug", initialState);
  $4.draw((target) => renderGamepads(target, $4));
  function connecthandler(e2) {
    const { index } = e2.gamepad;
    controllers[index] = e2.gamepad;
  }
  function disconnecthandler(e2) {
    const { index } = e2.gamepad;
    delete controllers[index];
  }
  function renderValue(value, index) {
    const offset = parseFloat(value) - 2 + "rem";
    return `
    <li
      class="input"
      style="--value: ${offset};"
    >${index}</li>
  `;
  }
  function renderInputs(_$, flags) {
    const { gamepad } = flags;
    return `
    <ul class="buttons">
      ${gamepad.buttons.map(renderValue).join("")}
    </ul>
    <ul class="axes">
      ${gamepad.axes.map(renderValue).join("")}
    </ul>
  `;
  }
  function renderGamepads(_target, $11) {
    const list = gamepads().map((gamepad, index) => `
      <li class="gamepad" id="${gamepad.id}">
        <label>${index + 1}: ${gamepad.id}</label>
        ${renderInputs($11, { gamepad })}
      </li>
    `).join("");
    return `<ul class="gamepads">${list}</ul>`;
  }
  function gatherInputs(gamepad, _index) {
    const buttons = [...gamepad.buttons].map((button, _i) => {
      let value = button;
      if (typeof value == "object") {
        value = value.value;
      }
      return value;
    });
    const axes = [...gamepad.axes].map((axis, _i) => {
      const value = axis;
      return value;
    });
    return { buttons, axes, id: gamepad.id, index: gamepad.index };
  }
  globalThis.addEventListener("gamepadconnected", connecthandler);
  globalThis.addEventListener("gamepaddisconnected", disconnecthandler);
  $4.flair(`
  & .gamepads {
    background: rgba(0,0,0,.04);
    border: 1px solid rgba(0,0,0,.1);
    border-radius: 1rem;
    list-style-type: none;
    padding: 0 1rem;
  }
  & .gamepad {
    border-bottom: 1px solid rgba(0,0,0,.1);
    padding: 1rem 0;
  }
  & .gamepad:last-child {
    border-bottom: none;

  }
  & .buttons,
  & .axes {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(2rem, 1fr));
    list-style-type: none;
    padding: .5rem 0 0;
  }
  & .input {
    background: linear-gradient(lime 0%, orange 50%, rebeccapurple 100%);
    background-size: 1px 6rem;
    background-repeat: repeat-x;
    background-position-y: var(--value);
    border-radius: 2rem;
    width: 2rem;
    height: 2rem;
    display: grid;
    place-content: center;
  }
`);

  // public/packages/guitar.js
  var initialState2 = {
    activeFrets: [],
    activeRegisters: [],
    activeMotions: [],
    frames: {}
  };
  var $5 = module2("guitar-debug", initialState2);
  var fretMap = [0, 1, 3, 2, 4];
  var registers = [
    "     ",
    "x    ",
    "x   x",
    " x   ",
    " x  x",
    "  x  ",
    "  x x",
    "   x ",
    "   xx",
    "xx   ",
    "xx  x",
    " xx  ",
    " xx x",
    "x x x",
    "xxxxx"
  ];
  requestAnimationFrame(loop);
  function loop(time) {
    const activeFrets = gamepads().map((x) => toFrets($5, x));
    const activeRegisters = activeFrets.map((x) => toRegisters($5, x));
    const activeMotions = gamepads().map((x) => toMotion($5, x));
    $5.teach({
      time,
      activeFrets,
      activeRegisters,
      activeMotions
    });
    requestAnimationFrame(loop);
  }
  $5.draw(() => {
    const {
      activeRegisters,
      activeMotions
    } = $5.learn();
    const classes = (i2) => {
      return ["up", "down", "left", "right"].map((x) => activeMotions[i2][x] ? x : "").join(" ");
    };
    return activeRegisters.map((x, i2) => `
    <div class="${classes(i2)}">
      ${x}
    </div>
  `).join("");
  });
  function toFrets(_$, flags) {
    const pressed = (value) => value === 1 ? "x" : " ";
    const frets = flags.buttons.map(pressed).slice(0, 5);
    return fretMap.map((i2) => frets[i2]).join("");
  }
  function toRegisters(_$, frets) {
    return registers.indexOf(frets);
  }
  function toMotion(_$, flags) {
    const [vertical] = [...flags.axes].splice(-1);
    const [horizontal] = [...flags.axes].splice(-2);
    return {
      up: vertical === -1,
      down: vertical === 1,
      left: horizontal === -1,
      right: horizontal === 1
    };
  }
  $5.flair(`
  & {
    display: grid;
    grid-template-columns: 1fr 1fr;
    height: 100vh;
    width: 100vw;
    place-items: center;
  }
  & .note {
    font-size: 10vh;
    line-height: 1;
  }

  & .strummed {
    transform: scale(2);
  }
`);
  var guitar_default = $5;

  // public/packages/synth-module.js
  var context = new AudioContext();
  async function loadSample(url) {
    const sample = await fetch(url).then((response) => response.arrayBuffer()).then((buffer) => context.decodeAudioData(buffer));
    return sample;
  }
  function playSample(sample, sampleNote, noteToPlay) {
    const source = context.createBufferSource();
    source.buffer = sample;
    source.playbackRate.value = 2 ** ((noteToPlay - sampleNote) / 12);
    source.connect(context.destination);
    source.start(0);
  }
  var synths = [];
  Promise.all([
    loadSample("/samples/1.mp3"),
    loadSample("/samples/2.mp3"),
    loadSample("/samples/3.mp3"),
    loadSample("/samples/4.mp3"),
    loadSample("/samples/5.mp3"),
    loadSample("/samples/6.mp3"),
    loadSample("/samples/7.mp3"),
    loadSample("/samples/8.mp3")
  ]).then((s) => synths = s);
  var $6 = module2("synth-module", {
    colors: [],
    start: 120,
    length: 360,
    octave: 4,
    reverse: false,
    pitch: 0,
    synth: 0
  });
  var strumVelocity = 75;
  var sustainedDuration = 100;
  var actionableFPS = 4;
  var majorScale = [
    "C",
    "G",
    "D",
    "A",
    "E",
    "B",
    "F#",
    "Db",
    "Ab",
    "Eb",
    "Bb",
    "F"
  ];
  var minorScale = [
    "a",
    "e",
    "b",
    "f#",
    "c#",
    "g#",
    "d#",
    "bb",
    "f",
    "c",
    "g",
    "d"
  ];
  var lightnessStops = [
    [5, 30],
    [20, 45],
    [35, 60],
    [50, 75],
    [65, 90],
    [80, 105],
    [95, 120]
  ];
  var octaveUp = () => {
    const octave = $6.learn().octave + 1;
    if (octave > 6) {
      return;
    }
    $6.teach({ octave });
  };
  var octaveDown = () => {
    const octave = $6.learn().octave - 1;
    if (octave < 0) {
      return;
    }
    $6.teach({ octave });
  };
  var pitchUp = () => {
    const pitch = $6.learn().pitch + 1;
    $6.teach({ pitch });
  };
  var pitchDown = () => {
    const pitch = $6.learn().pitch - 1;
    $6.teach({ pitch });
  };
  function attack(event) {
    event.preventDefault();
    const { colors, synth } = $6.learn();
    const { octave, note, hue } = event.target.dataset;
    playSample(synths[synth], 60, parseInt(octave) * 12 + (12 + parseInt(note)));
    event.target.classList.add("active");
    const body = new Color(colors[parseInt(hue)][parseInt(octave)].value).to("srgb");
    document.querySelector("body").style.setProperty("background", body);
  }
  function release2(event) {
    event.preventDefault();
    event.target.classList.remove("active");
  }
  var chords = [
    [],
    [0, 4, 1],
    [0, 9, 1],
    [1, 5, 2],
    [1, 10, 2],
    [2, 6, 3],
    [2, 11, 3],
    [4, 8, 5],
    [4, 2, 5],
    [3, 9, 4],
    [3, 0, 4],
    [11, 3, 0],
    [11, 8, 0],
    [],
    []
  ];
  var activeSynths = [];
  requestAnimationFrame(loop2);
  function loop2(time) {
    const { activeRegisters, activeFrets, activeMotions } = guitar_default.learn();
    activeRegisters.map((register2, i2) => {
      const { up, down } = activeMotions[i2];
      if (activeFrets[i2] === "x x x") {
        [[up, octaveUp], [down, octaveDown]].map(([flag, feature2]) => {
          flag && throttle({ key: "octave-shift", time, feature: feature2 });
        });
      }
      if (activeFrets[i2] === "xxxxx") {
        [[up, pitchUp], [down, pitchDown]].map(([flag, feature2]) => {
          flag && throttle({ key: "pitch-shift", time, feature: feature2 });
        });
      }
      if (!chords[register2])
        return;
      const feature = () => {
        if (up || down && register2 > 0) {
          activeSynths = chords[register2];
          activeSynths.map((x, i3) => {
            const index = down ? x : activeSynths[activeSynths.length - 1 - i3];
            const node = document.querySelector(`[data-index='${index}']`);
            node && queueAttack(node, i3);
          });
        }
      };
      feature();
    });
    requestAnimationFrame(loop2);
  }
  function throttle({ key: key2, time, feature }) {
    const { frames = {} } = $6.learn();
    const frame = frames[key2] || {};
    if (time - 1e3 / actionableFPS > (frame.time || 0)) {
      feature();
      $6.teach({ time }, (state3, payload) => {
        return {
          ...state3,
          frames: {
            ...frames,
            [key2]: {
              time: payload.time
            }
          }
        };
      });
    }
  }
  function queueRelease(node) {
    setTimeout(() => {
      node.dispatchEvent(new Event("touchend"));
    }, sustainedDuration);
  }
  function queueAttack(node, i2) {
    setTimeout(() => {
      node.dispatchEvent(new Event("touchstart"));
      queueRelease(node);
    }, i2 * strumVelocity);
  }
  $6.teach({ colors: recalculate() });
  $6.draw(() => {
    const { start: start2, length, reverse, colors, octave, pitch, debug } = $6.learn();
    const wheel = majorScale.map((majorNote, index) => {
      const majorScaleIndex = mod(index - pitch * 7, majorScale.length);
      const minorNote = minorScale[mod(majorScaleIndex + pitch * 7, minorScale.length)];
      const minorScaleIndex = mod(majorScaleIndex + 3, minorScale.length);
      const majorColorIndex = mod(
        mod(majorScaleIndex * 7, colors.length) + pitch,
        colors.length
      );
      const minorColorIndex = mod(
        mod(minorScaleIndex * 7, colors.length) + pitch,
        colors.length
      );
      const majorColorScales = colors[majorColorIndex].map((x) => x.value);
      const minorColorScales = colors[minorColorIndex].map((x) => x.value);
      const majorStepClass = majorNote.length === 2 ? "step half" : "step";
      const minorStepClass = minorNote.length === 2 ? "step half" : "step";
      const majorSynth = majorScaleIndex;
      const minorSynth = minorScaleIndex + majorScale.length;
      const note = mod(index * 7, majorScale.length);
      return `
      <div class="group" style="
				transform: rotate(${majorScaleIndex * 30}deg)
				
			">
        <button
          class="${majorStepClass}"
					data-index="${majorSynth}"
          data-octave="${octave}"
          data-note="${note}"
					data-hue="${majorColorIndex}"
          style="${gradient(majorColorScales, [4, 3, 2])}"
        >
        </button>
        <button
          class="${minorStepClass}"
					data-index="${minorSynth}"
          data-octave="${octave}"
          data-note="${minorScaleIndex}"
					data-hue="${minorColorIndex}"
          style="${gradient(minorColorScales, [4, 3, 2])}"
        >
        </button>
      </div>
    `;
    }).join("");
    return `
    <div class="wheel">
      ${wheel}
			${controls()}
    </div>
  `;
  });
  function controls() {
    return `
		<div class="controls" style="display: none;">
			<button class="octave-up"></button>
			<button class="pitch-up"></button>
			<button class="pitch-down"></button>
			<button class="octave-down"></button>
		</div>
	`;
  }
  $6.when("click", ".octave-up", octaveUp);
  $6.when("click", ".octave-down", octaveDown);
  $6.when("click", ".pitch-up", pitchUp);
  $6.when("click", ".pitch-down", pitchDown);
  $6.flair(`
  & {
    height: 100%;
    display: grid;
    place-content: center;
  }
  & .wheel {
    display: grid;
    grid-template-areas: "slot";
    grid-template-rows: 45vmin;
    grid-template-columns: 40vmin;
    place-content: start center;
    padding: 0 1rem;
    height: 90vmin;
		user-select: none; /* supported by Chrome and Opera */
		-webkit-user-select: none; /* Safari */
		-khtml-user-select: none; /* Konqueror HTML */
		-moz-user-select: none; /* Firefox */
		-ms-user-select: none; /* Internet Explorer/Edge */
    touch-action: manipulation;
  }
  & .group {
    grid-area: slot;
    transform-origin: bottom;
    display: grid;
    grid-template-columns: 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    clip-path: polygon(20% 0%, 50% 100%, 80% 0%);
    gap: 1px;
  }
  & .step {
    border: none;
    width: 100%;
    height: auto;
    display: grid;
    place-items: start;
    color: black;
		position: relative;
  }

  & .step.half {
    color: white;
  }

	& .step::before {
		content: '';
		position: absolute;
		inset: 0;
		background: linear-gradient(
			rgba(0, 0, 0, .25),
			transparent,
			rgba(255, 255, 255, .75),
			transparent,
			transparent,
			transparent
		);
		background-size: 300% 300%;
		background-position-y: 100%;
		animation: &-decay 100ms ease-out forwards;
	}

	& .step.active::before {
		animation: &-attack 100ms ease-out forwards;
	}

	@keyframes &-attack {
		0% {
			background-position-y: 50%;
		}
		100% {
			background-position-y: 0%;
		}
	}

	@keyframes &-decay {
		0% {
			background-position-y: 50%;
		}
		100% {
			background-position-y: 100%;
		}
	}

  ${invertedLabels()}
`);
  function invertedLabels() {
    const rulesets = [];
    for (let i2 = 1; i2 < 360; i2++) {
      rulesets.push(`
      & [style*="rotate(${i2}deg)"] label {
        transform: rotate(${-1 * i2}deg);
      }
    `);
    }
    return rulesets.join("");
  }
  function upload(colors) {
    const palette = colors.flatMap((x) => x).map(({ name: name3, value }) => `
    ${name3}: ${value};
  `).join("");
    fetch("/design-system", {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ palette })
    });
  }
  function gradient(scale2, stops) {
    return `
    background: linear-gradient(${stops.map((x) => scale2[x]).join(", ")})
  `;
  }
  function recalculate() {
    const { start: start2, length, reverse } = $6.learn();
    const colors = [...Array(12)].map((_, hueIndex) => {
      const step = length / 12 * hueIndex;
      const hue = reverse ? start2 - step : start2 + step;
      return lightnessStops.map(([l, c4], i2) => {
        const name3 = `--wheel-${hueIndex}-${i2}`;
        const value = new Color("lch", [l, c4, hue]).display().toString({ format: "hex" });
        return {
          name: name3,
          value,
          block: hueIndex,
          inline: i2
        };
      });
    });
    upload(colors);
    return colors;
  }
  $6.when("mousedown", ".step", attack);
  $6.when("mouseup", ".step", release2);
  $6.when("touchstart", ".step", attack);
  $6.when("touchend", ".step", release2);
  function mod(x, n2) {
    return (x % n2 + n2) % n2;
  }

  // public/packages/design-system.js
  var $7 = module2("design-system");
  $7.draw(() => {
    const { palette } = $7.learn();
    if (!palette) {
      fetch("/design-system").then((res) => res.json()).then(({ palette: palette2 }) => $7.teach({ palette: palette2 }));
      return;
    }
    return `
    <style>
      :root {
        "${palette}"
      }
    </style>
  `;
  });

  // public/packages/smug-mug.js
  var $8 = module2("smug-mug");
  $8.draw(() => {
    return `
    smug mug
  `;
  });
  $8.flair(`
  & { display: block }
`);

  // public/packages/google-maps.js
  var $9 = module2("google-maps");
  $9.draw(() => {
    return `
    google map
  `;
  });
  $9.flair(`
  & { display: block }
`);

  // public/packages/script-type.js
  var BIOS_MODE = Symbol("bios");
  var NORMAL_MODE = Symbol("normal");
  var KEY_VALUE_MODE = Symbol("key-value");
  var DYNAMIC_MODE = Symbol("dynamic");
  var compile = (script) => {
    const ScriptType = {
      "#": append.bind({}, "scripttype-address"),
      "@": append.bind({}, "scripttype-character"),
      '"': append.bind({}, "scripttype-quote"),
      "(": append.bind({}, "scripttype-parenthetical"),
      "!": append.bind({}, "scripttype-information"),
      "^": append.bind({}, "scripttype-effect"),
      "<": plugin,
      "{": scope
    };
    function scope(type2) {
      setScope(type2);
      resetAttributes(type2);
      setMode(KEY_VALUE_MODE);
    }
    function plugin(x) {
      setPlugin(x);
      resetAttributes(x);
      setMode(DYNAMIC_MODE);
    }
    const symbols2 = Object.keys(ScriptType);
    const modes2 = {
      [BIOS_MODE]: biosMode,
      [NORMAL_MODE]: normalMode,
      [KEY_VALUE_MODE]: kvMode,
      [DYNAMIC_MODE]: dynamicMode
    };
    const isolate = {
      scope: "global",
      plugin: "",
      mode: BIOS_MODE,
      result: ``
    };
    const lines = script.split("\n");
    for (const line of lines) {
      (modes2[isolate.mode] || noop)(line);
    }
    return isolate.result;
    function biosMode(line) {
      console.log("todo: implement");
      console.log(line);
      return setMode(NORMAL_MODE);
    }
    function normalMode(line) {
      if (!line)
        return blank();
      const symbol = line[0];
      if (symbols2.includes(symbol)) {
        const [_, text] = line.split(symbol);
        return ScriptType[symbol](text.trim());
      }
      return freetext(line);
    }
    function kvMode(line) {
      const [key2, value] = line.split(":");
      if (!value) {
        if (isolate.scope === "typewriter") {
          title();
        }
        return setMode(NORMAL_MODE);
      }
      state[isolate.scope][key2.trim()] = value.trim();
    }
    function dynamicMode(line) {
      const [key2, value] = line.split(":");
      if (!value) {
        embed();
        return setMode(NORMAL_MODE);
      }
      state[isolate.plugin][key2.trim()] = value.trim();
    }
    function setMode(m3) {
      isolate.mode = m3;
    }
    function setScope(s) {
      isolate.scope = s;
    }
    function setPlugin(d2) {
      isolate.plugin = d2;
    }
    function resetAttributes(x) {
      state[x] = {};
    }
    function title() {
      const {
        title: title2,
        author,
        contact,
        agent
      } = state[isolate.scope];
      append("scripttype-title", `
      <title-cover>
        <title-main>
          <title-title>
            ${title2}
          </title-title>
          by
          <title-author>
            ${author}
          </title-author>
        </title-main>
        <title-contact>
          ${markup(contact) || ""}
        </title-contact>
        <title-agent>
          ${markup(agent) || ""}
        </title-agent>
      </title-cover>
    `);
    }
    function embed() {
      const properties = state[isolate.plugin];
      const attributes2 = Object.keys(properties).map((x) => `${x}="${properties[x]}"`).join("");
      isolate.result += `<${isolate.plugin} ${attributes2}></${isolate.plugin}>`;
    }
    function markup(string2) {
      return string2 && string2.replaceAll("\\", "<br>");
    }
    function freetext(line) {
      append("scripttype-freetext", line);
    }
    function blank() {
      append("script-type-blankline", "");
    }
    function append(tag, content2) {
      const html = `
      <${tag}>
        ${content2}
      </${tag}>
    `;
      isolate.result += html;
    }
    function noop() {
    }
  };
  var $10 = module2("script-type", { file: hello() });
  var $editor = module2("script-editor");
  var $viewer = module2("script-viewer");
  $10.draw((target) => {
    return `
    <div name="transport">
      <button class="print">print</button>
    </div>
    <script-editor><\/script-editor>
    <script-viewer><\/script-viewer>
  `;
  });
  $10.flair(`
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }

  @media print {
    html, body {
      height: 100%;
    }
  }

  @page {
    size: 8.5in 11in;
    margin: 1in 1in 1in 1.5in;
  }

  @page {
    @top-right {
      content: counter(page) '.';
    }
  }

  @page:first {
    @top-right {
      content: '';
    }
  }


  & {
    display: grid;
    grid-template-areas:
    "transport transport"
    "editor viewer";
    grid-auto-columns: 1fr 1fr;
    grid-auto-rows: 2rem calc(100vh - 2rem);
  }

  & [name="transport"] {
    grid-area: transport;
  }

  & script-editor {
    grid-area: editor;
  }

  & script-viewer {
    grid-area: viewer;
  }

  @media print {
    & [name="transport"],
    & script-editor {
      display: none;
    }

    & { display: block }
    & script-viewer { display: block }
  }

`);
  $10.when("click", ".print", print);
  $viewer.draw((target) => {
    const source = target.closest($10.link).getAttribute("source");
    const { formatted } = state[source] || {};
    return `
    <div class="shadowbox">
      ${formatted}
    </div>
  `;
  });
  $editor.draw((target) => {
    const { file } = $10.learn();
    if (file && !target.view) {
      const config2 = {
        extensions: [
          basicSetup,
          EditorView.lineWrapping,
          EditorView.updateListener.of(
            persist2(target, $10, {})
          )
        ]
      };
      const state3 = EditorState.create({
        ...config2,
        doc: file
      });
      target.view = new EditorView({
        parent: target,
        state: state3
      });
    }
  });
  function persist2(target, $11, _flags) {
    return (update3) => {
      if (update3.changes.inserted.length < 0)
        return;
      const file = update3.view.state.doc.toString();
      const formatted = compile(file);
      const source = target.closest($11.link).getAttribute("source");
      state[source] = { file, formatted };
    };
  }
  $editor.flair(`
  & {
    display: block;
  }
`);
  $viewer.flair(`
  & {
    display: block;
    font-size: 12pt;
    font-family: courier;
    margin: 0 auto;
    max-width: 6in;
  }
  & scripttype-title {
    display: block;
    height: 100%;
    width: 100%;
  }

  & title-cover {
    display: grid;
    grid-template-areas:
      "main main"
      "contact agent";
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr auto;
    width: 100%;
    height: 100%;
  }

  & title-main {
    place-self: center;
    grid-area: main;
    text-align: center;
  }

  & title-title {
    margin-bottom: 1rem;
  }

  & title-title,
  & title-author {
    display: block;
  }

  & title-contact {
    grid-area: contact;
  }

  & title-agent {
    grid-area: agent;
  }

  & scripttype-address,
  & scripttype-character,
  & scripttype-quote,
  & scripttype-parenthetical,
  & scripttype-information,
  & scripttype-effect,
  & scripttype-freetext,
  & scripttype-blank {
    display: block;
  }

  & scripttype-address,
  & scripttype-information {
    text-transform: uppercase;
    margin: 1rem 0;
  }

  & scripttype-character,
  & scripttype-parenthetical {
    text-align: center;
  }

  & scripttype-character {
    text-align: center;
    text-transform: uppercase;
    margin: 1rem 0 0;
  }

  & scripttype-effect {
    margin: 1rem 0;
    text-align: right;
  }

  & scripttype-quote {
    margin: 0 1in;
  }

  & scripttype-quote:first-child::before {
    content: "(CONT'D)" !important;
    display: block;
    text-align: center;
  }

  & scripttype-parenthetical::before {
    content: '(';
  }

  & scripttype-parenthetical::after {
    content: ')';
  }

  & scripttype-freetext {
    margin: 1rem 0;
  }

`);
  function hello() {
    return `#!/bin/sh sillonious

{ typewriter
title: The Journal of the War on Clowns
author: Tyler Childs

^ fade in
# The Studio - Day

NOTORIOUS SILLONIOUS, a puppet made of a blue sweatshirt, a red beanie, but mostly a pair of glasses.

@ Notorious Sillonious (V.O.)
" Welcome.

The puppet does not move while it speaks.

ORIGIN WILDCLOAK, is a pile of hawaiian and flannel shirts in a lump.

@ Origin Wildcloak (V.O.)
" We've, been waiting for you.

TY enters wearing black on black crew uniform.

@ Ty
" Don't everyone spring up at once.

Ty points finger guns at both his alternative personas.

@ Origin Wildcloak (V.O.)
" Funny.

@ Notorious Sillonious (V.O.)
" Lazy.

@ Ty
" You're calling me lazy?

Ty high fives himself with the sleeve of Sillonious.

@ Origin Wildcloak
" You set yourself up for that.

@ Ty
" Alright, enough joking around, what's the latest?

^ Cut to black
`;
  }
})();
/*!
* focus-trap 7.0.0
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/
/*!
* tabbable 6.0.1
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
